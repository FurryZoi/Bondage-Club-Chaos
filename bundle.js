(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __decorateClass = (decorators, target, key, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
    for (var i5 = decorators.length - 1, decorator; i5 >= 0; i5--)
      if (decorator = decorators[i5])
        result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    if (kind && result) __defProp(target, key, result);
    return result;
  };

  // node_modules/.pnpm/reflect-metadata@0.2.2/node_modules/reflect-metadata/Reflect.js
  var require_Reflect = __commonJS({
    "node_modules/.pnpm/reflect-metadata@0.2.2/node_modules/reflect-metadata/Reflect.js"() {
      var Reflect2;
      (function(Reflect3) {
        (function(factory) {
          var root = typeof globalThis === "object" ? globalThis : typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : sloppyModeThis();
          var exporter = makeExporter(Reflect3);
          if (typeof root.Reflect !== "undefined") {
            exporter = makeExporter(root.Reflect, exporter);
          }
          factory(exporter, root);
          if (typeof root.Reflect === "undefined") {
            root.Reflect = Reflect3;
          }
          function makeExporter(target, previous) {
            return function(key, value) {
              Object.defineProperty(target, key, { configurable: true, writable: true, value });
              if (previous)
                previous(key, value);
            };
          }
          function functionThis() {
            try {
              return Function("return this;")();
            } catch (_4) {
            }
          }
          function indirectEvalThis() {
            try {
              return (void 0, eval)("(function() { return this; })()");
            } catch (_4) {
            }
          }
          function sloppyModeThis() {
            return functionThis() || indirectEvalThis();
          }
        })(function(exporter, root) {
          var hasOwn = Object.prototype.hasOwnProperty;
          var supportsSymbol = typeof Symbol === "function";
          var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
          var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
          var supportsCreate = typeof Object.create === "function";
          var supportsProto = { __proto__: [] } instanceof Array;
          var downLevel = !supportsCreate && !supportsProto;
          var HashMap = {
            // create an object in dictionary mode (a.k.a. "slow" mode in v8)
            create: supportsCreate ? function() {
              return MakeDictionary(/* @__PURE__ */ Object.create(null));
            } : supportsProto ? function() {
              return MakeDictionary({ __proto__: null });
            } : function() {
              return MakeDictionary({});
            },
            has: downLevel ? function(map, key) {
              return hasOwn.call(map, key);
            } : function(map, key) {
              return key in map;
            },
            get: downLevel ? function(map, key) {
              return hasOwn.call(map, key) ? map[key] : void 0;
            } : function(map, key) {
              return map[key];
            }
          };
          var functionPrototype = Object.getPrototypeOf(Function);
          var _Map = typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
          var _Set = typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
          var _WeakMap = typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
          var registrySymbol = supportsSymbol ? Symbol.for("@reflect-metadata:registry") : void 0;
          var metadataRegistry = GetOrCreateMetadataRegistry();
          var metadataProvider = CreateMetadataProvider(metadataRegistry);
          function decorate(decorators, target, propertyKey, attributes) {
            if (!IsUndefined(propertyKey)) {
              if (!IsArray(decorators))
                throw new TypeError();
              if (!IsObject3(target))
                throw new TypeError();
              if (!IsObject3(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
                throw new TypeError();
              if (IsNull(attributes))
                attributes = void 0;
              propertyKey = ToPropertyKey(propertyKey);
              return DecorateProperty(decorators, target, propertyKey, attributes);
            } else {
              if (!IsArray(decorators))
                throw new TypeError();
              if (!IsConstructor(target))
                throw new TypeError();
              return DecorateConstructor(decorators, target);
            }
          }
          exporter("decorate", decorate);
          function metadata(metadataKey, metadataValue) {
            function decorator(target, propertyKey) {
              if (!IsObject3(target))
                throw new TypeError();
              if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
                throw new TypeError();
              OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
            }
            return decorator;
          }
          exporter("metadata", metadata);
          function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
            if (!IsObject3(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
          }
          exporter("defineMetadata", defineMetadata);
          function hasMetadata(metadataKey, target, propertyKey) {
            if (!IsObject3(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasMetadata(metadataKey, target, propertyKey);
          }
          exporter("hasMetadata", hasMetadata);
          function hasOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject3(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
          }
          exporter("hasOwnMetadata", hasOwnMetadata);
          function getMetadata(metadataKey, target, propertyKey) {
            if (!IsObject3(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetMetadata(metadataKey, target, propertyKey);
          }
          exporter("getMetadata", getMetadata);
          function getOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject3(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
          }
          exporter("getOwnMetadata", getOwnMetadata);
          function getMetadataKeys(target, propertyKey) {
            if (!IsObject3(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryMetadataKeys(target, propertyKey);
          }
          exporter("getMetadataKeys", getMetadataKeys);
          function getOwnMetadataKeys(target, propertyKey) {
            if (!IsObject3(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryOwnMetadataKeys(target, propertyKey);
          }
          exporter("getOwnMetadataKeys", getOwnMetadataKeys);
          function deleteMetadata(metadataKey, target, propertyKey) {
            if (!IsObject3(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            if (!IsObject3(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            var provider = GetMetadataProvider(
              target,
              propertyKey,
              /*Create*/
              false
            );
            if (IsUndefined(provider))
              return false;
            return provider.OrdinaryDeleteMetadata(metadataKey, target, propertyKey);
          }
          exporter("deleteMetadata", deleteMetadata);
          function DecorateConstructor(decorators, target) {
            for (var i5 = decorators.length - 1; i5 >= 0; --i5) {
              var decorator = decorators[i5];
              var decorated = decorator(target);
              if (!IsUndefined(decorated) && !IsNull(decorated)) {
                if (!IsConstructor(decorated))
                  throw new TypeError();
                target = decorated;
              }
            }
            return target;
          }
          function DecorateProperty(decorators, target, propertyKey, descriptor) {
            for (var i5 = decorators.length - 1; i5 >= 0; --i5) {
              var decorator = decorators[i5];
              var decorated = decorator(target, propertyKey, descriptor);
              if (!IsUndefined(decorated) && !IsNull(decorated)) {
                if (!IsObject3(decorated))
                  throw new TypeError();
                descriptor = decorated;
              }
            }
            return descriptor;
          }
          function OrdinaryHasMetadata(MetadataKey, O5, P6) {
            var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O5, P6);
            if (hasOwn2)
              return true;
            var parent = OrdinaryGetPrototypeOf(O5);
            if (!IsNull(parent))
              return OrdinaryHasMetadata(MetadataKey, parent, P6);
            return false;
          }
          function OrdinaryHasOwnMetadata(MetadataKey, O5, P6) {
            var provider = GetMetadataProvider(
              O5,
              P6,
              /*Create*/
              false
            );
            if (IsUndefined(provider))
              return false;
            return ToBoolean(provider.OrdinaryHasOwnMetadata(MetadataKey, O5, P6));
          }
          function OrdinaryGetMetadata(MetadataKey, O5, P6) {
            var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O5, P6);
            if (hasOwn2)
              return OrdinaryGetOwnMetadata(MetadataKey, O5, P6);
            var parent = OrdinaryGetPrototypeOf(O5);
            if (!IsNull(parent))
              return OrdinaryGetMetadata(MetadataKey, parent, P6);
            return void 0;
          }
          function OrdinaryGetOwnMetadata(MetadataKey, O5, P6) {
            var provider = GetMetadataProvider(
              O5,
              P6,
              /*Create*/
              false
            );
            if (IsUndefined(provider))
              return;
            return provider.OrdinaryGetOwnMetadata(MetadataKey, O5, P6);
          }
          function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O5, P6) {
            var provider = GetMetadataProvider(
              O5,
              P6,
              /*Create*/
              true
            );
            provider.OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O5, P6);
          }
          function OrdinaryMetadataKeys(O5, P6) {
            var ownKeys = OrdinaryOwnMetadataKeys(O5, P6);
            var parent = OrdinaryGetPrototypeOf(O5);
            if (parent === null)
              return ownKeys;
            var parentKeys = OrdinaryMetadataKeys(parent, P6);
            if (parentKeys.length <= 0)
              return ownKeys;
            if (ownKeys.length <= 0)
              return parentKeys;
            var set = new _Set();
            var keys = [];
            for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
              var key = ownKeys_1[_i];
              var hasKey = set.has(key);
              if (!hasKey) {
                set.add(key);
                keys.push(key);
              }
            }
            for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
              var key = parentKeys_1[_a];
              var hasKey = set.has(key);
              if (!hasKey) {
                set.add(key);
                keys.push(key);
              }
            }
            return keys;
          }
          function OrdinaryOwnMetadataKeys(O5, P6) {
            var provider = GetMetadataProvider(
              O5,
              P6,
              /*create*/
              false
            );
            if (!provider) {
              return [];
            }
            return provider.OrdinaryOwnMetadataKeys(O5, P6);
          }
          function Type2(x5) {
            if (x5 === null)
              return 1;
            switch (typeof x5) {
              case "undefined":
                return 0;
              case "boolean":
                return 2;
              case "string":
                return 3;
              case "symbol":
                return 4;
              case "number":
                return 5;
              case "object":
                return x5 === null ? 1 : 6;
              default:
                return 6;
            }
          }
          function IsUndefined(x5) {
            return x5 === void 0;
          }
          function IsNull(x5) {
            return x5 === null;
          }
          function IsSymbol(x5) {
            return typeof x5 === "symbol";
          }
          function IsObject3(x5) {
            return typeof x5 === "object" ? x5 !== null : typeof x5 === "function";
          }
          function ToPrimitive(input, PreferredType) {
            switch (Type2(input)) {
              case 0:
                return input;
              case 1:
                return input;
              case 2:
                return input;
              case 3:
                return input;
              case 4:
                return input;
              case 5:
                return input;
            }
            var hint = PreferredType === 3 ? "string" : PreferredType === 5 ? "number" : "default";
            var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
            if (exoticToPrim !== void 0) {
              var result = exoticToPrim.call(input, hint);
              if (IsObject3(result))
                throw new TypeError();
              return result;
            }
            return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
          }
          function OrdinaryToPrimitive(O5, hint) {
            if (hint === "string") {
              var toString_1 = O5.toString;
              if (IsCallable(toString_1)) {
                var result = toString_1.call(O5);
                if (!IsObject3(result))
                  return result;
              }
              var valueOf = O5.valueOf;
              if (IsCallable(valueOf)) {
                var result = valueOf.call(O5);
                if (!IsObject3(result))
                  return result;
              }
            } else {
              var valueOf = O5.valueOf;
              if (IsCallable(valueOf)) {
                var result = valueOf.call(O5);
                if (!IsObject3(result))
                  return result;
              }
              var toString_2 = O5.toString;
              if (IsCallable(toString_2)) {
                var result = toString_2.call(O5);
                if (!IsObject3(result))
                  return result;
              }
            }
            throw new TypeError();
          }
          function ToBoolean(argument) {
            return !!argument;
          }
          function ToString(argument) {
            return "" + argument;
          }
          function ToPropertyKey(argument) {
            var key = ToPrimitive(
              argument,
              3
              /* String */
            );
            if (IsSymbol(key))
              return key;
            return ToString(key);
          }
          function IsArray(argument) {
            return Array.isArray ? Array.isArray(argument) : argument instanceof Object ? argument instanceof Array : Object.prototype.toString.call(argument) === "[object Array]";
          }
          function IsCallable(argument) {
            return typeof argument === "function";
          }
          function IsConstructor(argument) {
            return typeof argument === "function";
          }
          function IsPropertyKey(argument) {
            switch (Type2(argument)) {
              case 3:
                return true;
              case 4:
                return true;
              default:
                return false;
            }
          }
          function SameValueZero(x5, y5) {
            return x5 === y5 || x5 !== x5 && y5 !== y5;
          }
          function GetMethod(V4, P6) {
            var func = V4[P6];
            if (func === void 0 || func === null)
              return void 0;
            if (!IsCallable(func))
              throw new TypeError();
            return func;
          }
          function GetIterator(obj) {
            var method = GetMethod(obj, iteratorSymbol);
            if (!IsCallable(method))
              throw new TypeError();
            var iterator = method.call(obj);
            if (!IsObject3(iterator))
              throw new TypeError();
            return iterator;
          }
          function IteratorValue(iterResult) {
            return iterResult.value;
          }
          function IteratorStep(iterator) {
            var result = iterator.next();
            return result.done ? false : result;
          }
          function IteratorClose(iterator) {
            var f6 = iterator["return"];
            if (f6)
              f6.call(iterator);
          }
          function OrdinaryGetPrototypeOf(O5) {
            var proto = Object.getPrototypeOf(O5);
            if (typeof O5 !== "function" || O5 === functionPrototype)
              return proto;
            if (proto !== functionPrototype)
              return proto;
            var prototype = O5.prototype;
            var prototypeProto = prototype && Object.getPrototypeOf(prototype);
            if (prototypeProto == null || prototypeProto === Object.prototype)
              return proto;
            var constructor = prototypeProto.constructor;
            if (typeof constructor !== "function")
              return proto;
            if (constructor === O5)
              return proto;
            return constructor;
          }
          function CreateMetadataRegistry() {
            var fallback;
            if (!IsUndefined(registrySymbol) && typeof root.Reflect !== "undefined" && !(registrySymbol in root.Reflect) && typeof root.Reflect.defineMetadata === "function") {
              fallback = CreateFallbackProvider(root.Reflect);
            }
            var first;
            var second;
            var rest;
            var targetProviderMap = new _WeakMap();
            var registry = {
              registerProvider,
              getProvider,
              setProvider
            };
            return registry;
            function registerProvider(provider) {
              if (!Object.isExtensible(registry)) {
                throw new Error("Cannot add provider to a frozen registry.");
              }
              switch (true) {
                case fallback === provider:
                  break;
                case IsUndefined(first):
                  first = provider;
                  break;
                case first === provider:
                  break;
                case IsUndefined(second):
                  second = provider;
                  break;
                case second === provider:
                  break;
                default:
                  if (rest === void 0)
                    rest = new _Set();
                  rest.add(provider);
                  break;
              }
            }
            function getProviderNoCache(O5, P6) {
              if (!IsUndefined(first)) {
                if (first.isProviderFor(O5, P6))
                  return first;
                if (!IsUndefined(second)) {
                  if (second.isProviderFor(O5, P6))
                    return first;
                  if (!IsUndefined(rest)) {
                    var iterator = GetIterator(rest);
                    while (true) {
                      var next = IteratorStep(iterator);
                      if (!next) {
                        return void 0;
                      }
                      var provider = IteratorValue(next);
                      if (provider.isProviderFor(O5, P6)) {
                        IteratorClose(iterator);
                        return provider;
                      }
                    }
                  }
                }
              }
              if (!IsUndefined(fallback) && fallback.isProviderFor(O5, P6)) {
                return fallback;
              }
              return void 0;
            }
            function getProvider(O5, P6) {
              var providerMap = targetProviderMap.get(O5);
              var provider;
              if (!IsUndefined(providerMap)) {
                provider = providerMap.get(P6);
              }
              if (!IsUndefined(provider)) {
                return provider;
              }
              provider = getProviderNoCache(O5, P6);
              if (!IsUndefined(provider)) {
                if (IsUndefined(providerMap)) {
                  providerMap = new _Map();
                  targetProviderMap.set(O5, providerMap);
                }
                providerMap.set(P6, provider);
              }
              return provider;
            }
            function hasProvider(provider) {
              if (IsUndefined(provider))
                throw new TypeError();
              return first === provider || second === provider || !IsUndefined(rest) && rest.has(provider);
            }
            function setProvider(O5, P6, provider) {
              if (!hasProvider(provider)) {
                throw new Error("Metadata provider not registered.");
              }
              var existingProvider = getProvider(O5, P6);
              if (existingProvider !== provider) {
                if (!IsUndefined(existingProvider)) {
                  return false;
                }
                var providerMap = targetProviderMap.get(O5);
                if (IsUndefined(providerMap)) {
                  providerMap = new _Map();
                  targetProviderMap.set(O5, providerMap);
                }
                providerMap.set(P6, provider);
              }
              return true;
            }
          }
          function GetOrCreateMetadataRegistry() {
            var metadataRegistry2;
            if (!IsUndefined(registrySymbol) && IsObject3(root.Reflect) && Object.isExtensible(root.Reflect)) {
              metadataRegistry2 = root.Reflect[registrySymbol];
            }
            if (IsUndefined(metadataRegistry2)) {
              metadataRegistry2 = CreateMetadataRegistry();
            }
            if (!IsUndefined(registrySymbol) && IsObject3(root.Reflect) && Object.isExtensible(root.Reflect)) {
              Object.defineProperty(root.Reflect, registrySymbol, {
                enumerable: false,
                configurable: false,
                writable: false,
                value: metadataRegistry2
              });
            }
            return metadataRegistry2;
          }
          function CreateMetadataProvider(registry) {
            var metadata2 = new _WeakMap();
            var provider = {
              isProviderFor: function(O5, P6) {
                var targetMetadata = metadata2.get(O5);
                if (IsUndefined(targetMetadata))
                  return false;
                return targetMetadata.has(P6);
              },
              OrdinaryDefineOwnMetadata: OrdinaryDefineOwnMetadata2,
              OrdinaryHasOwnMetadata: OrdinaryHasOwnMetadata2,
              OrdinaryGetOwnMetadata: OrdinaryGetOwnMetadata2,
              OrdinaryOwnMetadataKeys: OrdinaryOwnMetadataKeys2,
              OrdinaryDeleteMetadata
            };
            metadataRegistry.registerProvider(provider);
            return provider;
            function GetOrCreateMetadataMap(O5, P6, Create) {
              var targetMetadata = metadata2.get(O5);
              var createdTargetMetadata = false;
              if (IsUndefined(targetMetadata)) {
                if (!Create)
                  return void 0;
                targetMetadata = new _Map();
                metadata2.set(O5, targetMetadata);
                createdTargetMetadata = true;
              }
              var metadataMap = targetMetadata.get(P6);
              if (IsUndefined(metadataMap)) {
                if (!Create)
                  return void 0;
                metadataMap = new _Map();
                targetMetadata.set(P6, metadataMap);
                if (!registry.setProvider(O5, P6, provider)) {
                  targetMetadata.delete(P6);
                  if (createdTargetMetadata) {
                    metadata2.delete(O5);
                  }
                  throw new Error("Wrong provider for target.");
                }
              }
              return metadataMap;
            }
            function OrdinaryHasOwnMetadata2(MetadataKey, O5, P6) {
              var metadataMap = GetOrCreateMetadataMap(
                O5,
                P6,
                /*Create*/
                false
              );
              if (IsUndefined(metadataMap))
                return false;
              return ToBoolean(metadataMap.has(MetadataKey));
            }
            function OrdinaryGetOwnMetadata2(MetadataKey, O5, P6) {
              var metadataMap = GetOrCreateMetadataMap(
                O5,
                P6,
                /*Create*/
                false
              );
              if (IsUndefined(metadataMap))
                return void 0;
              return metadataMap.get(MetadataKey);
            }
            function OrdinaryDefineOwnMetadata2(MetadataKey, MetadataValue, O5, P6) {
              var metadataMap = GetOrCreateMetadataMap(
                O5,
                P6,
                /*Create*/
                true
              );
              metadataMap.set(MetadataKey, MetadataValue);
            }
            function OrdinaryOwnMetadataKeys2(O5, P6) {
              var keys = [];
              var metadataMap = GetOrCreateMetadataMap(
                O5,
                P6,
                /*Create*/
                false
              );
              if (IsUndefined(metadataMap))
                return keys;
              var keysObj = metadataMap.keys();
              var iterator = GetIterator(keysObj);
              var k5 = 0;
              while (true) {
                var next = IteratorStep(iterator);
                if (!next) {
                  keys.length = k5;
                  return keys;
                }
                var nextValue = IteratorValue(next);
                try {
                  keys[k5] = nextValue;
                } catch (e2) {
                  try {
                    IteratorClose(iterator);
                  } finally {
                    throw e2;
                  }
                }
                k5++;
              }
            }
            function OrdinaryDeleteMetadata(MetadataKey, O5, P6) {
              var metadataMap = GetOrCreateMetadataMap(
                O5,
                P6,
                /*Create*/
                false
              );
              if (IsUndefined(metadataMap))
                return false;
              if (!metadataMap.delete(MetadataKey))
                return false;
              if (metadataMap.size === 0) {
                var targetMetadata = metadata2.get(O5);
                if (!IsUndefined(targetMetadata)) {
                  targetMetadata.delete(P6);
                  if (targetMetadata.size === 0) {
                    metadata2.delete(targetMetadata);
                  }
                }
              }
              return true;
            }
          }
          function CreateFallbackProvider(reflect) {
            var defineMetadata2 = reflect.defineMetadata, hasOwnMetadata2 = reflect.hasOwnMetadata, getOwnMetadata2 = reflect.getOwnMetadata, getOwnMetadataKeys2 = reflect.getOwnMetadataKeys, deleteMetadata2 = reflect.deleteMetadata;
            var metadataOwner = new _WeakMap();
            var provider = {
              isProviderFor: function(O5, P6) {
                var metadataPropertySet = metadataOwner.get(O5);
                if (!IsUndefined(metadataPropertySet) && metadataPropertySet.has(P6)) {
                  return true;
                }
                if (getOwnMetadataKeys2(O5, P6).length) {
                  if (IsUndefined(metadataPropertySet)) {
                    metadataPropertySet = new _Set();
                    metadataOwner.set(O5, metadataPropertySet);
                  }
                  metadataPropertySet.add(P6);
                  return true;
                }
                return false;
              },
              OrdinaryDefineOwnMetadata: defineMetadata2,
              OrdinaryHasOwnMetadata: hasOwnMetadata2,
              OrdinaryGetOwnMetadata: getOwnMetadata2,
              OrdinaryOwnMetadataKeys: getOwnMetadataKeys2,
              OrdinaryDeleteMetadata: deleteMetadata2
            };
            return provider;
          }
          function GetMetadataProvider(O5, P6, Create) {
            var registeredProvider = metadataRegistry.getProvider(O5, P6);
            if (!IsUndefined(registeredProvider)) {
              return registeredProvider;
            }
            if (Create) {
              if (metadataRegistry.setProvider(O5, P6, metadataProvider)) {
                return metadataProvider;
              }
              throw new Error("Illegal state.");
            }
            return void 0;
          }
          function CreateMapPolyfill() {
            var cacheSentinel = {};
            var arraySentinel = [];
            var MapIterator = (
              /** @class */
              (function() {
                function MapIterator2(keys, values, selector) {
                  this._index = 0;
                  this._keys = keys;
                  this._values = values;
                  this._selector = selector;
                }
                MapIterator2.prototype["@@iterator"] = function() {
                  return this;
                };
                MapIterator2.prototype[iteratorSymbol] = function() {
                  return this;
                };
                MapIterator2.prototype.next = function() {
                  var index = this._index;
                  if (index >= 0 && index < this._keys.length) {
                    var result = this._selector(this._keys[index], this._values[index]);
                    if (index + 1 >= this._keys.length) {
                      this._index = -1;
                      this._keys = arraySentinel;
                      this._values = arraySentinel;
                    } else {
                      this._index++;
                    }
                    return { value: result, done: false };
                  }
                  return { value: void 0, done: true };
                };
                MapIterator2.prototype.throw = function(error) {
                  if (this._index >= 0) {
                    this._index = -1;
                    this._keys = arraySentinel;
                    this._values = arraySentinel;
                  }
                  throw error;
                };
                MapIterator2.prototype.return = function(value) {
                  if (this._index >= 0) {
                    this._index = -1;
                    this._keys = arraySentinel;
                    this._values = arraySentinel;
                  }
                  return { value, done: true };
                };
                return MapIterator2;
              })()
            );
            var Map2 = (
              /** @class */
              (function() {
                function Map3() {
                  this._keys = [];
                  this._values = [];
                  this._cacheKey = cacheSentinel;
                  this._cacheIndex = -2;
                }
                Object.defineProperty(Map3.prototype, "size", {
                  get: function() {
                    return this._keys.length;
                  },
                  enumerable: true,
                  configurable: true
                });
                Map3.prototype.has = function(key) {
                  return this._find(
                    key,
                    /*insert*/
                    false
                  ) >= 0;
                };
                Map3.prototype.get = function(key) {
                  var index = this._find(
                    key,
                    /*insert*/
                    false
                  );
                  return index >= 0 ? this._values[index] : void 0;
                };
                Map3.prototype.set = function(key, value) {
                  var index = this._find(
                    key,
                    /*insert*/
                    true
                  );
                  this._values[index] = value;
                  return this;
                };
                Map3.prototype.delete = function(key) {
                  var index = this._find(
                    key,
                    /*insert*/
                    false
                  );
                  if (index >= 0) {
                    var size = this._keys.length;
                    for (var i5 = index + 1; i5 < size; i5++) {
                      this._keys[i5 - 1] = this._keys[i5];
                      this._values[i5 - 1] = this._values[i5];
                    }
                    this._keys.length--;
                    this._values.length--;
                    if (SameValueZero(key, this._cacheKey)) {
                      this._cacheKey = cacheSentinel;
                      this._cacheIndex = -2;
                    }
                    return true;
                  }
                  return false;
                };
                Map3.prototype.clear = function() {
                  this._keys.length = 0;
                  this._values.length = 0;
                  this._cacheKey = cacheSentinel;
                  this._cacheIndex = -2;
                };
                Map3.prototype.keys = function() {
                  return new MapIterator(this._keys, this._values, getKey);
                };
                Map3.prototype.values = function() {
                  return new MapIterator(this._keys, this._values, getValue);
                };
                Map3.prototype.entries = function() {
                  return new MapIterator(this._keys, this._values, getEntry);
                };
                Map3.prototype["@@iterator"] = function() {
                  return this.entries();
                };
                Map3.prototype[iteratorSymbol] = function() {
                  return this.entries();
                };
                Map3.prototype._find = function(key, insert) {
                  if (!SameValueZero(this._cacheKey, key)) {
                    this._cacheIndex = -1;
                    for (var i5 = 0; i5 < this._keys.length; i5++) {
                      if (SameValueZero(this._keys[i5], key)) {
                        this._cacheIndex = i5;
                        break;
                      }
                    }
                  }
                  if (this._cacheIndex < 0 && insert) {
                    this._cacheIndex = this._keys.length;
                    this._keys.push(key);
                    this._values.push(void 0);
                  }
                  return this._cacheIndex;
                };
                return Map3;
              })()
            );
            return Map2;
            function getKey(key, _4) {
              return key;
            }
            function getValue(_4, value) {
              return value;
            }
            function getEntry(key, value) {
              return [key, value];
            }
          }
          function CreateSetPolyfill() {
            var Set2 = (
              /** @class */
              (function() {
                function Set3() {
                  this._map = new _Map();
                }
                Object.defineProperty(Set3.prototype, "size", {
                  get: function() {
                    return this._map.size;
                  },
                  enumerable: true,
                  configurable: true
                });
                Set3.prototype.has = function(value) {
                  return this._map.has(value);
                };
                Set3.prototype.add = function(value) {
                  return this._map.set(value, value), this;
                };
                Set3.prototype.delete = function(value) {
                  return this._map.delete(value);
                };
                Set3.prototype.clear = function() {
                  this._map.clear();
                };
                Set3.prototype.keys = function() {
                  return this._map.keys();
                };
                Set3.prototype.values = function() {
                  return this._map.keys();
                };
                Set3.prototype.entries = function() {
                  return this._map.entries();
                };
                Set3.prototype["@@iterator"] = function() {
                  return this.keys();
                };
                Set3.prototype[iteratorSymbol] = function() {
                  return this.keys();
                };
                return Set3;
              })()
            );
            return Set2;
          }
          function CreateWeakMapPolyfill() {
            var UUID_SIZE = 16;
            var keys = HashMap.create();
            var rootKey = CreateUniqueKey();
            return (
              /** @class */
              (function() {
                function WeakMap2() {
                  this._key = CreateUniqueKey();
                }
                WeakMap2.prototype.has = function(target) {
                  var table = GetOrCreateWeakMapTable(
                    target,
                    /*create*/
                    false
                  );
                  return table !== void 0 ? HashMap.has(table, this._key) : false;
                };
                WeakMap2.prototype.get = function(target) {
                  var table = GetOrCreateWeakMapTable(
                    target,
                    /*create*/
                    false
                  );
                  return table !== void 0 ? HashMap.get(table, this._key) : void 0;
                };
                WeakMap2.prototype.set = function(target, value) {
                  var table = GetOrCreateWeakMapTable(
                    target,
                    /*create*/
                    true
                  );
                  table[this._key] = value;
                  return this;
                };
                WeakMap2.prototype.delete = function(target) {
                  var table = GetOrCreateWeakMapTable(
                    target,
                    /*create*/
                    false
                  );
                  return table !== void 0 ? delete table[this._key] : false;
                };
                WeakMap2.prototype.clear = function() {
                  this._key = CreateUniqueKey();
                };
                return WeakMap2;
              })()
            );
            function CreateUniqueKey() {
              var key;
              do
                key = "@@WeakMap@@" + CreateUUID();
              while (HashMap.has(keys, key));
              keys[key] = true;
              return key;
            }
            function GetOrCreateWeakMapTable(target, create2) {
              if (!hasOwn.call(target, rootKey)) {
                if (!create2)
                  return void 0;
                Object.defineProperty(target, rootKey, { value: HashMap.create() });
              }
              return target[rootKey];
            }
            function FillRandomBytes(buffer, size) {
              for (var i5 = 0; i5 < size; ++i5)
                buffer[i5] = Math.random() * 255 | 0;
              return buffer;
            }
            function GenRandomBytes(size) {
              if (typeof Uint8Array === "function") {
                var array = new Uint8Array(size);
                if (typeof crypto !== "undefined") {
                  crypto.getRandomValues(array);
                } else if (typeof msCrypto !== "undefined") {
                  msCrypto.getRandomValues(array);
                } else {
                  FillRandomBytes(array, size);
                }
                return array;
              }
              return FillRandomBytes(new Array(size), size);
            }
            function CreateUUID() {
              var data = GenRandomBytes(UUID_SIZE);
              data[6] = data[6] & 79 | 64;
              data[8] = data[8] & 191 | 128;
              var result = "";
              for (var offset = 0; offset < UUID_SIZE; ++offset) {
                var byte = data[offset];
                if (offset === 4 || offset === 6 || offset === 8)
                  result += "-";
                if (byte < 16)
                  result += "0";
                result += byte.toString(16).toLowerCase();
              }
              return result;
            }
          }
          function MakeDictionary(obj) {
            obj.__ = void 0;
            delete obj.__;
            return obj;
          }
        });
      })(Reflect2 || (Reflect2 = {}));
    }
  });

  // node_modules/.pnpm/bondage-club-mod-sdk@1.2.0/node_modules/bondage-club-mod-sdk/dist/bcmodsdk.js
  var require_bcmodsdk = __commonJS({
    "node_modules/.pnpm/bondage-club-mod-sdk@1.2.0/node_modules/bondage-club-mod-sdk/dist/bcmodsdk.js"(exports) {
      var bcModSdk = (function() {
        "use strict";
        const o5 = "1.2.0";
        function e2(o6) {
          alert("Mod ERROR:\n" + o6);
          const e3 = new Error(o6);
          throw console.error(e3), e3;
        }
        const t3 = new TextEncoder();
        function n4(o6) {
          return !!o6 && "object" == typeof o6 && !Array.isArray(o6);
        }
        function r5(o6) {
          const e3 = /* @__PURE__ */ new Set();
          return o6.filter(((o7) => !e3.has(o7) && e3.add(o7)));
        }
        const i5 = /* @__PURE__ */ new Map(), a5 = /* @__PURE__ */ new Set();
        function c7(o6) {
          a5.has(o6) || (a5.add(o6), console.warn(o6));
        }
        function s5(o6) {
          const e3 = [], t4 = /* @__PURE__ */ new Map(), n5 = /* @__PURE__ */ new Set();
          for (const r7 of f6.values()) {
            const i7 = r7.patching.get(o6.name);
            if (i7) {
              e3.push(...i7.hooks);
              for (const [e4, a6] of i7.patches.entries()) t4.has(e4) && t4.get(e4) !== a6 && c7(`ModSDK: Mod '${r7.name}' is patching function ${o6.name} with same pattern that is already applied by different mod, but with different pattern:
Pattern:
${e4}
Patch1:
${t4.get(e4) || ""}
Patch2:
${a6}`), t4.set(e4, a6), n5.add(r7.name);
            }
          }
          e3.sort(((o7, e4) => e4.priority - o7.priority));
          const r6 = (function(o7, e4) {
            if (0 === e4.size) return o7;
            let t5 = o7.toString().replaceAll("\r\n", "\n");
            for (const [n6, r7] of e4.entries()) t5.includes(n6) || c7(`ModSDK: Patching ${o7.name}: Patch ${n6} not applied`), t5 = t5.replaceAll(n6, r7);
            return (0, eval)(`(${t5})`);
          })(o6.original, t4);
          let i6 = function(e4) {
            var t5, i7;
            const a6 = null === (i7 = (t5 = m4.errorReporterHooks).hookChainExit) || void 0 === i7 ? void 0 : i7.call(t5, o6.name, n5), c8 = r6.apply(this, e4);
            return null == a6 || a6(), c8;
          };
          for (let t5 = e3.length - 1; t5 >= 0; t5--) {
            const n6 = e3[t5], r7 = i6;
            i6 = function(e4) {
              var t6, i7;
              const a6 = null === (i7 = (t6 = m4.errorReporterHooks).hookEnter) || void 0 === i7 ? void 0 : i7.call(t6, o6.name, n6.mod), c8 = n6.hook.apply(this, [e4, (o7) => {
                if (1 !== arguments.length || !Array.isArray(e4)) throw new Error(`Mod ${n6.mod} failed to call next hook: Expected args to be array, got ${typeof o7}`);
                return r7.call(this, o7);
              }]);
              return null == a6 || a6(), c8;
            };
          }
          return { hooks: e3, patches: t4, patchesSources: n5, enter: i6, final: r6 };
        }
        function l6(o6, e3 = false) {
          let r6 = i5.get(o6);
          if (r6) e3 && (r6.precomputed = s5(r6));
          else {
            let e4 = window;
            const a6 = o6.split(".");
            for (let t4 = 0; t4 < a6.length - 1; t4++) if (e4 = e4[a6[t4]], !n4(e4)) throw new Error(`ModSDK: Function ${o6} to be patched not found; ${a6.slice(0, t4 + 1).join(".")} is not object`);
            const c8 = e4[a6[a6.length - 1]];
            if ("function" != typeof c8) throw new Error(`ModSDK: Function ${o6} to be patched not found`);
            const l7 = (function(o7) {
              let e5 = -1;
              for (const n5 of t3.encode(o7)) {
                let o8 = 255 & (e5 ^ n5);
                for (let e6 = 0; e6 < 8; e6++) o8 = 1 & o8 ? -306674912 ^ o8 >>> 1 : o8 >>> 1;
                e5 = e5 >>> 8 ^ o8;
              }
              return ((-1 ^ e5) >>> 0).toString(16).padStart(8, "0").toUpperCase();
            })(c8.toString().replaceAll("\r\n", "\n")), d7 = { name: o6, original: c8, originalHash: l7 };
            r6 = Object.assign(Object.assign({}, d7), { precomputed: s5(d7), router: () => {
            }, context: e4, contextProperty: a6[a6.length - 1] }), r6.router = /* @__PURE__ */ (function(o7) {
              return function(...e5) {
                return o7.precomputed.enter.apply(this, [e5]);
              };
            })(r6), i5.set(o6, r6), e4[r6.contextProperty] = r6.router;
          }
          return r6;
        }
        function d6() {
          for (const o6 of i5.values()) o6.precomputed = s5(o6);
        }
        function p5() {
          const o6 = /* @__PURE__ */ new Map();
          for (const [e3, t4] of i5) o6.set(e3, { name: e3, original: t4.original, originalHash: t4.originalHash, sdkEntrypoint: t4.router, currentEntrypoint: t4.context[t4.contextProperty], hookedByMods: r5(t4.precomputed.hooks.map(((o7) => o7.mod))), patchedByMods: Array.from(t4.precomputed.patchesSources) });
          return o6;
        }
        const f6 = /* @__PURE__ */ new Map();
        function u6(o6) {
          f6.get(o6.name) !== o6 && e2(`Failed to unload mod '${o6.name}': Not registered`), f6.delete(o6.name), o6.loaded = false, d6();
        }
        function g6(o6, t4) {
          o6 && "object" == typeof o6 || e2("Failed to register mod: Expected info object, got " + typeof o6), "string" == typeof o6.name && o6.name || e2("Failed to register mod: Expected name to be non-empty string, got " + typeof o6.name);
          let r6 = `'${o6.name}'`;
          "string" == typeof o6.fullName && o6.fullName || e2(`Failed to register mod ${r6}: Expected fullName to be non-empty string, got ${typeof o6.fullName}`), r6 = `'${o6.fullName} (${o6.name})'`, "string" != typeof o6.version && e2(`Failed to register mod ${r6}: Expected version to be string, got ${typeof o6.version}`), o6.repository || (o6.repository = void 0), void 0 !== o6.repository && "string" != typeof o6.repository && e2(`Failed to register mod ${r6}: Expected repository to be undefined or string, got ${typeof o6.version}`), null == t4 && (t4 = {}), t4 && "object" == typeof t4 || e2(`Failed to register mod ${r6}: Expected options to be undefined or object, got ${typeof t4}`);
          const i6 = true === t4.allowReplace, a6 = f6.get(o6.name);
          a6 && (a6.allowReplace && i6 || e2(`Refusing to load mod ${r6}: it is already loaded and doesn't allow being replaced.
Was the mod loaded multiple times?`), u6(a6));
          const c8 = (o7) => {
            let e3 = g7.patching.get(o7.name);
            return e3 || (e3 = { hooks: [], patches: /* @__PURE__ */ new Map() }, g7.patching.set(o7.name, e3)), e3;
          }, s6 = (o7, t5) => (...n5) => {
            var i7, a7;
            const c9 = null === (a7 = (i7 = m4.errorReporterHooks).apiEndpointEnter) || void 0 === a7 ? void 0 : a7.call(i7, o7, g7.name);
            g7.loaded || e2(`Mod ${r6} attempted to call SDK function after being unloaded`);
            const s7 = t5(...n5);
            return null == c9 || c9(), s7;
          }, p6 = { unload: s6("unload", (() => u6(g7))), hookFunction: s6("hookFunction", ((o7, t5, n5) => {
            "string" == typeof o7 && o7 || e2(`Mod ${r6} failed to patch a function: Expected function name string, got ${typeof o7}`);
            const i7 = l6(o7), a7 = c8(i7);
            "number" != typeof t5 && e2(`Mod ${r6} failed to hook function '${o7}': Expected priority number, got ${typeof t5}`), "function" != typeof n5 && e2(`Mod ${r6} failed to hook function '${o7}': Expected hook function, got ${typeof n5}`);
            const s7 = { mod: g7.name, priority: t5, hook: n5 };
            return a7.hooks.push(s7), d6(), () => {
              const o8 = a7.hooks.indexOf(s7);
              o8 >= 0 && (a7.hooks.splice(o8, 1), d6());
            };
          })), patchFunction: s6("patchFunction", ((o7, t5) => {
            "string" == typeof o7 && o7 || e2(`Mod ${r6} failed to patch a function: Expected function name string, got ${typeof o7}`);
            const i7 = l6(o7), a7 = c8(i7);
            n4(t5) || e2(`Mod ${r6} failed to patch function '${o7}': Expected patches object, got ${typeof t5}`);
            for (const [n5, i8] of Object.entries(t5)) "string" == typeof i8 ? a7.patches.set(n5, i8) : null === i8 ? a7.patches.delete(n5) : e2(`Mod ${r6} failed to patch function '${o7}': Invalid format of patch '${n5}'`);
            d6();
          })), removePatches: s6("removePatches", ((o7) => {
            "string" == typeof o7 && o7 || e2(`Mod ${r6} failed to patch a function: Expected function name string, got ${typeof o7}`);
            const t5 = l6(o7);
            c8(t5).patches.clear(), d6();
          })), callOriginal: s6("callOriginal", ((o7, t5, n5) => {
            "string" == typeof o7 && o7 || e2(`Mod ${r6} failed to call a function: Expected function name string, got ${typeof o7}`);
            const i7 = l6(o7);
            return Array.isArray(t5) || e2(`Mod ${r6} failed to call a function: Expected args array, got ${typeof t5}`), i7.original.apply(null != n5 ? n5 : globalThis, t5);
          })), getOriginalHash: s6("getOriginalHash", ((o7) => {
            "string" == typeof o7 && o7 || e2(`Mod ${r6} failed to get hash: Expected function name string, got ${typeof o7}`);
            return l6(o7).originalHash;
          })) }, g7 = { name: o6.name, fullName: o6.fullName, version: o6.version, repository: o6.repository, allowReplace: i6, api: p6, loaded: true, patching: /* @__PURE__ */ new Map() };
          return f6.set(o6.name, g7), Object.freeze(p6);
        }
        function h7() {
          const o6 = [];
          for (const e3 of f6.values()) o6.push({ name: e3.name, fullName: e3.fullName, version: e3.version, repository: e3.repository });
          return o6;
        }
        let m4;
        const y5 = void 0 === window.bcModSdk ? window.bcModSdk = (function() {
          const e3 = { version: o5, apiVersion: 1, registerMod: g6, getModsInfo: h7, getPatchingInfo: p5, errorReporterHooks: Object.seal({ apiEndpointEnter: null, hookEnter: null, hookChainExit: null }) };
          return m4 = e3, Object.freeze(e3);
        })() : (n4(window.bcModSdk) || e2("Failed to init Mod SDK: Name already in use"), 1 !== window.bcModSdk.apiVersion && e2(`Failed to init Mod SDK: Different version already loaded ('1.2.0' vs '${window.bcModSdk.version}')`), window.bcModSdk.version !== o5 && alert(`Mod SDK warning: Loading different but compatible versions ('1.2.0' vs '${window.bcModSdk.version}')
One of mods you are using is using an old version of SDK. It will work for now but please inform author to update`), window.bcModSdk);
        return "undefined" != typeof exports && (Object.defineProperty(exports, "__esModule", { value: true }), exports.default = y5), y5;
      })();
    }
  });

  // node_modules/.pnpm/react@19.2.0/node_modules/react/cjs/react.development.js
  var require_react_development = __commonJS({
    "node_modules/.pnpm/react@19.2.0/node_modules/react/cjs/react.development.js"(exports, module) {
      "use strict";
      (function() {
        function defineDeprecationWarning(methodName, info) {
          Object.defineProperty(Component.prototype, methodName, {
            get: function() {
              console.warn(
                "%s(...) is deprecated in plain JavaScript React classes. %s",
                info[0],
                info[1]
              );
            }
          });
        }
        function getIteratorFn(maybeIterable) {
          if (null === maybeIterable || "object" !== typeof maybeIterable)
            return null;
          maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
          return "function" === typeof maybeIterable ? maybeIterable : null;
        }
        function warnNoop(publicInstance, callerName) {
          publicInstance = (publicInstance = publicInstance.constructor) && (publicInstance.displayName || publicInstance.name) || "ReactClass";
          var warningKey = publicInstance + "." + callerName;
          didWarnStateUpdateForUnmountedComponent[warningKey] || (console.error(
            "Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.",
            callerName,
            publicInstance
          ), didWarnStateUpdateForUnmountedComponent[warningKey] = true);
        }
        function Component(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        function ComponentDummy() {
        }
        function PureComponent(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        function noop() {
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkKeyStringCoercion(value) {
          try {
            testStringCoercion(value);
            var JSCompiler_inline_result = false;
          } catch (e2) {
            JSCompiler_inline_result = true;
          }
          if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(
              JSCompiler_inline_result,
              "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
              JSCompiler_inline_result$jscomp$0
            );
            return testStringCoercion(value);
          }
        }
        function getComponentNameFromType(type) {
          if (null == type) return null;
          if ("function" === typeof type)
            return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
          if ("string" === typeof type) return type;
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
              return "Activity";
          }
          if ("object" === typeof type)
            switch ("number" === typeof type.tag && console.error(
              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
            ), type.$$typeof) {
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_CONTEXT_TYPE:
                return type.displayName || "Context";
              case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
              case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
              case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                  return getComponentNameFromType(type(innerType));
                } catch (x5) {
                }
            }
          return null;
        }
        function getTaskName(type) {
          if (type === REACT_FRAGMENT_TYPE) return "<>";
          if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE)
            return "<...>";
          try {
            var name = getComponentNameFromType(type);
            return name ? "<" + name + ">" : "<...>";
          } catch (x5) {
            return "<...>";
          }
        }
        function getOwner() {
          var dispatcher = ReactSharedInternals.A;
          return null === dispatcher ? null : dispatcher.getOwner();
        }
        function UnknownOwner() {
          return Error("react-stack-top-frame");
        }
        function hasValidKey(config) {
          if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) return false;
          }
          return void 0 !== config.key;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error(
              "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
              displayName
            ));
          }
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function elementRefGetterWithDeprecationWarning() {
          var componentName = getComponentNameFromType(this.type);
          didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error(
            "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
          ));
          componentName = this.props.ref;
          return void 0 !== componentName ? componentName : null;
        }
        function ReactElement(type, key, props, owner, debugStack, debugTask) {
          var refProp = props.ref;
          type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type,
            key,
            props,
            _owner: owner
          };
          null !== (void 0 !== refProp ? refProp : null) ? Object.defineProperty(type, "ref", {
            enumerable: false,
            get: elementRefGetterWithDeprecationWarning
          }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
          type._store = {};
          Object.defineProperty(type._store, "validated", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: 0
          });
          Object.defineProperty(type, "_debugInfo", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: null
          });
          Object.defineProperty(type, "_debugStack", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: debugStack
          });
          Object.defineProperty(type, "_debugTask", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: debugTask
          });
          Object.freeze && (Object.freeze(type.props), Object.freeze(type));
          return type;
        }
        function cloneAndReplaceKey(oldElement, newKey) {
          newKey = ReactElement(
            oldElement.type,
            newKey,
            oldElement.props,
            oldElement._owner,
            oldElement._debugStack,
            oldElement._debugTask
          );
          oldElement._store && (newKey._store.validated = oldElement._store.validated);
          return newKey;
        }
        function validateChildKeys(node) {
          isValidElement(node) ? node._store && (node._store.validated = 1) : "object" === typeof node && null !== node && node.$$typeof === REACT_LAZY_TYPE && ("fulfilled" === node._payload.status ? isValidElement(node._payload.value) && node._payload.value._store && (node._payload.value._store.validated = 1) : node._store && (node._store.validated = 1));
        }
        function isValidElement(object) {
          return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function escape(key) {
          var escaperLookup = { "=": "=0", ":": "=2" };
          return "$" + key.replace(/[=:]/g, function(match) {
            return escaperLookup[match];
          });
        }
        function getElementKey(element, index) {
          return "object" === typeof element && null !== element && null != element.key ? (checkKeyStringCoercion(element.key), escape("" + element.key)) : index.toString(36);
        }
        function resolveThenable(thenable) {
          switch (thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenable.reason;
            default:
              switch ("string" === typeof thenable.status ? thenable.then(noop, noop) : (thenable.status = "pending", thenable.then(
                function(fulfilledValue) {
                  "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
                },
                function(error) {
                  "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
                }
              )), thenable.status) {
                case "fulfilled":
                  return thenable.value;
                case "rejected":
                  throw thenable.reason;
              }
          }
          throw thenable;
        }
        function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
          var type = typeof children;
          if ("undefined" === type || "boolean" === type) children = null;
          var invokeCallback = false;
          if (null === children) invokeCallback = true;
          else
            switch (type) {
              case "bigint":
              case "string":
              case "number":
                invokeCallback = true;
                break;
              case "object":
                switch (children.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    invokeCallback = true;
                    break;
                  case REACT_LAZY_TYPE:
                    return invokeCallback = children._init, mapIntoArray(
                      invokeCallback(children._payload),
                      array,
                      escapedPrefix,
                      nameSoFar,
                      callback
                    );
                }
            }
          if (invokeCallback) {
            invokeCallback = children;
            callback = callback(invokeCallback);
            var childKey = "" === nameSoFar ? "." + getElementKey(invokeCallback, 0) : nameSoFar;
            isArrayImpl(callback) ? (escapedPrefix = "", null != childKey && (escapedPrefix = childKey.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c7) {
              return c7;
            })) : null != callback && (isValidElement(callback) && (null != callback.key && (invokeCallback && invokeCallback.key === callback.key || checkKeyStringCoercion(callback.key)), escapedPrefix = cloneAndReplaceKey(
              callback,
              escapedPrefix + (null == callback.key || invokeCallback && invokeCallback.key === callback.key ? "" : ("" + callback.key).replace(
                userProvidedKeyEscapeRegex,
                "$&/"
              ) + "/") + childKey
            ), "" !== nameSoFar && null != invokeCallback && isValidElement(invokeCallback) && null == invokeCallback.key && invokeCallback._store && !invokeCallback._store.validated && (escapedPrefix._store.validated = 2), callback = escapedPrefix), array.push(callback));
            return 1;
          }
          invokeCallback = 0;
          childKey = "" === nameSoFar ? "." : nameSoFar + ":";
          if (isArrayImpl(children))
            for (var i5 = 0; i5 < children.length; i5++)
              nameSoFar = children[i5], type = childKey + getElementKey(nameSoFar, i5), invokeCallback += mapIntoArray(
                nameSoFar,
                array,
                escapedPrefix,
                type,
                callback
              );
          else if (i5 = getIteratorFn(children), "function" === typeof i5)
            for (i5 === children.entries && (didWarnAboutMaps || console.warn(
              "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
            ), didWarnAboutMaps = true), children = i5.call(children), i5 = 0; !(nameSoFar = children.next()).done; )
              nameSoFar = nameSoFar.value, type = childKey + getElementKey(nameSoFar, i5++), invokeCallback += mapIntoArray(
                nameSoFar,
                array,
                escapedPrefix,
                type,
                callback
              );
          else if ("object" === type) {
            if ("function" === typeof children.then)
              return mapIntoArray(
                resolveThenable(children),
                array,
                escapedPrefix,
                nameSoFar,
                callback
              );
            array = String(children);
            throw Error(
              "Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead."
            );
          }
          return invokeCallback;
        }
        function mapChildren(children, func, context) {
          if (null == children) return children;
          var result = [], count = 0;
          mapIntoArray(children, result, "", "", function(child) {
            return func.call(context, child, count++);
          });
          return result;
        }
        function lazyInitializer(payload) {
          if (-1 === payload._status) {
            var ioInfo = payload._ioInfo;
            null != ioInfo && (ioInfo.start = ioInfo.end = performance.now());
            ioInfo = payload._result;
            var thenable = ioInfo();
            thenable.then(
              function(moduleObject) {
                if (0 === payload._status || -1 === payload._status) {
                  payload._status = 1;
                  payload._result = moduleObject;
                  var _ioInfo = payload._ioInfo;
                  null != _ioInfo && (_ioInfo.end = performance.now());
                  void 0 === thenable.status && (thenable.status = "fulfilled", thenable.value = moduleObject);
                }
              },
              function(error) {
                if (0 === payload._status || -1 === payload._status) {
                  payload._status = 2;
                  payload._result = error;
                  var _ioInfo2 = payload._ioInfo;
                  null != _ioInfo2 && (_ioInfo2.end = performance.now());
                  void 0 === thenable.status && (thenable.status = "rejected", thenable.reason = error);
                }
              }
            );
            ioInfo = payload._ioInfo;
            if (null != ioInfo) {
              ioInfo.value = thenable;
              var displayName = thenable.displayName;
              "string" === typeof displayName && (ioInfo.name = displayName);
            }
            -1 === payload._status && (payload._status = 0, payload._result = thenable);
          }
          if (1 === payload._status)
            return ioInfo = payload._result, void 0 === ioInfo && console.error(
              "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?",
              ioInfo
            ), "default" in ioInfo || console.error(
              "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))",
              ioInfo
            ), ioInfo.default;
          throw payload._result;
        }
        function resolveDispatcher() {
          var dispatcher = ReactSharedInternals.H;
          null === dispatcher && console.error(
            "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
          );
          return dispatcher;
        }
        function releaseAsyncTransition() {
          ReactSharedInternals.asyncTransitions--;
        }
        function enqueueTask(task) {
          if (null === enqueueTaskImpl)
            try {
              var requireString = ("require" + Math.random()).slice(0, 7);
              enqueueTaskImpl = (module && module[requireString]).call(
                module,
                "timers"
              ).setImmediate;
            } catch (_err) {
              enqueueTaskImpl = function(callback) {
                false === didWarnAboutMessageChannel && (didWarnAboutMessageChannel = true, "undefined" === typeof MessageChannel && console.error(
                  "This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."
                ));
                var channel = new MessageChannel();
                channel.port1.onmessage = callback;
                channel.port2.postMessage(void 0);
              };
            }
          return enqueueTaskImpl(task);
        }
        function aggregateErrors(errors) {
          return 1 < errors.length && "function" === typeof AggregateError ? new AggregateError(errors) : errors[0];
        }
        function popActScope(prevActQueue, prevActScopeDepth) {
          prevActScopeDepth !== actScopeDepth - 1 && console.error(
            "You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "
          );
          actScopeDepth = prevActScopeDepth;
        }
        function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
          var queue = ReactSharedInternals.actQueue;
          if (null !== queue)
            if (0 !== queue.length)
              try {
                flushActQueue(queue);
                enqueueTask(function() {
                  return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                });
                return;
              } catch (error) {
                ReactSharedInternals.thrownErrors.push(error);
              }
            else ReactSharedInternals.actQueue = null;
          0 < ReactSharedInternals.thrownErrors.length ? (queue = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject(queue)) : resolve(returnValue);
        }
        function flushActQueue(queue) {
          if (!isFlushing) {
            isFlushing = true;
            var i5 = 0;
            try {
              for (; i5 < queue.length; i5++) {
                var callback = queue[i5];
                do {
                  ReactSharedInternals.didUsePromise = false;
                  var continuation = callback(false);
                  if (null !== continuation) {
                    if (ReactSharedInternals.didUsePromise) {
                      queue[i5] = callback;
                      queue.splice(0, i5);
                      return;
                    }
                    callback = continuation;
                  } else break;
                } while (1);
              }
              queue.length = 0;
            } catch (error) {
              queue.splice(0, i5 + 1), ReactSharedInternals.thrownErrors.push(error);
            } finally {
              isFlushing = false;
            }
          }
        }
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
        var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, didWarnStateUpdateForUnmountedComponent = {}, ReactNoopUpdateQueue = {
          isMounted: function() {
            return false;
          },
          enqueueForceUpdate: function(publicInstance) {
            warnNoop(publicInstance, "forceUpdate");
          },
          enqueueReplaceState: function(publicInstance) {
            warnNoop(publicInstance, "replaceState");
          },
          enqueueSetState: function(publicInstance) {
            warnNoop(publicInstance, "setState");
          }
        }, assign = Object.assign, emptyObject = {};
        Object.freeze(emptyObject);
        Component.prototype.isReactComponent = {};
        Component.prototype.setState = function(partialState, callback) {
          if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
            throw Error(
              "takes an object of state variables to update or a function which returns an object of state variables."
            );
          this.updater.enqueueSetState(this, partialState, callback, "setState");
        };
        Component.prototype.forceUpdate = function(callback) {
          this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
        };
        var deprecatedAPIs = {
          isMounted: [
            "isMounted",
            "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."
          ],
          replaceState: [
            "replaceState",
            "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."
          ]
        };
        for (fnName in deprecatedAPIs)
          deprecatedAPIs.hasOwnProperty(fnName) && defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
        ComponentDummy.prototype = Component.prototype;
        deprecatedAPIs = PureComponent.prototype = new ComponentDummy();
        deprecatedAPIs.constructor = PureComponent;
        assign(deprecatedAPIs, Component.prototype);
        deprecatedAPIs.isPureReactComponent = true;
        var isArrayImpl = Array.isArray, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = {
          H: null,
          A: null,
          T: null,
          S: null,
          actQueue: null,
          asyncTransitions: 0,
          isBatchingLegacy: false,
          didScheduleLegacyUpdate: false,
          didUsePromise: false,
          thrownErrors: [],
          getCurrentStack: null,
          recentlyCreatedOwnerStacks: 0
        }, hasOwnProperty = Object.prototype.hasOwnProperty, createTask = console.createTask ? console.createTask : function() {
          return null;
        };
        deprecatedAPIs = {
          react_stack_bottom_frame: function(callStackForError) {
            return callStackForError();
          }
        };
        var specialPropKeyWarningShown, didWarnAboutOldJSXRuntime;
        var didWarnAboutElementRef = {};
        var unknownOwnerDebugStack = deprecatedAPIs.react_stack_bottom_frame.bind(
          deprecatedAPIs,
          UnknownOwner
        )();
        var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
        var didWarnAboutMaps = false, userProvidedKeyEscapeRegex = /\/+/g, reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
          if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
            var event = new window.ErrorEvent("error", {
              bubbles: true,
              cancelable: true,
              message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
              error
            });
            if (!window.dispatchEvent(event)) return;
          } else if ("object" === typeof process && "function" === typeof process.emit) {
            process.emit("uncaughtException", error);
            return;
          }
          console.error(error);
        }, didWarnAboutMessageChannel = false, enqueueTaskImpl = null, actScopeDepth = 0, didWarnNoAwaitAct = false, isFlushing = false, queueSeveralMicrotasks = "function" === typeof queueMicrotask ? function(callback) {
          queueMicrotask(function() {
            return queueMicrotask(callback);
          });
        } : enqueueTask;
        deprecatedAPIs = Object.freeze({
          __proto__: null,
          c: function(size) {
            return resolveDispatcher().useMemoCache(size);
          }
        });
        var fnName = {
          map: mapChildren,
          forEach: function(children, forEachFunc, forEachContext) {
            mapChildren(
              children,
              function() {
                forEachFunc.apply(this, arguments);
              },
              forEachContext
            );
          },
          count: function(children) {
            var n4 = 0;
            mapChildren(children, function() {
              n4++;
            });
            return n4;
          },
          toArray: function(children) {
            return mapChildren(children, function(child) {
              return child;
            }) || [];
          },
          only: function(children) {
            if (!isValidElement(children))
              throw Error(
                "React.Children.only expected to receive a single React element child."
              );
            return children;
          }
        };
        exports.Activity = REACT_ACTIVITY_TYPE;
        exports.Children = fnName;
        exports.Component = Component;
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.Profiler = REACT_PROFILER_TYPE;
        exports.PureComponent = PureComponent;
        exports.StrictMode = REACT_STRICT_MODE_TYPE;
        exports.Suspense = REACT_SUSPENSE_TYPE;
        exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
        exports.__COMPILER_RUNTIME = deprecatedAPIs;
        exports.act = function(callback) {
          var prevActQueue = ReactSharedInternals.actQueue, prevActScopeDepth = actScopeDepth;
          actScopeDepth++;
          var queue = ReactSharedInternals.actQueue = null !== prevActQueue ? prevActQueue : [], didAwaitActCall = false;
          try {
            var result = callback();
          } catch (error) {
            ReactSharedInternals.thrownErrors.push(error);
          }
          if (0 < ReactSharedInternals.thrownErrors.length)
            throw popActScope(prevActQueue, prevActScopeDepth), callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
          if (null !== result && "object" === typeof result && "function" === typeof result.then) {
            var thenable = result;
            queueSeveralMicrotasks(function() {
              didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error(
                "You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"
              ));
            });
            return {
              then: function(resolve, reject) {
                didAwaitActCall = true;
                thenable.then(
                  function(returnValue) {
                    popActScope(prevActQueue, prevActScopeDepth);
                    if (0 === prevActScopeDepth) {
                      try {
                        flushActQueue(queue), enqueueTask(function() {
                          return recursivelyFlushAsyncActWork(
                            returnValue,
                            resolve,
                            reject
                          );
                        });
                      } catch (error$0) {
                        ReactSharedInternals.thrownErrors.push(error$0);
                      }
                      if (0 < ReactSharedInternals.thrownErrors.length) {
                        var _thrownError = aggregateErrors(
                          ReactSharedInternals.thrownErrors
                        );
                        ReactSharedInternals.thrownErrors.length = 0;
                        reject(_thrownError);
                      }
                    } else resolve(returnValue);
                  },
                  function(error) {
                    popActScope(prevActQueue, prevActScopeDepth);
                    0 < ReactSharedInternals.thrownErrors.length ? (error = aggregateErrors(
                      ReactSharedInternals.thrownErrors
                    ), ReactSharedInternals.thrownErrors.length = 0, reject(error)) : reject(error);
                  }
                );
              }
            };
          }
          var returnValue$jscomp$0 = result;
          popActScope(prevActQueue, prevActScopeDepth);
          0 === prevActScopeDepth && (flushActQueue(queue), 0 !== queue.length && queueSeveralMicrotasks(function() {
            didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error(
              "A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"
            ));
          }), ReactSharedInternals.actQueue = null);
          if (0 < ReactSharedInternals.thrownErrors.length)
            throw callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
          return {
            then: function(resolve, reject) {
              didAwaitActCall = true;
              0 === prevActScopeDepth ? (ReactSharedInternals.actQueue = queue, enqueueTask(function() {
                return recursivelyFlushAsyncActWork(
                  returnValue$jscomp$0,
                  resolve,
                  reject
                );
              })) : resolve(returnValue$jscomp$0);
            }
          };
        };
        exports.cache = function(fn) {
          return function() {
            return fn.apply(null, arguments);
          };
        };
        exports.cacheSignal = function() {
          return null;
        };
        exports.captureOwnerStack = function() {
          var getCurrentStack = ReactSharedInternals.getCurrentStack;
          return null === getCurrentStack ? null : getCurrentStack();
        };
        exports.cloneElement = function(element, config, children) {
          if (null === element || void 0 === element)
            throw Error(
              "The argument must be a React element, but you passed " + element + "."
            );
          var props = assign({}, element.props), key = element.key, owner = element._owner;
          if (null != config) {
            var JSCompiler_inline_result;
            a: {
              if (hasOwnProperty.call(config, "ref") && (JSCompiler_inline_result = Object.getOwnPropertyDescriptor(
                config,
                "ref"
              ).get) && JSCompiler_inline_result.isReactWarning) {
                JSCompiler_inline_result = false;
                break a;
              }
              JSCompiler_inline_result = void 0 !== config.ref;
            }
            JSCompiler_inline_result && (owner = getOwner());
            hasValidKey(config) && (checkKeyStringCoercion(config.key), key = "" + config.key);
            for (propName in config)
              !hasOwnProperty.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
          }
          var propName = arguments.length - 2;
          if (1 === propName) props.children = children;
          else if (1 < propName) {
            JSCompiler_inline_result = Array(propName);
            for (var i5 = 0; i5 < propName; i5++)
              JSCompiler_inline_result[i5] = arguments[i5 + 2];
            props.children = JSCompiler_inline_result;
          }
          props = ReactElement(
            element.type,
            key,
            props,
            owner,
            element._debugStack,
            element._debugTask
          );
          for (key = 2; key < arguments.length; key++)
            validateChildKeys(arguments[key]);
          return props;
        };
        exports.createContext = function(defaultValue) {
          defaultValue = {
            $$typeof: REACT_CONTEXT_TYPE,
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            _threadCount: 0,
            Provider: null,
            Consumer: null
          };
          defaultValue.Provider = defaultValue;
          defaultValue.Consumer = {
            $$typeof: REACT_CONSUMER_TYPE,
            _context: defaultValue
          };
          defaultValue._currentRenderer = null;
          defaultValue._currentRenderer2 = null;
          return defaultValue;
        };
        exports.createElement = function(type, config, children) {
          for (var i5 = 2; i5 < arguments.length; i5++)
            validateChildKeys(arguments[i5]);
          i5 = {};
          var key = null;
          if (null != config)
            for (propName in didWarnAboutOldJSXRuntime || !("__self" in config) || "key" in config || (didWarnAboutOldJSXRuntime = true, console.warn(
              "Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform"
            )), hasValidKey(config) && (checkKeyStringCoercion(config.key), key = "" + config.key), config)
              hasOwnProperty.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (i5[propName] = config[propName]);
          var childrenLength = arguments.length - 2;
          if (1 === childrenLength) i5.children = children;
          else if (1 < childrenLength) {
            for (var childArray = Array(childrenLength), _i = 0; _i < childrenLength; _i++)
              childArray[_i] = arguments[_i + 2];
            Object.freeze && Object.freeze(childArray);
            i5.children = childArray;
          }
          if (type && type.defaultProps)
            for (propName in childrenLength = type.defaultProps, childrenLength)
              void 0 === i5[propName] && (i5[propName] = childrenLength[propName]);
          key && defineKeyPropWarningGetter(
            i5,
            "function" === typeof type ? type.displayName || type.name || "Unknown" : type
          );
          var propName = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
          return ReactElement(
            type,
            key,
            i5,
            getOwner(),
            propName ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
            propName ? createTask(getTaskName(type)) : unknownOwnerDebugTask
          );
        };
        exports.createRef = function() {
          var refObject = { current: null };
          Object.seal(refObject);
          return refObject;
        };
        exports.forwardRef = function(render) {
          null != render && render.$$typeof === REACT_MEMO_TYPE ? console.error(
            "forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))."
          ) : "function" !== typeof render ? console.error(
            "forwardRef requires a render function but was given %s.",
            null === render ? "null" : typeof render
          ) : 0 !== render.length && 2 !== render.length && console.error(
            "forwardRef render functions accept exactly two parameters: props and ref. %s",
            1 === render.length ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."
          );
          null != render && null != render.defaultProps && console.error(
            "forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?"
          );
          var elementType = { $$typeof: REACT_FORWARD_REF_TYPE, render }, ownName;
          Object.defineProperty(elementType, "displayName", {
            enumerable: false,
            configurable: true,
            get: function() {
              return ownName;
            },
            set: function(name) {
              ownName = name;
              render.name || render.displayName || (Object.defineProperty(render, "name", { value: name }), render.displayName = name);
            }
          });
          return elementType;
        };
        exports.isValidElement = isValidElement;
        exports.lazy = function(ctor) {
          ctor = { _status: -1, _result: ctor };
          var lazyType = {
            $$typeof: REACT_LAZY_TYPE,
            _payload: ctor,
            _init: lazyInitializer
          }, ioInfo = {
            name: "lazy",
            start: -1,
            end: -1,
            value: null,
            owner: null,
            debugStack: Error("react-stack-top-frame"),
            debugTask: console.createTask ? console.createTask("lazy()") : null
          };
          ctor._ioInfo = ioInfo;
          lazyType._debugInfo = [{ awaited: ioInfo }];
          return lazyType;
        };
        exports.memo = function(type, compare) {
          null == type && console.error(
            "memo: The first argument must be a component. Instead received: %s",
            null === type ? "null" : typeof type
          );
          compare = {
            $$typeof: REACT_MEMO_TYPE,
            type,
            compare: void 0 === compare ? null : compare
          };
          var ownName;
          Object.defineProperty(compare, "displayName", {
            enumerable: false,
            configurable: true,
            get: function() {
              return ownName;
            },
            set: function(name) {
              ownName = name;
              type.name || type.displayName || (Object.defineProperty(type, "name", { value: name }), type.displayName = name);
            }
          });
          return compare;
        };
        exports.startTransition = function(scope) {
          var prevTransition = ReactSharedInternals.T, currentTransition = {};
          currentTransition._updatedFibers = /* @__PURE__ */ new Set();
          ReactSharedInternals.T = currentTransition;
          try {
            var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
            null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
            "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && (ReactSharedInternals.asyncTransitions++, returnValue.then(releaseAsyncTransition, releaseAsyncTransition), returnValue.then(noop, reportGlobalError));
          } catch (error) {
            reportGlobalError(error);
          } finally {
            null === prevTransition && currentTransition._updatedFibers && (scope = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < scope && console.warn(
              "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
            )), null !== prevTransition && null !== currentTransition.types && (null !== prevTransition.types && prevTransition.types !== currentTransition.types && console.error(
              "We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React."
            ), prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
          }
        };
        exports.unstable_useCacheRefresh = function() {
          return resolveDispatcher().useCacheRefresh();
        };
        exports.use = function(usable) {
          return resolveDispatcher().use(usable);
        };
        exports.useActionState = function(action, initialState, permalink) {
          return resolveDispatcher().useActionState(
            action,
            initialState,
            permalink
          );
        };
        exports.useCallback = function(callback, deps) {
          return resolveDispatcher().useCallback(callback, deps);
        };
        exports.useContext = function(Context) {
          var dispatcher = resolveDispatcher();
          Context.$$typeof === REACT_CONSUMER_TYPE && console.error(
            "Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?"
          );
          return dispatcher.useContext(Context);
        };
        exports.useDebugValue = function(value, formatterFn) {
          return resolveDispatcher().useDebugValue(value, formatterFn);
        };
        exports.useDeferredValue = function(value, initialValue) {
          return resolveDispatcher().useDeferredValue(value, initialValue);
        };
        exports.useEffect = function(create2, deps) {
          null == create2 && console.warn(
            "React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?"
          );
          return resolveDispatcher().useEffect(create2, deps);
        };
        exports.useEffectEvent = function(callback) {
          return resolveDispatcher().useEffectEvent(callback);
        };
        exports.useId = function() {
          return resolveDispatcher().useId();
        };
        exports.useImperativeHandle = function(ref, create2, deps) {
          return resolveDispatcher().useImperativeHandle(ref, create2, deps);
        };
        exports.useInsertionEffect = function(create2, deps) {
          null == create2 && console.warn(
            "React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?"
          );
          return resolveDispatcher().useInsertionEffect(create2, deps);
        };
        exports.useLayoutEffect = function(create2, deps) {
          null == create2 && console.warn(
            "React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?"
          );
          return resolveDispatcher().useLayoutEffect(create2, deps);
        };
        exports.useMemo = function(create2, deps) {
          return resolveDispatcher().useMemo(create2, deps);
        };
        exports.useOptimistic = function(passthrough, reducer) {
          return resolveDispatcher().useOptimistic(passthrough, reducer);
        };
        exports.useReducer = function(reducer, initialArg, init) {
          return resolveDispatcher().useReducer(reducer, initialArg, init);
        };
        exports.useRef = function(initialValue) {
          return resolveDispatcher().useRef(initialValue);
        };
        exports.useState = function(initialState) {
          return resolveDispatcher().useState(initialState);
        };
        exports.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
          return resolveDispatcher().useSyncExternalStore(
            subscribe,
            getSnapshot,
            getServerSnapshot
          );
        };
        exports.useTransition = function() {
          return resolveDispatcher().useTransition();
        };
        exports.version = "19.2.0";
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
      })();
    }
  });

  // node_modules/.pnpm/react@19.2.0/node_modules/react/index.js
  var require_react = __commonJS({
    "node_modules/.pnpm/react@19.2.0/node_modules/react/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_react_development();
      }
    }
  });

  // node_modules/.pnpm/scheduler@0.27.0/node_modules/scheduler/cjs/scheduler.development.js
  var require_scheduler_development = __commonJS({
    "node_modules/.pnpm/scheduler@0.27.0/node_modules/scheduler/cjs/scheduler.development.js"(exports) {
      "use strict";
      (function() {
        function performWorkUntilDeadline() {
          needsPaint = false;
          if (isMessageLoopRunning) {
            var currentTime = exports.unstable_now();
            startTime = currentTime;
            var hasMoreWork = true;
            try {
              a: {
                isHostCallbackScheduled = false;
                isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
                isPerformingWork = true;
                var previousPriorityLevel = currentPriorityLevel;
                try {
                  b: {
                    advanceTimers(currentTime);
                    for (currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost()); ) {
                      var callback = currentTask.callback;
                      if ("function" === typeof callback) {
                        currentTask.callback = null;
                        currentPriorityLevel = currentTask.priorityLevel;
                        var continuationCallback = callback(
                          currentTask.expirationTime <= currentTime
                        );
                        currentTime = exports.unstable_now();
                        if ("function" === typeof continuationCallback) {
                          currentTask.callback = continuationCallback;
                          advanceTimers(currentTime);
                          hasMoreWork = true;
                          break b;
                        }
                        currentTask === peek(taskQueue) && pop(taskQueue);
                        advanceTimers(currentTime);
                      } else pop(taskQueue);
                      currentTask = peek(taskQueue);
                    }
                    if (null !== currentTask) hasMoreWork = true;
                    else {
                      var firstTimer = peek(timerQueue);
                      null !== firstTimer && requestHostTimeout(
                        handleTimeout,
                        firstTimer.startTime - currentTime
                      );
                      hasMoreWork = false;
                    }
                  }
                  break a;
                } finally {
                  currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
                }
                hasMoreWork = void 0;
              }
            } finally {
              hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
            }
          }
        }
        function push(heap, node) {
          var index = heap.length;
          heap.push(node);
          a: for (; 0 < index; ) {
            var parentIndex = index - 1 >>> 1, parent = heap[parentIndex];
            if (0 < compare(parent, node))
              heap[parentIndex] = node, heap[index] = parent, index = parentIndex;
            else break a;
          }
        }
        function peek(heap) {
          return 0 === heap.length ? null : heap[0];
        }
        function pop(heap) {
          if (0 === heap.length) return null;
          var first = heap[0], last = heap.pop();
          if (last !== first) {
            heap[0] = last;
            a: for (var index = 0, length = heap.length, halfLength = length >>> 1; index < halfLength; ) {
              var leftIndex = 2 * (index + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
              if (0 > compare(left, last))
                rightIndex < length && 0 > compare(right, left) ? (heap[index] = right, heap[rightIndex] = last, index = rightIndex) : (heap[index] = left, heap[leftIndex] = last, index = leftIndex);
              else if (rightIndex < length && 0 > compare(right, last))
                heap[index] = right, heap[rightIndex] = last, index = rightIndex;
              else break a;
            }
          }
          return first;
        }
        function compare(a5, b3) {
          var diff = a5.sortIndex - b3.sortIndex;
          return 0 !== diff ? diff : a5.id - b3.id;
        }
        function advanceTimers(currentTime) {
          for (var timer = peek(timerQueue); null !== timer; ) {
            if (null === timer.callback) pop(timerQueue);
            else if (timer.startTime <= currentTime)
              pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
            else break;
            timer = peek(timerQueue);
          }
        }
        function handleTimeout(currentTime) {
          isHostTimeoutScheduled = false;
          advanceTimers(currentTime);
          if (!isHostCallbackScheduled)
            if (null !== peek(taskQueue))
              isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());
            else {
              var firstTimer = peek(timerQueue);
              null !== firstTimer && requestHostTimeout(
                handleTimeout,
                firstTimer.startTime - currentTime
              );
            }
        }
        function shouldYieldToHost() {
          return needsPaint ? true : exports.unstable_now() - startTime < frameInterval ? false : true;
        }
        function requestHostTimeout(callback, ms) {
          taskTimeoutID = localSetTimeout(function() {
            callback(exports.unstable_now());
          }, ms);
        }
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
        exports.unstable_now = void 0;
        if ("object" === typeof performance && "function" === typeof performance.now) {
          var localPerformance = performance;
          exports.unstable_now = function() {
            return localPerformance.now();
          };
        } else {
          var localDate = Date, initialTime = localDate.now();
          exports.unstable_now = function() {
            return localDate.now() - initialTime;
          };
        }
        var taskQueue = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = false, isHostCallbackScheduled = false, isHostTimeoutScheduled = false, needsPaint = false, localSetTimeout = "function" === typeof setTimeout ? setTimeout : null, localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null, localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null, isMessageLoopRunning = false, taskTimeoutID = -1, frameInterval = 5, startTime = -1;
        if ("function" === typeof localSetImmediate)
          var schedulePerformWorkUntilDeadline = function() {
            localSetImmediate(performWorkUntilDeadline);
          };
        else if ("undefined" !== typeof MessageChannel) {
          var channel = new MessageChannel(), port = channel.port2;
          channel.port1.onmessage = performWorkUntilDeadline;
          schedulePerformWorkUntilDeadline = function() {
            port.postMessage(null);
          };
        } else
          schedulePerformWorkUntilDeadline = function() {
            localSetTimeout(performWorkUntilDeadline, 0);
          };
        exports.unstable_IdlePriority = 5;
        exports.unstable_ImmediatePriority = 1;
        exports.unstable_LowPriority = 4;
        exports.unstable_NormalPriority = 3;
        exports.unstable_Profiling = null;
        exports.unstable_UserBlockingPriority = 2;
        exports.unstable_cancelCallback = function(task) {
          task.callback = null;
        };
        exports.unstable_forceFrameRate = function(fps) {
          0 > fps || 125 < fps ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          ) : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
        };
        exports.unstable_getCurrentPriorityLevel = function() {
          return currentPriorityLevel;
        };
        exports.unstable_next = function(eventHandler) {
          switch (currentPriorityLevel) {
            case 1:
            case 2:
            case 3:
              var priorityLevel = 3;
              break;
            default:
              priorityLevel = currentPriorityLevel;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
        exports.unstable_requestPaint = function() {
          needsPaint = true;
        };
        exports.unstable_runWithPriority = function(priorityLevel, eventHandler) {
          switch (priorityLevel) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
              break;
            default:
              priorityLevel = 3;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
        exports.unstable_scheduleCallback = function(priorityLevel, callback, options) {
          var currentTime = exports.unstable_now();
          "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
          switch (priorityLevel) {
            case 1:
              var timeout = -1;
              break;
            case 2:
              timeout = 250;
              break;
            case 5:
              timeout = 1073741823;
              break;
            case 4:
              timeout = 1e4;
              break;
            default:
              timeout = 5e3;
          }
          timeout = options + timeout;
          priorityLevel = {
            id: taskIdCounter++,
            callback,
            priorityLevel,
            startTime: options,
            expirationTime: timeout,
            sortIndex: -1
          };
          options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline())));
          return priorityLevel;
        };
        exports.unstable_shouldYield = shouldYieldToHost;
        exports.unstable_wrapCallback = function(callback) {
          var parentPriorityLevel = currentPriorityLevel;
          return function() {
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = parentPriorityLevel;
            try {
              return callback.apply(this, arguments);
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          };
        };
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
      })();
    }
  });

  // node_modules/.pnpm/scheduler@0.27.0/node_modules/scheduler/index.js
  var require_scheduler = __commonJS({
    "node_modules/.pnpm/scheduler@0.27.0/node_modules/scheduler/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_scheduler_development();
      }
    }
  });

  // node_modules/.pnpm/react-dom@19.2.0_react@19.2.0/node_modules/react-dom/cjs/react-dom.development.js
  var require_react_dom_development = __commonJS({
    "node_modules/.pnpm/react-dom@19.2.0_react@19.2.0/node_modules/react-dom/cjs/react-dom.development.js"(exports) {
      "use strict";
      (function() {
        function noop() {
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function createPortal$1(children, containerInfo, implementation) {
          var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
          try {
            testStringCoercion(key);
            var JSCompiler_inline_result = false;
          } catch (e2) {
            JSCompiler_inline_result = true;
          }
          JSCompiler_inline_result && (console.error(
            "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
            "function" === typeof Symbol && Symbol.toStringTag && key[Symbol.toStringTag] || key.constructor.name || "Object"
          ), testStringCoercion(key));
          return {
            $$typeof: REACT_PORTAL_TYPE,
            key: null == key ? null : "" + key,
            children,
            containerInfo,
            implementation
          };
        }
        function getCrossOriginStringAs(as, input) {
          if ("font" === as) return "";
          if ("string" === typeof input)
            return "use-credentials" === input ? input : "";
        }
        function getValueDescriptorExpectingObjectForWarning(thing) {
          return null === thing ? "`null`" : void 0 === thing ? "`undefined`" : "" === thing ? "an empty string" : 'something with type "' + typeof thing + '"';
        }
        function getValueDescriptorExpectingEnumForWarning(thing) {
          return null === thing ? "`null`" : void 0 === thing ? "`undefined`" : "" === thing ? "an empty string" : "string" === typeof thing ? JSON.stringify(thing) : "number" === typeof thing ? "`" + thing + "`" : 'something with type "' + typeof thing + '"';
        }
        function resolveDispatcher() {
          var dispatcher = ReactSharedInternals.H;
          null === dispatcher && console.error(
            "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
          );
          return dispatcher;
        }
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
        var React2 = require_react(), Internals = {
          d: {
            f: noop,
            r: function() {
              throw Error(
                "Invalid form element. requestFormReset must be passed a form that was rendered by React."
              );
            },
            D: noop,
            C: noop,
            L: noop,
            m: noop,
            X: noop,
            S: noop,
            M: noop
          },
          p: 0,
          findDOMNode: null
        }, REACT_PORTAL_TYPE = Symbol.for("react.portal"), ReactSharedInternals = React2.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
        "function" === typeof Map && null != Map.prototype && "function" === typeof Map.prototype.forEach && "function" === typeof Set && null != Set.prototype && "function" === typeof Set.prototype.clear && "function" === typeof Set.prototype.forEach || console.error(
          "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"
        );
        exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
        exports.createPortal = function(children, container) {
          var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
          if (!container || 1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType)
            throw Error("Target container is not a DOM element.");
          return createPortal$1(children, container, null, key);
        };
        exports.flushSync = function(fn) {
          var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
          try {
            if (ReactSharedInternals.T = null, Internals.p = 2, fn)
              return fn();
          } finally {
            ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f() && console.error(
              "flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."
            );
          }
        };
        exports.preconnect = function(href, options) {
          "string" === typeof href && href ? null != options && "object" !== typeof options ? console.error(
            "ReactDOM.preconnect(): Expected the `options` argument (second) to be an object but encountered %s instead. The only supported option at this time is `crossOrigin` which accepts a string.",
            getValueDescriptorExpectingEnumForWarning(options)
          ) : null != options && "string" !== typeof options.crossOrigin && console.error(
            "ReactDOM.preconnect(): Expected the `crossOrigin` option (second argument) to be a string but encountered %s instead. Try removing this option or passing a string value instead.",
            getValueDescriptorExpectingObjectForWarning(options.crossOrigin)
          ) : console.error(
            "ReactDOM.preconnect(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
            getValueDescriptorExpectingObjectForWarning(href)
          );
          "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
        };
        exports.prefetchDNS = function(href) {
          if ("string" !== typeof href || !href)
            console.error(
              "ReactDOM.prefetchDNS(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
              getValueDescriptorExpectingObjectForWarning(href)
            );
          else if (1 < arguments.length) {
            var options = arguments[1];
            "object" === typeof options && options.hasOwnProperty("crossOrigin") ? console.error(
              "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. It looks like the you are attempting to set a crossOrigin property for this DNS lookup hint. Browsers do not perform DNS queries using CORS and setting this attribute on the resource hint has no effect. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
              getValueDescriptorExpectingEnumForWarning(options)
            ) : console.error(
              "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
              getValueDescriptorExpectingEnumForWarning(options)
            );
          }
          "string" === typeof href && Internals.d.D(href);
        };
        exports.preinit = function(href, options) {
          "string" === typeof href && href ? null == options || "object" !== typeof options ? console.error(
            "ReactDOM.preinit(): Expected the `options` argument (second) to be an object with an `as` property describing the type of resource to be preinitialized but encountered %s instead.",
            getValueDescriptorExpectingEnumForWarning(options)
          ) : "style" !== options.as && "script" !== options.as && console.error(
            'ReactDOM.preinit(): Expected the `as` property in the `options` argument (second) to contain a valid value describing the type of resource to be preinitialized but encountered %s instead. Valid values for `as` are "style" and "script".',
            getValueDescriptorExpectingEnumForWarning(options.as)
          ) : console.error(
            "ReactDOM.preinit(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
            getValueDescriptorExpectingObjectForWarning(href)
          );
          if ("string" === typeof href && options && "string" === typeof options.as) {
            var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin), integrity = "string" === typeof options.integrity ? options.integrity : void 0, fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
            "style" === as ? Internals.d.S(
              href,
              "string" === typeof options.precedence ? options.precedence : void 0,
              {
                crossOrigin,
                integrity,
                fetchPriority
              }
            ) : "script" === as && Internals.d.X(href, {
              crossOrigin,
              integrity,
              fetchPriority,
              nonce: "string" === typeof options.nonce ? options.nonce : void 0
            });
          }
        };
        exports.preinitModule = function(href, options) {
          var encountered = "";
          "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
          void 0 !== options && "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && "as" in options && "script" !== options.as && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingEnumForWarning(options.as) + ".");
          if (encountered)
            console.error(
              "ReactDOM.preinitModule(): Expected up to two arguments, a non-empty `href` string and, optionally, an `options` object with a valid `as` property.%s",
              encountered
            );
          else
            switch (encountered = options && "string" === typeof options.as ? options.as : "script", encountered) {
              case "script":
                break;
              default:
                encountered = getValueDescriptorExpectingEnumForWarning(encountered), console.error(
                  'ReactDOM.preinitModule(): Currently the only supported "as" type for this function is "script" but received "%s" instead. This warning was generated for `href` "%s". In the future other module types will be supported, aligning with the import-attributes proposal. Learn more here: (https://github.com/tc39/proposal-import-attributes)',
                  encountered,
                  href
                );
            }
          if ("string" === typeof href)
            if ("object" === typeof options && null !== options) {
              if (null == options.as || "script" === options.as)
                encountered = getCrossOriginStringAs(
                  options.as,
                  options.crossOrigin
                ), Internals.d.M(href, {
                  crossOrigin: encountered,
                  integrity: "string" === typeof options.integrity ? options.integrity : void 0,
                  nonce: "string" === typeof options.nonce ? options.nonce : void 0
                });
            } else null == options && Internals.d.M(href);
        };
        exports.preload = function(href, options) {
          var encountered = "";
          "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
          null == options || "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : "string" === typeof options.as && options.as || (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
          encountered && console.error(
            'ReactDOM.preload(): Expected two arguments, a non-empty `href` string and an `options` object with an `as` property valid for a `<link rel="preload" as="..." />` tag.%s',
            encountered
          );
          if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
            encountered = options.as;
            var crossOrigin = getCrossOriginStringAs(
              encountered,
              options.crossOrigin
            );
            Internals.d.L(href, encountered, {
              crossOrigin,
              integrity: "string" === typeof options.integrity ? options.integrity : void 0,
              nonce: "string" === typeof options.nonce ? options.nonce : void 0,
              type: "string" === typeof options.type ? options.type : void 0,
              fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
              referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
              imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
              imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
              media: "string" === typeof options.media ? options.media : void 0
            });
          }
        };
        exports.preloadModule = function(href, options) {
          var encountered = "";
          "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
          void 0 !== options && "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && "as" in options && "string" !== typeof options.as && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
          encountered && console.error(
            'ReactDOM.preloadModule(): Expected two arguments, a non-empty `href` string and, optionally, an `options` object with an `as` property valid for a `<link rel="modulepreload" as="..." />` tag.%s',
            encountered
          );
          "string" === typeof href && (options ? (encountered = getCrossOriginStringAs(
            options.as,
            options.crossOrigin
          ), Internals.d.m(href, {
            as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
            crossOrigin: encountered,
            integrity: "string" === typeof options.integrity ? options.integrity : void 0
          })) : Internals.d.m(href));
        };
        exports.requestFormReset = function(form) {
          Internals.d.r(form);
        };
        exports.unstable_batchedUpdates = function(fn, a5) {
          return fn(a5);
        };
        exports.useFormState = function(action, initialState, permalink) {
          return resolveDispatcher().useFormState(action, initialState, permalink);
        };
        exports.useFormStatus = function() {
          return resolveDispatcher().useHostTransitionStatus();
        };
        exports.version = "19.2.0";
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
      })();
    }
  });

  // node_modules/.pnpm/react-dom@19.2.0_react@19.2.0/node_modules/react-dom/index.js
  var require_react_dom = __commonJS({
    "node_modules/.pnpm/react-dom@19.2.0_react@19.2.0/node_modules/react-dom/index.js"(exports, module) {
      "use strict";
      if (false) {
        checkDCE();
        module.exports = null;
      } else {
        module.exports = require_react_dom_development();
      }
    }
  });

  // node_modules/.pnpm/react-dom@19.2.0_react@19.2.0/node_modules/react-dom/cjs/react-dom-client.development.js
  var require_react_dom_client_development = __commonJS({
    "node_modules/.pnpm/react-dom@19.2.0_react@19.2.0/node_modules/react-dom/cjs/react-dom-client.development.js"(exports) {
      "use strict";
      (function() {
        function findHook(fiber, id) {
          for (fiber = fiber.memoizedState; null !== fiber && 0 < id; )
            fiber = fiber.next, id--;
          return fiber;
        }
        function copyWithSetImpl(obj, path, index, value) {
          if (index >= path.length) return value;
          var key = path[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
          updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);
          return updated;
        }
        function copyWithRename(obj, oldPath, newPath) {
          if (oldPath.length !== newPath.length)
            console.warn("copyWithRename() expects paths of the same length");
          else {
            for (var i5 = 0; i5 < newPath.length - 1; i5++)
              if (oldPath[i5] !== newPath[i5]) {
                console.warn(
                  "copyWithRename() expects paths to be the same except for the deepest key"
                );
                return;
              }
            return copyWithRenameImpl(obj, oldPath, newPath, 0);
          }
        }
        function copyWithRenameImpl(obj, oldPath, newPath, index) {
          var oldKey = oldPath[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
          index + 1 === oldPath.length ? (updated[newPath[index]] = updated[oldKey], isArrayImpl(updated) ? updated.splice(oldKey, 1) : delete updated[oldKey]) : updated[oldKey] = copyWithRenameImpl(
            obj[oldKey],
            oldPath,
            newPath,
            index + 1
          );
          return updated;
        }
        function copyWithDeleteImpl(obj, path, index) {
          var key = path[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
          if (index + 1 === path.length)
            return isArrayImpl(updated) ? updated.splice(key, 1) : delete updated[key], updated;
          updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);
          return updated;
        }
        function shouldSuspendImpl() {
          return false;
        }
        function shouldErrorImpl() {
          return null;
        }
        function warnInvalidHookAccess() {
          console.error(
            "Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks"
          );
        }
        function warnInvalidContextAccess() {
          console.error(
            "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
          );
        }
        function noop() {
        }
        function warnForMissingKey() {
        }
        function setToSortedString(set) {
          var array = [];
          set.forEach(function(value) {
            array.push(value);
          });
          return array.sort().join(", ");
        }
        function createFiber(tag, pendingProps, key, mode) {
          return new FiberNode(tag, pendingProps, key, mode);
        }
        function scheduleRoot(root2, element) {
          root2.context === emptyContextObject && (updateContainerImpl(root2.current, 2, element, root2, null, null), flushSyncWork$1());
        }
        function scheduleRefresh(root2, update) {
          if (null !== resolveFamily) {
            var staleFamilies = update.staleFamilies;
            update = update.updatedFamilies;
            flushPendingEffects();
            scheduleFibersWithFamiliesRecursively(
              root2.current,
              update,
              staleFamilies
            );
            flushSyncWork$1();
          }
        }
        function setRefreshHandler(handler) {
          resolveFamily = handler;
        }
        function isValidContainer(node) {
          return !(!node || 1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType);
        }
        function getNearestMountedFiber(fiber) {
          var node = fiber, nearestMounted = fiber;
          if (fiber.alternate) for (; node.return; ) node = node.return;
          else {
            fiber = node;
            do
              node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return;
            while (fiber);
          }
          return 3 === node.tag ? nearestMounted : null;
        }
        function getSuspenseInstanceFromFiber(fiber) {
          if (13 === fiber.tag) {
            var suspenseState = fiber.memoizedState;
            null === suspenseState && (fiber = fiber.alternate, null !== fiber && (suspenseState = fiber.memoizedState));
            if (null !== suspenseState) return suspenseState.dehydrated;
          }
          return null;
        }
        function getActivityInstanceFromFiber(fiber) {
          if (31 === fiber.tag) {
            var activityState = fiber.memoizedState;
            null === activityState && (fiber = fiber.alternate, null !== fiber && (activityState = fiber.memoizedState));
            if (null !== activityState) return activityState.dehydrated;
          }
          return null;
        }
        function assertIsMounted(fiber) {
          if (getNearestMountedFiber(fiber) !== fiber)
            throw Error("Unable to find node on an unmounted component.");
        }
        function findCurrentFiberUsingSlowPath(fiber) {
          var alternate = fiber.alternate;
          if (!alternate) {
            alternate = getNearestMountedFiber(fiber);
            if (null === alternate)
              throw Error("Unable to find node on an unmounted component.");
            return alternate !== fiber ? null : fiber;
          }
          for (var a5 = fiber, b3 = alternate; ; ) {
            var parentA = a5.return;
            if (null === parentA) break;
            var parentB = parentA.alternate;
            if (null === parentB) {
              b3 = parentA.return;
              if (null !== b3) {
                a5 = b3;
                continue;
              }
              break;
            }
            if (parentA.child === parentB.child) {
              for (parentB = parentA.child; parentB; ) {
                if (parentB === a5) return assertIsMounted(parentA), fiber;
                if (parentB === b3) return assertIsMounted(parentA), alternate;
                parentB = parentB.sibling;
              }
              throw Error("Unable to find node on an unmounted component.");
            }
            if (a5.return !== b3.return) a5 = parentA, b3 = parentB;
            else {
              for (var didFindChild = false, _child = parentA.child; _child; ) {
                if (_child === a5) {
                  didFindChild = true;
                  a5 = parentA;
                  b3 = parentB;
                  break;
                }
                if (_child === b3) {
                  didFindChild = true;
                  b3 = parentA;
                  a5 = parentB;
                  break;
                }
                _child = _child.sibling;
              }
              if (!didFindChild) {
                for (_child = parentB.child; _child; ) {
                  if (_child === a5) {
                    didFindChild = true;
                    a5 = parentB;
                    b3 = parentA;
                    break;
                  }
                  if (_child === b3) {
                    didFindChild = true;
                    b3 = parentB;
                    a5 = parentA;
                    break;
                  }
                  _child = _child.sibling;
                }
                if (!didFindChild)
                  throw Error(
                    "Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue."
                  );
              }
            }
            if (a5.alternate !== b3)
              throw Error(
                "Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue."
              );
          }
          if (3 !== a5.tag)
            throw Error("Unable to find node on an unmounted component.");
          return a5.stateNode.current === a5 ? fiber : alternate;
        }
        function findCurrentHostFiberImpl(node) {
          var tag = node.tag;
          if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
          for (node = node.child; null !== node; ) {
            tag = findCurrentHostFiberImpl(node);
            if (null !== tag) return tag;
            node = node.sibling;
          }
          return null;
        }
        function getIteratorFn(maybeIterable) {
          if (null === maybeIterable || "object" !== typeof maybeIterable)
            return null;
          maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
          return "function" === typeof maybeIterable ? maybeIterable : null;
        }
        function getComponentNameFromType(type) {
          if (null == type) return null;
          if ("function" === typeof type)
            return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
          if ("string" === typeof type) return type;
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
              return "Activity";
          }
          if ("object" === typeof type)
            switch ("number" === typeof type.tag && console.error(
              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
            ), type.$$typeof) {
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_CONTEXT_TYPE:
                return type.displayName || "Context";
              case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
              case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
              case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                  return getComponentNameFromType(type(innerType));
                } catch (x5) {
                }
            }
          return null;
        }
        function getComponentNameFromOwner(owner) {
          return "number" === typeof owner.tag ? getComponentNameFromFiber(owner) : "string" === typeof owner.name ? owner.name : null;
        }
        function getComponentNameFromFiber(fiber) {
          var type = fiber.type;
          switch (fiber.tag) {
            case 31:
              return "Activity";
            case 24:
              return "Cache";
            case 9:
              return (type._context.displayName || "Context") + ".Consumer";
            case 10:
              return type.displayName || "Context";
            case 18:
              return "DehydratedFragment";
            case 11:
              return fiber = type.render, fiber = fiber.displayName || fiber.name || "", type.displayName || ("" !== fiber ? "ForwardRef(" + fiber + ")" : "ForwardRef");
            case 7:
              return "Fragment";
            case 26:
            case 27:
            case 5:
              return type;
            case 4:
              return "Portal";
            case 3:
              return "Root";
            case 6:
              return "Text";
            case 16:
              return getComponentNameFromType(type);
            case 8:
              return type === REACT_STRICT_MODE_TYPE ? "StrictMode" : "Mode";
            case 22:
              return "Offscreen";
            case 12:
              return "Profiler";
            case 21:
              return "Scope";
            case 13:
              return "Suspense";
            case 19:
              return "SuspenseList";
            case 25:
              return "TracingMarker";
            case 1:
            case 0:
            case 14:
            case 15:
              if ("function" === typeof type)
                return type.displayName || type.name || null;
              if ("string" === typeof type) return type;
              break;
            case 29:
              type = fiber._debugInfo;
              if (null != type) {
                for (var i5 = type.length - 1; 0 <= i5; i5--)
                  if ("string" === typeof type[i5].name) return type[i5].name;
              }
              if (null !== fiber.return)
                return getComponentNameFromFiber(fiber.return);
          }
          return null;
        }
        function createCursor(defaultValue) {
          return { current: defaultValue };
        }
        function pop(cursor, fiber) {
          0 > index$jscomp$0 ? console.error("Unexpected pop.") : (fiber !== fiberStack[index$jscomp$0] && console.error("Unexpected Fiber popped."), cursor.current = valueStack[index$jscomp$0], valueStack[index$jscomp$0] = null, fiberStack[index$jscomp$0] = null, index$jscomp$0--);
        }
        function push(cursor, value, fiber) {
          index$jscomp$0++;
          valueStack[index$jscomp$0] = cursor.current;
          fiberStack[index$jscomp$0] = fiber;
          cursor.current = value;
        }
        function requiredContext(c7) {
          null === c7 && console.error(
            "Expected host context to exist. This error is likely caused by a bug in React. Please file an issue."
          );
          return c7;
        }
        function pushHostContainer(fiber, nextRootInstance) {
          push(rootInstanceStackCursor, nextRootInstance, fiber);
          push(contextFiberStackCursor, fiber, fiber);
          push(contextStackCursor, null, fiber);
          var nextRootContext = nextRootInstance.nodeType;
          switch (nextRootContext) {
            case 9:
            case 11:
              nextRootContext = 9 === nextRootContext ? "#document" : "#fragment";
              nextRootInstance = (nextRootInstance = nextRootInstance.documentElement) ? (nextRootInstance = nextRootInstance.namespaceURI) ? getOwnHostContext(nextRootInstance) : HostContextNamespaceNone : HostContextNamespaceNone;
              break;
            default:
              if (nextRootContext = nextRootInstance.tagName, nextRootInstance = nextRootInstance.namespaceURI)
                nextRootInstance = getOwnHostContext(nextRootInstance), nextRootInstance = getChildHostContextProd(
                  nextRootInstance,
                  nextRootContext
                );
              else
                switch (nextRootContext) {
                  case "svg":
                    nextRootInstance = HostContextNamespaceSvg;
                    break;
                  case "math":
                    nextRootInstance = HostContextNamespaceMath;
                    break;
                  default:
                    nextRootInstance = HostContextNamespaceNone;
                }
          }
          nextRootContext = nextRootContext.toLowerCase();
          nextRootContext = updatedAncestorInfoDev(null, nextRootContext);
          nextRootContext = {
            context: nextRootInstance,
            ancestorInfo: nextRootContext
          };
          pop(contextStackCursor, fiber);
          push(contextStackCursor, nextRootContext, fiber);
        }
        function popHostContainer(fiber) {
          pop(contextStackCursor, fiber);
          pop(contextFiberStackCursor, fiber);
          pop(rootInstanceStackCursor, fiber);
        }
        function getHostContext() {
          return requiredContext(contextStackCursor.current);
        }
        function pushHostContext(fiber) {
          null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber, fiber);
          var context = requiredContext(contextStackCursor.current);
          var type = fiber.type;
          var nextContext = getChildHostContextProd(context.context, type);
          type = updatedAncestorInfoDev(context.ancestorInfo, type);
          nextContext = { context: nextContext, ancestorInfo: type };
          context !== nextContext && (push(contextFiberStackCursor, fiber, fiber), push(contextStackCursor, nextContext, fiber));
        }
        function popHostContext(fiber) {
          contextFiberStackCursor.current === fiber && (pop(contextStackCursor, fiber), pop(contextFiberStackCursor, fiber));
          hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor, fiber), HostTransitionContext._currentValue = NotPendingTransition);
        }
        function disabledLog() {
        }
        function disableLogs() {
          if (0 === disabledDepth) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
        function reenableLogs() {
          disabledDepth--;
          if (0 === disabledDepth) {
            var props = { configurable: true, enumerable: true, writable: true };
            Object.defineProperties(console, {
              log: assign({}, props, { value: prevLog }),
              info: assign({}, props, { value: prevInfo }),
              warn: assign({}, props, { value: prevWarn }),
              error: assign({}, props, { value: prevError }),
              group: assign({}, props, { value: prevGroup }),
              groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),
              groupEnd: assign({}, props, { value: prevGroupEnd })
            });
          }
          0 > disabledDepth && console.error(
            "disabledDepth fell below zero. This is a bug in React. Please file an issue."
          );
        }
        function formatOwnerStack(error) {
          var prevPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          error = error.stack;
          Error.prepareStackTrace = prevPrepareStackTrace;
          error.startsWith("Error: react-stack-top-frame\n") && (error = error.slice(29));
          prevPrepareStackTrace = error.indexOf("\n");
          -1 !== prevPrepareStackTrace && (error = error.slice(prevPrepareStackTrace + 1));
          prevPrepareStackTrace = error.indexOf("react_stack_bottom_frame");
          -1 !== prevPrepareStackTrace && (prevPrepareStackTrace = error.lastIndexOf(
            "\n",
            prevPrepareStackTrace
          ));
          if (-1 !== prevPrepareStackTrace)
            error = error.slice(0, prevPrepareStackTrace);
          else return "";
          return error;
        }
        function describeBuiltInComponentFrame(name) {
          if (void 0 === prefix)
            try {
              throw Error();
            } catch (x5) {
              var match = x5.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
              suffix = -1 < x5.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x5.stack.indexOf("@") ? "@unknown:0:0" : "";
            }
          return "\n" + prefix + name + suffix;
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) return "";
          var frame = componentFrameCache.get(fn);
          if (void 0 !== frame) return frame;
          reentry = true;
          frame = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher2 = null;
          previousDispatcher2 = ReactSharedInternals.H;
          ReactSharedInternals.H = null;
          disableLogs();
          try {
            var RunInRootFrame = {
              DetermineComponentFrameRoot: function() {
                try {
                  if (construct) {
                    var Fake = function() {
                      throw Error();
                    };
                    Object.defineProperty(Fake.prototype, "props", {
                      set: function() {
                        throw Error();
                      }
                    });
                    if ("object" === typeof Reflect && Reflect.construct) {
                      try {
                        Reflect.construct(Fake, []);
                      } catch (x5) {
                        var control = x5;
                      }
                      Reflect.construct(fn, [], Fake);
                    } else {
                      try {
                        Fake.call();
                      } catch (x$0) {
                        control = x$0;
                      }
                      fn.call(Fake.prototype);
                    }
                  } else {
                    try {
                      throw Error();
                    } catch (x$1) {
                      control = x$1;
                    }
                    (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {
                    });
                  }
                } catch (sample) {
                  if (sample && control && "string" === typeof sample.stack)
                    return [sample.stack, control.stack];
                }
                return [null, null];
              }
            };
            RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
            var namePropDescriptor = Object.getOwnPropertyDescriptor(
              RunInRootFrame.DetermineComponentFrameRoot,
              "name"
            );
            namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
              RunInRootFrame.DetermineComponentFrameRoot,
              "name",
              { value: "DetermineComponentFrameRoot" }
            );
            var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
            if (sampleStack && controlStack) {
              var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
              for (_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes(
                "DetermineComponentFrameRoot"
              ); )
                namePropDescriptor++;
              for (; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes(
                "DetermineComponentFrameRoot"
              ); )
                _RunInRootFrame$Deter++;
              if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length)
                for (namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]; )
                  _RunInRootFrame$Deter--;
              for (; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)
                if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                  if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
                    do
                      if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                        var _frame = "\n" + sampleLines[namePropDescriptor].replace(
                          " at new ",
                          " at "
                        );
                        fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName));
                        "function" === typeof fn && componentFrameCache.set(fn, _frame);
                        return _frame;
                      }
                    while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
                  }
                  break;
                }
            }
          } finally {
            reentry = false, ReactSharedInternals.H = previousDispatcher2, reenableLogs(), Error.prepareStackTrace = frame;
          }
          sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
          "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
          return sampleLines;
        }
        function describeFiber(fiber, childFiber) {
          switch (fiber.tag) {
            case 26:
            case 27:
            case 5:
              return describeBuiltInComponentFrame(fiber.type);
            case 16:
              return describeBuiltInComponentFrame("Lazy");
            case 13:
              return fiber.child !== childFiber && null !== childFiber ? describeBuiltInComponentFrame("Suspense Fallback") : describeBuiltInComponentFrame("Suspense");
            case 19:
              return describeBuiltInComponentFrame("SuspenseList");
            case 0:
            case 15:
              return describeNativeComponentFrame(fiber.type, false);
            case 11:
              return describeNativeComponentFrame(fiber.type.render, false);
            case 1:
              return describeNativeComponentFrame(fiber.type, true);
            case 31:
              return describeBuiltInComponentFrame("Activity");
            default:
              return "";
          }
        }
        function getStackByFiberInDevAndProd(workInProgress2) {
          try {
            var info = "", previous = null;
            do {
              info += describeFiber(workInProgress2, previous);
              var debugInfo = workInProgress2._debugInfo;
              if (debugInfo)
                for (var i5 = debugInfo.length - 1; 0 <= i5; i5--) {
                  var entry = debugInfo[i5];
                  if ("string" === typeof entry.name) {
                    var JSCompiler_temp_const = info;
                    a: {
                      var name = entry.name, env = entry.env, location = entry.debugLocation;
                      if (null != location) {
                        var childStack = formatOwnerStack(location), idx = childStack.lastIndexOf("\n"), lastLine = -1 === idx ? childStack : childStack.slice(idx + 1);
                        if (-1 !== lastLine.indexOf(name)) {
                          var JSCompiler_inline_result = "\n" + lastLine;
                          break a;
                        }
                      }
                      JSCompiler_inline_result = describeBuiltInComponentFrame(
                        name + (env ? " [" + env + "]" : "")
                      );
                    }
                    info = JSCompiler_temp_const + JSCompiler_inline_result;
                  }
                }
              previous = workInProgress2;
              workInProgress2 = workInProgress2.return;
            } while (workInProgress2);
            return info;
          } catch (x5) {
            return "\nError generating stack: " + x5.message + "\n" + x5.stack;
          }
        }
        function describeFunctionComponentFrameWithoutLineNumber(fn) {
          return (fn = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(fn) : "";
        }
        function getCurrentFiberOwnerNameInDevOrNull() {
          if (null === current) return null;
          var owner = current._debugOwner;
          return null != owner ? getComponentNameFromOwner(owner) : null;
        }
        function getCurrentFiberStackInDev() {
          if (null === current) return "";
          var workInProgress2 = current;
          try {
            var info = "";
            6 === workInProgress2.tag && (workInProgress2 = workInProgress2.return);
            switch (workInProgress2.tag) {
              case 26:
              case 27:
              case 5:
                info += describeBuiltInComponentFrame(workInProgress2.type);
                break;
              case 13:
                info += describeBuiltInComponentFrame("Suspense");
                break;
              case 19:
                info += describeBuiltInComponentFrame("SuspenseList");
                break;
              case 31:
                info += describeBuiltInComponentFrame("Activity");
                break;
              case 30:
              case 0:
              case 15:
              case 1:
                workInProgress2._debugOwner || "" !== info || (info += describeFunctionComponentFrameWithoutLineNumber(
                  workInProgress2.type
                ));
                break;
              case 11:
                workInProgress2._debugOwner || "" !== info || (info += describeFunctionComponentFrameWithoutLineNumber(
                  workInProgress2.type.render
                ));
            }
            for (; workInProgress2; )
              if ("number" === typeof workInProgress2.tag) {
                var fiber = workInProgress2;
                workInProgress2 = fiber._debugOwner;
                var debugStack = fiber._debugStack;
                if (workInProgress2 && debugStack) {
                  var formattedStack = formatOwnerStack(debugStack);
                  "" !== formattedStack && (info += "\n" + formattedStack);
                }
              } else if (null != workInProgress2.debugStack) {
                var ownerStack = workInProgress2.debugStack;
                (workInProgress2 = workInProgress2.owner) && ownerStack && (info += "\n" + formatOwnerStack(ownerStack));
              } else break;
            var JSCompiler_inline_result = info;
          } catch (x5) {
            JSCompiler_inline_result = "\nError generating stack: " + x5.message + "\n" + x5.stack;
          }
          return JSCompiler_inline_result;
        }
        function runWithFiberInDEV(fiber, callback, arg0, arg1, arg2, arg3, arg4) {
          var previousFiber = current;
          setCurrentFiber(fiber);
          try {
            return null !== fiber && fiber._debugTask ? fiber._debugTask.run(
              callback.bind(null, arg0, arg1, arg2, arg3, arg4)
            ) : callback(arg0, arg1, arg2, arg3, arg4);
          } finally {
            setCurrentFiber(previousFiber);
          }
          throw Error(
            "runWithFiberInDEV should never be called in production. This is a bug in React."
          );
        }
        function setCurrentFiber(fiber) {
          ReactSharedInternals.getCurrentStack = null === fiber ? null : getCurrentFiberStackInDev;
          isRendering = false;
          current = fiber;
        }
        function typeName(value) {
          return "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
        }
        function willCoercionThrow(value) {
          try {
            return testStringCoercion(value), false;
          } catch (e2) {
            return true;
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkAttributeStringCoercion(value, attributeName) {
          if (willCoercionThrow(value))
            return console.error(
              "The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.",
              attributeName,
              typeName(value)
            ), testStringCoercion(value);
        }
        function checkCSSPropertyStringCoercion(value, propName) {
          if (willCoercionThrow(value))
            return console.error(
              "The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.",
              propName,
              typeName(value)
            ), testStringCoercion(value);
        }
        function checkFormFieldValueStringCoercion(value) {
          if (willCoercionThrow(value))
            return console.error(
              "Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before using it here.",
              typeName(value)
            ), testStringCoercion(value);
        }
        function injectInternals(internals) {
          if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return false;
          var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
          if (hook.isDisabled) return true;
          if (!hook.supportsFiber)
            return console.error(
              "The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://react.dev/link/react-devtools"
            ), true;
          try {
            rendererID = hook.inject(internals), injectedHook = hook;
          } catch (err) {
            console.error("React instrumentation encountered an error: %o.", err);
          }
          return hook.checkDCE ? true : false;
        }
        function setIsStrictModeForDevtools(newIsStrictMode) {
          "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
          if (injectedHook && "function" === typeof injectedHook.setStrictMode)
            try {
              injectedHook.setStrictMode(rendererID, newIsStrictMode);
            } catch (err) {
              hasLoggedError || (hasLoggedError = true, console.error(
                "React instrumentation encountered an error: %o",
                err
              ));
            }
        }
        function clz32Fallback(x5) {
          x5 >>>= 0;
          return 0 === x5 ? 32 : 31 - (log(x5) / LN2 | 0) | 0;
        }
        function getHighestPriorityLanes(lanes) {
          var pendingSyncLanes = lanes & 42;
          if (0 !== pendingSyncLanes) return pendingSyncLanes;
          switch (lanes & -lanes) {
            case 1:
              return 1;
            case 2:
              return 2;
            case 4:
              return 4;
            case 8:
              return 8;
            case 16:
              return 16;
            case 32:
              return 32;
            case 64:
              return 64;
            case 128:
              return 128;
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
              return lanes & 261888;
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return lanes & 3932160;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
              return lanes & 62914560;
            case 67108864:
              return 67108864;
            case 134217728:
              return 134217728;
            case 268435456:
              return 268435456;
            case 536870912:
              return 536870912;
            case 1073741824:
              return 0;
            default:
              return console.error(
                "Should have found matching lanes. This is a bug in React."
              ), lanes;
          }
        }
        function getNextLanes(root2, wipLanes, rootHasPendingCommit) {
          var pendingLanes = root2.pendingLanes;
          if (0 === pendingLanes) return 0;
          var nextLanes = 0, suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes;
          root2 = root2.warmLanes;
          var nonIdlePendingLanes = pendingLanes & 134217727;
          0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = nonIdlePendingLanes & ~root2, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = pendingLanes & ~root2, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
          return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, rootHasPendingCommit = wipLanes & -wipLanes, suspendedLanes >= rootHasPendingCommit || 32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)) ? wipLanes : nextLanes;
        }
        function checkIfRootIsPrerendering(root2, renderLanes2) {
          return 0 === (root2.pendingLanes & ~(root2.suspendedLanes & ~root2.pingedLanes) & renderLanes2);
        }
        function computeExpirationTime(lane, currentTime) {
          switch (lane) {
            case 1:
            case 2:
            case 4:
            case 8:
            case 64:
              return currentTime + 250;
            case 16:
            case 32:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return currentTime + 5e3;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
              return -1;
            case 67108864:
            case 134217728:
            case 268435456:
            case 536870912:
            case 1073741824:
              return -1;
            default:
              return console.error(
                "Should have found matching lanes. This is a bug in React."
              ), -1;
          }
        }
        function claimNextRetryLane() {
          var lane = nextRetryLane;
          nextRetryLane <<= 1;
          0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
          return lane;
        }
        function createLaneMap(initial) {
          for (var laneMap = [], i5 = 0; 31 > i5; i5++) laneMap.push(initial);
          return laneMap;
        }
        function markRootUpdated$1(root2, updateLane) {
          root2.pendingLanes |= updateLane;
          268435456 !== updateLane && (root2.suspendedLanes = 0, root2.pingedLanes = 0, root2.warmLanes = 0);
        }
        function markRootFinished(root2, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
          var previouslyPendingLanes = root2.pendingLanes;
          root2.pendingLanes = remainingLanes;
          root2.suspendedLanes = 0;
          root2.pingedLanes = 0;
          root2.warmLanes = 0;
          root2.expiredLanes &= remainingLanes;
          root2.entangledLanes &= remainingLanes;
          root2.errorRecoveryDisabledLanes &= remainingLanes;
          root2.shellSuspendCounter = 0;
          var entanglements = root2.entanglements, expirationTimes = root2.expirationTimes, hiddenUpdates = root2.hiddenUpdates;
          for (remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes; ) {
            var index = 31 - clz32(remainingLanes), lane = 1 << index;
            entanglements[index] = 0;
            expirationTimes[index] = -1;
            var hiddenUpdatesForLane = hiddenUpdates[index];
            if (null !== hiddenUpdatesForLane)
              for (hiddenUpdates[index] = null, index = 0; index < hiddenUpdatesForLane.length; index++) {
                var update = hiddenUpdatesForLane[index];
                null !== update && (update.lane &= -536870913);
              }
            remainingLanes &= ~lane;
          }
          0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, 0);
          0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root2.tag && (root2.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
        }
        function markSpawnedDeferredLane(root2, spawnedLane, entangledLanes) {
          root2.pendingLanes |= spawnedLane;
          root2.suspendedLanes &= ~spawnedLane;
          var spawnedLaneIndex = 31 - clz32(spawnedLane);
          root2.entangledLanes |= spawnedLane;
          root2.entanglements[spawnedLaneIndex] = root2.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 261930;
        }
        function markRootEntangled(root2, entangledLanes) {
          var rootEntangledLanes = root2.entangledLanes |= entangledLanes;
          for (root2 = root2.entanglements; rootEntangledLanes; ) {
            var index = 31 - clz32(rootEntangledLanes), lane = 1 << index;
            lane & entangledLanes | root2[index] & entangledLanes && (root2[index] |= entangledLanes);
            rootEntangledLanes &= ~lane;
          }
        }
        function getBumpedLaneForHydration(root2, renderLanes2) {
          var renderLane = renderLanes2 & -renderLanes2;
          renderLane = 0 !== (renderLane & 42) ? 1 : getBumpedLaneForHydrationByLane(renderLane);
          return 0 !== (renderLane & (root2.suspendedLanes | renderLanes2)) ? 0 : renderLane;
        }
        function getBumpedLaneForHydrationByLane(lane) {
          switch (lane) {
            case 2:
              lane = 1;
              break;
            case 8:
              lane = 4;
              break;
            case 32:
              lane = 16;
              break;
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
              lane = 128;
              break;
            case 268435456:
              lane = 134217728;
              break;
            default:
              lane = 0;
          }
          return lane;
        }
        function addFiberToLanesMap(root2, fiber, lanes) {
          if (isDevToolsPresent)
            for (root2 = root2.pendingUpdatersLaneMap; 0 < lanes; ) {
              var index = 31 - clz32(lanes), lane = 1 << index;
              root2[index].add(fiber);
              lanes &= ~lane;
            }
        }
        function movePendingFibersToMemoized(root2, lanes) {
          if (isDevToolsPresent)
            for (var pendingUpdatersLaneMap = root2.pendingUpdatersLaneMap, memoizedUpdaters = root2.memoizedUpdaters; 0 < lanes; ) {
              var index = 31 - clz32(lanes);
              root2 = 1 << index;
              index = pendingUpdatersLaneMap[index];
              0 < index.size && (index.forEach(function(fiber) {
                var alternate = fiber.alternate;
                null !== alternate && memoizedUpdaters.has(alternate) || memoizedUpdaters.add(fiber);
              }), index.clear());
              lanes &= ~root2;
            }
        }
        function lanesToEventPriority(lanes) {
          lanes &= -lanes;
          return 0 !== DiscreteEventPriority && DiscreteEventPriority < lanes ? 0 !== ContinuousEventPriority && ContinuousEventPriority < lanes ? 0 !== (lanes & 134217727) ? DefaultEventPriority : IdleEventPriority : ContinuousEventPriority : DiscreteEventPriority;
        }
        function resolveUpdatePriority() {
          var updatePriority = ReactDOMSharedInternals.p;
          if (0 !== updatePriority) return updatePriority;
          updatePriority = window.event;
          return void 0 === updatePriority ? DefaultEventPriority : getEventPriority(updatePriority.type);
        }
        function runWithPriority(priority, fn) {
          var previousPriority = ReactDOMSharedInternals.p;
          try {
            return ReactDOMSharedInternals.p = priority, fn();
          } finally {
            ReactDOMSharedInternals.p = previousPriority;
          }
        }
        function detachDeletedInstance(node) {
          delete node[internalInstanceKey];
          delete node[internalPropsKey];
          delete node[internalEventHandlersKey];
          delete node[internalEventHandlerListenersKey];
          delete node[internalEventHandlesSetKey];
        }
        function getClosestInstanceFromNode(targetNode) {
          var targetInst = targetNode[internalInstanceKey];
          if (targetInst) return targetInst;
          for (var parentNode = targetNode.parentNode; parentNode; ) {
            if (targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey]) {
              parentNode = targetInst.alternate;
              if (null !== targetInst.child || null !== parentNode && null !== parentNode.child)
                for (targetNode = getParentHydrationBoundary(targetNode); null !== targetNode; ) {
                  if (parentNode = targetNode[internalInstanceKey])
                    return parentNode;
                  targetNode = getParentHydrationBoundary(targetNode);
                }
              return targetInst;
            }
            targetNode = parentNode;
            parentNode = targetNode.parentNode;
          }
          return null;
        }
        function getInstanceFromNode(node) {
          if (node = node[internalInstanceKey] || node[internalContainerInstanceKey]) {
            var tag = node.tag;
            if (5 === tag || 6 === tag || 13 === tag || 31 === tag || 26 === tag || 27 === tag || 3 === tag)
              return node;
          }
          return null;
        }
        function getNodeFromInstance(inst) {
          var tag = inst.tag;
          if (5 === tag || 26 === tag || 27 === tag || 6 === tag)
            return inst.stateNode;
          throw Error("getNodeFromInstance: Invalid argument.");
        }
        function getResourcesFromRoot(root2) {
          var resources = root2[internalRootNodeResourcesKey];
          resources || (resources = root2[internalRootNodeResourcesKey] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() });
          return resources;
        }
        function markNodeAsHoistable(node) {
          node[internalHoistableMarker] = true;
        }
        function registerTwoPhaseEvent(registrationName, dependencies) {
          registerDirectEvent(registrationName, dependencies);
          registerDirectEvent(registrationName + "Capture", dependencies);
        }
        function registerDirectEvent(registrationName, dependencies) {
          registrationNameDependencies[registrationName] && console.error(
            "EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.",
            registrationName
          );
          registrationNameDependencies[registrationName] = dependencies;
          var lowerCasedName = registrationName.toLowerCase();
          possibleRegistrationNames[lowerCasedName] = registrationName;
          "onDoubleClick" === registrationName && (possibleRegistrationNames.ondblclick = registrationName);
          for (registrationName = 0; registrationName < dependencies.length; registrationName++)
            allNativeEvents.add(dependencies[registrationName]);
        }
        function checkControlledValueProps(tagName, props) {
          hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || null == props.value || ("select" === tagName ? console.error(
            "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`."
          ) : console.error(
            "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."
          ));
          props.onChange || props.readOnly || props.disabled || null == props.checked || console.error(
            "You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`."
          );
        }
        function isAttributeNameSafe(attributeName) {
          if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
            return true;
          if (hasOwnProperty.call(illegalAttributeNameCache, attributeName))
            return false;
          if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
            return validatedAttributeNameCache[attributeName] = true;
          illegalAttributeNameCache[attributeName] = true;
          console.error("Invalid attribute name: `%s`", attributeName);
          return false;
        }
        function getValueForAttributeOnCustomComponent(node, name, expected) {
          if (isAttributeNameSafe(name)) {
            if (!node.hasAttribute(name)) {
              switch (typeof expected) {
                case "symbol":
                case "object":
                  return expected;
                case "function":
                  return expected;
                case "boolean":
                  if (false === expected) return expected;
              }
              return void 0 === expected ? void 0 : null;
            }
            node = node.getAttribute(name);
            if ("" === node && true === expected) return true;
            checkAttributeStringCoercion(expected, name);
            return node === "" + expected ? expected : node;
          }
        }
        function setValueForAttribute(node, name, value) {
          if (isAttributeNameSafe(name))
            if (null === value) node.removeAttribute(name);
            else {
              switch (typeof value) {
                case "undefined":
                case "function":
                case "symbol":
                  node.removeAttribute(name);
                  return;
                case "boolean":
                  var prefix2 = name.toLowerCase().slice(0, 5);
                  if ("data-" !== prefix2 && "aria-" !== prefix2) {
                    node.removeAttribute(name);
                    return;
                  }
              }
              checkAttributeStringCoercion(value, name);
              node.setAttribute(name, "" + value);
            }
        }
        function setValueForKnownAttribute(node, name, value) {
          if (null === value) node.removeAttribute(name);
          else {
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                node.removeAttribute(name);
                return;
            }
            checkAttributeStringCoercion(value, name);
            node.setAttribute(name, "" + value);
          }
        }
        function setValueForNamespacedAttribute(node, namespace, name, value) {
          if (null === value) node.removeAttribute(name);
          else {
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                node.removeAttribute(name);
                return;
            }
            checkAttributeStringCoercion(value, name);
            node.setAttributeNS(namespace, name, "" + value);
          }
        }
        function getToStringValue(value) {
          switch (typeof value) {
            case "bigint":
            case "boolean":
            case "number":
            case "string":
            case "undefined":
              return value;
            case "object":
              return checkFormFieldValueStringCoercion(value), value;
            default:
              return "";
          }
        }
        function isCheckable(elem) {
          var type = elem.type;
          return (elem = elem.nodeName) && "input" === elem.toLowerCase() && ("checkbox" === type || "radio" === type);
        }
        function trackValueOnNode(node, valueField, currentValue) {
          var descriptor = Object.getOwnPropertyDescriptor(
            node.constructor.prototype,
            valueField
          );
          if (!node.hasOwnProperty(valueField) && "undefined" !== typeof descriptor && "function" === typeof descriptor.get && "function" === typeof descriptor.set) {
            var get = descriptor.get, set = descriptor.set;
            Object.defineProperty(node, valueField, {
              configurable: true,
              get: function() {
                return get.call(this);
              },
              set: function(value) {
                checkFormFieldValueStringCoercion(value);
                currentValue = "" + value;
                set.call(this, value);
              }
            });
            Object.defineProperty(node, valueField, {
              enumerable: descriptor.enumerable
            });
            return {
              getValue: function() {
                return currentValue;
              },
              setValue: function(value) {
                checkFormFieldValueStringCoercion(value);
                currentValue = "" + value;
              },
              stopTracking: function() {
                node._valueTracker = null;
                delete node[valueField];
              }
            };
          }
        }
        function track(node) {
          if (!node._valueTracker) {
            var valueField = isCheckable(node) ? "checked" : "value";
            node._valueTracker = trackValueOnNode(
              node,
              valueField,
              "" + node[valueField]
            );
          }
        }
        function updateValueIfChanged(node) {
          if (!node) return false;
          var tracker = node._valueTracker;
          if (!tracker) return true;
          var lastValue = tracker.getValue();
          var value = "";
          node && (value = isCheckable(node) ? node.checked ? "true" : "false" : node.value);
          node = value;
          return node !== lastValue ? (tracker.setValue(node), true) : false;
        }
        function getActiveElement(doc) {
          doc = doc || ("undefined" !== typeof document ? document : void 0);
          if ("undefined" === typeof doc) return null;
          try {
            return doc.activeElement || doc.body;
          } catch (e2) {
            return doc.body;
          }
        }
        function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
          return value.replace(
            escapeSelectorAttributeValueInsideDoubleQuotesRegex,
            function(ch) {
              return "\\" + ch.charCodeAt(0).toString(16) + " ";
            }
          );
        }
        function validateInputProps(element, props) {
          void 0 === props.checked || void 0 === props.defaultChecked || didWarnCheckedDefaultChecked || (console.error(
            "%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
            getCurrentFiberOwnerNameInDevOrNull() || "A component",
            props.type
          ), didWarnCheckedDefaultChecked = true);
          void 0 === props.value || void 0 === props.defaultValue || didWarnValueDefaultValue$1 || (console.error(
            "%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
            getCurrentFiberOwnerNameInDevOrNull() || "A component",
            props.type
          ), didWarnValueDefaultValue$1 = true);
        }
        function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name) {
          element.name = "";
          null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type ? (checkAttributeStringCoercion(type, "type"), element.type = type) : element.removeAttribute("type");
          if (null != value)
            if ("number" === type) {
              if (0 === value && "" === element.value || element.value != value)
                element.value = "" + getToStringValue(value);
            } else
              element.value !== "" + getToStringValue(value) && (element.value = "" + getToStringValue(value));
          else
            "submit" !== type && "reset" !== type || element.removeAttribute("value");
          null != value ? setDefaultValue(element, type, getToStringValue(value)) : null != defaultValue ? setDefaultValue(element, type, getToStringValue(defaultValue)) : null != lastDefaultValue && element.removeAttribute("value");
          null == checked && null != defaultChecked && (element.defaultChecked = !!defaultChecked);
          null != checked && (element.checked = checked && "function" !== typeof checked && "symbol" !== typeof checked);
          null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name ? (checkAttributeStringCoercion(name, "name"), element.name = "" + getToStringValue(name)) : element.removeAttribute("name");
        }
        function initInput(element, value, defaultValue, checked, defaultChecked, type, name, isHydrating2) {
          null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type && (checkAttributeStringCoercion(type, "type"), element.type = type);
          if (null != value || null != defaultValue) {
            if (!("submit" !== type && "reset" !== type || void 0 !== value && null !== value)) {
              track(element);
              return;
            }
            defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
            value = null != value ? "" + getToStringValue(value) : defaultValue;
            isHydrating2 || value === element.value || (element.value = value);
            element.defaultValue = value;
          }
          checked = null != checked ? checked : defaultChecked;
          checked = "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
          element.checked = isHydrating2 ? element.checked : !!checked;
          element.defaultChecked = !!checked;
          null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name && (checkAttributeStringCoercion(name, "name"), element.name = name);
          track(element);
        }
        function setDefaultValue(node, type, value) {
          "number" === type && getActiveElement(node.ownerDocument) === node || node.defaultValue === "" + value || (node.defaultValue = "" + value);
        }
        function validateOptionProps(element, props) {
          null == props.value && ("object" === typeof props.children && null !== props.children ? React2.Children.forEach(props.children, function(child) {
            null == child || "string" === typeof child || "number" === typeof child || "bigint" === typeof child || didWarnInvalidChild || (didWarnInvalidChild = true, console.error(
              "Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>."
            ));
          }) : null == props.dangerouslySetInnerHTML || didWarnInvalidInnerHTML || (didWarnInvalidInnerHTML = true, console.error(
            "Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."
          )));
          null == props.selected || didWarnSelectedSetOnOption || (console.error(
            "Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."
          ), didWarnSelectedSetOnOption = true);
        }
        function getDeclarationErrorAddendum() {
          var ownerName = getCurrentFiberOwnerNameInDevOrNull();
          return ownerName ? "\n\nCheck the render method of `" + ownerName + "`." : "";
        }
        function updateOptions(node, multiple, propValue, setDefaultSelected) {
          node = node.options;
          if (multiple) {
            multiple = {};
            for (var i5 = 0; i5 < propValue.length; i5++)
              multiple["$" + propValue[i5]] = true;
            for (propValue = 0; propValue < node.length; propValue++)
              i5 = multiple.hasOwnProperty("$" + node[propValue].value), node[propValue].selected !== i5 && (node[propValue].selected = i5), i5 && setDefaultSelected && (node[propValue].defaultSelected = true);
          } else {
            propValue = "" + getToStringValue(propValue);
            multiple = null;
            for (i5 = 0; i5 < node.length; i5++) {
              if (node[i5].value === propValue) {
                node[i5].selected = true;
                setDefaultSelected && (node[i5].defaultSelected = true);
                return;
              }
              null !== multiple || node[i5].disabled || (multiple = node[i5]);
            }
            null !== multiple && (multiple.selected = true);
          }
        }
        function validateSelectProps(element, props) {
          for (element = 0; element < valuePropNames.length; element++) {
            var propName = valuePropNames[element];
            if (null != props[propName]) {
              var propNameIsArray = isArrayImpl(props[propName]);
              props.multiple && !propNameIsArray ? console.error(
                "The `%s` prop supplied to <select> must be an array if `multiple` is true.%s",
                propName,
                getDeclarationErrorAddendum()
              ) : !props.multiple && propNameIsArray && console.error(
                "The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s",
                propName,
                getDeclarationErrorAddendum()
              );
            }
          }
          void 0 === props.value || void 0 === props.defaultValue || didWarnValueDefaultValue || (console.error(
            "Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components"
          ), didWarnValueDefaultValue = true);
        }
        function validateTextareaProps(element, props) {
          void 0 === props.value || void 0 === props.defaultValue || didWarnValDefaultVal || (console.error(
            "%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components",
            getCurrentFiberOwnerNameInDevOrNull() || "A component"
          ), didWarnValDefaultVal = true);
          null != props.children && null == props.value && console.error(
            "Use the `defaultValue` or `value` props instead of setting children on <textarea>."
          );
        }
        function updateTextarea(element, value, defaultValue) {
          if (null != value && (value = "" + getToStringValue(value), value !== element.value && (element.value = value), null == defaultValue)) {
            element.defaultValue !== value && (element.defaultValue = value);
            return;
          }
          element.defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
        }
        function initTextarea(element, value, defaultValue, children) {
          if (null == value) {
            if (null != children) {
              if (null != defaultValue)
                throw Error(
                  "If you supply `defaultValue` on a <textarea>, do not pass children."
                );
              if (isArrayImpl(children)) {
                if (1 < children.length)
                  throw Error("<textarea> can only have at most one child.");
                children = children[0];
              }
              defaultValue = children;
            }
            null == defaultValue && (defaultValue = "");
            value = defaultValue;
          }
          defaultValue = getToStringValue(value);
          element.defaultValue = defaultValue;
          children = element.textContent;
          children === defaultValue && "" !== children && null !== children && (element.value = children);
          track(element);
        }
        function findNotableNode(node, indent) {
          return void 0 === node.serverProps && 0 === node.serverTail.length && 1 === node.children.length && 3 < node.distanceFromLeaf && node.distanceFromLeaf > 15 - indent ? findNotableNode(node.children[0], indent) : node;
        }
        function indentation(indent) {
          return "  " + "  ".repeat(indent);
        }
        function added(indent) {
          return "+ " + "  ".repeat(indent);
        }
        function removed(indent) {
          return "- " + "  ".repeat(indent);
        }
        function describeFiberType(fiber) {
          switch (fiber.tag) {
            case 26:
            case 27:
            case 5:
              return fiber.type;
            case 16:
              return "Lazy";
            case 31:
              return "Activity";
            case 13:
              return "Suspense";
            case 19:
              return "SuspenseList";
            case 0:
            case 15:
              return fiber = fiber.type, fiber.displayName || fiber.name || null;
            case 11:
              return fiber = fiber.type.render, fiber.displayName || fiber.name || null;
            case 1:
              return fiber = fiber.type, fiber.displayName || fiber.name || null;
            default:
              return null;
          }
        }
        function describeTextNode(content, maxLength) {
          return needsEscaping.test(content) ? (content = JSON.stringify(content), content.length > maxLength - 2 ? 8 > maxLength ? '{"..."}' : "{" + content.slice(0, maxLength - 7) + '..."}' : "{" + content + "}") : content.length > maxLength ? 5 > maxLength ? '{"..."}' : content.slice(0, maxLength - 3) + "..." : content;
        }
        function describeTextDiff(clientText, serverProps, indent) {
          var maxLength = 120 - 2 * indent;
          if (null === serverProps)
            return added(indent) + describeTextNode(clientText, maxLength) + "\n";
          if ("string" === typeof serverProps) {
            for (var firstDiff = 0; firstDiff < serverProps.length && firstDiff < clientText.length && serverProps.charCodeAt(firstDiff) === clientText.charCodeAt(firstDiff); firstDiff++) ;
            firstDiff > maxLength - 8 && 10 < firstDiff && (clientText = "..." + clientText.slice(firstDiff - 8), serverProps = "..." + serverProps.slice(firstDiff - 8));
            return added(indent) + describeTextNode(clientText, maxLength) + "\n" + removed(indent) + describeTextNode(serverProps, maxLength) + "\n";
          }
          return indentation(indent) + describeTextNode(clientText, maxLength) + "\n";
        }
        function objectName(object) {
          return Object.prototype.toString.call(object).replace(/^\[object (.*)\]$/, function(m4, p0) {
            return p0;
          });
        }
        function describeValue(value, maxLength) {
          switch (typeof value) {
            case "string":
              return value = JSON.stringify(value), value.length > maxLength ? 5 > maxLength ? '"..."' : value.slice(0, maxLength - 4) + '..."' : value;
            case "object":
              if (null === value) return "null";
              if (isArrayImpl(value)) return "[...]";
              if (value.$$typeof === REACT_ELEMENT_TYPE)
                return (maxLength = getComponentNameFromType(value.type)) ? "<" + maxLength + ">" : "<...>";
              var name = objectName(value);
              if ("Object" === name) {
                name = "";
                maxLength -= 2;
                for (var propName in value)
                  if (value.hasOwnProperty(propName)) {
                    var jsonPropName = JSON.stringify(propName);
                    jsonPropName !== '"' + propName + '"' && (propName = jsonPropName);
                    maxLength -= propName.length - 2;
                    jsonPropName = describeValue(
                      value[propName],
                      15 > maxLength ? maxLength : 15
                    );
                    maxLength -= jsonPropName.length;
                    if (0 > maxLength) {
                      name += "" === name ? "..." : ", ...";
                      break;
                    }
                    name += ("" === name ? "" : ",") + propName + ":" + jsonPropName;
                  }
                return "{" + name + "}";
              }
              return name;
            case "function":
              return (maxLength = value.displayName || value.name) ? "function " + maxLength : "function";
            default:
              return String(value);
          }
        }
        function describePropValue(value, maxLength) {
          return "string" !== typeof value || needsEscaping.test(value) ? "{" + describeValue(value, maxLength - 2) + "}" : value.length > maxLength - 2 ? 5 > maxLength ? '"..."' : '"' + value.slice(0, maxLength - 5) + '..."' : '"' + value + '"';
        }
        function describeExpandedElement(type, props, rowPrefix) {
          var remainingRowLength = 120 - rowPrefix.length - type.length, properties = [], propName;
          for (propName in props)
            if (props.hasOwnProperty(propName) && "children" !== propName) {
              var propValue = describePropValue(
                props[propName],
                120 - rowPrefix.length - propName.length - 1
              );
              remainingRowLength -= propName.length + propValue.length + 2;
              properties.push(propName + "=" + propValue);
            }
          return 0 === properties.length ? rowPrefix + "<" + type + ">\n" : 0 < remainingRowLength ? rowPrefix + "<" + type + " " + properties.join(" ") + ">\n" : rowPrefix + "<" + type + "\n" + rowPrefix + "  " + properties.join("\n" + rowPrefix + "  ") + "\n" + rowPrefix + ">\n";
        }
        function describePropertiesDiff(clientObject, serverObject, indent) {
          var properties = "", remainingServerProperties = assign({}, serverObject), propName;
          for (propName in clientObject)
            if (clientObject.hasOwnProperty(propName)) {
              delete remainingServerProperties[propName];
              var maxLength = 120 - 2 * indent - propName.length - 2, clientPropValue = describeValue(clientObject[propName], maxLength);
              serverObject.hasOwnProperty(propName) ? (maxLength = describeValue(serverObject[propName], maxLength), properties += added(indent) + propName + ": " + clientPropValue + "\n", properties += removed(indent) + propName + ": " + maxLength + "\n") : properties += added(indent) + propName + ": " + clientPropValue + "\n";
            }
          for (var _propName in remainingServerProperties)
            remainingServerProperties.hasOwnProperty(_propName) && (clientObject = describeValue(
              remainingServerProperties[_propName],
              120 - 2 * indent - _propName.length - 2
            ), properties += removed(indent) + _propName + ": " + clientObject + "\n");
          return properties;
        }
        function describeElementDiff(type, clientProps, serverProps, indent) {
          var content = "", serverPropNames = /* @__PURE__ */ new Map();
          for (propName$jscomp$0 in serverProps)
            serverProps.hasOwnProperty(propName$jscomp$0) && serverPropNames.set(
              propName$jscomp$0.toLowerCase(),
              propName$jscomp$0
            );
          if (1 === serverPropNames.size && serverPropNames.has("children"))
            content += describeExpandedElement(
              type,
              clientProps,
              indentation(indent)
            );
          else {
            for (var _propName2 in clientProps)
              if (clientProps.hasOwnProperty(_propName2) && "children" !== _propName2) {
                var maxLength$jscomp$0 = 120 - 2 * (indent + 1) - _propName2.length - 1, serverPropName = serverPropNames.get(_propName2.toLowerCase());
                if (void 0 !== serverPropName) {
                  serverPropNames.delete(_propName2.toLowerCase());
                  var propName$jscomp$0 = clientProps[_propName2];
                  serverPropName = serverProps[serverPropName];
                  var clientPropValue = describePropValue(
                    propName$jscomp$0,
                    maxLength$jscomp$0
                  );
                  maxLength$jscomp$0 = describePropValue(
                    serverPropName,
                    maxLength$jscomp$0
                  );
                  "object" === typeof propName$jscomp$0 && null !== propName$jscomp$0 && "object" === typeof serverPropName && null !== serverPropName && "Object" === objectName(propName$jscomp$0) && "Object" === objectName(serverPropName) && (2 < Object.keys(propName$jscomp$0).length || 2 < Object.keys(serverPropName).length || -1 < clientPropValue.indexOf("...") || -1 < maxLength$jscomp$0.indexOf("...")) ? content += indentation(indent + 1) + _propName2 + "={{\n" + describePropertiesDiff(
                    propName$jscomp$0,
                    serverPropName,
                    indent + 2
                  ) + indentation(indent + 1) + "}}\n" : (content += added(indent + 1) + _propName2 + "=" + clientPropValue + "\n", content += removed(indent + 1) + _propName2 + "=" + maxLength$jscomp$0 + "\n");
                } else
                  content += indentation(indent + 1) + _propName2 + "=" + describePropValue(clientProps[_propName2], maxLength$jscomp$0) + "\n";
              }
            serverPropNames.forEach(function(propName) {
              if ("children" !== propName) {
                var maxLength = 120 - 2 * (indent + 1) - propName.length - 1;
                content += removed(indent + 1) + propName + "=" + describePropValue(serverProps[propName], maxLength) + "\n";
              }
            });
            content = "" === content ? indentation(indent) + "<" + type + ">\n" : indentation(indent) + "<" + type + "\n" + content + indentation(indent) + ">\n";
          }
          type = serverProps.children;
          clientProps = clientProps.children;
          if ("string" === typeof type || "number" === typeof type || "bigint" === typeof type) {
            serverPropNames = "";
            if ("string" === typeof clientProps || "number" === typeof clientProps || "bigint" === typeof clientProps)
              serverPropNames = "" + clientProps;
            content += describeTextDiff(serverPropNames, "" + type, indent + 1);
          } else if ("string" === typeof clientProps || "number" === typeof clientProps || "bigint" === typeof clientProps)
            content = null == type ? content + describeTextDiff("" + clientProps, null, indent + 1) : content + describeTextDiff("" + clientProps, void 0, indent + 1);
          return content;
        }
        function describeSiblingFiber(fiber, indent) {
          var type = describeFiberType(fiber);
          if (null === type) {
            type = "";
            for (fiber = fiber.child; fiber; )
              type += describeSiblingFiber(fiber, indent), fiber = fiber.sibling;
            return type;
          }
          return indentation(indent) + "<" + type + ">\n";
        }
        function describeNode(node, indent) {
          var skipToNode = findNotableNode(node, indent);
          if (skipToNode !== node && (1 !== node.children.length || node.children[0] !== skipToNode))
            return indentation(indent) + "...\n" + describeNode(skipToNode, indent + 1);
          skipToNode = "";
          var debugInfo = node.fiber._debugInfo;
          if (debugInfo)
            for (var i5 = 0; i5 < debugInfo.length; i5++) {
              var serverComponentName = debugInfo[i5].name;
              "string" === typeof serverComponentName && (skipToNode += indentation(indent) + "<" + serverComponentName + ">\n", indent++);
            }
          debugInfo = "";
          i5 = node.fiber.pendingProps;
          if (6 === node.fiber.tag)
            debugInfo = describeTextDiff(i5, node.serverProps, indent), indent++;
          else if (serverComponentName = describeFiberType(node.fiber), null !== serverComponentName)
            if (void 0 === node.serverProps) {
              debugInfo = indent;
              var maxLength = 120 - 2 * debugInfo - serverComponentName.length - 2, content = "";
              for (propName in i5)
                if (i5.hasOwnProperty(propName) && "children" !== propName) {
                  var propValue = describePropValue(i5[propName], 15);
                  maxLength -= propName.length + propValue.length + 2;
                  if (0 > maxLength) {
                    content += " ...";
                    break;
                  }
                  content += " " + propName + "=" + propValue;
                }
              debugInfo = indentation(debugInfo) + "<" + serverComponentName + content + ">\n";
              indent++;
            } else
              null === node.serverProps ? (debugInfo = describeExpandedElement(
                serverComponentName,
                i5,
                added(indent)
              ), indent++) : "string" === typeof node.serverProps ? console.error(
                "Should not have matched a non HostText fiber to a Text node. This is a bug in React."
              ) : (debugInfo = describeElementDiff(
                serverComponentName,
                i5,
                node.serverProps,
                indent
              ), indent++);
          var propName = "";
          i5 = node.fiber.child;
          for (serverComponentName = 0; i5 && serverComponentName < node.children.length; )
            maxLength = node.children[serverComponentName], maxLength.fiber === i5 ? (propName += describeNode(maxLength, indent), serverComponentName++) : propName += describeSiblingFiber(i5, indent), i5 = i5.sibling;
          i5 && 0 < node.children.length && (propName += indentation(indent) + "...\n");
          i5 = node.serverTail;
          null === node.serverProps && indent--;
          for (node = 0; node < i5.length; node++)
            serverComponentName = i5[node], propName = "string" === typeof serverComponentName ? propName + (removed(indent) + describeTextNode(serverComponentName, 120 - 2 * indent) + "\n") : propName + describeExpandedElement(
              serverComponentName.type,
              serverComponentName.props,
              removed(indent)
            );
          return skipToNode + debugInfo + propName;
        }
        function describeDiff(rootNode) {
          try {
            return "\n\n" + describeNode(rootNode, 0);
          } catch (x5) {
            return "";
          }
        }
        function describeAncestors(ancestor, child, props) {
          for (var fiber = child, node = null, distanceFromLeaf = 0; fiber; )
            fiber === ancestor && (distanceFromLeaf = 0), node = {
              fiber,
              children: null !== node ? [node] : [],
              serverProps: fiber === child ? props : fiber === ancestor ? null : void 0,
              serverTail: [],
              distanceFromLeaf
            }, distanceFromLeaf++, fiber = fiber.return;
          return null !== node ? describeDiff(node).replaceAll(/^[+-]/gm, ">") : "";
        }
        function updatedAncestorInfoDev(oldInfo, tag) {
          var ancestorInfo = assign({}, oldInfo || emptyAncestorInfoDev), info = { tag };
          -1 !== inScopeTags.indexOf(tag) && (ancestorInfo.aTagInScope = null, ancestorInfo.buttonTagInScope = null, ancestorInfo.nobrTagInScope = null);
          -1 !== buttonScopeTags.indexOf(tag) && (ancestorInfo.pTagInButtonScope = null);
          -1 !== specialTags.indexOf(tag) && "address" !== tag && "div" !== tag && "p" !== tag && (ancestorInfo.listItemTagAutoclosing = null, ancestorInfo.dlItemTagAutoclosing = null);
          ancestorInfo.current = info;
          "form" === tag && (ancestorInfo.formTag = info);
          "a" === tag && (ancestorInfo.aTagInScope = info);
          "button" === tag && (ancestorInfo.buttonTagInScope = info);
          "nobr" === tag && (ancestorInfo.nobrTagInScope = info);
          "p" === tag && (ancestorInfo.pTagInButtonScope = info);
          "li" === tag && (ancestorInfo.listItemTagAutoclosing = info);
          if ("dd" === tag || "dt" === tag)
            ancestorInfo.dlItemTagAutoclosing = info;
          "#document" === tag || "html" === tag ? ancestorInfo.containerTagInScope = null : ancestorInfo.containerTagInScope || (ancestorInfo.containerTagInScope = info);
          null !== oldInfo || "#document" !== tag && "html" !== tag && "body" !== tag ? true === ancestorInfo.implicitRootScope && (ancestorInfo.implicitRootScope = false) : ancestorInfo.implicitRootScope = true;
          return ancestorInfo;
        }
        function isTagValidWithParent(tag, parentTag, implicitRootScope) {
          switch (parentTag) {
            case "select":
              return "hr" === tag || "option" === tag || "optgroup" === tag || "script" === tag || "template" === tag || "#text" === tag;
            case "optgroup":
              return "option" === tag || "#text" === tag;
            case "option":
              return "#text" === tag;
            case "tr":
              return "th" === tag || "td" === tag || "style" === tag || "script" === tag || "template" === tag;
            case "tbody":
            case "thead":
            case "tfoot":
              return "tr" === tag || "style" === tag || "script" === tag || "template" === tag;
            case "colgroup":
              return "col" === tag || "template" === tag;
            case "table":
              return "caption" === tag || "colgroup" === tag || "tbody" === tag || "tfoot" === tag || "thead" === tag || "style" === tag || "script" === tag || "template" === tag;
            case "head":
              return "base" === tag || "basefont" === tag || "bgsound" === tag || "link" === tag || "meta" === tag || "title" === tag || "noscript" === tag || "noframes" === tag || "style" === tag || "script" === tag || "template" === tag;
            case "html":
              if (implicitRootScope) break;
              return "head" === tag || "body" === tag || "frameset" === tag;
            case "frameset":
              return "frame" === tag;
            case "#document":
              if (!implicitRootScope) return "html" === tag;
          }
          switch (tag) {
            case "h1":
            case "h2":
            case "h3":
            case "h4":
            case "h5":
            case "h6":
              return "h1" !== parentTag && "h2" !== parentTag && "h3" !== parentTag && "h4" !== parentTag && "h5" !== parentTag && "h6" !== parentTag;
            case "rp":
            case "rt":
              return -1 === impliedEndTags.indexOf(parentTag);
            case "caption":
            case "col":
            case "colgroup":
            case "frameset":
            case "frame":
            case "tbody":
            case "td":
            case "tfoot":
            case "th":
            case "thead":
            case "tr":
              return null == parentTag;
            case "head":
              return implicitRootScope || null === parentTag;
            case "html":
              return implicitRootScope && "#document" === parentTag || null === parentTag;
            case "body":
              return implicitRootScope && ("#document" === parentTag || "html" === parentTag) || null === parentTag;
          }
          return true;
        }
        function findInvalidAncestorForTag(tag, ancestorInfo) {
          switch (tag) {
            case "address":
            case "article":
            case "aside":
            case "blockquote":
            case "center":
            case "details":
            case "dialog":
            case "dir":
            case "div":
            case "dl":
            case "fieldset":
            case "figcaption":
            case "figure":
            case "footer":
            case "header":
            case "hgroup":
            case "main":
            case "menu":
            case "nav":
            case "ol":
            case "p":
            case "section":
            case "summary":
            case "ul":
            case "pre":
            case "listing":
            case "table":
            case "hr":
            case "xmp":
            case "h1":
            case "h2":
            case "h3":
            case "h4":
            case "h5":
            case "h6":
              return ancestorInfo.pTagInButtonScope;
            case "form":
              return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
            case "li":
              return ancestorInfo.listItemTagAutoclosing;
            case "dd":
            case "dt":
              return ancestorInfo.dlItemTagAutoclosing;
            case "button":
              return ancestorInfo.buttonTagInScope;
            case "a":
              return ancestorInfo.aTagInScope;
            case "nobr":
              return ancestorInfo.nobrTagInScope;
          }
          return null;
        }
        function findAncestor(parent, tagName) {
          for (; parent; ) {
            switch (parent.tag) {
              case 5:
              case 26:
              case 27:
                if (parent.type === tagName) return parent;
            }
            parent = parent.return;
          }
          return null;
        }
        function validateDOMNesting(childTag, ancestorInfo) {
          ancestorInfo = ancestorInfo || emptyAncestorInfoDev;
          var parentInfo = ancestorInfo.current;
          ancestorInfo = (parentInfo = isTagValidWithParent(
            childTag,
            parentInfo && parentInfo.tag,
            ancestorInfo.implicitRootScope
          ) ? null : parentInfo) ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
          ancestorInfo = parentInfo || ancestorInfo;
          if (!ancestorInfo) return true;
          var ancestorTag = ancestorInfo.tag;
          ancestorInfo = String(!!parentInfo) + "|" + childTag + "|" + ancestorTag;
          if (didWarn[ancestorInfo]) return false;
          didWarn[ancestorInfo] = true;
          var ancestor = (ancestorInfo = current) ? findAncestor(ancestorInfo.return, ancestorTag) : null, ancestorDescription = null !== ancestorInfo && null !== ancestor ? describeAncestors(ancestor, ancestorInfo, null) : "", tagDisplayName = "<" + childTag + ">";
          parentInfo ? (parentInfo = "", "table" === ancestorTag && "tr" === childTag && (parentInfo += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), console.error(
            "In HTML, %s cannot be a child of <%s>.%s\nThis will cause a hydration error.%s",
            tagDisplayName,
            ancestorTag,
            parentInfo,
            ancestorDescription
          )) : console.error(
            "In HTML, %s cannot be a descendant of <%s>.\nThis will cause a hydration error.%s",
            tagDisplayName,
            ancestorTag,
            ancestorDescription
          );
          ancestorInfo && (childTag = ancestorInfo.return, null === ancestor || null === childTag || ancestor === childTag && childTag._debugOwner === ancestorInfo._debugOwner || runWithFiberInDEV(ancestor, function() {
            console.error(
              "<%s> cannot contain a nested %s.\nSee this log for the ancestor stack trace.",
              ancestorTag,
              tagDisplayName
            );
          }));
          return false;
        }
        function validateTextNesting(childText, parentTag, implicitRootScope) {
          if (implicitRootScope || isTagValidWithParent("#text", parentTag, false))
            return true;
          implicitRootScope = "#text|" + parentTag;
          if (didWarn[implicitRootScope]) return false;
          didWarn[implicitRootScope] = true;
          var ancestor = (implicitRootScope = current) ? findAncestor(implicitRootScope, parentTag) : null;
          implicitRootScope = null !== implicitRootScope && null !== ancestor ? describeAncestors(
            ancestor,
            implicitRootScope,
            6 !== implicitRootScope.tag ? { children: null } : null
          ) : "";
          /\S/.test(childText) ? console.error(
            "In HTML, text nodes cannot be a child of <%s>.\nThis will cause a hydration error.%s",
            parentTag,
            implicitRootScope
          ) : console.error(
            "In HTML, whitespace text nodes cannot be a child of <%s>. Make sure you don't have any extra whitespace between tags on each line of your source code.\nThis will cause a hydration error.%s",
            parentTag,
            implicitRootScope
          );
          return false;
        }
        function setTextContent(node, text) {
          if (text) {
            var firstChild = node.firstChild;
            if (firstChild && firstChild === node.lastChild && 3 === firstChild.nodeType) {
              firstChild.nodeValue = text;
              return;
            }
          }
          node.textContent = text;
        }
        function camelize(string) {
          return string.replace(hyphenPattern, function(_4, character) {
            return character.toUpperCase();
          });
        }
        function setValueForStyle(style2, styleName, value) {
          var isCustomProperty = 0 === styleName.indexOf("--");
          isCustomProperty || (-1 < styleName.indexOf("-") ? warnedStyleNames.hasOwnProperty(styleName) && warnedStyleNames[styleName] || (warnedStyleNames[styleName] = true, console.error(
            "Unsupported style property %s. Did you mean %s?",
            styleName,
            camelize(styleName.replace(msPattern, "ms-"))
          )) : badVendoredStyleNamePattern.test(styleName) ? warnedStyleNames.hasOwnProperty(styleName) && warnedStyleNames[styleName] || (warnedStyleNames[styleName] = true, console.error(
            "Unsupported vendor-prefixed style property %s. Did you mean %s?",
            styleName,
            styleName.charAt(0).toUpperCase() + styleName.slice(1)
          )) : !badStyleValueWithSemicolonPattern.test(value) || warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value] || (warnedStyleValues[value] = true, console.error(
            `Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`,
            styleName,
            value.replace(badStyleValueWithSemicolonPattern, "")
          )), "number" === typeof value && (isNaN(value) ? warnedForNaNValue || (warnedForNaNValue = true, console.error(
            "`NaN` is an invalid value for the `%s` css style property.",
            styleName
          )) : isFinite(value) || warnedForInfinityValue || (warnedForInfinityValue = true, console.error(
            "`Infinity` is an invalid value for the `%s` css style property.",
            styleName
          ))));
          null == value || "boolean" === typeof value || "" === value ? isCustomProperty ? style2.setProperty(styleName, "") : "float" === styleName ? style2.cssFloat = "" : style2[styleName] = "" : isCustomProperty ? style2.setProperty(styleName, value) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? "float" === styleName ? style2.cssFloat = value : (checkCSSPropertyStringCoercion(value, styleName), style2[styleName] = ("" + value).trim()) : style2[styleName] = value + "px";
        }
        function setValueForStyles(node, styles, prevStyles) {
          if (null != styles && "object" !== typeof styles)
            throw Error(
              "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
            );
          styles && Object.freeze(styles);
          node = node.style;
          if (null != prevStyles) {
            if (styles) {
              var expandedUpdates = {};
              if (prevStyles) {
                for (var key in prevStyles)
                  if (prevStyles.hasOwnProperty(key) && !styles.hasOwnProperty(key))
                    for (var longhands = shorthandToLonghand[key] || [key], i5 = 0; i5 < longhands.length; i5++)
                      expandedUpdates[longhands[i5]] = key;
              }
              for (var _key in styles)
                if (styles.hasOwnProperty(_key) && (!prevStyles || prevStyles[_key] !== styles[_key]))
                  for (key = shorthandToLonghand[_key] || [_key], longhands = 0; longhands < key.length; longhands++)
                    expandedUpdates[key[longhands]] = _key;
              _key = {};
              for (var key$jscomp$0 in styles)
                for (key = shorthandToLonghand[key$jscomp$0] || [key$jscomp$0], longhands = 0; longhands < key.length; longhands++)
                  _key[key[longhands]] = key$jscomp$0;
              key$jscomp$0 = {};
              for (var _key2 in expandedUpdates)
                if (key = expandedUpdates[_key2], (longhands = _key[_key2]) && key !== longhands && (i5 = key + "," + longhands, !key$jscomp$0[i5])) {
                  key$jscomp$0[i5] = true;
                  i5 = console;
                  var value = styles[key];
                  i5.error.call(
                    i5,
                    "%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.",
                    null == value || "boolean" === typeof value || "" === value ? "Removing" : "Updating",
                    key,
                    longhands
                  );
                }
            }
            for (var styleName in prevStyles)
              !prevStyles.hasOwnProperty(styleName) || null != styles && styles.hasOwnProperty(styleName) || (0 === styleName.indexOf("--") ? node.setProperty(styleName, "") : "float" === styleName ? node.cssFloat = "" : node[styleName] = "");
            for (var _styleName in styles)
              _key2 = styles[_styleName], styles.hasOwnProperty(_styleName) && prevStyles[_styleName] !== _key2 && setValueForStyle(node, _styleName, _key2);
          } else
            for (expandedUpdates in styles)
              styles.hasOwnProperty(expandedUpdates) && setValueForStyle(node, expandedUpdates, styles[expandedUpdates]);
        }
        function isCustomElement(tagName) {
          if (-1 === tagName.indexOf("-")) return false;
          switch (tagName) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              return false;
            default:
              return true;
          }
        }
        function getAttributeAlias(name) {
          return aliases.get(name) || name;
        }
        function validateProperty$1(tagName, name) {
          if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name])
            return true;
          if (rARIACamel$1.test(name)) {
            tagName = "aria-" + name.slice(4).toLowerCase();
            tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
            if (null == tagName)
              return console.error(
                "Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.",
                name
              ), warnedProperties$1[name] = true;
            if (name !== tagName)
              return console.error(
                "Invalid ARIA attribute `%s`. Did you mean `%s`?",
                name,
                tagName
              ), warnedProperties$1[name] = true;
          }
          if (rARIA$1.test(name)) {
            tagName = name.toLowerCase();
            tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
            if (null == tagName) return warnedProperties$1[name] = true, false;
            name !== tagName && (console.error(
              "Unknown ARIA attribute `%s`. Did you mean `%s`?",
              name,
              tagName
            ), warnedProperties$1[name] = true);
          }
          return true;
        }
        function validateProperties$2(type, props) {
          var invalidProps = [], key;
          for (key in props)
            validateProperty$1(type, key) || invalidProps.push(key);
          props = invalidProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          1 === invalidProps.length ? console.error(
            "Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
            props,
            type
          ) : 1 < invalidProps.length && console.error(
            "Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
            props,
            type
          );
        }
        function validateProperty(tagName, name, value, eventRegistry) {
          if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name])
            return true;
          var lowerCasedName = name.toLowerCase();
          if ("onfocusin" === lowerCasedName || "onfocusout" === lowerCasedName)
            return console.error(
              "React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."
            ), warnedProperties[name] = true;
          if ("function" === typeof value && ("form" === tagName && "action" === name || "input" === tagName && "formAction" === name || "button" === tagName && "formAction" === name))
            return true;
          if (null != eventRegistry) {
            tagName = eventRegistry.possibleRegistrationNames;
            if (eventRegistry.registrationNameDependencies.hasOwnProperty(name))
              return true;
            eventRegistry = tagName.hasOwnProperty(lowerCasedName) ? tagName[lowerCasedName] : null;
            if (null != eventRegistry)
              return console.error(
                "Invalid event handler property `%s`. Did you mean `%s`?",
                name,
                eventRegistry
              ), warnedProperties[name] = true;
            if (EVENT_NAME_REGEX.test(name))
              return console.error(
                "Unknown event handler property `%s`. It will be ignored.",
                name
              ), warnedProperties[name] = true;
          } else if (EVENT_NAME_REGEX.test(name))
            return INVALID_EVENT_NAME_REGEX.test(name) && console.error(
              "Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.",
              name
            ), warnedProperties[name] = true;
          if (rARIA.test(name) || rARIACamel.test(name)) return true;
          if ("innerhtml" === lowerCasedName)
            return console.error(
              "Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."
            ), warnedProperties[name] = true;
          if ("aria" === lowerCasedName)
            return console.error(
              "The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."
            ), warnedProperties[name] = true;
          if ("is" === lowerCasedName && null !== value && void 0 !== value && "string" !== typeof value)
            return console.error(
              "Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.",
              typeof value
            ), warnedProperties[name] = true;
          if ("number" === typeof value && isNaN(value))
            return console.error(
              "Received NaN for the `%s` attribute. If this is expected, cast the value to a string.",
              name
            ), warnedProperties[name] = true;
          if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
            if (lowerCasedName = possibleStandardNames[lowerCasedName], lowerCasedName !== name)
              return console.error(
                "Invalid DOM property `%s`. Did you mean `%s`?",
                name,
                lowerCasedName
              ), warnedProperties[name] = true;
          } else if (name !== lowerCasedName)
            return console.error(
              "React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.",
              name,
              lowerCasedName
            ), warnedProperties[name] = true;
          switch (name) {
            case "dangerouslySetInnerHTML":
            case "children":
            case "style":
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
            case "defaultValue":
            case "defaultChecked":
            case "innerHTML":
            case "ref":
              return true;
            case "innerText":
            case "textContent":
              return true;
          }
          switch (typeof value) {
            case "boolean":
              switch (name) {
                case "autoFocus":
                case "checked":
                case "multiple":
                case "muted":
                case "selected":
                case "contentEditable":
                case "spellCheck":
                case "draggable":
                case "value":
                case "autoReverse":
                case "externalResourcesRequired":
                case "focusable":
                case "preserveAlpha":
                case "allowFullScreen":
                case "async":
                case "autoPlay":
                case "controls":
                case "default":
                case "defer":
                case "disabled":
                case "disablePictureInPicture":
                case "disableRemotePlayback":
                case "formNoValidate":
                case "hidden":
                case "loop":
                case "noModule":
                case "noValidate":
                case "open":
                case "playsInline":
                case "readOnly":
                case "required":
                case "reversed":
                case "scoped":
                case "seamless":
                case "itemScope":
                case "capture":
                case "download":
                case "inert":
                  return true;
                default:
                  lowerCasedName = name.toLowerCase().slice(0, 5);
                  if ("data-" === lowerCasedName || "aria-" === lowerCasedName)
                    return true;
                  value ? console.error(
                    'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.',
                    value,
                    name,
                    name,
                    value,
                    name
                  ) : console.error(
                    'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',
                    value,
                    name,
                    name,
                    value,
                    name,
                    name,
                    name
                  );
                  return warnedProperties[name] = true;
              }
            case "function":
            case "symbol":
              return warnedProperties[name] = true, false;
            case "string":
              if ("false" === value || "true" === value) {
                switch (name) {
                  case "checked":
                  case "selected":
                  case "multiple":
                  case "muted":
                  case "allowFullScreen":
                  case "async":
                  case "autoPlay":
                  case "controls":
                  case "default":
                  case "defer":
                  case "disabled":
                  case "disablePictureInPicture":
                  case "disableRemotePlayback":
                  case "formNoValidate":
                  case "hidden":
                  case "loop":
                  case "noModule":
                  case "noValidate":
                  case "open":
                  case "playsInline":
                  case "readOnly":
                  case "required":
                  case "reversed":
                  case "scoped":
                  case "seamless":
                  case "itemScope":
                  case "inert":
                    break;
                  default:
                    return true;
                }
                console.error(
                  "Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?",
                  value,
                  name,
                  "false" === value ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".',
                  name,
                  value
                );
                warnedProperties[name] = true;
              }
          }
          return true;
        }
        function warnUnknownProperties(type, props, eventRegistry) {
          var unknownProps = [], key;
          for (key in props)
            validateProperty(type, key, props[key], eventRegistry) || unknownProps.push(key);
          props = unknownProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          1 === unknownProps.length ? console.error(
            "Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior ",
            props,
            type
          ) : 1 < unknownProps.length && console.error(
            "Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior ",
            props,
            type
          );
        }
        function sanitizeURL(url) {
          return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
        }
        function noop$1() {
        }
        function getEventTarget(nativeEvent) {
          nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
          nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
          return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
        }
        function restoreStateOfTarget(target) {
          var internalInstance = getInstanceFromNode(target);
          if (internalInstance && (target = internalInstance.stateNode)) {
            var props = target[internalPropsKey] || null;
            a: switch (target = internalInstance.stateNode, internalInstance.type) {
              case "input":
                updateInput(
                  target,
                  props.value,
                  props.defaultValue,
                  props.defaultValue,
                  props.checked,
                  props.defaultChecked,
                  props.type,
                  props.name
                );
                internalInstance = props.name;
                if ("radio" === props.type && null != internalInstance) {
                  for (props = target; props.parentNode; ) props = props.parentNode;
                  checkAttributeStringCoercion(internalInstance, "name");
                  props = props.querySelectorAll(
                    'input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                      "" + internalInstance
                    ) + '"][type="radio"]'
                  );
                  for (internalInstance = 0; internalInstance < props.length; internalInstance++) {
                    var otherNode = props[internalInstance];
                    if (otherNode !== target && otherNode.form === target.form) {
                      var otherProps = otherNode[internalPropsKey] || null;
                      if (!otherProps)
                        throw Error(
                          "ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported."
                        );
                      updateInput(
                        otherNode,
                        otherProps.value,
                        otherProps.defaultValue,
                        otherProps.defaultValue,
                        otherProps.checked,
                        otherProps.defaultChecked,
                        otherProps.type,
                        otherProps.name
                      );
                    }
                  }
                  for (internalInstance = 0; internalInstance < props.length; internalInstance++)
                    otherNode = props[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode);
                }
                break a;
              case "textarea":
                updateTextarea(target, props.value, props.defaultValue);
                break a;
              case "select":
                internalInstance = props.value, null != internalInstance && updateOptions(target, !!props.multiple, internalInstance, false);
            }
          }
        }
        function batchedUpdates$1(fn, a5, b3) {
          if (isInsideEventHandler) return fn(a5, b3);
          isInsideEventHandler = true;
          try {
            var JSCompiler_inline_result = fn(a5);
            return JSCompiler_inline_result;
          } finally {
            if (isInsideEventHandler = false, null !== restoreTarget || null !== restoreQueue) {
              if (flushSyncWork$1(), restoreTarget && (a5 = restoreTarget, fn = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(a5), fn))
                for (a5 = 0; a5 < fn.length; a5++) restoreStateOfTarget(fn[a5]);
            }
          }
        }
        function getListener(inst, registrationName) {
          var stateNode = inst.stateNode;
          if (null === stateNode) return null;
          var props = stateNode[internalPropsKey] || null;
          if (null === props) return null;
          stateNode = props[registrationName];
          a: switch (registrationName) {
            case "onClick":
            case "onClickCapture":
            case "onDoubleClick":
            case "onDoubleClickCapture":
            case "onMouseDown":
            case "onMouseDownCapture":
            case "onMouseMove":
            case "onMouseMoveCapture":
            case "onMouseUp":
            case "onMouseUpCapture":
            case "onMouseEnter":
              (props = !props.disabled) || (inst = inst.type, props = !("button" === inst || "input" === inst || "select" === inst || "textarea" === inst));
              inst = !props;
              break a;
            default:
              inst = false;
          }
          if (inst) return null;
          if (stateNode && "function" !== typeof stateNode)
            throw Error(
              "Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof stateNode + "` type."
            );
          return stateNode;
        }
        function getData() {
          if (fallbackText) return fallbackText;
          var start2, startValue = startText, startLength = startValue.length, end, endValue = "value" in root ? root.value : root.textContent, endLength = endValue.length;
          for (start2 = 0; start2 < startLength && startValue[start2] === endValue[start2]; start2++) ;
          var minEnd = startLength - start2;
          for (end = 1; end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++) ;
          return fallbackText = endValue.slice(start2, 1 < end ? 1 - end : void 0);
        }
        function getEventCharCode(nativeEvent) {
          var keyCode = nativeEvent.keyCode;
          "charCode" in nativeEvent ? (nativeEvent = nativeEvent.charCode, 0 === nativeEvent && 13 === keyCode && (nativeEvent = 13)) : nativeEvent = keyCode;
          10 === nativeEvent && (nativeEvent = 13);
          return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
        }
        function functionThatReturnsTrue() {
          return true;
        }
        function functionThatReturnsFalse() {
          return false;
        }
        function createSyntheticEvent(Interface) {
          function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
            this._reactName = reactName;
            this._targetInst = targetInst;
            this.type = reactEventType;
            this.nativeEvent = nativeEvent;
            this.target = nativeEventTarget;
            this.currentTarget = null;
            for (var propName in Interface)
              Interface.hasOwnProperty(propName) && (reactName = Interface[propName], this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]);
            this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : false === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
            this.isPropagationStopped = functionThatReturnsFalse;
            return this;
          }
          assign(SyntheticBaseEvent.prototype, {
            preventDefault: function() {
              this.defaultPrevented = true;
              var event = this.nativeEvent;
              event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = false), this.isDefaultPrevented = functionThatReturnsTrue);
            },
            stopPropagation: function() {
              var event = this.nativeEvent;
              event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = true), this.isPropagationStopped = functionThatReturnsTrue);
            },
            persist: function() {
            },
            isPersistent: functionThatReturnsTrue
          });
          return SyntheticBaseEvent;
        }
        function modifierStateGetter(keyArg) {
          var nativeEvent = this.nativeEvent;
          return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArg) : (keyArg = modifierKeyToProp[keyArg]) ? !!nativeEvent[keyArg] : false;
        }
        function getEventModifierState() {
          return modifierStateGetter;
        }
        function isFallbackCompositionEnd(domEventName, nativeEvent) {
          switch (domEventName) {
            case "keyup":
              return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
            case "keydown":
              return nativeEvent.keyCode !== START_KEYCODE;
            case "keypress":
            case "mousedown":
            case "focusout":
              return true;
            default:
              return false;
          }
        }
        function getDataFromCustomEvent(nativeEvent) {
          nativeEvent = nativeEvent.detail;
          return "object" === typeof nativeEvent && "data" in nativeEvent ? nativeEvent.data : null;
        }
        function getNativeBeforeInputChars(domEventName, nativeEvent) {
          switch (domEventName) {
            case "compositionend":
              return getDataFromCustomEvent(nativeEvent);
            case "keypress":
              if (nativeEvent.which !== SPACEBAR_CODE) return null;
              hasSpaceKeypress = true;
              return SPACEBAR_CHAR;
            case "textInput":
              return domEventName = nativeEvent.data, domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName;
            default:
              return null;
          }
        }
        function getFallbackBeforeInputChars(domEventName, nativeEvent) {
          if (isComposing)
            return "compositionend" === domEventName || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent) ? (domEventName = getData(), fallbackText = startText = root = null, isComposing = false, domEventName) : null;
          switch (domEventName) {
            case "paste":
              return null;
            case "keypress":
              if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || nativeEvent.ctrlKey && nativeEvent.altKey) {
                if (nativeEvent.char && 1 < nativeEvent.char.length)
                  return nativeEvent.char;
                if (nativeEvent.which)
                  return String.fromCharCode(nativeEvent.which);
              }
              return null;
            case "compositionend":
              return useFallbackCompositionData && "ko" !== nativeEvent.locale ? null : nativeEvent.data;
            default:
              return null;
          }
        }
        function isTextInputElement(elem) {
          var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
          return "input" === nodeName ? !!supportedInputTypes[elem.type] : "textarea" === nodeName ? true : false;
        }
        function isEventSupported(eventNameSuffix) {
          if (!canUseDOM) return false;
          eventNameSuffix = "on" + eventNameSuffix;
          var isSupported = eventNameSuffix in document;
          isSupported || (isSupported = document.createElement("div"), isSupported.setAttribute(eventNameSuffix, "return;"), isSupported = "function" === typeof isSupported[eventNameSuffix]);
          return isSupported;
        }
        function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
          restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [target] : restoreTarget = target;
          inst = accumulateTwoPhaseListeners(inst, "onChange");
          0 < inst.length && (nativeEvent = new SyntheticEvent(
            "onChange",
            "change",
            null,
            nativeEvent,
            target
          ), dispatchQueue.push({ event: nativeEvent, listeners: inst }));
        }
        function runEventInBatch(dispatchQueue) {
          processDispatchQueue(dispatchQueue, 0);
        }
        function getInstIfValueChanged(targetInst) {
          var targetNode = getNodeFromInstance(targetInst);
          if (updateValueIfChanged(targetNode)) return targetInst;
        }
        function getTargetInstForChangeEvent(domEventName, targetInst) {
          if ("change" === domEventName) return targetInst;
        }
        function stopWatchingForValueChange() {
          activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), activeElementInst$1 = activeElement$1 = null);
        }
        function handlePropertyChange(nativeEvent) {
          if ("value" === nativeEvent.propertyName && getInstIfValueChanged(activeElementInst$1)) {
            var dispatchQueue = [];
            createAndAccumulateChangeEvent(
              dispatchQueue,
              activeElementInst$1,
              nativeEvent,
              getEventTarget(nativeEvent)
            );
            batchedUpdates$1(runEventInBatch, dispatchQueue);
          }
        }
        function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
          "focusin" === domEventName ? (stopWatchingForValueChange(), activeElement$1 = target, activeElementInst$1 = targetInst, activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : "focusout" === domEventName && stopWatchingForValueChange();
        }
        function getTargetInstForInputEventPolyfill(domEventName) {
          if ("selectionchange" === domEventName || "keyup" === domEventName || "keydown" === domEventName)
            return getInstIfValueChanged(activeElementInst$1);
        }
        function getTargetInstForClickEvent(domEventName, targetInst) {
          if ("click" === domEventName) return getInstIfValueChanged(targetInst);
        }
        function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
          if ("input" === domEventName || "change" === domEventName)
            return getInstIfValueChanged(targetInst);
        }
        function is(x5, y5) {
          return x5 === y5 && (0 !== x5 || 1 / x5 === 1 / y5) || x5 !== x5 && y5 !== y5;
        }
        function shallowEqual(objA, objB) {
          if (objectIs(objA, objB)) return true;
          if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB)
            return false;
          var keysA = Object.keys(objA), keysB = Object.keys(objB);
          if (keysA.length !== keysB.length) return false;
          for (keysB = 0; keysB < keysA.length; keysB++) {
            var currentKey = keysA[keysB];
            if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey]))
              return false;
          }
          return true;
        }
        function getLeafNode(node) {
          for (; node && node.firstChild; ) node = node.firstChild;
          return node;
        }
        function getNodeForCharacterOffset(root2, offset) {
          var node = getLeafNode(root2);
          root2 = 0;
          for (var nodeEnd; node; ) {
            if (3 === node.nodeType) {
              nodeEnd = root2 + node.textContent.length;
              if (root2 <= offset && nodeEnd >= offset)
                return { node, offset: offset - root2 };
              root2 = nodeEnd;
            }
            a: {
              for (; node; ) {
                if (node.nextSibling) {
                  node = node.nextSibling;
                  break a;
                }
                node = node.parentNode;
              }
              node = void 0;
            }
            node = getLeafNode(node);
          }
        }
        function containsNode(outerNode, innerNode) {
          return outerNode && innerNode ? outerNode === innerNode ? true : outerNode && 3 === outerNode.nodeType ? false : innerNode && 3 === innerNode.nodeType ? containsNode(outerNode, innerNode.parentNode) : "contains" in outerNode ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : false : false;
        }
        function getActiveElementDeep(containerInfo) {
          containerInfo = null != containerInfo && null != containerInfo.ownerDocument && null != containerInfo.ownerDocument.defaultView ? containerInfo.ownerDocument.defaultView : window;
          for (var element = getActiveElement(containerInfo.document); element instanceof containerInfo.HTMLIFrameElement; ) {
            try {
              var JSCompiler_inline_result = "string" === typeof element.contentWindow.location.href;
            } catch (err) {
              JSCompiler_inline_result = false;
            }
            if (JSCompiler_inline_result) containerInfo = element.contentWindow;
            else break;
            element = getActiveElement(containerInfo.document);
          }
          return element;
        }
        function hasSelectionCapabilities(elem) {
          var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
          return nodeName && ("input" === nodeName && ("text" === elem.type || "search" === elem.type || "tel" === elem.type || "url" === elem.type || "password" === elem.type) || "textarea" === nodeName || "true" === elem.contentEditable);
        }
        function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
          var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : 9 === nativeEventTarget.nodeType ? nativeEventTarget : nativeEventTarget.ownerDocument;
          mouseDown || null == activeElement || activeElement !== getActiveElement(doc) || (doc = activeElement, "selectionStart" in doc && hasSelectionCapabilities(doc) ? doc = { start: doc.selectionStart, end: doc.selectionEnd } : (doc = (doc.ownerDocument && doc.ownerDocument.defaultView || window).getSelection(), doc = {
            anchorNode: doc.anchorNode,
            anchorOffset: doc.anchorOffset,
            focusNode: doc.focusNode,
            focusOffset: doc.focusOffset
          }), lastSelection && shallowEqual(lastSelection, doc) || (lastSelection = doc, doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect"), 0 < doc.length && (nativeEvent = new SyntheticEvent(
            "onSelect",
            "select",
            null,
            nativeEvent,
            nativeEventTarget
          ), dispatchQueue.push({ event: nativeEvent, listeners: doc }), nativeEvent.target = activeElement)));
        }
        function makePrefixMap(styleProp, eventName) {
          var prefixes = {};
          prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
          prefixes["Webkit" + styleProp] = "webkit" + eventName;
          prefixes["Moz" + styleProp] = "moz" + eventName;
          return prefixes;
        }
        function getVendorPrefixedEventName(eventName) {
          if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
          if (!vendorPrefixes[eventName]) return eventName;
          var prefixMap = vendorPrefixes[eventName], styleProp;
          for (styleProp in prefixMap)
            if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
              return prefixedEventNames[eventName] = prefixMap[styleProp];
          return eventName;
        }
        function registerSimpleEvent(domEventName, reactName) {
          topLevelEventsToReactNames.set(domEventName, reactName);
          registerTwoPhaseEvent(reactName, [domEventName]);
        }
        function getArrayKind(array) {
          for (var kind = EMPTY_ARRAY, i5 = 0; i5 < array.length; i5++) {
            var value = array[i5];
            if ("object" === typeof value && null !== value)
              if (isArrayImpl(value) && 2 === value.length && "string" === typeof value[0]) {
                if (kind !== EMPTY_ARRAY && kind !== ENTRIES_ARRAY)
                  return COMPLEX_ARRAY;
                kind = ENTRIES_ARRAY;
              } else return COMPLEX_ARRAY;
            else {
              if ("function" === typeof value || "string" === typeof value && 50 < value.length || kind !== EMPTY_ARRAY && kind !== PRIMITIVE_ARRAY)
                return COMPLEX_ARRAY;
              kind = PRIMITIVE_ARRAY;
            }
          }
          return kind;
        }
        function addObjectToProperties(object, properties, indent, prefix2) {
          for (var key in object)
            hasOwnProperty.call(object, key) && "_" !== key[0] && addValueToProperties(key, object[key], properties, indent, prefix2);
        }
        function addValueToProperties(propertyName, value, properties, indent, prefix2) {
          switch (typeof value) {
            case "object":
              if (null === value) {
                value = "null";
                break;
              } else {
                if (value.$$typeof === REACT_ELEMENT_TYPE) {
                  var typeName2 = getComponentNameFromType(value.type) || "\u2026", key = value.key;
                  value = value.props;
                  var propsKeys = Object.keys(value), propsLength = propsKeys.length;
                  if (null == key && 0 === propsLength) {
                    value = "<" + typeName2 + " />";
                    break;
                  }
                  if (3 > indent || 1 === propsLength && "children" === propsKeys[0] && null == key) {
                    value = "<" + typeName2 + " \u2026 />";
                    break;
                  }
                  properties.push([
                    prefix2 + "\xA0\xA0".repeat(indent) + propertyName,
                    "<" + typeName2
                  ]);
                  null !== key && addValueToProperties(
                    "key",
                    key,
                    properties,
                    indent + 1,
                    prefix2
                  );
                  propertyName = false;
                  for (var propKey in value)
                    "children" === propKey ? null != value.children && (!isArrayImpl(value.children) || 0 < value.children.length) && (propertyName = true) : hasOwnProperty.call(value, propKey) && "_" !== propKey[0] && addValueToProperties(
                      propKey,
                      value[propKey],
                      properties,
                      indent + 1,
                      prefix2
                    );
                  properties.push([
                    "",
                    propertyName ? ">\u2026</" + typeName2 + ">" : "/>"
                  ]);
                  return;
                }
                typeName2 = Object.prototype.toString.call(value);
                typeName2 = typeName2.slice(8, typeName2.length - 1);
                if ("Array" === typeName2) {
                  if (propKey = getArrayKind(value), propKey === PRIMITIVE_ARRAY || propKey === EMPTY_ARRAY) {
                    value = JSON.stringify(value);
                    break;
                  } else if (propKey === ENTRIES_ARRAY) {
                    properties.push([
                      prefix2 + "\xA0\xA0".repeat(indent) + propertyName,
                      ""
                    ]);
                    for (propertyName = 0; propertyName < value.length; propertyName++)
                      typeName2 = value[propertyName], addValueToProperties(
                        typeName2[0],
                        typeName2[1],
                        properties,
                        indent + 1,
                        prefix2
                      );
                    return;
                  }
                }
                if ("Promise" === typeName2) {
                  if ("fulfilled" === value.status) {
                    if (typeName2 = properties.length, addValueToProperties(
                      propertyName,
                      value.value,
                      properties,
                      indent,
                      prefix2
                    ), properties.length > typeName2) {
                      properties = properties[typeName2];
                      properties[1] = "Promise<" + (properties[1] || "Object") + ">";
                      return;
                    }
                  } else if ("rejected" === value.status && (typeName2 = properties.length, addValueToProperties(
                    propertyName,
                    value.reason,
                    properties,
                    indent,
                    prefix2
                  ), properties.length > typeName2)) {
                    properties = properties[typeName2];
                    properties[1] = "Rejected Promise<" + properties[1] + ">";
                    return;
                  }
                  properties.push([
                    "\xA0\xA0".repeat(indent) + propertyName,
                    "Promise"
                  ]);
                  return;
                }
                "Object" === typeName2 && (propKey = Object.getPrototypeOf(value)) && "function" === typeof propKey.constructor && (typeName2 = propKey.constructor.name);
                properties.push([
                  prefix2 + "\xA0\xA0".repeat(indent) + propertyName,
                  "Object" === typeName2 ? 3 > indent ? "" : "\u2026" : typeName2
                ]);
                3 > indent && addObjectToProperties(value, properties, indent + 1, prefix2);
                return;
              }
            case "function":
              value = "" === value.name ? "() => {}" : value.name + "() {}";
              break;
            case "string":
              value = value === OMITTED_PROP_ERROR ? "\u2026" : JSON.stringify(value);
              break;
            case "undefined":
              value = "undefined";
              break;
            case "boolean":
              value = value ? "true" : "false";
              break;
            default:
              value = String(value);
          }
          properties.push([
            prefix2 + "\xA0\xA0".repeat(indent) + propertyName,
            value
          ]);
        }
        function addObjectDiffToProperties(prev, next, properties, indent) {
          var isDeeplyEqual = true;
          for (key in prev)
            key in next || (properties.push([
              REMOVED + "\xA0\xA0".repeat(indent) + key,
              "\u2026"
            ]), isDeeplyEqual = false);
          for (var _key in next)
            if (_key in prev) {
              var key = prev[_key];
              var nextValue = next[_key];
              if (key !== nextValue) {
                if (0 === indent && "children" === _key)
                  isDeeplyEqual = "\xA0\xA0".repeat(indent) + _key, properties.push(
                    [REMOVED + isDeeplyEqual, "\u2026"],
                    [ADDED + isDeeplyEqual, "\u2026"]
                  );
                else {
                  if (!(3 <= indent)) {
                    if ("object" === typeof key && "object" === typeof nextValue && null !== key && null !== nextValue && key.$$typeof === nextValue.$$typeof)
                      if (nextValue.$$typeof === REACT_ELEMENT_TYPE) {
                        if (key.type === nextValue.type && key.key === nextValue.key) {
                          key = getComponentNameFromType(nextValue.type) || "\u2026";
                          isDeeplyEqual = "\xA0\xA0".repeat(indent) + _key;
                          key = "<" + key + " \u2026 />";
                          properties.push(
                            [REMOVED + isDeeplyEqual, key],
                            [ADDED + isDeeplyEqual, key]
                          );
                          isDeeplyEqual = false;
                          continue;
                        }
                      } else {
                        var prevKind = Object.prototype.toString.call(key), nextKind = Object.prototype.toString.call(nextValue);
                        if (prevKind === nextKind && ("[object Object]" === nextKind || "[object Array]" === nextKind)) {
                          prevKind = [
                            UNCHANGED + "\xA0\xA0".repeat(indent) + _key,
                            "[object Array]" === nextKind ? "Array" : ""
                          ];
                          properties.push(prevKind);
                          nextKind = properties.length;
                          addObjectDiffToProperties(
                            key,
                            nextValue,
                            properties,
                            indent + 1
                          ) ? nextKind === properties.length && (prevKind[1] = "Referentially unequal but deeply equal objects. Consider memoization.") : isDeeplyEqual = false;
                          continue;
                        }
                      }
                    else if ("function" === typeof key && "function" === typeof nextValue && key.name === nextValue.name && key.length === nextValue.length && (prevKind = Function.prototype.toString.call(key), nextKind = Function.prototype.toString.call(nextValue), prevKind === nextKind)) {
                      key = "" === nextValue.name ? "() => {}" : nextValue.name + "() {}";
                      properties.push([
                        UNCHANGED + "\xA0\xA0".repeat(indent) + _key,
                        key + " Referentially unequal function closure. Consider memoization."
                      ]);
                      continue;
                    }
                  }
                  addValueToProperties(_key, key, properties, indent, REMOVED);
                  addValueToProperties(_key, nextValue, properties, indent, ADDED);
                }
                isDeeplyEqual = false;
              }
            } else
              properties.push([
                ADDED + "\xA0\xA0".repeat(indent) + _key,
                "\u2026"
              ]), isDeeplyEqual = false;
          return isDeeplyEqual;
        }
        function setCurrentTrackFromLanes(lanes) {
          currentTrack = lanes & 63 ? "Blocking" : lanes & 64 ? "Gesture" : lanes & 4194176 ? "Transition" : lanes & 62914560 ? "Suspense" : lanes & 2080374784 ? "Idle" : "Other";
        }
        function logComponentTrigger(fiber, startTime, endTime, trigger) {
          supportsUserTiming && (reusableComponentOptions.start = startTime, reusableComponentOptions.end = endTime, reusableComponentDevToolDetails.color = "warning", reusableComponentDevToolDetails.tooltipText = trigger, reusableComponentDevToolDetails.properties = null, (fiber = fiber._debugTask) ? fiber.run(
            performance.measure.bind(
              performance,
              trigger,
              reusableComponentOptions
            )
          ) : performance.measure(trigger, reusableComponentOptions));
        }
        function logComponentReappeared(fiber, startTime, endTime) {
          logComponentTrigger(fiber, startTime, endTime, "Reconnect");
        }
        function logComponentRender(fiber, startTime, endTime, wasHydrated, committedLanes) {
          var name = getComponentNameFromFiber(fiber);
          if (null !== name && supportsUserTiming) {
            var alternate = fiber.alternate, selfTime = fiber.actualDuration;
            if (null === alternate || alternate.child !== fiber.child)
              for (var child = fiber.child; null !== child; child = child.sibling)
                selfTime -= child.actualDuration;
            wasHydrated = 0.5 > selfTime ? wasHydrated ? "tertiary-light" : "primary-light" : 10 > selfTime ? wasHydrated ? "tertiary" : "primary" : 100 > selfTime ? wasHydrated ? "tertiary-dark" : "primary-dark" : "error";
            var props = fiber.memoizedProps;
            selfTime = fiber._debugTask;
            null !== props && null !== alternate && alternate.memoizedProps !== props ? (child = [resuableChangedPropsEntry], props = addObjectDiffToProperties(
              alternate.memoizedProps,
              props,
              child,
              0
            ), 1 < child.length && (props && !alreadyWarnedForDeepEquality && 0 === (alternate.lanes & committedLanes) && 100 < fiber.actualDuration ? (alreadyWarnedForDeepEquality = true, child[0] = reusableDeeplyEqualPropsEntry, reusableComponentDevToolDetails.color = "warning", reusableComponentDevToolDetails.tooltipText = DEEP_EQUALITY_WARNING) : (reusableComponentDevToolDetails.color = wasHydrated, reusableComponentDevToolDetails.tooltipText = name), reusableComponentDevToolDetails.properties = child, reusableComponentOptions.start = startTime, reusableComponentOptions.end = endTime, null != selfTime ? selfTime.run(
              performance.measure.bind(
                performance,
                "\u200B" + name,
                reusableComponentOptions
              )
            ) : performance.measure(
              "\u200B" + name,
              reusableComponentOptions
            ))) : null != selfTime ? selfTime.run(
              console.timeStamp.bind(
                console,
                name,
                startTime,
                endTime,
                COMPONENTS_TRACK,
                void 0,
                wasHydrated
              )
            ) : console.timeStamp(
              name,
              startTime,
              endTime,
              COMPONENTS_TRACK,
              void 0,
              wasHydrated
            );
          }
        }
        function logComponentErrored(fiber, startTime, endTime, errors) {
          if (supportsUserTiming) {
            var name = getComponentNameFromFiber(fiber);
            if (null !== name) {
              for (var debugTask = null, properties = [], i5 = 0; i5 < errors.length; i5++) {
                var capturedValue = errors[i5];
                null == debugTask && null !== capturedValue.source && (debugTask = capturedValue.source._debugTask);
                capturedValue = capturedValue.value;
                properties.push([
                  "Error",
                  "object" === typeof capturedValue && null !== capturedValue && "string" === typeof capturedValue.message ? String(capturedValue.message) : String(capturedValue)
                ]);
              }
              null !== fiber.key && addValueToProperties("key", fiber.key, properties, 0, "");
              null !== fiber.memoizedProps && addObjectToProperties(fiber.memoizedProps, properties, 0, "");
              null == debugTask && (debugTask = fiber._debugTask);
              fiber = {
                start: startTime,
                end: endTime,
                detail: {
                  devtools: {
                    color: "error",
                    track: COMPONENTS_TRACK,
                    tooltipText: 13 === fiber.tag ? "Hydration failed" : "Error boundary caught an error",
                    properties
                  }
                }
              };
              debugTask ? debugTask.run(
                performance.measure.bind(performance, "\u200B" + name, fiber)
              ) : performance.measure("\u200B" + name, fiber);
            }
          }
        }
        function logComponentEffect(fiber, startTime, endTime, selfTime, errors) {
          if (null !== errors) {
            if (supportsUserTiming) {
              var name = getComponentNameFromFiber(fiber);
              if (null !== name) {
                selfTime = [];
                for (var i5 = 0; i5 < errors.length; i5++) {
                  var error = errors[i5].value;
                  selfTime.push([
                    "Error",
                    "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error)
                  ]);
                }
                null !== fiber.key && addValueToProperties("key", fiber.key, selfTime, 0, "");
                null !== fiber.memoizedProps && addObjectToProperties(fiber.memoizedProps, selfTime, 0, "");
                startTime = {
                  start: startTime,
                  end: endTime,
                  detail: {
                    devtools: {
                      color: "error",
                      track: COMPONENTS_TRACK,
                      tooltipText: "A lifecycle or effect errored",
                      properties: selfTime
                    }
                  }
                };
                (fiber = fiber._debugTask) ? fiber.run(
                  performance.measure.bind(
                    performance,
                    "\u200B" + name,
                    startTime
                  )
                ) : performance.measure("\u200B" + name, startTime);
              }
            }
          } else
            name = getComponentNameFromFiber(fiber), null !== name && supportsUserTiming && (errors = 1 > selfTime ? "secondary-light" : 100 > selfTime ? "secondary" : 500 > selfTime ? "secondary-dark" : "error", (fiber = fiber._debugTask) ? fiber.run(
              console.timeStamp.bind(
                console,
                name,
                startTime,
                endTime,
                COMPONENTS_TRACK,
                void 0,
                errors
              )
            ) : console.timeStamp(
              name,
              startTime,
              endTime,
              COMPONENTS_TRACK,
              void 0,
              errors
            ));
        }
        function logRenderPhase(startTime, endTime, lanes, debugTask) {
          if (supportsUserTiming && !(endTime <= startTime)) {
            var color = (lanes & 738197653) === lanes ? "tertiary-dark" : "primary-dark";
            lanes = (lanes & 536870912) === lanes ? "Prepared" : (lanes & 201326741) === lanes ? "Hydrated" : "Render";
            debugTask ? debugTask.run(
              console.timeStamp.bind(
                console,
                lanes,
                startTime,
                endTime,
                currentTrack,
                LANES_TRACK_GROUP,
                color
              )
            ) : console.timeStamp(
              lanes,
              startTime,
              endTime,
              currentTrack,
              LANES_TRACK_GROUP,
              color
            );
          }
        }
        function logSuspendedRenderPhase(startTime, endTime, lanes, debugTask) {
          !supportsUserTiming || endTime <= startTime || (lanes = (lanes & 738197653) === lanes ? "tertiary-dark" : "primary-dark", debugTask ? debugTask.run(
            console.timeStamp.bind(
              console,
              "Prewarm",
              startTime,
              endTime,
              currentTrack,
              LANES_TRACK_GROUP,
              lanes
            )
          ) : console.timeStamp(
            "Prewarm",
            startTime,
            endTime,
            currentTrack,
            LANES_TRACK_GROUP,
            lanes
          ));
        }
        function logSuspendedWithDelayPhase(startTime, endTime, lanes, debugTask) {
          !supportsUserTiming || endTime <= startTime || (lanes = (lanes & 738197653) === lanes ? "tertiary-dark" : "primary-dark", debugTask ? debugTask.run(
            console.timeStamp.bind(
              console,
              "Suspended",
              startTime,
              endTime,
              currentTrack,
              LANES_TRACK_GROUP,
              lanes
            )
          ) : console.timeStamp(
            "Suspended",
            startTime,
            endTime,
            currentTrack,
            LANES_TRACK_GROUP,
            lanes
          ));
        }
        function logRecoveredRenderPhase(startTime, endTime, lanes, recoverableErrors, hydrationFailed, debugTask) {
          if (supportsUserTiming && !(endTime <= startTime)) {
            lanes = [];
            for (var i5 = 0; i5 < recoverableErrors.length; i5++) {
              var error = recoverableErrors[i5].value;
              lanes.push([
                "Recoverable Error",
                "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error)
              ]);
            }
            startTime = {
              start: startTime,
              end: endTime,
              detail: {
                devtools: {
                  color: "primary-dark",
                  track: currentTrack,
                  trackGroup: LANES_TRACK_GROUP,
                  tooltipText: hydrationFailed ? "Hydration Failed" : "Recovered after Error",
                  properties: lanes
                }
              }
            };
            debugTask ? debugTask.run(
              performance.measure.bind(performance, "Recovered", startTime)
            ) : performance.measure("Recovered", startTime);
          }
        }
        function logErroredRenderPhase(startTime, endTime, lanes, debugTask) {
          !supportsUserTiming || endTime <= startTime || (debugTask ? debugTask.run(
            console.timeStamp.bind(
              console,
              "Errored",
              startTime,
              endTime,
              currentTrack,
              LANES_TRACK_GROUP,
              "error"
            )
          ) : console.timeStamp(
            "Errored",
            startTime,
            endTime,
            currentTrack,
            LANES_TRACK_GROUP,
            "error"
          ));
        }
        function logSuspendedCommitPhase(startTime, endTime, reason, debugTask) {
          !supportsUserTiming || endTime <= startTime || (debugTask ? debugTask.run(
            console.timeStamp.bind(
              console,
              reason,
              startTime,
              endTime,
              currentTrack,
              LANES_TRACK_GROUP,
              "secondary-light"
            )
          ) : console.timeStamp(
            reason,
            startTime,
            endTime,
            currentTrack,
            LANES_TRACK_GROUP,
            "secondary-light"
          ));
        }
        function logCommitErrored(startTime, endTime, errors, passive, debugTask) {
          if (supportsUserTiming && !(endTime <= startTime)) {
            for (var properties = [], i5 = 0; i5 < errors.length; i5++) {
              var error = errors[i5].value;
              properties.push([
                "Error",
                "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error)
              ]);
            }
            startTime = {
              start: startTime,
              end: endTime,
              detail: {
                devtools: {
                  color: "error",
                  track: currentTrack,
                  trackGroup: LANES_TRACK_GROUP,
                  tooltipText: passive ? "Remaining Effects Errored" : "Commit Errored",
                  properties
                }
              }
            };
            debugTask ? debugTask.run(
              performance.measure.bind(performance, "Errored", startTime)
            ) : performance.measure("Errored", startTime);
          }
        }
        function logAnimatingPhase(startTime, endTime, debugTask) {
          !supportsUserTiming || endTime <= startTime || (debugTask ? debugTask.run(
            console.timeStamp.bind(
              console,
              "Animating",
              startTime,
              endTime,
              currentTrack,
              LANES_TRACK_GROUP,
              "secondary-dark"
            )
          ) : console.timeStamp(
            "Animating",
            startTime,
            endTime,
            currentTrack,
            LANES_TRACK_GROUP,
            "secondary-dark"
          ));
        }
        function finishQueueingConcurrentUpdates() {
          for (var endIndex = concurrentQueuesIndex, i5 = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i5 < endIndex; ) {
            var fiber = concurrentQueues[i5];
            concurrentQueues[i5++] = null;
            var queue = concurrentQueues[i5];
            concurrentQueues[i5++] = null;
            var update = concurrentQueues[i5];
            concurrentQueues[i5++] = null;
            var lane = concurrentQueues[i5];
            concurrentQueues[i5++] = null;
            if (null !== queue && null !== update) {
              var pending = queue.pending;
              null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
              queue.pending = update;
            }
            0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
          }
        }
        function enqueueUpdate$1(fiber, queue, update, lane) {
          concurrentQueues[concurrentQueuesIndex++] = fiber;
          concurrentQueues[concurrentQueuesIndex++] = queue;
          concurrentQueues[concurrentQueuesIndex++] = update;
          concurrentQueues[concurrentQueuesIndex++] = lane;
          concurrentlyUpdatedLanes |= lane;
          fiber.lanes |= lane;
          fiber = fiber.alternate;
          null !== fiber && (fiber.lanes |= lane);
        }
        function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
          enqueueUpdate$1(fiber, queue, update, lane);
          return getRootForUpdatedFiber(fiber);
        }
        function enqueueConcurrentRenderForLane(fiber, lane) {
          enqueueUpdate$1(fiber, null, null, lane);
          return getRootForUpdatedFiber(fiber);
        }
        function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
          sourceFiber.lanes |= lane;
          var alternate = sourceFiber.alternate;
          null !== alternate && (alternate.lanes |= lane);
          for (var isHidden = false, parent = sourceFiber.return; null !== parent; )
            parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & OffscreenVisible || (isHidden = true)), sourceFiber = parent, parent = parent.return;
          return 3 === sourceFiber.tag ? (parent = sourceFiber.stateNode, isHidden && null !== update && (isHidden = 31 - clz32(lane), sourceFiber = parent.hiddenUpdates, alternate = sourceFiber[isHidden], null === alternate ? sourceFiber[isHidden] = [update] : alternate.push(update), update.lane = lane | 536870912), parent) : null;
        }
        function getRootForUpdatedFiber(sourceFiber) {
          if (nestedUpdateCount > NESTED_UPDATE_LIMIT)
            throw nestedPassiveUpdateCount = nestedUpdateCount = 0, rootWithPassiveNestedUpdates = rootWithNestedUpdates = null, Error(
              "Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops."
            );
          nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT && (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, console.error(
            "Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."
          ));
          null === sourceFiber.alternate && 0 !== (sourceFiber.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
          for (var node = sourceFiber, parent = node.return; null !== parent; )
            null === node.alternate && 0 !== (node.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber), node = parent, parent = node.return;
          return 3 === node.tag ? node.stateNode : null;
        }
        function resolveFunctionForHotReloading(type) {
          if (null === resolveFamily) return type;
          var family = resolveFamily(type);
          return void 0 === family ? type : family.current;
        }
        function resolveForwardRefForHotReloading(type) {
          if (null === resolveFamily) return type;
          var family = resolveFamily(type);
          return void 0 === family ? null !== type && void 0 !== type && "function" === typeof type.render && (family = resolveFunctionForHotReloading(type.render), type.render !== family) ? (family = { $$typeof: REACT_FORWARD_REF_TYPE, render: family }, void 0 !== type.displayName && (family.displayName = type.displayName), family) : type : family.current;
        }
        function isCompatibleFamilyForHotReloading(fiber, element) {
          if (null === resolveFamily) return false;
          var prevType = fiber.elementType;
          element = element.type;
          var needsCompareFamilies = false, $$typeofNextType = "object" === typeof element && null !== element ? element.$$typeof : null;
          switch (fiber.tag) {
            case 1:
              "function" === typeof element && (needsCompareFamilies = true);
              break;
            case 0:
              "function" === typeof element ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
              break;
            case 11:
              $$typeofNextType === REACT_FORWARD_REF_TYPE ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
              break;
            case 14:
            case 15:
              $$typeofNextType === REACT_MEMO_TYPE ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
              break;
            default:
              return false;
          }
          return needsCompareFamilies && (fiber = resolveFamily(prevType), void 0 !== fiber && fiber === resolveFamily(element)) ? true : false;
        }
        function markFailedErrorBoundaryForHotReloading(fiber) {
          null !== resolveFamily && "function" === typeof WeakSet && (null === failedBoundaries && (failedBoundaries = /* @__PURE__ */ new WeakSet()), failedBoundaries.add(fiber));
        }
        function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
          do {
            var _fiber = fiber, alternate = _fiber.alternate, child = _fiber.child, sibling = _fiber.sibling, tag = _fiber.tag;
            _fiber = _fiber.type;
            var candidateType = null;
            switch (tag) {
              case 0:
              case 15:
              case 1:
                candidateType = _fiber;
                break;
              case 11:
                candidateType = _fiber.render;
            }
            if (null === resolveFamily)
              throw Error("Expected resolveFamily to be set during hot reload.");
            var needsRender = false;
            _fiber = false;
            null !== candidateType && (candidateType = resolveFamily(candidateType), void 0 !== candidateType && (staleFamilies.has(candidateType) ? _fiber = true : updatedFamilies.has(candidateType) && (1 === tag ? _fiber = true : needsRender = true)));
            null !== failedBoundaries && (failedBoundaries.has(fiber) || null !== alternate && failedBoundaries.has(alternate)) && (_fiber = true);
            _fiber && (fiber._debugNeedsRemount = true);
            if (_fiber || needsRender)
              alternate = enqueueConcurrentRenderForLane(fiber, 2), null !== alternate && scheduleUpdateOnFiber(alternate, fiber, 2);
            null === child || _fiber || scheduleFibersWithFamiliesRecursively(
              child,
              updatedFamilies,
              staleFamilies
            );
            if (null === sibling) break;
            fiber = sibling;
          } while (1);
        }
        function FiberNode(tag, pendingProps, key, mode) {
          this.tag = tag;
          this.key = key;
          this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
          this.index = 0;
          this.refCleanup = this.ref = null;
          this.pendingProps = pendingProps;
          this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
          this.mode = mode;
          this.subtreeFlags = this.flags = 0;
          this.deletions = null;
          this.childLanes = this.lanes = 0;
          this.alternate = null;
          this.actualDuration = -0;
          this.actualStartTime = -1.1;
          this.treeBaseDuration = this.selfBaseDuration = -0;
          this._debugTask = this._debugStack = this._debugOwner = this._debugInfo = null;
          this._debugNeedsRemount = false;
          this._debugHookTypes = null;
          hasBadMapPolyfill || "function" !== typeof Object.preventExtensions || Object.preventExtensions(this);
        }
        function shouldConstruct(Component) {
          Component = Component.prototype;
          return !(!Component || !Component.isReactComponent);
        }
        function createWorkInProgress(current2, pendingProps) {
          var workInProgress2 = current2.alternate;
          null === workInProgress2 ? (workInProgress2 = createFiber(
            current2.tag,
            pendingProps,
            current2.key,
            current2.mode
          ), workInProgress2.elementType = current2.elementType, workInProgress2.type = current2.type, workInProgress2.stateNode = current2.stateNode, workInProgress2._debugOwner = current2._debugOwner, workInProgress2._debugStack = current2._debugStack, workInProgress2._debugTask = current2._debugTask, workInProgress2._debugHookTypes = current2._debugHookTypes, workInProgress2.alternate = current2, current2.alternate = workInProgress2) : (workInProgress2.pendingProps = pendingProps, workInProgress2.type = current2.type, workInProgress2.flags = 0, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.actualDuration = -0, workInProgress2.actualStartTime = -1.1);
          workInProgress2.flags = current2.flags & 65011712;
          workInProgress2.childLanes = current2.childLanes;
          workInProgress2.lanes = current2.lanes;
          workInProgress2.child = current2.child;
          workInProgress2.memoizedProps = current2.memoizedProps;
          workInProgress2.memoizedState = current2.memoizedState;
          workInProgress2.updateQueue = current2.updateQueue;
          pendingProps = current2.dependencies;
          workInProgress2.dependencies = null === pendingProps ? null : {
            lanes: pendingProps.lanes,
            firstContext: pendingProps.firstContext,
            _debugThenableState: pendingProps._debugThenableState
          };
          workInProgress2.sibling = current2.sibling;
          workInProgress2.index = current2.index;
          workInProgress2.ref = current2.ref;
          workInProgress2.refCleanup = current2.refCleanup;
          workInProgress2.selfBaseDuration = current2.selfBaseDuration;
          workInProgress2.treeBaseDuration = current2.treeBaseDuration;
          workInProgress2._debugInfo = current2._debugInfo;
          workInProgress2._debugNeedsRemount = current2._debugNeedsRemount;
          switch (workInProgress2.tag) {
            case 0:
            case 15:
              workInProgress2.type = resolveFunctionForHotReloading(current2.type);
              break;
            case 1:
              workInProgress2.type = resolveFunctionForHotReloading(current2.type);
              break;
            case 11:
              workInProgress2.type = resolveForwardRefForHotReloading(current2.type);
          }
          return workInProgress2;
        }
        function resetWorkInProgress(workInProgress2, renderLanes2) {
          workInProgress2.flags &= 65011714;
          var current2 = workInProgress2.alternate;
          null === current2 ? (workInProgress2.childLanes = 0, workInProgress2.lanes = renderLanes2, workInProgress2.child = null, workInProgress2.subtreeFlags = 0, workInProgress2.memoizedProps = null, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null, workInProgress2.dependencies = null, workInProgress2.stateNode = null, workInProgress2.selfBaseDuration = 0, workInProgress2.treeBaseDuration = 0) : (workInProgress2.childLanes = current2.childLanes, workInProgress2.lanes = current2.lanes, workInProgress2.child = current2.child, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.memoizedProps = current2.memoizedProps, workInProgress2.memoizedState = current2.memoizedState, workInProgress2.updateQueue = current2.updateQueue, workInProgress2.type = current2.type, renderLanes2 = current2.dependencies, workInProgress2.dependencies = null === renderLanes2 ? null : {
            lanes: renderLanes2.lanes,
            firstContext: renderLanes2.firstContext,
            _debugThenableState: renderLanes2._debugThenableState
          }, workInProgress2.selfBaseDuration = current2.selfBaseDuration, workInProgress2.treeBaseDuration = current2.treeBaseDuration);
          return workInProgress2;
        }
        function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
          var fiberTag = 0, resolvedType = type;
          if ("function" === typeof type)
            shouldConstruct(type) && (fiberTag = 1), resolvedType = resolveFunctionForHotReloading(resolvedType);
          else if ("string" === typeof type)
            fiberTag = getHostContext(), fiberTag = isHostHoistableType(type, pendingProps, fiberTag) ? 26 : "html" === type || "head" === type || "body" === type ? 27 : 5;
          else
            a: switch (type) {
              case REACT_ACTIVITY_TYPE:
                return key = createFiber(31, pendingProps, key, mode), key.elementType = REACT_ACTIVITY_TYPE, key.lanes = lanes, key;
              case REACT_FRAGMENT_TYPE:
                return createFiberFromFragment(
                  pendingProps.children,
                  mode,
                  lanes,
                  key
                );
              case REACT_STRICT_MODE_TYPE:
                fiberTag = 8;
                mode |= StrictLegacyMode;
                mode |= StrictEffectsMode;
                break;
              case REACT_PROFILER_TYPE:
                return type = pendingProps, owner = mode, "string" !== typeof type.id && console.error(
                  'Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.',
                  typeof type.id
                ), key = createFiber(12, type, key, owner | ProfileMode), key.elementType = REACT_PROFILER_TYPE, key.lanes = lanes, key.stateNode = { effectDuration: 0, passiveEffectDuration: 0 }, key;
              case REACT_SUSPENSE_TYPE:
                return key = createFiber(13, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_TYPE, key.lanes = lanes, key;
              case REACT_SUSPENSE_LIST_TYPE:
                return key = createFiber(19, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_LIST_TYPE, key.lanes = lanes, key;
              default:
                if ("object" === typeof type && null !== type)
                  switch (type.$$typeof) {
                    case REACT_CONTEXT_TYPE:
                      fiberTag = 10;
                      break a;
                    case REACT_CONSUMER_TYPE:
                      fiberTag = 9;
                      break a;
                    case REACT_FORWARD_REF_TYPE:
                      fiberTag = 11;
                      resolvedType = resolveForwardRefForHotReloading(resolvedType);
                      break a;
                    case REACT_MEMO_TYPE:
                      fiberTag = 14;
                      break a;
                    case REACT_LAZY_TYPE:
                      fiberTag = 16;
                      resolvedType = null;
                      break a;
                  }
                resolvedType = "";
                if (void 0 === type || "object" === typeof type && null !== type && 0 === Object.keys(type).length)
                  resolvedType += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                null === type ? pendingProps = "null" : isArrayImpl(type) ? pendingProps = "array" : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE ? (pendingProps = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />", resolvedType = " Did you accidentally export a JSX literal instead of a component?") : pendingProps = typeof type;
                (fiberTag = owner ? getComponentNameFromOwner(owner) : null) && (resolvedType += "\n\nCheck the render method of `" + fiberTag + "`.");
                fiberTag = 29;
                pendingProps = Error(
                  "Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (pendingProps + "." + resolvedType)
                );
                resolvedType = null;
            }
          key = createFiber(fiberTag, pendingProps, key, mode);
          key.elementType = type;
          key.type = resolvedType;
          key.lanes = lanes;
          key._debugOwner = owner;
          return key;
        }
        function createFiberFromElement(element, mode, lanes) {
          mode = createFiberFromTypeAndProps(
            element.type,
            element.key,
            element.props,
            element._owner,
            mode,
            lanes
          );
          mode._debugOwner = element._owner;
          mode._debugStack = element._debugStack;
          mode._debugTask = element._debugTask;
          return mode;
        }
        function createFiberFromFragment(elements, mode, lanes, key) {
          elements = createFiber(7, elements, key, mode);
          elements.lanes = lanes;
          return elements;
        }
        function createFiberFromText(content, mode, lanes) {
          content = createFiber(6, content, null, mode);
          content.lanes = lanes;
          return content;
        }
        function createFiberFromDehydratedFragment(dehydratedNode) {
          var fiber = createFiber(18, null, null, NoMode);
          fiber.stateNode = dehydratedNode;
          return fiber;
        }
        function createFiberFromPortal(portal, mode, lanes) {
          mode = createFiber(
            4,
            null !== portal.children ? portal.children : [],
            portal.key,
            mode
          );
          mode.lanes = lanes;
          mode.stateNode = {
            containerInfo: portal.containerInfo,
            pendingChildren: null,
            implementation: portal.implementation
          };
          return mode;
        }
        function createCapturedValueAtFiber(value, source) {
          if ("object" === typeof value && null !== value) {
            var existing = CapturedStacks.get(value);
            if (void 0 !== existing) return existing;
            source = {
              value,
              source,
              stack: getStackByFiberInDevAndProd(source)
            };
            CapturedStacks.set(value, source);
            return source;
          }
          return {
            value,
            source,
            stack: getStackByFiberInDevAndProd(source)
          };
        }
        function pushTreeFork(workInProgress2, totalChildren) {
          warnIfNotHydrating();
          forkStack[forkStackIndex++] = treeForkCount;
          forkStack[forkStackIndex++] = treeForkProvider;
          treeForkProvider = workInProgress2;
          treeForkCount = totalChildren;
        }
        function pushTreeId(workInProgress2, totalChildren, index) {
          warnIfNotHydrating();
          idStack[idStackIndex++] = treeContextId;
          idStack[idStackIndex++] = treeContextOverflow;
          idStack[idStackIndex++] = treeContextProvider;
          treeContextProvider = workInProgress2;
          var baseIdWithLeadingBit = treeContextId;
          workInProgress2 = treeContextOverflow;
          var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
          baseIdWithLeadingBit &= ~(1 << baseLength);
          index += 1;
          var length = 32 - clz32(totalChildren) + baseLength;
          if (30 < length) {
            var numberOfOverflowBits = baseLength - baseLength % 5;
            length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
            baseIdWithLeadingBit >>= numberOfOverflowBits;
            baseLength -= numberOfOverflowBits;
            treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit;
            treeContextOverflow = length + workInProgress2;
          } else
            treeContextId = 1 << length | index << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress2;
        }
        function pushMaterializedTreeId(workInProgress2) {
          warnIfNotHydrating();
          null !== workInProgress2.return && (pushTreeFork(workInProgress2, 1), pushTreeId(workInProgress2, 1, 0));
        }
        function popTreeContext(workInProgress2) {
          for (; workInProgress2 === treeForkProvider; )
            treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
          for (; workInProgress2 === treeContextProvider; )
            treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
        }
        function getSuspendedTreeContext() {
          warnIfNotHydrating();
          return null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null;
        }
        function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {
          warnIfNotHydrating();
          idStack[idStackIndex++] = treeContextId;
          idStack[idStackIndex++] = treeContextOverflow;
          idStack[idStackIndex++] = treeContextProvider;
          treeContextId = suspendedContext.id;
          treeContextOverflow = suspendedContext.overflow;
          treeContextProvider = workInProgress2;
        }
        function warnIfNotHydrating() {
          isHydrating || console.error(
            "Expected to be hydrating. This is a bug in React. Please file an issue."
          );
        }
        function buildHydrationDiffNode(fiber, distanceFromLeaf) {
          if (null === fiber.return) {
            if (null === hydrationDiffRootDEV)
              hydrationDiffRootDEV = {
                fiber,
                children: [],
                serverProps: void 0,
                serverTail: [],
                distanceFromLeaf
              };
            else {
              if (hydrationDiffRootDEV.fiber !== fiber)
                throw Error(
                  "Saw multiple hydration diff roots in a pass. This is a bug in React."
                );
              hydrationDiffRootDEV.distanceFromLeaf > distanceFromLeaf && (hydrationDiffRootDEV.distanceFromLeaf = distanceFromLeaf);
            }
            return hydrationDiffRootDEV;
          }
          var siblings = buildHydrationDiffNode(
            fiber.return,
            distanceFromLeaf + 1
          ).children;
          if (0 < siblings.length && siblings[siblings.length - 1].fiber === fiber)
            return siblings = siblings[siblings.length - 1], siblings.distanceFromLeaf > distanceFromLeaf && (siblings.distanceFromLeaf = distanceFromLeaf), siblings;
          distanceFromLeaf = {
            fiber,
            children: [],
            serverProps: void 0,
            serverTail: [],
            distanceFromLeaf
          };
          siblings.push(distanceFromLeaf);
          return distanceFromLeaf;
        }
        function warnIfHydrating() {
          isHydrating && console.error(
            "We should not be hydrating here. This is a bug in React. Please file a bug."
          );
        }
        function warnNonHydratedInstance(fiber, rejectedCandidate) {
          didSuspendOrErrorDEV || (fiber = buildHydrationDiffNode(fiber, 0), fiber.serverProps = null, null !== rejectedCandidate && (rejectedCandidate = describeHydratableInstanceForDevWarnings(rejectedCandidate), fiber.serverTail.push(rejectedCandidate)));
        }
        function throwOnHydrationMismatch(fiber) {
          var fromText = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : false, diff = "", diffRoot = hydrationDiffRootDEV;
          null !== diffRoot && (hydrationDiffRootDEV = null, diff = describeDiff(diffRoot));
          queueHydrationError(
            createCapturedValueAtFiber(
              Error(
                "Hydration failed because the server rendered " + (fromText ? "text" : "HTML") + " didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\nhttps://react.dev/link/hydration-mismatch" + diff
              ),
              fiber
            )
          );
          throw HydrationMismatchException;
        }
        function prepareToHydrateHostInstance(fiber) {
          var didHydrate = fiber.stateNode;
          var type = fiber.type, props = fiber.memoizedProps;
          didHydrate[internalInstanceKey] = fiber;
          didHydrate[internalPropsKey] = props;
          validatePropertiesInDevelopment(type, props);
          switch (type) {
            case "dialog":
              listenToNonDelegatedEvent("cancel", didHydrate);
              listenToNonDelegatedEvent("close", didHydrate);
              break;
            case "iframe":
            case "object":
            case "embed":
              listenToNonDelegatedEvent("load", didHydrate);
              break;
            case "video":
            case "audio":
              for (type = 0; type < mediaEventTypes.length; type++)
                listenToNonDelegatedEvent(mediaEventTypes[type], didHydrate);
              break;
            case "source":
              listenToNonDelegatedEvent("error", didHydrate);
              break;
            case "img":
            case "image":
            case "link":
              listenToNonDelegatedEvent("error", didHydrate);
              listenToNonDelegatedEvent("load", didHydrate);
              break;
            case "details":
              listenToNonDelegatedEvent("toggle", didHydrate);
              break;
            case "input":
              checkControlledValueProps("input", props);
              listenToNonDelegatedEvent("invalid", didHydrate);
              validateInputProps(didHydrate, props);
              initInput(
                didHydrate,
                props.value,
                props.defaultValue,
                props.checked,
                props.defaultChecked,
                props.type,
                props.name,
                true
              );
              break;
            case "option":
              validateOptionProps(didHydrate, props);
              break;
            case "select":
              checkControlledValueProps("select", props);
              listenToNonDelegatedEvent("invalid", didHydrate);
              validateSelectProps(didHydrate, props);
              break;
            case "textarea":
              checkControlledValueProps("textarea", props), listenToNonDelegatedEvent("invalid", didHydrate), validateTextareaProps(didHydrate, props), initTextarea(
                didHydrate,
                props.value,
                props.defaultValue,
                props.children
              );
          }
          type = props.children;
          "string" !== typeof type && "number" !== typeof type && "bigint" !== typeof type || didHydrate.textContent === "" + type || true === props.suppressHydrationWarning || checkForUnmatchedText(didHydrate.textContent, type) ? (null != props.popover && (listenToNonDelegatedEvent("beforetoggle", didHydrate), listenToNonDelegatedEvent("toggle", didHydrate)), null != props.onScroll && listenToNonDelegatedEvent("scroll", didHydrate), null != props.onScrollEnd && listenToNonDelegatedEvent("scrollend", didHydrate), null != props.onClick && (didHydrate.onclick = noop$1), didHydrate = true) : didHydrate = false;
          didHydrate || throwOnHydrationMismatch(fiber, true);
        }
        function popToNextHostParent(fiber) {
          for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
            switch (hydrationParentFiber.tag) {
              case 5:
              case 31:
              case 13:
                rootOrSingletonContext = false;
                return;
              case 27:
              case 3:
                rootOrSingletonContext = true;
                return;
              default:
                hydrationParentFiber = hydrationParentFiber.return;
            }
        }
        function popHydrationState(fiber) {
          if (fiber !== hydrationParentFiber) return false;
          if (!isHydrating)
            return popToNextHostParent(fiber), isHydrating = true, false;
          var tag = fiber.tag, JSCompiler_temp;
          if (JSCompiler_temp = 3 !== tag && 27 !== tag) {
            if (JSCompiler_temp = 5 === tag)
              JSCompiler_temp = fiber.type, JSCompiler_temp = !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) || shouldSetTextContent(fiber.type, fiber.memoizedProps);
            JSCompiler_temp = !JSCompiler_temp;
          }
          if (JSCompiler_temp && nextHydratableInstance) {
            for (JSCompiler_temp = nextHydratableInstance; JSCompiler_temp; ) {
              var diffNode = buildHydrationDiffNode(fiber, 0), description = describeHydratableInstanceForDevWarnings(JSCompiler_temp);
              diffNode.serverTail.push(description);
              JSCompiler_temp = "Suspense" === description.type ? getNextHydratableInstanceAfterHydrationBoundary(JSCompiler_temp) : getNextHydratable(JSCompiler_temp.nextSibling);
            }
            throwOnHydrationMismatch(fiber);
          }
          popToNextHostParent(fiber);
          if (13 === tag) {
            fiber = fiber.memoizedState;
            fiber = null !== fiber ? fiber.dehydrated : null;
            if (!fiber)
              throw Error(
                "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
              );
            nextHydratableInstance = getNextHydratableInstanceAfterHydrationBoundary(fiber);
          } else if (31 === tag) {
            fiber = fiber.memoizedState;
            fiber = null !== fiber ? fiber.dehydrated : null;
            if (!fiber)
              throw Error(
                "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
              );
            nextHydratableInstance = getNextHydratableInstanceAfterHydrationBoundary(fiber);
          } else
            27 === tag ? (tag = nextHydratableInstance, isSingletonScope(fiber.type) ? (fiber = previousHydratableOnEnteringScopedSingleton, previousHydratableOnEnteringScopedSingleton = null, nextHydratableInstance = fiber) : nextHydratableInstance = tag) : nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null;
          return true;
        }
        function resetHydrationState() {
          nextHydratableInstance = hydrationParentFiber = null;
          didSuspendOrErrorDEV = isHydrating = false;
        }
        function upgradeHydrationErrorsToRecoverable() {
          var queuedErrors = hydrationErrors;
          null !== queuedErrors && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = queuedErrors : workInProgressRootRecoverableErrors.push.apply(
            workInProgressRootRecoverableErrors,
            queuedErrors
          ), hydrationErrors = null);
          return queuedErrors;
        }
        function queueHydrationError(error) {
          null === hydrationErrors ? hydrationErrors = [error] : hydrationErrors.push(error);
        }
        function emitPendingHydrationWarnings() {
          var diffRoot = hydrationDiffRootDEV;
          if (null !== diffRoot) {
            hydrationDiffRootDEV = null;
            for (var diff = describeDiff(diffRoot); 0 < diffRoot.children.length; )
              diffRoot = diffRoot.children[0];
            runWithFiberInDEV(diffRoot.fiber, function() {
              console.error(
                "A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\n%s%s",
                "https://react.dev/link/hydration-mismatch",
                diff
              );
            });
          }
        }
        function resetContextDependencies() {
          lastContextDependency = currentlyRenderingFiber$1 = null;
          isDisallowedContextReadInDEV = false;
        }
        function pushProvider(providerFiber, context, nextValue) {
          push(valueCursor, context._currentValue, providerFiber);
          context._currentValue = nextValue;
          push(rendererCursorDEV, context._currentRenderer, providerFiber);
          void 0 !== context._currentRenderer && null !== context._currentRenderer && context._currentRenderer !== rendererSigil && console.error(
            "Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."
          );
          context._currentRenderer = rendererSigil;
        }
        function popProvider(context, providerFiber) {
          context._currentValue = valueCursor.current;
          var currentRenderer = rendererCursorDEV.current;
          pop(rendererCursorDEV, providerFiber);
          context._currentRenderer = currentRenderer;
          pop(valueCursor, providerFiber);
        }
        function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
          for (; null !== parent; ) {
            var alternate = parent.alternate;
            (parent.childLanes & renderLanes2) !== renderLanes2 ? (parent.childLanes |= renderLanes2, null !== alternate && (alternate.childLanes |= renderLanes2)) : null !== alternate && (alternate.childLanes & renderLanes2) !== renderLanes2 && (alternate.childLanes |= renderLanes2);
            if (parent === propagationRoot) break;
            parent = parent.return;
          }
          parent !== propagationRoot && console.error(
            "Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue."
          );
        }
        function propagateContextChanges(workInProgress2, contexts, renderLanes2, forcePropagateEntireTree) {
          var fiber = workInProgress2.child;
          null !== fiber && (fiber.return = workInProgress2);
          for (; null !== fiber; ) {
            var list = fiber.dependencies;
            if (null !== list) {
              var nextFiber = fiber.child;
              list = list.firstContext;
              a: for (; null !== list; ) {
                var dependency = list;
                list = fiber;
                for (var i5 = 0; i5 < contexts.length; i5++)
                  if (dependency.context === contexts[i5]) {
                    list.lanes |= renderLanes2;
                    dependency = list.alternate;
                    null !== dependency && (dependency.lanes |= renderLanes2);
                    scheduleContextWorkOnParentPath(
                      list.return,
                      renderLanes2,
                      workInProgress2
                    );
                    forcePropagateEntireTree || (nextFiber = null);
                    break a;
                  }
                list = dependency.next;
              }
            } else if (18 === fiber.tag) {
              nextFiber = fiber.return;
              if (null === nextFiber)
                throw Error(
                  "We just came from a parent so we must have had a parent. This is a bug in React."
                );
              nextFiber.lanes |= renderLanes2;
              list = nextFiber.alternate;
              null !== list && (list.lanes |= renderLanes2);
              scheduleContextWorkOnParentPath(
                nextFiber,
                renderLanes2,
                workInProgress2
              );
              nextFiber = null;
            } else nextFiber = fiber.child;
            if (null !== nextFiber) nextFiber.return = fiber;
            else
              for (nextFiber = fiber; null !== nextFiber; ) {
                if (nextFiber === workInProgress2) {
                  nextFiber = null;
                  break;
                }
                fiber = nextFiber.sibling;
                if (null !== fiber) {
                  fiber.return = nextFiber.return;
                  nextFiber = fiber;
                  break;
                }
                nextFiber = nextFiber.return;
              }
            fiber = nextFiber;
          }
        }
        function propagateParentContextChanges(current2, workInProgress2, renderLanes2, forcePropagateEntireTree) {
          current2 = null;
          for (var parent = workInProgress2, isInsidePropagationBailout = false; null !== parent; ) {
            if (!isInsidePropagationBailout) {
              if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = true;
              else if (0 !== (parent.flags & 262144)) break;
            }
            if (10 === parent.tag) {
              var currentParent = parent.alternate;
              if (null === currentParent)
                throw Error("Should have a current fiber. This is a bug in React.");
              currentParent = currentParent.memoizedProps;
              if (null !== currentParent) {
                var context = parent.type;
                objectIs(parent.pendingProps.value, currentParent.value) || (null !== current2 ? current2.push(context) : current2 = [context]);
              }
            } else if (parent === hostTransitionProviderCursor.current) {
              currentParent = parent.alternate;
              if (null === currentParent)
                throw Error("Should have a current fiber. This is a bug in React.");
              currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current2 ? current2.push(HostTransitionContext) : current2 = [HostTransitionContext]);
            }
            parent = parent.return;
          }
          null !== current2 && propagateContextChanges(
            workInProgress2,
            current2,
            renderLanes2,
            forcePropagateEntireTree
          );
          workInProgress2.flags |= 262144;
        }
        function checkIfContextChanged(currentDependencies) {
          for (currentDependencies = currentDependencies.firstContext; null !== currentDependencies; ) {
            if (!objectIs(
              currentDependencies.context._currentValue,
              currentDependencies.memoizedValue
            ))
              return true;
            currentDependencies = currentDependencies.next;
          }
          return false;
        }
        function prepareToReadContext(workInProgress2) {
          currentlyRenderingFiber$1 = workInProgress2;
          lastContextDependency = null;
          workInProgress2 = workInProgress2.dependencies;
          null !== workInProgress2 && (workInProgress2.firstContext = null);
        }
        function readContext(context) {
          isDisallowedContextReadInDEV && console.error(
            "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
          );
          return readContextForConsumer(currentlyRenderingFiber$1, context);
        }
        function readContextDuringReconciliation(consumer, context) {
          null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
          return readContextForConsumer(consumer, context);
        }
        function readContextForConsumer(consumer, context) {
          var value = context._currentValue;
          context = { context, memoizedValue: value, next: null };
          if (null === lastContextDependency) {
            if (null === consumer)
              throw Error(
                "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
              );
            lastContextDependency = context;
            consumer.dependencies = {
              lanes: 0,
              firstContext: context,
              _debugThenableState: null
            };
            consumer.flags |= 524288;
          } else lastContextDependency = lastContextDependency.next = context;
          return value;
        }
        function createCache() {
          return {
            controller: new AbortControllerLocal(),
            data: /* @__PURE__ */ new Map(),
            refCount: 0
          };
        }
        function retainCache(cache) {
          cache.controller.signal.aborted && console.warn(
            "A cache instance was retained after it was already freed. This likely indicates a bug in React."
          );
          cache.refCount++;
        }
        function releaseCache(cache) {
          cache.refCount--;
          0 > cache.refCount && console.warn(
            "A cache instance was released after it was already freed. This likely indicates a bug in React."
          );
          0 === cache.refCount && scheduleCallback$2(NormalPriority, function() {
            cache.controller.abort();
          });
        }
        function startUpdateTimerByLane(lane, method, fiber) {
          if (0 !== (lane & 127))
            0 > blockingUpdateTime && (blockingUpdateTime = now(), blockingUpdateTask = createTask(method), blockingUpdateMethodName = method, null != fiber && (blockingUpdateComponentName = getComponentNameFromFiber(fiber)), (executionContext & (RenderContext | CommitContext)) !== NoContext && (componentEffectSpawnedUpdate = true, blockingUpdateType = SPAWNED_UPDATE), lane = resolveEventTimeStamp(), method = resolveEventType(), lane !== blockingEventRepeatTime || method !== blockingEventType ? blockingEventRepeatTime = -1.1 : null !== method && (blockingUpdateType = SPAWNED_UPDATE), blockingEventTime = lane, blockingEventType = method);
          else if (0 !== (lane & 4194048) && 0 > transitionUpdateTime && (transitionUpdateTime = now(), transitionUpdateTask = createTask(method), transitionUpdateMethodName = method, null != fiber && (transitionUpdateComponentName = getComponentNameFromFiber(fiber)), 0 > transitionStartTime)) {
            lane = resolveEventTimeStamp();
            method = resolveEventType();
            if (lane !== transitionEventRepeatTime || method !== transitionEventType)
              transitionEventRepeatTime = -1.1;
            transitionEventTime = lane;
            transitionEventType = method;
          }
        }
        function startHostActionTimer(fiber) {
          if (0 > blockingUpdateTime) {
            blockingUpdateTime = now();
            blockingUpdateTask = null != fiber._debugTask ? fiber._debugTask : null;
            (executionContext & (RenderContext | CommitContext)) !== NoContext && (blockingUpdateType = SPAWNED_UPDATE);
            var newEventTime = resolveEventTimeStamp(), newEventType = resolveEventType();
            newEventTime !== blockingEventRepeatTime || newEventType !== blockingEventType ? blockingEventRepeatTime = -1.1 : null !== newEventType && (blockingUpdateType = SPAWNED_UPDATE);
            blockingEventTime = newEventTime;
            blockingEventType = newEventType;
          }
          if (0 > transitionUpdateTime && (transitionUpdateTime = now(), transitionUpdateTask = null != fiber._debugTask ? fiber._debugTask : null, 0 > transitionStartTime)) {
            fiber = resolveEventTimeStamp();
            newEventTime = resolveEventType();
            if (fiber !== transitionEventRepeatTime || newEventTime !== transitionEventType)
              transitionEventRepeatTime = -1.1;
            transitionEventTime = fiber;
            transitionEventType = newEventTime;
          }
        }
        function pushNestedEffectDurations() {
          var prevEffectDuration = profilerEffectDuration;
          profilerEffectDuration = 0;
          return prevEffectDuration;
        }
        function popNestedEffectDurations(prevEffectDuration) {
          var elapsedTime = profilerEffectDuration;
          profilerEffectDuration = prevEffectDuration;
          return elapsedTime;
        }
        function bubbleNestedEffectDurations(prevEffectDuration) {
          var elapsedTime = profilerEffectDuration;
          profilerEffectDuration += prevEffectDuration;
          return elapsedTime;
        }
        function resetComponentEffectTimers() {
          componentEffectEndTime = componentEffectStartTime = -1.1;
        }
        function pushComponentEffectStart() {
          var prevEffectStart = componentEffectStartTime;
          componentEffectStartTime = -1.1;
          return prevEffectStart;
        }
        function popComponentEffectStart(prevEffectStart) {
          0 <= prevEffectStart && (componentEffectStartTime = prevEffectStart);
        }
        function pushComponentEffectDuration() {
          var prevEffectDuration = componentEffectDuration;
          componentEffectDuration = -0;
          return prevEffectDuration;
        }
        function popComponentEffectDuration(prevEffectDuration) {
          0 <= prevEffectDuration && (componentEffectDuration = prevEffectDuration);
        }
        function pushComponentEffectErrors() {
          var prevErrors = componentEffectErrors;
          componentEffectErrors = null;
          return prevErrors;
        }
        function pushComponentEffectDidSpawnUpdate() {
          var prev = componentEffectSpawnedUpdate;
          componentEffectSpawnedUpdate = false;
          return prev;
        }
        function startProfilerTimer(fiber) {
          profilerStartTime = now();
          0 > fiber.actualStartTime && (fiber.actualStartTime = profilerStartTime);
        }
        function stopProfilerTimerIfRunningAndRecordDuration(fiber) {
          if (0 <= profilerStartTime) {
            var elapsedTime = now() - profilerStartTime;
            fiber.actualDuration += elapsedTime;
            fiber.selfBaseDuration = elapsedTime;
            profilerStartTime = -1;
          }
        }
        function stopProfilerTimerIfRunningAndRecordIncompleteDuration(fiber) {
          if (0 <= profilerStartTime) {
            var elapsedTime = now() - profilerStartTime;
            fiber.actualDuration += elapsedTime;
            profilerStartTime = -1;
          }
        }
        function recordEffectDuration() {
          if (0 <= profilerStartTime) {
            var endTime = now(), elapsedTime = endTime - profilerStartTime;
            profilerStartTime = -1;
            profilerEffectDuration += elapsedTime;
            componentEffectDuration += elapsedTime;
            componentEffectEndTime = endTime;
          }
        }
        function recordEffectError(errorInfo) {
          null === componentEffectErrors && (componentEffectErrors = []);
          componentEffectErrors.push(errorInfo);
          null === commitErrors && (commitErrors = []);
          commitErrors.push(errorInfo);
        }
        function startEffectTimer() {
          profilerStartTime = now();
          0 > componentEffectStartTime && (componentEffectStartTime = profilerStartTime);
        }
        function transferActualDuration(fiber) {
          for (var child = fiber.child; child; )
            fiber.actualDuration += child.actualDuration, child = child.sibling;
        }
        function entangleAsyncAction(transition, thenable) {
          if (null === currentEntangledListeners) {
            var entangledListeners = currentEntangledListeners = [];
            currentEntangledPendingCount = 0;
            currentEntangledLane = requestTransitionLane();
            currentEntangledActionThenable = {
              status: "pending",
              value: void 0,
              then: function(resolve) {
                entangledListeners.push(resolve);
              }
            };
          }
          currentEntangledPendingCount++;
          thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
          return thenable;
        }
        function pingEngtangledActionScope() {
          if (0 === --currentEntangledPendingCount && (-1 < transitionUpdateTime || (transitionStartTime = -1.1), null !== currentEntangledListeners)) {
            null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = "fulfilled");
            var listeners = currentEntangledListeners;
            currentEntangledListeners = null;
            currentEntangledLane = 0;
            currentEntangledActionThenable = null;
            for (var i5 = 0; i5 < listeners.length; i5++) (0, listeners[i5])();
          }
        }
        function chainThenableValue(thenable, result) {
          var listeners = [], thenableWithOverride = {
            status: "pending",
            value: null,
            reason: null,
            then: function(resolve) {
              listeners.push(resolve);
            }
          };
          thenable.then(
            function() {
              thenableWithOverride.status = "fulfilled";
              thenableWithOverride.value = result;
              for (var i5 = 0; i5 < listeners.length; i5++) (0, listeners[i5])(result);
            },
            function(error) {
              thenableWithOverride.status = "rejected";
              thenableWithOverride.reason = error;
              for (error = 0; error < listeners.length; error++)
                (0, listeners[error])(void 0);
            }
          );
          return thenableWithOverride;
        }
        function peekCacheFromPool() {
          var cacheResumedFromPreviousRender = resumedCache.current;
          return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
        }
        function pushTransition(offscreenWorkInProgress, prevCachePool) {
          null === prevCachePool ? push(resumedCache, resumedCache.current, offscreenWorkInProgress) : push(resumedCache, prevCachePool.pool, offscreenWorkInProgress);
        }
        function getSuspendedCache() {
          var cacheFromPool = peekCacheFromPool();
          return null === cacheFromPool ? null : { parent: CacheContext._currentValue, pool: cacheFromPool };
        }
        function createThenableState() {
          return { didWarnAboutUncachedPromise: false, thenables: [] };
        }
        function isThenableResolved(thenable) {
          thenable = thenable.status;
          return "fulfilled" === thenable || "rejected" === thenable;
        }
        function trackUsedThenable(thenableState2, thenable, index) {
          null !== ReactSharedInternals.actQueue && (ReactSharedInternals.didUsePromise = true);
          var trackedThenables = thenableState2.thenables;
          index = trackedThenables[index];
          void 0 === index ? trackedThenables.push(thenable) : index !== thenable && (thenableState2.didWarnAboutUncachedPromise || (thenableState2.didWarnAboutUncachedPromise = true, console.error(
            "A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework."
          )), thenable.then(noop$1, noop$1), thenable = index);
          if (void 0 === thenable._debugInfo) {
            thenableState2 = performance.now();
            trackedThenables = thenable.displayName;
            var ioInfo = {
              name: "string" === typeof trackedThenables ? trackedThenables : "Promise",
              start: thenableState2,
              end: thenableState2,
              value: thenable
            };
            thenable._debugInfo = [{ awaited: ioInfo }];
            "fulfilled" !== thenable.status && "rejected" !== thenable.status && (thenableState2 = function() {
              ioInfo.end = performance.now();
            }, thenable.then(thenableState2, thenableState2));
          }
          switch (thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
            default:
              if ("string" === typeof thenable.status)
                thenable.then(noop$1, noop$1);
              else {
                thenableState2 = workInProgressRoot;
                if (null !== thenableState2 && 100 < thenableState2.shellSuspendCounter)
                  throw Error(
                    "An unknown Component is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
                  );
                thenableState2 = thenable;
                thenableState2.status = "pending";
                thenableState2.then(
                  function(fulfilledValue) {
                    if ("pending" === thenable.status) {
                      var fulfilledThenable = thenable;
                      fulfilledThenable.status = "fulfilled";
                      fulfilledThenable.value = fulfilledValue;
                    }
                  },
                  function(error) {
                    if ("pending" === thenable.status) {
                      var rejectedThenable = thenable;
                      rejectedThenable.status = "rejected";
                      rejectedThenable.reason = error;
                    }
                  }
                );
              }
              switch (thenable.status) {
                case "fulfilled":
                  return thenable.value;
                case "rejected":
                  throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
              }
              suspendedThenable = thenable;
              needsToResetSuspendedThenableDEV = true;
              throw SuspenseException;
          }
        }
        function resolveLazy(lazyType) {
          try {
            return callLazyInitInDEV(lazyType);
          } catch (x5) {
            if (null !== x5 && "object" === typeof x5 && "function" === typeof x5.then)
              throw suspendedThenable = x5, needsToResetSuspendedThenableDEV = true, SuspenseException;
            throw x5;
          }
        }
        function getSuspendedThenable() {
          if (null === suspendedThenable)
            throw Error(
              "Expected a suspended thenable. This is a bug in React. Please file an issue."
            );
          var thenable = suspendedThenable;
          suspendedThenable = null;
          needsToResetSuspendedThenableDEV = false;
          return thenable;
        }
        function checkIfUseWrappedInAsyncCatch(rejectedReason) {
          if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException)
            throw Error(
              "Hooks are not supported inside an async component. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
            );
        }
        function pushDebugInfo(debugInfo) {
          var previousDebugInfo = currentDebugInfo;
          null != debugInfo && (currentDebugInfo = null === previousDebugInfo ? debugInfo : previousDebugInfo.concat(debugInfo));
          return previousDebugInfo;
        }
        function getCurrentDebugTask() {
          var debugInfo = currentDebugInfo;
          if (null != debugInfo) {
            for (var i5 = debugInfo.length - 1; 0 <= i5; i5--)
              if (null != debugInfo[i5].name) {
                var debugTask = debugInfo[i5].debugTask;
                if (null != debugTask) return debugTask;
              }
          }
          return null;
        }
        function validateFragmentProps(element, fiber, returnFiber) {
          for (var keys = Object.keys(element.props), i5 = 0; i5 < keys.length; i5++) {
            var key = keys[i5];
            if ("children" !== key && "key" !== key) {
              null === fiber && (fiber = createFiberFromElement(element, returnFiber.mode, 0), fiber._debugInfo = currentDebugInfo, fiber.return = returnFiber);
              runWithFiberInDEV(
                fiber,
                function(erroredKey) {
                  console.error(
                    "Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.",
                    erroredKey
                  );
                },
                key
              );
              break;
            }
          }
        }
        function unwrapThenable(thenable) {
          var index = thenableIndexCounter$1;
          thenableIndexCounter$1 += 1;
          null === thenableState$1 && (thenableState$1 = createThenableState());
          return trackUsedThenable(thenableState$1, thenable, index);
        }
        function coerceRef(workInProgress2, element) {
          element = element.props.ref;
          workInProgress2.ref = void 0 !== element ? element : null;
        }
        function throwOnInvalidObjectTypeImpl(returnFiber, newChild) {
          if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
            throw Error(
              'A React Element from an older version of React was rendered. This is not supported. It can happen if:\n- Multiple copies of the "react" package is used.\n- A library pre-bundled an old copy of "react" or "react/jsx-runtime".\n- A compiler tries to "inline" JSX instead of using the runtime.'
            );
          returnFiber = Object.prototype.toString.call(newChild);
          throw Error(
            "Objects are not valid as a React child (found: " + ("[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber) + "). If you meant to render a collection of children, use an array instead."
          );
        }
        function throwOnInvalidObjectType(returnFiber, newChild) {
          var debugTask = getCurrentDebugTask();
          null !== debugTask ? debugTask.run(
            throwOnInvalidObjectTypeImpl.bind(null, returnFiber, newChild)
          ) : throwOnInvalidObjectTypeImpl(returnFiber, newChild);
        }
        function warnOnFunctionTypeImpl(returnFiber, invalidChild) {
          var parentName = getComponentNameFromFiber(returnFiber) || "Component";
          ownerHasFunctionTypeWarning[parentName] || (ownerHasFunctionTypeWarning[parentName] = true, invalidChild = invalidChild.displayName || invalidChild.name || "Component", 3 === returnFiber.tag ? console.error(
            "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  root.render(%s)",
            invalidChild,
            invalidChild,
            invalidChild
          ) : console.error(
            "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  <%s>{%s}</%s>",
            invalidChild,
            invalidChild,
            parentName,
            invalidChild,
            parentName
          ));
        }
        function warnOnFunctionType(returnFiber, invalidChild) {
          var debugTask = getCurrentDebugTask();
          null !== debugTask ? debugTask.run(
            warnOnFunctionTypeImpl.bind(null, returnFiber, invalidChild)
          ) : warnOnFunctionTypeImpl(returnFiber, invalidChild);
        }
        function warnOnSymbolTypeImpl(returnFiber, invalidChild) {
          var parentName = getComponentNameFromFiber(returnFiber) || "Component";
          ownerHasSymbolTypeWarning[parentName] || (ownerHasSymbolTypeWarning[parentName] = true, invalidChild = String(invalidChild), 3 === returnFiber.tag ? console.error(
            "Symbols are not valid as a React child.\n  root.render(%s)",
            invalidChild
          ) : console.error(
            "Symbols are not valid as a React child.\n  <%s>%s</%s>",
            parentName,
            invalidChild,
            parentName
          ));
        }
        function warnOnSymbolType(returnFiber, invalidChild) {
          var debugTask = getCurrentDebugTask();
          null !== debugTask ? debugTask.run(
            warnOnSymbolTypeImpl.bind(null, returnFiber, invalidChild)
          ) : warnOnSymbolTypeImpl(returnFiber, invalidChild);
        }
        function createChildReconciler(shouldTrackSideEffects) {
          function deleteChild(returnFiber, childToDelete) {
            if (shouldTrackSideEffects) {
              var deletions = returnFiber.deletions;
              null === deletions ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
            }
          }
          function deleteRemainingChildren(returnFiber, currentFirstChild) {
            if (!shouldTrackSideEffects) return null;
            for (; null !== currentFirstChild; )
              deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
            return null;
          }
          function mapRemainingChildren(currentFirstChild) {
            for (var existingChildren = /* @__PURE__ */ new Map(); null !== currentFirstChild; )
              null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
            return existingChildren;
          }
          function useFiber(fiber, pendingProps) {
            fiber = createWorkInProgress(fiber, pendingProps);
            fiber.index = 0;
            fiber.sibling = null;
            return fiber;
          }
          function placeChild(newFiber, lastPlacedIndex, newIndex) {
            newFiber.index = newIndex;
            if (!shouldTrackSideEffects)
              return newFiber.flags |= 1048576, lastPlacedIndex;
            newIndex = newFiber.alternate;
            if (null !== newIndex)
              return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 67108866, lastPlacedIndex) : newIndex;
            newFiber.flags |= 67108866;
            return lastPlacedIndex;
          }
          function placeSingleChild(newFiber) {
            shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 67108866);
            return newFiber;
          }
          function updateTextNode(returnFiber, current2, textContent, lanes) {
            if (null === current2 || 6 !== current2.tag)
              return current2 = createFiberFromText(
                textContent,
                returnFiber.mode,
                lanes
              ), current2.return = returnFiber, current2._debugOwner = returnFiber, current2._debugTask = returnFiber._debugTask, current2._debugInfo = currentDebugInfo, current2;
            current2 = useFiber(current2, textContent);
            current2.return = returnFiber;
            current2._debugInfo = currentDebugInfo;
            return current2;
          }
          function updateElement(returnFiber, current2, element, lanes) {
            var elementType = element.type;
            if (elementType === REACT_FRAGMENT_TYPE)
              return current2 = updateFragment(
                returnFiber,
                current2,
                element.props.children,
                lanes,
                element.key
              ), validateFragmentProps(element, current2, returnFiber), current2;
            if (null !== current2 && (current2.elementType === elementType || isCompatibleFamilyForHotReloading(current2, element) || "object" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current2.type))
              return current2 = useFiber(current2, element.props), coerceRef(current2, element), current2.return = returnFiber, current2._debugOwner = element._owner, current2._debugInfo = currentDebugInfo, current2;
            current2 = createFiberFromElement(element, returnFiber.mode, lanes);
            coerceRef(current2, element);
            current2.return = returnFiber;
            current2._debugInfo = currentDebugInfo;
            return current2;
          }
          function updatePortal(returnFiber, current2, portal, lanes) {
            if (null === current2 || 4 !== current2.tag || current2.stateNode.containerInfo !== portal.containerInfo || current2.stateNode.implementation !== portal.implementation)
              return current2 = createFiberFromPortal(portal, returnFiber.mode, lanes), current2.return = returnFiber, current2._debugInfo = currentDebugInfo, current2;
            current2 = useFiber(current2, portal.children || []);
            current2.return = returnFiber;
            current2._debugInfo = currentDebugInfo;
            return current2;
          }
          function updateFragment(returnFiber, current2, fragment, lanes, key) {
            if (null === current2 || 7 !== current2.tag)
              return current2 = createFiberFromFragment(
                fragment,
                returnFiber.mode,
                lanes,
                key
              ), current2.return = returnFiber, current2._debugOwner = returnFiber, current2._debugTask = returnFiber._debugTask, current2._debugInfo = currentDebugInfo, current2;
            current2 = useFiber(current2, fragment);
            current2.return = returnFiber;
            current2._debugInfo = currentDebugInfo;
            return current2;
          }
          function createChild(returnFiber, newChild, lanes) {
            if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
              return newChild = createFiberFromText(
                "" + newChild,
                returnFiber.mode,
                lanes
              ), newChild.return = returnFiber, newChild._debugOwner = returnFiber, newChild._debugTask = returnFiber._debugTask, newChild._debugInfo = currentDebugInfo, newChild;
            if ("object" === typeof newChild && null !== newChild) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  return lanes = createFiberFromElement(
                    newChild,
                    returnFiber.mode,
                    lanes
                  ), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;
                case REACT_PORTAL_TYPE:
                  return newChild = createFiberFromPortal(
                    newChild,
                    returnFiber.mode,
                    lanes
                  ), newChild.return = returnFiber, newChild._debugInfo = currentDebugInfo, newChild;
                case REACT_LAZY_TYPE:
                  var _prevDebugInfo = pushDebugInfo(newChild._debugInfo);
                  newChild = resolveLazy(newChild);
                  returnFiber = createChild(returnFiber, newChild, lanes);
                  currentDebugInfo = _prevDebugInfo;
                  return returnFiber;
              }
              if (isArrayImpl(newChild) || getIteratorFn(newChild))
                return lanes = createFiberFromFragment(
                  newChild,
                  returnFiber.mode,
                  lanes,
                  null
                ), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;
              if ("function" === typeof newChild.then)
                return _prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = createChild(
                  returnFiber,
                  unwrapThenable(newChild),
                  lanes
                ), currentDebugInfo = _prevDebugInfo, returnFiber;
              if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                return createChild(
                  returnFiber,
                  readContextDuringReconciliation(returnFiber, newChild),
                  lanes
                );
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
            "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
            return null;
          }
          function updateSlot(returnFiber, oldFiber, newChild, lanes) {
            var key = null !== oldFiber ? oldFiber.key : null;
            if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
              return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
            if ("object" === typeof newChild && null !== newChild) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  return newChild.key === key ? (key = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(
                    returnFiber,
                    oldFiber,
                    newChild,
                    lanes
                  ), currentDebugInfo = key, returnFiber) : null;
                case REACT_PORTAL_TYPE:
                  return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
                case REACT_LAZY_TYPE:
                  return key = pushDebugInfo(newChild._debugInfo), newChild = resolveLazy(newChild), returnFiber = updateSlot(
                    returnFiber,
                    oldFiber,
                    newChild,
                    lanes
                  ), currentDebugInfo = key, returnFiber;
              }
              if (isArrayImpl(newChild) || getIteratorFn(newChild)) {
                if (null !== key) return null;
                key = pushDebugInfo(newChild._debugInfo);
                returnFiber = updateFragment(
                  returnFiber,
                  oldFiber,
                  newChild,
                  lanes,
                  null
                );
                currentDebugInfo = key;
                return returnFiber;
              }
              if ("function" === typeof newChild.then)
                return key = pushDebugInfo(newChild._debugInfo), returnFiber = updateSlot(
                  returnFiber,
                  oldFiber,
                  unwrapThenable(newChild),
                  lanes
                ), currentDebugInfo = key, returnFiber;
              if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                return updateSlot(
                  returnFiber,
                  oldFiber,
                  readContextDuringReconciliation(returnFiber, newChild),
                  lanes
                );
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
            "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
            return null;
          }
          function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
            if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
              return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
            if ("object" === typeof newChild && null !== newChild) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  return newIdx = existingChildren.get(
                    null === newChild.key ? newIdx : newChild.key
                  ) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(
                    returnFiber,
                    newIdx,
                    newChild,
                    lanes
                  ), currentDebugInfo = existingChildren, returnFiber;
                case REACT_PORTAL_TYPE:
                  return existingChildren = existingChildren.get(
                    null === newChild.key ? newIdx : newChild.key
                  ) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
                case REACT_LAZY_TYPE:
                  var _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo);
                  newChild = resolveLazy(newChild);
                  returnFiber = updateFromMap(
                    existingChildren,
                    returnFiber,
                    newIdx,
                    newChild,
                    lanes
                  );
                  currentDebugInfo = _prevDebugInfo7;
                  return returnFiber;
              }
              if (isArrayImpl(newChild) || getIteratorFn(newChild))
                return newIdx = existingChildren.get(newIdx) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateFragment(
                  returnFiber,
                  newIdx,
                  newChild,
                  lanes,
                  null
                ), currentDebugInfo = existingChildren, returnFiber;
              if ("function" === typeof newChild.then)
                return _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo), returnFiber = updateFromMap(
                  existingChildren,
                  returnFiber,
                  newIdx,
                  unwrapThenable(newChild),
                  lanes
                ), currentDebugInfo = _prevDebugInfo7, returnFiber;
              if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                return updateFromMap(
                  existingChildren,
                  returnFiber,
                  newIdx,
                  readContextDuringReconciliation(returnFiber, newChild),
                  lanes
                );
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
            "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
            return null;
          }
          function warnOnInvalidKey(returnFiber, workInProgress2, child, knownKeys) {
            if ("object" !== typeof child || null === child) return knownKeys;
            switch (child.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_PORTAL_TYPE:
                warnForMissingKey(returnFiber, workInProgress2, child);
                var key = child.key;
                if ("string" !== typeof key) break;
                if (null === knownKeys) {
                  knownKeys = /* @__PURE__ */ new Set();
                  knownKeys.add(key);
                  break;
                }
                if (!knownKeys.has(key)) {
                  knownKeys.add(key);
                  break;
                }
                runWithFiberInDEV(workInProgress2, function() {
                  console.error(
                    "Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.",
                    key
                  );
                });
                break;
              case REACT_LAZY_TYPE:
                child = resolveLazy(child), warnOnInvalidKey(returnFiber, workInProgress2, child, knownKeys);
            }
            return knownKeys;
          }
          function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
            for (var knownKeys = null, resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
              oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
              var newFiber = updateSlot(
                returnFiber,
                oldFiber,
                newChildren[newIdx],
                lanes
              );
              if (null === newFiber) {
                null === oldFiber && (oldFiber = nextOldFiber);
                break;
              }
              knownKeys = warnOnInvalidKey(
                returnFiber,
                newFiber,
                newChildren[newIdx],
                knownKeys
              );
              shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
              currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
              null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
              previousNewFiber = newFiber;
              oldFiber = nextOldFiber;
            }
            if (newIdx === newChildren.length)
              return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
            if (null === oldFiber) {
              for (; newIdx < newChildren.length; newIdx++)
                oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(
                  returnFiber,
                  oldFiber,
                  newChildren[newIdx],
                  knownKeys
                ), currentFirstChild = placeChild(
                  oldFiber,
                  currentFirstChild,
                  newIdx
                ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
              isHydrating && pushTreeFork(returnFiber, newIdx);
              return resultingFirstChild;
            }
            for (oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)
              nextOldFiber = updateFromMap(
                oldFiber,
                returnFiber,
                newIdx,
                newChildren[newIdx],
                lanes
              ), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(
                returnFiber,
                nextOldFiber,
                newChildren[newIdx],
                knownKeys
              ), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
                null === nextOldFiber.key ? newIdx : nextOldFiber.key
              ), currentFirstChild = placeChild(
                nextOldFiber,
                currentFirstChild,
                newIdx
              ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
            shouldTrackSideEffects && oldFiber.forEach(function(child) {
              return deleteChild(returnFiber, child);
            });
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
            if (null == newChildren)
              throw Error("An iterable object provided no iterator.");
            for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, knownKeys = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()) {
              oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
              var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
              if (null === newFiber) {
                null === oldFiber && (oldFiber = nextOldFiber);
                break;
              }
              knownKeys = warnOnInvalidKey(
                returnFiber,
                newFiber,
                step.value,
                knownKeys
              );
              shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
              currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
              null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
              previousNewFiber = newFiber;
              oldFiber = nextOldFiber;
            }
            if (step.done)
              return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
            if (null === oldFiber) {
              for (; !step.done; newIdx++, step = newChildren.next())
                oldFiber = createChild(returnFiber, step.value, lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(
                  returnFiber,
                  oldFiber,
                  step.value,
                  knownKeys
                ), currentFirstChild = placeChild(
                  oldFiber,
                  currentFirstChild,
                  newIdx
                ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
              isHydrating && pushTreeFork(returnFiber, newIdx);
              return resultingFirstChild;
            }
            for (oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next())
              nextOldFiber = updateFromMap(
                oldFiber,
                returnFiber,
                newIdx,
                step.value,
                lanes
              ), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(
                returnFiber,
                nextOldFiber,
                step.value,
                knownKeys
              ), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
                null === nextOldFiber.key ? newIdx : nextOldFiber.key
              ), currentFirstChild = placeChild(
                nextOldFiber,
                currentFirstChild,
                newIdx
              ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
            shouldTrackSideEffects && oldFiber.forEach(function(child) {
              return deleteChild(returnFiber, child);
            });
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
            "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (validateFragmentProps(newChild, null, returnFiber), newChild = newChild.props.children);
            if ("object" === typeof newChild && null !== newChild) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  var prevDebugInfo = pushDebugInfo(newChild._debugInfo);
                  a: {
                    for (var key = newChild.key; null !== currentFirstChild; ) {
                      if (currentFirstChild.key === key) {
                        key = newChild.type;
                        if (key === REACT_FRAGMENT_TYPE) {
                          if (7 === currentFirstChild.tag) {
                            deleteRemainingChildren(
                              returnFiber,
                              currentFirstChild.sibling
                            );
                            lanes = useFiber(
                              currentFirstChild,
                              newChild.props.children
                            );
                            lanes.return = returnFiber;
                            lanes._debugOwner = newChild._owner;
                            lanes._debugInfo = currentDebugInfo;
                            validateFragmentProps(newChild, lanes, returnFiber);
                            returnFiber = lanes;
                            break a;
                          }
                        } else if (currentFirstChild.elementType === key || isCompatibleFamilyForHotReloading(
                          currentFirstChild,
                          newChild
                        ) || "object" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && resolveLazy(key) === currentFirstChild.type) {
                          deleteRemainingChildren(
                            returnFiber,
                            currentFirstChild.sibling
                          );
                          lanes = useFiber(currentFirstChild, newChild.props);
                          coerceRef(lanes, newChild);
                          lanes.return = returnFiber;
                          lanes._debugOwner = newChild._owner;
                          lanes._debugInfo = currentDebugInfo;
                          returnFiber = lanes;
                          break a;
                        }
                        deleteRemainingChildren(returnFiber, currentFirstChild);
                        break;
                      } else deleteChild(returnFiber, currentFirstChild);
                      currentFirstChild = currentFirstChild.sibling;
                    }
                    newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(
                      newChild.props.children,
                      returnFiber.mode,
                      lanes,
                      newChild.key
                    ), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, lanes._debugInfo = currentDebugInfo, validateFragmentProps(newChild, lanes, returnFiber), returnFiber = lanes) : (lanes = createFiberFromElement(
                      newChild,
                      returnFiber.mode,
                      lanes
                    ), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes._debugInfo = currentDebugInfo, returnFiber = lanes);
                  }
                  returnFiber = placeSingleChild(returnFiber);
                  currentDebugInfo = prevDebugInfo;
                  return returnFiber;
                case REACT_PORTAL_TYPE:
                  a: {
                    prevDebugInfo = newChild;
                    for (newChild = prevDebugInfo.key; null !== currentFirstChild; ) {
                      if (currentFirstChild.key === newChild)
                        if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === prevDebugInfo.containerInfo && currentFirstChild.stateNode.implementation === prevDebugInfo.implementation) {
                          deleteRemainingChildren(
                            returnFiber,
                            currentFirstChild.sibling
                          );
                          lanes = useFiber(
                            currentFirstChild,
                            prevDebugInfo.children || []
                          );
                          lanes.return = returnFiber;
                          returnFiber = lanes;
                          break a;
                        } else {
                          deleteRemainingChildren(returnFiber, currentFirstChild);
                          break;
                        }
                      else deleteChild(returnFiber, currentFirstChild);
                      currentFirstChild = currentFirstChild.sibling;
                    }
                    lanes = createFiberFromPortal(
                      prevDebugInfo,
                      returnFiber.mode,
                      lanes
                    );
                    lanes.return = returnFiber;
                    returnFiber = lanes;
                  }
                  return placeSingleChild(returnFiber);
                case REACT_LAZY_TYPE:
                  return prevDebugInfo = pushDebugInfo(newChild._debugInfo), newChild = resolveLazy(newChild), returnFiber = reconcileChildFibersImpl(
                    returnFiber,
                    currentFirstChild,
                    newChild,
                    lanes
                  ), currentDebugInfo = prevDebugInfo, returnFiber;
              }
              if (isArrayImpl(newChild))
                return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildrenArray(
                  returnFiber,
                  currentFirstChild,
                  newChild,
                  lanes
                ), currentDebugInfo = prevDebugInfo, returnFiber;
              if (getIteratorFn(newChild)) {
                prevDebugInfo = pushDebugInfo(newChild._debugInfo);
                key = getIteratorFn(newChild);
                if ("function" !== typeof key)
                  throw Error(
                    "An object is not an iterable. This error is likely caused by a bug in React. Please file an issue."
                  );
                var newChildren = key.call(newChild);
                if (newChildren === newChild) {
                  if (0 !== returnFiber.tag || "[object GeneratorFunction]" !== Object.prototype.toString.call(returnFiber.type) || "[object Generator]" !== Object.prototype.toString.call(newChildren))
                    didWarnAboutGenerators || console.error(
                      "Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."
                    ), didWarnAboutGenerators = true;
                } else
                  newChild.entries !== key || didWarnAboutMaps || (console.error(
                    "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
                  ), didWarnAboutMaps = true);
                returnFiber = reconcileChildrenIterator(
                  returnFiber,
                  currentFirstChild,
                  newChildren,
                  lanes
                );
                currentDebugInfo = prevDebugInfo;
                return returnFiber;
              }
              if ("function" === typeof newChild.then)
                return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildFibersImpl(
                  returnFiber,
                  currentFirstChild,
                  unwrapThenable(newChild),
                  lanes
                ), currentDebugInfo = prevDebugInfo, returnFiber;
              if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                return reconcileChildFibersImpl(
                  returnFiber,
                  currentFirstChild,
                  readContextDuringReconciliation(returnFiber, newChild),
                  lanes
                );
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
              return prevDebugInfo = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(
                returnFiber,
                currentFirstChild.sibling
              ), lanes = useFiber(currentFirstChild, prevDebugInfo), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(
                prevDebugInfo,
                returnFiber.mode,
                lanes
              ), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, lanes._debugInfo = currentDebugInfo, returnFiber = lanes), placeSingleChild(returnFiber);
            "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
            "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
            return deleteRemainingChildren(returnFiber, currentFirstChild);
          }
          return function(returnFiber, currentFirstChild, newChild, lanes) {
            var prevDebugInfo = currentDebugInfo;
            currentDebugInfo = null;
            try {
              thenableIndexCounter$1 = 0;
              var firstChildFiber = reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                newChild,
                lanes
              );
              thenableState$1 = null;
              return firstChildFiber;
            } catch (x5) {
              if (x5 === SuspenseException || x5 === SuspenseActionException) throw x5;
              var fiber = createFiber(29, x5, null, returnFiber.mode);
              fiber.lanes = lanes;
              fiber.return = returnFiber;
              var debugInfo = fiber._debugInfo = currentDebugInfo;
              fiber._debugOwner = returnFiber._debugOwner;
              fiber._debugTask = returnFiber._debugTask;
              if (null != debugInfo) {
                for (var i5 = debugInfo.length - 1; 0 <= i5; i5--)
                  if ("string" === typeof debugInfo[i5].stack) {
                    fiber._debugOwner = debugInfo[i5];
                    fiber._debugTask = debugInfo[i5].debugTask;
                    break;
                  }
              }
              return fiber;
            } finally {
              currentDebugInfo = prevDebugInfo;
            }
          };
        }
        function validateSuspenseListNestedChild(childSlot, index) {
          var isAnArray = isArrayImpl(childSlot);
          childSlot = !isAnArray && "function" === typeof getIteratorFn(childSlot);
          return isAnArray || childSlot ? (isAnArray = isAnArray ? "array" : "iterable", console.error(
            "A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>",
            isAnArray,
            index,
            isAnArray
          ), false) : true;
        }
        function initializeUpdateQueue(fiber) {
          fiber.updateQueue = {
            baseState: fiber.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: { pending: null, lanes: 0, hiddenCallbacks: null },
            callbacks: null
          };
        }
        function cloneUpdateQueue(current2, workInProgress2) {
          current2 = current2.updateQueue;
          workInProgress2.updateQueue === current2 && (workInProgress2.updateQueue = {
            baseState: current2.baseState,
            firstBaseUpdate: current2.firstBaseUpdate,
            lastBaseUpdate: current2.lastBaseUpdate,
            shared: current2.shared,
            callbacks: null
          });
        }
        function createUpdate(lane) {
          return {
            lane,
            tag: UpdateState,
            payload: null,
            callback: null,
            next: null
          };
        }
        function enqueueUpdate(fiber, update, lane) {
          var updateQueue = fiber.updateQueue;
          if (null === updateQueue) return null;
          updateQueue = updateQueue.shared;
          if (currentlyProcessingQueue === updateQueue && !didWarnUpdateInsideUpdate) {
            var componentName2 = getComponentNameFromFiber(fiber);
            console.error(
              "An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.\n\nPlease update the following component: %s",
              componentName2
            );
            didWarnUpdateInsideUpdate = true;
          }
          if ((executionContext & RenderContext) !== NoContext)
            return componentName2 = updateQueue.pending, null === componentName2 ? update.next = update : (update.next = componentName2.next, componentName2.next = update), updateQueue.pending = update, update = getRootForUpdatedFiber(fiber), markUpdateLaneFromFiberToRoot(fiber, null, lane), update;
          enqueueUpdate$1(fiber, updateQueue, update, lane);
          return getRootForUpdatedFiber(fiber);
        }
        function entangleTransitions(root2, fiber, lane) {
          fiber = fiber.updateQueue;
          if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194048))) {
            var queueLanes = fiber.lanes;
            queueLanes &= root2.pendingLanes;
            lane |= queueLanes;
            fiber.lanes = lane;
            markRootEntangled(root2, lane);
          }
        }
        function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
          var queue = workInProgress2.updateQueue, current2 = workInProgress2.alternate;
          if (null !== current2 && (current2 = current2.updateQueue, queue === current2)) {
            var newFirst = null, newLast = null;
            queue = queue.firstBaseUpdate;
            if (null !== queue) {
              do {
                var clone = {
                  lane: queue.lane,
                  tag: queue.tag,
                  payload: queue.payload,
                  callback: null,
                  next: null
                };
                null === newLast ? newFirst = newLast = clone : newLast = newLast.next = clone;
                queue = queue.next;
              } while (null !== queue);
              null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
            } else newFirst = newLast = capturedUpdate;
            queue = {
              baseState: current2.baseState,
              firstBaseUpdate: newFirst,
              lastBaseUpdate: newLast,
              shared: current2.shared,
              callbacks: current2.callbacks
            };
            workInProgress2.updateQueue = queue;
            return;
          }
          workInProgress2 = queue.lastBaseUpdate;
          null === workInProgress2 ? queue.firstBaseUpdate = capturedUpdate : workInProgress2.next = capturedUpdate;
          queue.lastBaseUpdate = capturedUpdate;
        }
        function suspendIfUpdateReadFromEntangledAsyncAction() {
          if (didReadFromEntangledAsyncAction) {
            var entangledActionThenable = currentEntangledActionThenable;
            if (null !== entangledActionThenable) throw entangledActionThenable;
          }
        }
        function processUpdateQueue(workInProgress2, props, instance$jscomp$0, renderLanes2) {
          didReadFromEntangledAsyncAction = false;
          var queue = workInProgress2.updateQueue;
          hasForceUpdate = false;
          currentlyProcessingQueue = queue.shared;
          var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;
          if (null !== pendingQueue) {
            queue.shared.pending = null;
            var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
            lastPendingUpdate.next = null;
            null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
            lastBaseUpdate = lastPendingUpdate;
            var current2 = workInProgress2.alternate;
            null !== current2 && (current2 = current2.updateQueue, pendingQueue = current2.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current2.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current2.lastBaseUpdate = lastPendingUpdate));
          }
          if (null !== firstBaseUpdate) {
            var newState = queue.baseState;
            lastBaseUpdate = 0;
            current2 = firstPendingUpdate = lastPendingUpdate = null;
            pendingQueue = firstBaseUpdate;
            do {
              var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;
              if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes2 & updateLane) === updateLane) {
                0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = true);
                null !== current2 && (current2 = current2.next = {
                  lane: 0,
                  tag: pendingQueue.tag,
                  payload: pendingQueue.payload,
                  callback: null,
                  next: null
                });
                a: {
                  updateLane = workInProgress2;
                  var partialState = pendingQueue;
                  var nextProps = props, instance = instance$jscomp$0;
                  switch (partialState.tag) {
                    case ReplaceState:
                      partialState = partialState.payload;
                      if ("function" === typeof partialState) {
                        isDisallowedContextReadInDEV = true;
                        var nextState = partialState.call(
                          instance,
                          newState,
                          nextProps
                        );
                        if (updateLane.mode & StrictLegacyMode) {
                          setIsStrictModeForDevtools(true);
                          try {
                            partialState.call(instance, newState, nextProps);
                          } finally {
                            setIsStrictModeForDevtools(false);
                          }
                        }
                        isDisallowedContextReadInDEV = false;
                        newState = nextState;
                        break a;
                      }
                      newState = partialState;
                      break a;
                    case CaptureUpdate:
                      updateLane.flags = updateLane.flags & -65537 | 128;
                    case UpdateState:
                      nextState = partialState.payload;
                      if ("function" === typeof nextState) {
                        isDisallowedContextReadInDEV = true;
                        partialState = nextState.call(
                          instance,
                          newState,
                          nextProps
                        );
                        if (updateLane.mode & StrictLegacyMode) {
                          setIsStrictModeForDevtools(true);
                          try {
                            nextState.call(instance, newState, nextProps);
                          } finally {
                            setIsStrictModeForDevtools(false);
                          }
                        }
                        isDisallowedContextReadInDEV = false;
                      } else partialState = nextState;
                      if (null === partialState || void 0 === partialState) break a;
                      newState = assign({}, newState, partialState);
                      break a;
                    case ForceUpdate:
                      hasForceUpdate = true;
                  }
                }
                updateLane = pendingQueue.callback;
                null !== updateLane && (workInProgress2.flags |= 64, isHiddenUpdate && (workInProgress2.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
              } else
                isHiddenUpdate = {
                  lane: updateLane,
                  tag: pendingQueue.tag,
                  payload: pendingQueue.payload,
                  callback: pendingQueue.callback,
                  next: null
                }, null === current2 ? (firstPendingUpdate = current2 = isHiddenUpdate, lastPendingUpdate = newState) : current2 = current2.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
              pendingQueue = pendingQueue.next;
              if (null === pendingQueue)
                if (pendingQueue = queue.shared.pending, null === pendingQueue)
                  break;
                else
                  isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
            } while (1);
            null === current2 && (lastPendingUpdate = newState);
            queue.baseState = lastPendingUpdate;
            queue.firstBaseUpdate = firstPendingUpdate;
            queue.lastBaseUpdate = current2;
            null === firstBaseUpdate && (queue.shared.lanes = 0);
            workInProgressRootSkippedLanes |= lastBaseUpdate;
            workInProgress2.lanes = lastBaseUpdate;
            workInProgress2.memoizedState = newState;
          }
          currentlyProcessingQueue = null;
        }
        function callCallback(callback, context) {
          if ("function" !== typeof callback)
            throw Error(
              "Invalid argument passed as callback. Expected a function. Instead received: " + callback
            );
          callback.call(context);
        }
        function commitHiddenCallbacks(updateQueue, context) {
          var hiddenCallbacks = updateQueue.shared.hiddenCallbacks;
          if (null !== hiddenCallbacks)
            for (updateQueue.shared.hiddenCallbacks = null, updateQueue = 0; updateQueue < hiddenCallbacks.length; updateQueue++)
              callCallback(hiddenCallbacks[updateQueue], context);
        }
        function commitCallbacks(updateQueue, context) {
          var callbacks = updateQueue.callbacks;
          if (null !== callbacks)
            for (updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++)
              callCallback(callbacks[updateQueue], context);
        }
        function pushHiddenContext(fiber, context) {
          var prevEntangledRenderLanes = entangledRenderLanes;
          push(prevEntangledRenderLanesCursor, prevEntangledRenderLanes, fiber);
          push(currentTreeHiddenStackCursor, context, fiber);
          entangledRenderLanes = prevEntangledRenderLanes | context.baseLanes;
        }
        function reuseHiddenContextOnStack(fiber) {
          push(prevEntangledRenderLanesCursor, entangledRenderLanes, fiber);
          push(
            currentTreeHiddenStackCursor,
            currentTreeHiddenStackCursor.current,
            fiber
          );
        }
        function popHiddenContext(fiber) {
          entangledRenderLanes = prevEntangledRenderLanesCursor.current;
          pop(currentTreeHiddenStackCursor, fiber);
          pop(prevEntangledRenderLanesCursor, fiber);
        }
        function pushPrimaryTreeSuspenseHandler(handler) {
          var current2 = handler.alternate;
          push(
            suspenseStackCursor,
            suspenseStackCursor.current & SubtreeSuspenseContextMask,
            handler
          );
          push(suspenseHandlerStackCursor, handler, handler);
          null === shellBoundary && (null === current2 || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current2.memoizedState && (shellBoundary = handler));
        }
        function pushDehydratedActivitySuspenseHandler(fiber) {
          push(suspenseStackCursor, suspenseStackCursor.current, fiber);
          push(suspenseHandlerStackCursor, fiber, fiber);
          null === shellBoundary && (shellBoundary = fiber);
        }
        function pushOffscreenSuspenseHandler(fiber) {
          22 === fiber.tag ? (push(suspenseStackCursor, suspenseStackCursor.current, fiber), push(suspenseHandlerStackCursor, fiber, fiber), null === shellBoundary && (shellBoundary = fiber)) : reuseSuspenseHandlerOnStack(fiber);
        }
        function reuseSuspenseHandlerOnStack(fiber) {
          push(suspenseStackCursor, suspenseStackCursor.current, fiber);
          push(
            suspenseHandlerStackCursor,
            suspenseHandlerStackCursor.current,
            fiber
          );
        }
        function popSuspenseHandler(fiber) {
          pop(suspenseHandlerStackCursor, fiber);
          shellBoundary === fiber && (shellBoundary = null);
          pop(suspenseStackCursor, fiber);
        }
        function findFirstSuspended(row) {
          for (var node = row; null !== node; ) {
            if (13 === node.tag) {
              var state = node.memoizedState;
              if (null !== state && (state = state.dehydrated, null === state || isSuspenseInstancePending(state) || isSuspenseInstanceFallback(state)))
                return node;
            } else if (19 === node.tag && ("forwards" === node.memoizedProps.revealOrder || "backwards" === node.memoizedProps.revealOrder || "unstable_legacy-backwards" === node.memoizedProps.revealOrder || "together" === node.memoizedProps.revealOrder)) {
              if (0 !== (node.flags & 128)) return node;
            } else if (null !== node.child) {
              node.child.return = node;
              node = node.child;
              continue;
            }
            if (node === row) break;
            for (; null === node.sibling; ) {
              if (null === node.return || node.return === row) return null;
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
          return null;
        }
        function mountHookTypesDev() {
          var hookName = currentHookNameInDev;
          null === hookTypesDev ? hookTypesDev = [hookName] : hookTypesDev.push(hookName);
        }
        function updateHookTypesDev() {
          var hookName = currentHookNameInDev;
          if (null !== hookTypesDev && (hookTypesUpdateIndexDev++, hookTypesDev[hookTypesUpdateIndexDev] !== hookName)) {
            var componentName2 = getComponentNameFromFiber(currentlyRenderingFiber);
            if (!didWarnAboutMismatchedHooksForComponent.has(componentName2) && (didWarnAboutMismatchedHooksForComponent.add(componentName2), null !== hookTypesDev)) {
              for (var table = "", i5 = 0; i5 <= hookTypesUpdateIndexDev; i5++) {
                var oldHookName = hookTypesDev[i5], newHookName = i5 === hookTypesUpdateIndexDev ? hookName : oldHookName;
                for (oldHookName = i5 + 1 + ". " + oldHookName; 30 > oldHookName.length; )
                  oldHookName += " ";
                oldHookName += newHookName + "\n";
                table += oldHookName;
              }
              console.error(
                "React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n",
                componentName2,
                table
              );
            }
          }
        }
        function checkDepsAreArrayDev(deps) {
          void 0 === deps || null === deps || isArrayImpl(deps) || console.error(
            "%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.",
            currentHookNameInDev,
            typeof deps
          );
        }
        function warnOnUseFormStateInDev() {
          var componentName2 = getComponentNameFromFiber(currentlyRenderingFiber);
          didWarnAboutUseFormState.has(componentName2) || (didWarnAboutUseFormState.add(componentName2), console.error(
            "ReactDOM.useFormState has been renamed to React.useActionState. Please update %s to use React.useActionState.",
            componentName2
          ));
        }
        function throwInvalidHookError() {
          throw Error(
            "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
          );
        }
        function areHookInputsEqual(nextDeps, prevDeps) {
          if (ignorePreviousDependencies) return false;
          if (null === prevDeps)
            return console.error(
              "%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.",
              currentHookNameInDev
            ), false;
          nextDeps.length !== prevDeps.length && console.error(
            "The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s",
            currentHookNameInDev,
            "[" + prevDeps.join(", ") + "]",
            "[" + nextDeps.join(", ") + "]"
          );
          for (var i5 = 0; i5 < prevDeps.length && i5 < nextDeps.length; i5++)
            if (!objectIs(nextDeps[i5], prevDeps[i5])) return false;
          return true;
        }
        function renderWithHooks(current2, workInProgress2, Component, props, secondArg, nextRenderLanes) {
          renderLanes = nextRenderLanes;
          currentlyRenderingFiber = workInProgress2;
          hookTypesDev = null !== current2 ? current2._debugHookTypes : null;
          hookTypesUpdateIndexDev = -1;
          ignorePreviousDependencies = null !== current2 && current2.type !== workInProgress2.type;
          if ("[object AsyncFunction]" === Object.prototype.toString.call(Component) || "[object AsyncGeneratorFunction]" === Object.prototype.toString.call(Component))
            nextRenderLanes = getComponentNameFromFiber(currentlyRenderingFiber), didWarnAboutAsyncClientComponent.has(nextRenderLanes) || (didWarnAboutAsyncClientComponent.add(nextRenderLanes), console.error(
              "%s is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.",
              null === nextRenderLanes ? "An unknown Component" : "<" + nextRenderLanes + ">"
            ));
          workInProgress2.memoizedState = null;
          workInProgress2.updateQueue = null;
          workInProgress2.lanes = 0;
          ReactSharedInternals.H = null !== current2 && null !== current2.memoizedState ? HooksDispatcherOnUpdateInDEV : null !== hookTypesDev ? HooksDispatcherOnMountWithHookTypesInDEV : HooksDispatcherOnMountInDEV;
          shouldDoubleInvokeUserFnsInHooksDEV = nextRenderLanes = (workInProgress2.mode & StrictLegacyMode) !== NoMode;
          var children = callComponentInDEV(Component, props, secondArg);
          shouldDoubleInvokeUserFnsInHooksDEV = false;
          didScheduleRenderPhaseUpdateDuringThisPass && (children = renderWithHooksAgain(
            workInProgress2,
            Component,
            props,
            secondArg
          ));
          if (nextRenderLanes) {
            setIsStrictModeForDevtools(true);
            try {
              children = renderWithHooksAgain(
                workInProgress2,
                Component,
                props,
                secondArg
              );
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          finishRenderingHooks(current2, workInProgress2);
          return children;
        }
        function finishRenderingHooks(current2, workInProgress2) {
          workInProgress2._debugHookTypes = hookTypesDev;
          null === workInProgress2.dependencies ? null !== thenableState && (workInProgress2.dependencies = {
            lanes: 0,
            firstContext: null,
            _debugThenableState: thenableState
          }) : workInProgress2.dependencies._debugThenableState = thenableState;
          ReactSharedInternals.H = ContextOnlyDispatcher;
          var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
          renderLanes = 0;
          hookTypesDev = currentHookNameInDev = workInProgressHook = currentHook = currentlyRenderingFiber = null;
          hookTypesUpdateIndexDev = -1;
          null !== current2 && (current2.flags & 65011712) !== (workInProgress2.flags & 65011712) && console.error(
            "Internal React error: Expected static flag was missing. Please notify the React team."
          );
          didScheduleRenderPhaseUpdate = false;
          thenableIndexCounter = 0;
          thenableState = null;
          if (didRenderTooFewHooks)
            throw Error(
              "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
            );
          null === current2 || didReceiveUpdate || (current2 = current2.dependencies, null !== current2 && checkIfContextChanged(current2) && (didReceiveUpdate = true));
          needsToResetSuspendedThenableDEV ? (needsToResetSuspendedThenableDEV = false, current2 = true) : current2 = false;
          current2 && (workInProgress2 = getComponentNameFromFiber(workInProgress2) || "Unknown", didWarnAboutUseWrappedInTryCatch.has(workInProgress2) || didWarnAboutAsyncClientComponent.has(workInProgress2) || (didWarnAboutUseWrappedInTryCatch.add(workInProgress2), console.error(
            "`use` was called from inside a try/catch block. This is not allowed and can lead to unexpected behavior. To handle errors triggered by `use`, wrap your component in a error boundary."
          )));
        }
        function renderWithHooksAgain(workInProgress2, Component, props, secondArg) {
          currentlyRenderingFiber = workInProgress2;
          var numberOfReRenders = 0;
          do {
            didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);
            thenableIndexCounter = 0;
            didScheduleRenderPhaseUpdateDuringThisPass = false;
            if (numberOfReRenders >= RE_RENDER_LIMIT)
              throw Error(
                "Too many re-renders. React limits the number of renders to prevent an infinite loop."
              );
            numberOfReRenders += 1;
            ignorePreviousDependencies = false;
            workInProgressHook = currentHook = null;
            if (null != workInProgress2.updateQueue) {
              var children = workInProgress2.updateQueue;
              children.lastEffect = null;
              children.events = null;
              children.stores = null;
              null != children.memoCache && (children.memoCache.index = 0);
            }
            hookTypesUpdateIndexDev = -1;
            ReactSharedInternals.H = HooksDispatcherOnRerenderInDEV;
            children = callComponentInDEV(Component, props, secondArg);
          } while (didScheduleRenderPhaseUpdateDuringThisPass);
          return children;
        }
        function TransitionAwareHostComponent() {
          var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];
          maybeThenable = "function" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
          dispatcher = dispatcher.useState()[0];
          (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber.flags |= 1024);
          return maybeThenable;
        }
        function checkDidRenderIdHook() {
          var didRenderIdHook = 0 !== localIdCounter;
          localIdCounter = 0;
          return didRenderIdHook;
        }
        function bailoutHooks(current2, workInProgress2, lanes) {
          workInProgress2.updateQueue = current2.updateQueue;
          workInProgress2.flags = (workInProgress2.mode & StrictEffectsMode) !== NoMode ? workInProgress2.flags & -402655237 : workInProgress2.flags & -2053;
          current2.lanes &= ~lanes;
        }
        function resetHooksOnUnwind(workInProgress2) {
          if (didScheduleRenderPhaseUpdate) {
            for (workInProgress2 = workInProgress2.memoizedState; null !== workInProgress2; ) {
              var queue = workInProgress2.queue;
              null !== queue && (queue.pending = null);
              workInProgress2 = workInProgress2.next;
            }
            didScheduleRenderPhaseUpdate = false;
          }
          renderLanes = 0;
          hookTypesDev = workInProgressHook = currentHook = currentlyRenderingFiber = null;
          hookTypesUpdateIndexDev = -1;
          currentHookNameInDev = null;
          didScheduleRenderPhaseUpdateDuringThisPass = false;
          thenableIndexCounter = localIdCounter = 0;
          thenableState = null;
        }
        function mountWorkInProgressHook() {
          var hook = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
          };
          null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
          return workInProgressHook;
        }
        function updateWorkInProgressHook() {
          if (null === currentHook) {
            var nextCurrentHook = currentlyRenderingFiber.alternate;
            nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
          } else nextCurrentHook = currentHook.next;
          var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;
          if (null !== nextWorkInProgressHook)
            workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;
          else {
            if (null === nextCurrentHook) {
              if (null === currentlyRenderingFiber.alternate)
                throw Error(
                  "Update hook called on initial render. This is likely a bug in React. Please file an issue."
                );
              throw Error("Rendered more hooks than during the previous render.");
            }
            currentHook = nextCurrentHook;
            nextCurrentHook = {
              memoizedState: currentHook.memoizedState,
              baseState: currentHook.baseState,
              baseQueue: currentHook.baseQueue,
              queue: currentHook.queue,
              next: null
            };
            null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
          }
          return workInProgressHook;
        }
        function createFunctionComponentUpdateQueue() {
          return { lastEffect: null, events: null, stores: null, memoCache: null };
        }
        function useThenable(thenable) {
          var index = thenableIndexCounter;
          thenableIndexCounter += 1;
          null === thenableState && (thenableState = createThenableState());
          thenable = trackUsedThenable(thenableState, thenable, index);
          index = currentlyRenderingFiber;
          null === (null === workInProgressHook ? index.memoizedState : workInProgressHook.next) && (index = index.alternate, ReactSharedInternals.H = null !== index && null !== index.memoizedState ? HooksDispatcherOnUpdateInDEV : HooksDispatcherOnMountInDEV);
          return thenable;
        }
        function use(usable) {
          if (null !== usable && "object" === typeof usable) {
            if ("function" === typeof usable.then) return useThenable(usable);
            if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
          }
          throw Error("An unsupported type was passed to use(): " + String(usable));
        }
        function useMemoCache(size) {
          var memoCache = null, updateQueue = currentlyRenderingFiber.updateQueue;
          null !== updateQueue && (memoCache = updateQueue.memoCache);
          if (null == memoCache) {
            var current2 = currentlyRenderingFiber.alternate;
            null !== current2 && (current2 = current2.updateQueue, null !== current2 && (current2 = current2.memoCache, null != current2 && (memoCache = {
              data: current2.data.map(function(array) {
                return array.slice();
              }),
              index: 0
            })));
          }
          null == memoCache && (memoCache = { data: [], index: 0 });
          null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = updateQueue);
          updateQueue.memoCache = memoCache;
          updateQueue = memoCache.data[memoCache.index];
          if (void 0 === updateQueue || ignorePreviousDependencies)
            for (updateQueue = memoCache.data[memoCache.index] = Array(size), current2 = 0; current2 < size; current2++)
              updateQueue[current2] = REACT_MEMO_CACHE_SENTINEL;
          else
            updateQueue.length !== size && console.error(
              "Expected a constant size argument for each invocation of useMemoCache. The previous cache was allocated with size %s but size %s was requested.",
              updateQueue.length,
              size
            );
          memoCache.index++;
          return updateQueue;
        }
        function basicStateReducer(state, action) {
          return "function" === typeof action ? action(state) : action;
        }
        function mountReducer(reducer, initialArg, init) {
          var hook = mountWorkInProgressHook();
          if (void 0 !== init) {
            var initialState = init(initialArg);
            if (shouldDoubleInvokeUserFnsInHooksDEV) {
              setIsStrictModeForDevtools(true);
              try {
                init(initialArg);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
          } else initialState = initialArg;
          hook.memoizedState = hook.baseState = initialState;
          reducer = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: reducer,
            lastRenderedState: initialState
          };
          hook.queue = reducer;
          reducer = reducer.dispatch = dispatchReducerAction.bind(
            null,
            currentlyRenderingFiber,
            reducer
          );
          return [hook.memoizedState, reducer];
        }
        function updateReducer(reducer) {
          var hook = updateWorkInProgressHook();
          return updateReducerImpl(hook, currentHook, reducer);
        }
        function updateReducerImpl(hook, current2, reducer) {
          var queue = hook.queue;
          if (null === queue)
            throw Error(
              "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
            );
          queue.lastRenderedReducer = reducer;
          var baseQueue = hook.baseQueue, pendingQueue = queue.pending;
          if (null !== pendingQueue) {
            if (null !== baseQueue) {
              var baseFirst = baseQueue.next;
              baseQueue.next = pendingQueue.next;
              pendingQueue.next = baseFirst;
            }
            current2.baseQueue !== baseQueue && console.error(
              "Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."
            );
            current2.baseQueue = baseQueue = pendingQueue;
            queue.pending = null;
          }
          pendingQueue = hook.baseState;
          if (null === baseQueue) hook.memoizedState = pendingQueue;
          else {
            current2 = baseQueue.next;
            var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current2, didReadFromEntangledAsyncAction2 = false;
            do {
              var updateLane = update.lane & -536870913;
              if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
                var revertLane = update.revertLane;
                if (0 === revertLane)
                  null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
                    lane: 0,
                    revertLane: 0,
                    gesture: null,
                    action: update.action,
                    hasEagerState: update.hasEagerState,
                    eagerState: update.eagerState,
                    next: null
                  }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction2 = true);
                else if ((renderLanes & revertLane) === revertLane) {
                  update = update.next;
                  revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction2 = true);
                  continue;
                } else
                  updateLane = {
                    lane: 0,
                    revertLane: update.revertLane,
                    gesture: null,
                    action: update.action,
                    hasEagerState: update.hasEagerState,
                    eagerState: update.eagerState,
                    next: null
                  }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
                updateLane = update.action;
                shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
                pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
              } else
                revertLane = {
                  lane: updateLane,
                  revertLane: update.revertLane,
                  gesture: update.gesture,
                  action: update.action,
                  hasEagerState: update.hasEagerState,
                  eagerState: update.eagerState,
                  next: null
                }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
              update = update.next;
            } while (null !== update && update !== current2);
            null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
            if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = true, didReadFromEntangledAsyncAction2 && (reducer = currentEntangledActionThenable, null !== reducer)))
              throw reducer;
            hook.memoizedState = pendingQueue;
            hook.baseState = baseFirst;
            hook.baseQueue = newBaseQueueLast;
            queue.lastRenderedState = pendingQueue;
          }
          null === baseQueue && (queue.lanes = 0);
          return [hook.memoizedState, queue.dispatch];
        }
        function rerenderReducer(reducer) {
          var hook = updateWorkInProgressHook(), queue = hook.queue;
          if (null === queue)
            throw Error(
              "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
            );
          queue.lastRenderedReducer = reducer;
          var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;
          if (null !== lastRenderPhaseUpdate) {
            queue.pending = null;
            var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
            do
              newState = reducer(newState, update.action), update = update.next;
            while (update !== lastRenderPhaseUpdate);
            objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
            hook.memoizedState = newState;
            null === hook.baseQueue && (hook.baseState = newState);
            queue.lastRenderedState = newState;
          }
          return [newState, dispatch];
        }
        function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          var fiber = currentlyRenderingFiber, hook = mountWorkInProgressHook();
          if (isHydrating) {
            if (void 0 === getServerSnapshot)
              throw Error(
                "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
              );
            var nextSnapshot = getServerSnapshot();
            didWarnUncachedGetSnapshot || nextSnapshot === getServerSnapshot() || (console.error(
              "The result of getServerSnapshot should be cached to avoid an infinite loop"
            ), didWarnUncachedGetSnapshot = true);
          } else {
            nextSnapshot = getSnapshot();
            didWarnUncachedGetSnapshot || (getServerSnapshot = getSnapshot(), objectIs(nextSnapshot, getServerSnapshot) || (console.error(
              "The result of getSnapshot should be cached to avoid an infinite loop"
            ), didWarnUncachedGetSnapshot = true));
            if (null === workInProgressRoot)
              throw Error(
                "Expected a work-in-progress root. This is a bug in React. Please file an issue."
              );
            0 !== (workInProgressRootRenderLanes & 127) || pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
          }
          hook.memoizedState = nextSnapshot;
          getServerSnapshot = { value: nextSnapshot, getSnapshot };
          hook.queue = getServerSnapshot;
          mountEffect(
            subscribeToStore.bind(null, fiber, getServerSnapshot, subscribe),
            [subscribe]
          );
          fiber.flags |= 2048;
          pushSimpleEffect(
            HasEffect | Passive,
            { destroy: void 0 },
            updateStoreInstance.bind(
              null,
              fiber,
              getServerSnapshot,
              nextSnapshot,
              getSnapshot
            ),
            null
          );
          return nextSnapshot;
        }
        function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          var fiber = currentlyRenderingFiber, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;
          if (isHydrating$jscomp$0) {
            if (void 0 === getServerSnapshot)
              throw Error(
                "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
              );
            getServerSnapshot = getServerSnapshot();
          } else if (getServerSnapshot = getSnapshot(), !didWarnUncachedGetSnapshot) {
            var cachedSnapshot = getSnapshot();
            objectIs(getServerSnapshot, cachedSnapshot) || (console.error(
              "The result of getSnapshot should be cached to avoid an infinite loop"
            ), didWarnUncachedGetSnapshot = true);
          }
          if (cachedSnapshot = !objectIs(
            (currentHook || hook).memoizedState,
            getServerSnapshot
          ))
            hook.memoizedState = getServerSnapshot, didReceiveUpdate = true;
          hook = hook.queue;
          var create2 = subscribeToStore.bind(null, fiber, hook, subscribe);
          updateEffectImpl(2048, Passive, create2, [subscribe]);
          if (hook.getSnapshot !== getSnapshot || cachedSnapshot || null !== workInProgressHook && workInProgressHook.memoizedState.tag & HasEffect) {
            fiber.flags |= 2048;
            pushSimpleEffect(
              HasEffect | Passive,
              { destroy: void 0 },
              updateStoreInstance.bind(
                null,
                fiber,
                hook,
                getServerSnapshot,
                getSnapshot
              ),
              null
            );
            if (null === workInProgressRoot)
              throw Error(
                "Expected a work-in-progress root. This is a bug in React. Please file an issue."
              );
            isHydrating$jscomp$0 || 0 !== (renderLanes & 127) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
          }
          return getServerSnapshot;
        }
        function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
          fiber.flags |= 16384;
          fiber = { getSnapshot, value: renderedSnapshot };
          getSnapshot = currentlyRenderingFiber.updateQueue;
          null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
        }
        function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
          inst.value = nextSnapshot;
          inst.getSnapshot = getSnapshot;
          checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
        }
        function subscribeToStore(fiber, inst, subscribe) {
          return subscribe(function() {
            checkIfSnapshotChanged(inst) && (startUpdateTimerByLane(2, "updateSyncExternalStore()", fiber), forceStoreRerender(fiber));
          });
        }
        function checkIfSnapshotChanged(inst) {
          var latestGetSnapshot = inst.getSnapshot;
          inst = inst.value;
          try {
            var nextValue = latestGetSnapshot();
            return !objectIs(inst, nextValue);
          } catch (error) {
            return true;
          }
        }
        function forceStoreRerender(fiber) {
          var root2 = enqueueConcurrentRenderForLane(fiber, 2);
          null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2);
        }
        function mountStateImpl(initialState) {
          var hook = mountWorkInProgressHook();
          if ("function" === typeof initialState) {
            var initialStateInitializer = initialState;
            initialState = initialStateInitializer();
            if (shouldDoubleInvokeUserFnsInHooksDEV) {
              setIsStrictModeForDevtools(true);
              try {
                initialStateInitializer();
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
          }
          hook.memoizedState = hook.baseState = initialState;
          hook.queue = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: initialState
          };
          return hook;
        }
        function mountState(initialState) {
          initialState = mountStateImpl(initialState);
          var queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
          queue.dispatch = dispatch;
          return [initialState.memoizedState, dispatch];
        }
        function mountOptimistic(passthrough) {
          var hook = mountWorkInProgressHook();
          hook.memoizedState = hook.baseState = passthrough;
          var queue = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: null,
            lastRenderedState: null
          };
          hook.queue = queue;
          hook = dispatchOptimisticSetState.bind(
            null,
            currentlyRenderingFiber,
            true,
            queue
          );
          queue.dispatch = hook;
          return [passthrough, hook];
        }
        function updateOptimistic(passthrough, reducer) {
          var hook = updateWorkInProgressHook();
          return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
        }
        function updateOptimisticImpl(hook, current2, passthrough, reducer) {
          hook.baseState = passthrough;
          return updateReducerImpl(
            hook,
            currentHook,
            "function" === typeof reducer ? reducer : basicStateReducer
          );
        }
        function rerenderOptimistic(passthrough, reducer) {
          var hook = updateWorkInProgressHook();
          if (null !== currentHook)
            return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
          hook.baseState = passthrough;
          return [passthrough, hook.queue.dispatch];
        }
        function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
          if (isRenderPhaseUpdate(fiber))
            throw Error("Cannot update form state while rendering.");
          fiber = actionQueue.action;
          if (null !== fiber) {
            var actionNode = {
              payload,
              action: fiber,
              next: null,
              isTransition: true,
              status: "pending",
              value: null,
              reason: null,
              listeners: [],
              then: function(listener) {
                actionNode.listeners.push(listener);
              }
            };
            null !== ReactSharedInternals.T ? setPendingState(true) : actionNode.isTransition = false;
            setState(actionNode);
            setPendingState = actionQueue.pending;
            null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
          }
        }
        function runActionStateAction(actionQueue, node) {
          var action = node.action, payload = node.payload, prevState = actionQueue.state;
          if (node.isTransition) {
            var prevTransition = ReactSharedInternals.T, currentTransition = {};
            currentTransition._updatedFibers = /* @__PURE__ */ new Set();
            ReactSharedInternals.T = currentTransition;
            try {
              var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;
              null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
              handleActionReturnValue(actionQueue, node, returnValue);
            } catch (error) {
              onActionError(actionQueue, node, error);
            } finally {
              null !== prevTransition && null !== currentTransition.types && (null !== prevTransition.types && prevTransition.types !== currentTransition.types && console.error(
                "We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React."
              ), prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (actionQueue = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < actionQueue && console.warn(
                "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
              ));
            }
          } else
            try {
              currentTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, currentTransition);
            } catch (error$4) {
              onActionError(actionQueue, node, error$4);
            }
        }
        function handleActionReturnValue(actionQueue, node, returnValue) {
          null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then ? (ReactSharedInternals.asyncTransitions++, returnValue.then(releaseAsyncTransition, releaseAsyncTransition), returnValue.then(
            function(nextState) {
              onActionSuccess(actionQueue, node, nextState);
            },
            function(error) {
              return onActionError(actionQueue, node, error);
            }
          ), node.isTransition || console.error(
            "An async function with useActionState was called outside of a transition. This is likely not what you intended (for example, isPending will not update correctly). Either call the returned function inside startTransition, or pass it to an `action` or `formAction` prop."
          )) : onActionSuccess(actionQueue, node, returnValue);
        }
        function onActionSuccess(actionQueue, actionNode, nextState) {
          actionNode.status = "fulfilled";
          actionNode.value = nextState;
          notifyActionListeners(actionNode);
          actionQueue.state = nextState;
          actionNode = actionQueue.pending;
          null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
        }
        function onActionError(actionQueue, actionNode, error) {
          var last = actionQueue.pending;
          actionQueue.pending = null;
          if (null !== last) {
            last = last.next;
            do
              actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;
            while (actionNode !== last);
          }
          actionQueue.action = null;
        }
        function notifyActionListeners(actionNode) {
          actionNode = actionNode.listeners;
          for (var i5 = 0; i5 < actionNode.length; i5++) (0, actionNode[i5])();
        }
        function actionStateReducer(oldState, newState) {
          return newState;
        }
        function mountActionState(action, initialStateProp) {
          if (isHydrating) {
            var ssrFormState = workInProgressRoot.formState;
            if (null !== ssrFormState) {
              a: {
                var isMatching = currentlyRenderingFiber;
                if (isHydrating) {
                  if (nextHydratableInstance) {
                    b: {
                      var markerInstance = nextHydratableInstance;
                      for (var inRootOrSingleton = rootOrSingletonContext; 8 !== markerInstance.nodeType; ) {
                        if (!inRootOrSingleton) {
                          markerInstance = null;
                          break b;
                        }
                        markerInstance = getNextHydratable(
                          markerInstance.nextSibling
                        );
                        if (null === markerInstance) {
                          markerInstance = null;
                          break b;
                        }
                      }
                      inRootOrSingleton = markerInstance.data;
                      markerInstance = inRootOrSingleton === FORM_STATE_IS_MATCHING || inRootOrSingleton === FORM_STATE_IS_NOT_MATCHING ? markerInstance : null;
                    }
                    if (markerInstance) {
                      nextHydratableInstance = getNextHydratable(
                        markerInstance.nextSibling
                      );
                      isMatching = markerInstance.data === FORM_STATE_IS_MATCHING;
                      break a;
                    }
                  }
                  throwOnHydrationMismatch(isMatching);
                }
                isMatching = false;
              }
              isMatching && (initialStateProp = ssrFormState[0]);
            }
          }
          ssrFormState = mountWorkInProgressHook();
          ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
          isMatching = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: actionStateReducer,
            lastRenderedState: initialStateProp
          };
          ssrFormState.queue = isMatching;
          ssrFormState = dispatchSetState.bind(
            null,
            currentlyRenderingFiber,
            isMatching
          );
          isMatching.dispatch = ssrFormState;
          isMatching = mountStateImpl(false);
          inRootOrSingleton = dispatchOptimisticSetState.bind(
            null,
            currentlyRenderingFiber,
            false,
            isMatching.queue
          );
          isMatching = mountWorkInProgressHook();
          markerInstance = {
            state: initialStateProp,
            dispatch: null,
            action,
            pending: null
          };
          isMatching.queue = markerInstance;
          ssrFormState = dispatchActionState.bind(
            null,
            currentlyRenderingFiber,
            markerInstance,
            inRootOrSingleton,
            ssrFormState
          );
          markerInstance.dispatch = ssrFormState;
          isMatching.memoizedState = action;
          return [initialStateProp, ssrFormState, false];
        }
        function updateActionState(action) {
          var stateHook = updateWorkInProgressHook();
          return updateActionStateImpl(stateHook, currentHook, action);
        }
        function updateActionStateImpl(stateHook, currentStateHook, action) {
          currentStateHook = updateReducerImpl(
            stateHook,
            currentStateHook,
            actionStateReducer
          )[0];
          stateHook = updateReducer(basicStateReducer)[0];
          if ("object" === typeof currentStateHook && null !== currentStateHook && "function" === typeof currentStateHook.then)
            try {
              var state = useThenable(currentStateHook);
            } catch (x5) {
              if (x5 === SuspenseException) throw SuspenseActionException;
              throw x5;
            }
          else state = currentStateHook;
          currentStateHook = updateWorkInProgressHook();
          var actionQueue = currentStateHook.queue, dispatch = actionQueue.dispatch;
          action !== currentStateHook.memoizedState && (currentlyRenderingFiber.flags |= 2048, pushSimpleEffect(
            HasEffect | Passive,
            { destroy: void 0 },
            actionStateActionEffect.bind(null, actionQueue, action),
            null
          ));
          return [state, dispatch, stateHook];
        }
        function actionStateActionEffect(actionQueue, action) {
          actionQueue.action = action;
        }
        function rerenderActionState(action) {
          var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;
          if (null !== currentStateHook)
            return updateActionStateImpl(stateHook, currentStateHook, action);
          updateWorkInProgressHook();
          stateHook = stateHook.memoizedState;
          currentStateHook = updateWorkInProgressHook();
          var dispatch = currentStateHook.queue.dispatch;
          currentStateHook.memoizedState = action;
          return [stateHook, dispatch, false];
        }
        function pushSimpleEffect(tag, inst, create2, deps) {
          tag = { tag, create: create2, deps, inst, next: null };
          inst = currentlyRenderingFiber.updateQueue;
          null === inst && (inst = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = inst);
          create2 = inst.lastEffect;
          null === create2 ? inst.lastEffect = tag.next = tag : (deps = create2.next, create2.next = tag, tag.next = deps, inst.lastEffect = tag);
          return tag;
        }
        function mountRef(initialValue) {
          var hook = mountWorkInProgressHook();
          initialValue = { current: initialValue };
          return hook.memoizedState = initialValue;
        }
        function mountEffectImpl(fiberFlags, hookFlags, create2, deps) {
          var hook = mountWorkInProgressHook();
          currentlyRenderingFiber.flags |= fiberFlags;
          hook.memoizedState = pushSimpleEffect(
            HasEffect | hookFlags,
            { destroy: void 0 },
            create2,
            void 0 === deps ? null : deps
          );
        }
        function updateEffectImpl(fiberFlags, hookFlags, create2, deps) {
          var hook = updateWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var inst = hook.memoizedState.inst;
          null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushSimpleEffect(hookFlags, inst, create2, deps) : (currentlyRenderingFiber.flags |= fiberFlags, hook.memoizedState = pushSimpleEffect(
            HasEffect | hookFlags,
            inst,
            create2,
            deps
          ));
        }
        function mountEffect(create2, deps) {
          (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode ? mountEffectImpl(276826112, Passive, create2, deps) : mountEffectImpl(8390656, Passive, create2, deps);
        }
        function useEffectEventImpl(payload) {
          currentlyRenderingFiber.flags |= 4;
          var componentUpdateQueue = currentlyRenderingFiber.updateQueue;
          if (null === componentUpdateQueue)
            componentUpdateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = componentUpdateQueue, componentUpdateQueue.events = [payload];
          else {
            var events = componentUpdateQueue.events;
            null === events ? componentUpdateQueue.events = [payload] : events.push(payload);
          }
        }
        function mountEvent(callback) {
          var hook = mountWorkInProgressHook(), ref = { impl: callback };
          hook.memoizedState = ref;
          return function() {
            if ((executionContext & RenderContext) !== NoContext)
              throw Error(
                "A function wrapped in useEffectEvent can't be called during rendering."
              );
            return ref.impl.apply(void 0, arguments);
          };
        }
        function updateEvent(callback) {
          var ref = updateWorkInProgressHook().memoizedState;
          useEffectEventImpl({ ref, nextImpl: callback });
          return function() {
            if ((executionContext & RenderContext) !== NoContext)
              throw Error(
                "A function wrapped in useEffectEvent can't be called during rendering."
              );
            return ref.impl.apply(void 0, arguments);
          };
        }
        function mountLayoutEffect(create2, deps) {
          var fiberFlags = 4194308;
          (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode && (fiberFlags |= 134217728);
          return mountEffectImpl(fiberFlags, Layout, create2, deps);
        }
        function imperativeHandleEffect(create2, ref) {
          if ("function" === typeof ref) {
            create2 = create2();
            var refCleanup = ref(create2);
            return function() {
              "function" === typeof refCleanup ? refCleanup() : ref(null);
            };
          }
          if (null !== ref && void 0 !== ref)
            return ref.hasOwnProperty("current") || console.error(
              "Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.",
              "an object with keys {" + Object.keys(ref).join(", ") + "}"
            ), create2 = create2(), ref.current = create2, function() {
              ref.current = null;
            };
        }
        function mountImperativeHandle(ref, create2, deps) {
          "function" !== typeof create2 && console.error(
            "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
            null !== create2 ? typeof create2 : "null"
          );
          deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
          var fiberFlags = 4194308;
          (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode && (fiberFlags |= 134217728);
          mountEffectImpl(
            fiberFlags,
            Layout,
            imperativeHandleEffect.bind(null, create2, ref),
            deps
          );
        }
        function updateImperativeHandle(ref, create2, deps) {
          "function" !== typeof create2 && console.error(
            "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
            null !== create2 ? typeof create2 : "null"
          );
          deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
          updateEffectImpl(
            4,
            Layout,
            imperativeHandleEffect.bind(null, create2, ref),
            deps
          );
        }
        function mountCallback(callback, deps) {
          mountWorkInProgressHook().memoizedState = [
            callback,
            void 0 === deps ? null : deps
          ];
          return callback;
        }
        function updateCallback(callback, deps) {
          var hook = updateWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var prevState = hook.memoizedState;
          if (null !== deps && areHookInputsEqual(deps, prevState[1]))
            return prevState[0];
          hook.memoizedState = [callback, deps];
          return callback;
        }
        function mountMemo(nextCreate, deps) {
          var hook = mountWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var nextValue = nextCreate();
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              nextCreate();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          hook.memoizedState = [nextValue, deps];
          return nextValue;
        }
        function updateMemo(nextCreate, deps) {
          var hook = updateWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var prevState = hook.memoizedState;
          if (null !== deps && areHookInputsEqual(deps, prevState[1]))
            return prevState[0];
          prevState = nextCreate();
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              nextCreate();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          hook.memoizedState = [prevState, deps];
          return prevState;
        }
        function mountDeferredValue(value, initialValue) {
          var hook = mountWorkInProgressHook();
          return mountDeferredValueImpl(hook, value, initialValue);
        }
        function updateDeferredValue(value, initialValue) {
          var hook = updateWorkInProgressHook();
          return updateDeferredValueImpl(
            hook,
            currentHook.memoizedState,
            value,
            initialValue
          );
        }
        function rerenderDeferredValue(value, initialValue) {
          var hook = updateWorkInProgressHook();
          return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(
            hook,
            currentHook.memoizedState,
            value,
            initialValue
          );
        }
        function mountDeferredValueImpl(hook, value, initialValue) {
          if (void 0 === initialValue || 0 !== (renderLanes & 1073741824) && 0 === (workInProgressRootRenderLanes & 261930))
            return hook.memoizedState = value;
          hook.memoizedState = initialValue;
          hook = requestDeferredLane();
          currentlyRenderingFiber.lanes |= hook;
          workInProgressRootSkippedLanes |= hook;
          return initialValue;
        }
        function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
          if (objectIs(value, prevValue)) return value;
          if (null !== currentTreeHiddenStackCursor.current)
            return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = true), hook;
          if (0 === (renderLanes & 42) || 0 !== (renderLanes & 1073741824) && 0 === (workInProgressRootRenderLanes & 261930))
            return didReceiveUpdate = true, hook.memoizedState = value;
          hook = requestDeferredLane();
          currentlyRenderingFiber.lanes |= hook;
          workInProgressRootSkippedLanes |= hook;
          return prevValue;
        }
        function releaseAsyncTransition() {
          ReactSharedInternals.asyncTransitions--;
        }
        function startTransition(fiber, queue, pendingState, finishedState, callback) {
          var previousPriority = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = 0 !== previousPriority && previousPriority < ContinuousEventPriority ? previousPriority : ContinuousEventPriority;
          var prevTransition = ReactSharedInternals.T, currentTransition = {};
          currentTransition._updatedFibers = /* @__PURE__ */ new Set();
          ReactSharedInternals.T = currentTransition;
          dispatchOptimisticSetState(fiber, false, queue, pendingState);
          try {
            var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;
            null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
            if (null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then) {
              ReactSharedInternals.asyncTransitions++;
              returnValue.then(releaseAsyncTransition, releaseAsyncTransition);
              var thenableForFinishedState = chainThenableValue(
                returnValue,
                finishedState
              );
              dispatchSetStateInternal(
                fiber,
                queue,
                thenableForFinishedState,
                requestUpdateLane(fiber)
              );
            } else
              dispatchSetStateInternal(
                fiber,
                queue,
                finishedState,
                requestUpdateLane(fiber)
              );
          } catch (error) {
            dispatchSetStateInternal(
              fiber,
              queue,
              { then: function() {
              }, status: "rejected", reason: error },
              requestUpdateLane(fiber)
            );
          } finally {
            ReactDOMSharedInternals.p = previousPriority, null !== prevTransition && null !== currentTransition.types && (null !== prevTransition.types && prevTransition.types !== currentTransition.types && console.error(
              "We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React."
            ), prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (fiber = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < fiber && console.warn(
              "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
            ));
          }
        }
        function startHostTransition(formFiber, pendingState, action, formData) {
          if (5 !== formFiber.tag)
            throw Error(
              "Expected the form instance to be a HostComponent. This is a bug in React."
            );
          var queue = ensureFormComponentIsStateful(formFiber).queue;
          startHostActionTimer(formFiber);
          startTransition(
            formFiber,
            queue,
            pendingState,
            NotPendingTransition,
            null === action ? noop : function() {
              requestFormReset$1(formFiber);
              return action(formData);
            }
          );
        }
        function ensureFormComponentIsStateful(formFiber) {
          var existingStateHook = formFiber.memoizedState;
          if (null !== existingStateHook) return existingStateHook;
          existingStateHook = {
            memoizedState: NotPendingTransition,
            baseState: NotPendingTransition,
            baseQueue: null,
            queue: {
              pending: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: basicStateReducer,
              lastRenderedState: NotPendingTransition
            },
            next: null
          };
          var initialResetState = {};
          existingStateHook.next = {
            memoizedState: initialResetState,
            baseState: initialResetState,
            baseQueue: null,
            queue: {
              pending: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: basicStateReducer,
              lastRenderedState: initialResetState
            },
            next: null
          };
          formFiber.memoizedState = existingStateHook;
          formFiber = formFiber.alternate;
          null !== formFiber && (formFiber.memoizedState = existingStateHook);
          return existingStateHook;
        }
        function requestFormReset$1(formFiber) {
          null === ReactSharedInternals.T && console.error(
            "requestFormReset was called outside a transition or action. To fix, move to an action, or wrap with startTransition."
          );
          var stateHook = ensureFormComponentIsStateful(formFiber);
          null === stateHook.next && (stateHook = formFiber.alternate.memoizedState);
          dispatchSetStateInternal(
            formFiber,
            stateHook.next.queue,
            {},
            requestUpdateLane(formFiber)
          );
        }
        function mountTransition() {
          var stateHook = mountStateImpl(false);
          stateHook = startTransition.bind(
            null,
            currentlyRenderingFiber,
            stateHook.queue,
            true,
            false
          );
          mountWorkInProgressHook().memoizedState = stateHook;
          return [false, stateHook];
        }
        function updateTransition() {
          var booleanOrThenable = updateReducer(basicStateReducer)[0], start2 = updateWorkInProgressHook().memoizedState;
          return [
            "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
            start2
          ];
        }
        function rerenderTransition() {
          var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start2 = updateWorkInProgressHook().memoizedState;
          return [
            "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
            start2
          ];
        }
        function useHostTransitionStatus() {
          return readContext(HostTransitionContext);
        }
        function mountId() {
          var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;
          if (isHydrating) {
            var treeId = treeContextOverflow;
            var idWithLeadingBit = treeContextId;
            treeId = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + treeId;
            identifierPrefix = "_" + identifierPrefix + "R_" + treeId;
            treeId = localIdCounter++;
            0 < treeId && (identifierPrefix += "H" + treeId.toString(32));
            identifierPrefix += "_";
          } else
            treeId = globalClientIdCounter++, identifierPrefix = "_" + identifierPrefix + "r_" + treeId.toString(32) + "_";
          return hook.memoizedState = identifierPrefix;
        }
        function mountRefresh() {
          return mountWorkInProgressHook().memoizedState = refreshCache.bind(
            null,
            currentlyRenderingFiber
          );
        }
        function refreshCache(fiber, seedKey) {
          for (var provider = fiber.return; null !== provider; ) {
            switch (provider.tag) {
              case 24:
              case 3:
                var lane = requestUpdateLane(provider), refreshUpdate = createUpdate(lane), root2 = enqueueUpdate(provider, refreshUpdate, lane);
                null !== root2 && (startUpdateTimerByLane(lane, "refresh()", fiber), scheduleUpdateOnFiber(root2, provider, lane), entangleTransitions(root2, provider, lane));
                fiber = createCache();
                null !== seedKey && void 0 !== seedKey && null !== root2 && console.error(
                  "The seed argument is not enabled outside experimental channels."
                );
                refreshUpdate.payload = { cache: fiber };
                return;
            }
            provider = provider.return;
          }
        }
        function dispatchReducerAction(fiber, queue, action) {
          var args = arguments;
          "function" === typeof args[3] && console.error(
            "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
          );
          args = requestUpdateLane(fiber);
          var update = {
            lane: args,
            revertLane: 0,
            gesture: null,
            action,
            hasEagerState: false,
            eagerState: null,
            next: null
          };
          isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, update) : (update = enqueueConcurrentHookUpdate(fiber, queue, update, args), null !== update && (startUpdateTimerByLane(args, "dispatch()", fiber), scheduleUpdateOnFiber(update, fiber, args), entangleTransitionUpdate(update, queue, args)));
        }
        function dispatchSetState(fiber, queue, action) {
          var args = arguments;
          "function" === typeof args[3] && console.error(
            "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
          );
          args = requestUpdateLane(fiber);
          dispatchSetStateInternal(fiber, queue, action, args) && startUpdateTimerByLane(args, "setState()", fiber);
        }
        function dispatchSetStateInternal(fiber, queue, action, lane) {
          var update = {
            lane,
            revertLane: 0,
            gesture: null,
            action,
            hasEagerState: false,
            eagerState: null,
            next: null
          };
          if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
          else {
            var alternate = fiber.alternate;
            if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate)) {
              var prevDispatcher = ReactSharedInternals.H;
              ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);
                update.hasEagerState = true;
                update.eagerState = eagerState;
                if (objectIs(eagerState, currentState))
                  return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), false;
              } catch (error) {
              } finally {
                ReactSharedInternals.H = prevDispatcher;
              }
            }
            action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
            if (null !== action)
              return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), true;
          }
          return false;
        }
        function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
          null === ReactSharedInternals.T && 0 === currentEntangledLane && console.error(
            "An optimistic state update occurred outside a transition or action. To fix, move the update to an action, or wrap with startTransition."
          );
          action = {
            lane: 2,
            revertLane: requestTransitionLane(),
            gesture: null,
            action,
            hasEagerState: false,
            eagerState: null,
            next: null
          };
          if (isRenderPhaseUpdate(fiber)) {
            if (throwIfDuringRender)
              throw Error("Cannot update optimistic state while rendering.");
            console.error("Cannot call startTransition while rendering.");
          } else
            throwIfDuringRender = enqueueConcurrentHookUpdate(
              fiber,
              queue,
              action,
              2
            ), null !== throwIfDuringRender && (startUpdateTimerByLane(2, "setOptimistic()", fiber), scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2));
        }
        function isRenderPhaseUpdate(fiber) {
          var alternate = fiber.alternate;
          return fiber === currentlyRenderingFiber || null !== alternate && alternate === currentlyRenderingFiber;
        }
        function enqueueRenderPhaseUpdate(queue, update) {
          didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
          var pending = queue.pending;
          null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
          queue.pending = update;
        }
        function entangleTransitionUpdate(root2, queue, lane) {
          if (0 !== (lane & 4194048)) {
            var queueLanes = queue.lanes;
            queueLanes &= root2.pendingLanes;
            lane |= queueLanes;
            queue.lanes = lane;
            markRootEntangled(root2, lane);
          }
        }
        function warnOnInvalidCallback(callback) {
          if (null !== callback && "function" !== typeof callback) {
            var key = String(callback);
            didWarnOnInvalidCallback.has(key) || (didWarnOnInvalidCallback.add(key), console.error(
              "Expected the last optional `callback` argument to be a function. Instead received: %s.",
              callback
            ));
          }
        }
        function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
          var prevState = workInProgress2.memoizedState, partialState = getDerivedStateFromProps(nextProps, prevState);
          if (workInProgress2.mode & StrictLegacyMode) {
            setIsStrictModeForDevtools(true);
            try {
              partialState = getDerivedStateFromProps(nextProps, prevState);
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          void 0 === partialState && (ctor = getComponentNameFromType(ctor) || "Component", didWarnAboutUndefinedDerivedState.has(ctor) || (didWarnAboutUndefinedDerivedState.add(ctor), console.error(
            "%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.",
            ctor
          )));
          prevState = null === partialState || void 0 === partialState ? prevState : assign({}, prevState, partialState);
          workInProgress2.memoizedState = prevState;
          0 === workInProgress2.lanes && (workInProgress2.updateQueue.baseState = prevState);
        }
        function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
          var instance = workInProgress2.stateNode;
          if ("function" === typeof instance.shouldComponentUpdate) {
            oldProps = instance.shouldComponentUpdate(
              newProps,
              newState,
              nextContext
            );
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                oldProps = instance.shouldComponentUpdate(
                  newProps,
                  newState,
                  nextContext
                );
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            void 0 === oldProps && console.error(
              "%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.",
              getComponentNameFromType(ctor) || "Component"
            );
            return oldProps;
          }
          return ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : true;
        }
        function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
          var oldState = instance.state;
          "function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
          "function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
          instance.state !== oldState && (workInProgress2 = getComponentNameFromFiber(workInProgress2) || "Component", didWarnAboutStateAssignmentForComponent.has(workInProgress2) || (didWarnAboutStateAssignmentForComponent.add(workInProgress2), console.error(
            "%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
            workInProgress2
          )), classComponentUpdater.enqueueReplaceState(
            instance,
            instance.state,
            null
          ));
        }
        function resolveClassComponentProps(Component, baseProps) {
          var newProps = baseProps;
          if ("ref" in baseProps) {
            newProps = {};
            for (var propName in baseProps)
              "ref" !== propName && (newProps[propName] = baseProps[propName]);
          }
          if (Component = Component.defaultProps) {
            newProps === baseProps && (newProps = assign({}, newProps));
            for (var _propName in Component)
              void 0 === newProps[_propName] && (newProps[_propName] = Component[_propName]);
          }
          return newProps;
        }
        function defaultOnUncaughtError(error) {
          reportGlobalError(error);
          console.warn(
            "%s\n\n%s\n",
            componentName ? "An error occurred in the <" + componentName + "> component." : "An error occurred in one of your React components.",
            "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://react.dev/link/error-boundaries to learn more about error boundaries."
          );
        }
        function defaultOnCaughtError(error) {
          var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component." : "The above error occurred in one of your React components.", recreateMessage = "React will try to recreate this component tree from scratch using the error boundary you provided, " + ((errorBoundaryName || "Anonymous") + ".");
          if ("object" === typeof error && null !== error && "string" === typeof error.environmentName) {
            var JSCompiler_inline_result = error.environmentName;
            error = [
              "%o\n\n%s\n\n%s\n",
              error,
              componentNameMessage,
              recreateMessage
            ].slice(0);
            "string" === typeof error[0] ? error.splice(
              0,
              1,
              badgeFormat + " " + error[0],
              badgeStyle,
              pad + JSCompiler_inline_result + pad,
              resetStyle
            ) : error.splice(
              0,
              0,
              badgeFormat,
              badgeStyle,
              pad + JSCompiler_inline_result + pad,
              resetStyle
            );
            error.unshift(console);
            JSCompiler_inline_result = bind.apply(console.error, error);
            JSCompiler_inline_result();
          } else
            console.error(
              "%o\n\n%s\n\n%s\n",
              error,
              componentNameMessage,
              recreateMessage
            );
        }
        function defaultOnRecoverableError(error) {
          reportGlobalError(error);
        }
        function logUncaughtError(root2, errorInfo) {
          try {
            componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;
            errorBoundaryName = null;
            var error = errorInfo.value;
            if (null !== ReactSharedInternals.actQueue)
              ReactSharedInternals.thrownErrors.push(error);
            else {
              var onUncaughtError = root2.onUncaughtError;
              onUncaughtError(error, { componentStack: errorInfo.stack });
            }
          } catch (e$5) {
            setTimeout(function() {
              throw e$5;
            });
          }
        }
        function logCaughtError(root2, boundary, errorInfo) {
          try {
            componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;
            errorBoundaryName = getComponentNameFromFiber(boundary);
            var onCaughtError = root2.onCaughtError;
            onCaughtError(errorInfo.value, {
              componentStack: errorInfo.stack,
              errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
            });
          } catch (e$6) {
            setTimeout(function() {
              throw e$6;
            });
          }
        }
        function createRootErrorUpdate(root2, errorInfo, lane) {
          lane = createUpdate(lane);
          lane.tag = CaptureUpdate;
          lane.payload = { element: null };
          lane.callback = function() {
            runWithFiberInDEV(errorInfo.source, logUncaughtError, root2, errorInfo);
          };
          return lane;
        }
        function createClassErrorUpdate(lane) {
          lane = createUpdate(lane);
          lane.tag = CaptureUpdate;
          return lane;
        }
        function initializeClassErrorUpdate(update, root2, fiber, errorInfo) {
          var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
          if ("function" === typeof getDerivedStateFromError) {
            var error = errorInfo.value;
            update.payload = function() {
              return getDerivedStateFromError(error);
            };
            update.callback = function() {
              markFailedErrorBoundaryForHotReloading(fiber);
              runWithFiberInDEV(
                errorInfo.source,
                logCaughtError,
                root2,
                fiber,
                errorInfo
              );
            };
          }
          var inst = fiber.stateNode;
          null !== inst && "function" === typeof inst.componentDidCatch && (update.callback = function() {
            markFailedErrorBoundaryForHotReloading(fiber);
            runWithFiberInDEV(
              errorInfo.source,
              logCaughtError,
              root2,
              fiber,
              errorInfo
            );
            "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
            callComponentDidCatchInDEV(this, errorInfo);
            "function" === typeof getDerivedStateFromError || 0 === (fiber.lanes & 2) && console.error(
              "%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.",
              getComponentNameFromFiber(fiber) || "Unknown"
            );
          });
        }
        function throwException(root2, returnFiber, sourceFiber, value, rootRenderLanes) {
          sourceFiber.flags |= 32768;
          isDevToolsPresent && restorePendingUpdaters(root2, rootRenderLanes);
          if (null !== value && "object" === typeof value && "function" === typeof value.then) {
            returnFiber = sourceFiber.alternate;
            null !== returnFiber && propagateParentContextChanges(
              returnFiber,
              sourceFiber,
              rootRenderLanes,
              true
            );
            isHydrating && (didSuspendOrErrorDEV = true);
            sourceFiber = suspenseHandlerStackCursor.current;
            if (null !== sourceFiber) {
              switch (sourceFiber.tag) {
                case 31:
                case 13:
                  return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootSuspended), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = /* @__PURE__ */ new Set([value]) : returnFiber.add(value), attachPingListener(root2, value, rootRenderLanes)), false;
                case 22:
                  return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {
                    transitions: null,
                    markerInstances: null,
                    retryQueue: /* @__PURE__ */ new Set([value])
                  }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = /* @__PURE__ */ new Set([value]) : sourceFiber.add(value)), attachPingListener(root2, value, rootRenderLanes)), false;
              }
              throw Error(
                "Unexpected Suspense handler tag (" + sourceFiber.tag + "). This is a bug in React."
              );
            }
            attachPingListener(root2, value, rootRenderLanes);
            renderDidSuspendDelayIfPossible();
            return false;
          }
          if (isHydrating)
            return didSuspendOrErrorDEV = true, returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && queueHydrationError(
              createCapturedValueAtFiber(
                Error(
                  "There was an error while hydrating but React was able to recover by instead client rendering from the nearest Suspense boundary.",
                  { cause: value }
                ),
                sourceFiber
              )
            )) : (value !== HydrationMismatchException && queueHydrationError(
              createCapturedValueAtFiber(
                Error(
                  "There was an error while hydrating but React was able to recover by instead client rendering the entire root.",
                  { cause: value }
                ),
                sourceFiber
              )
            ), root2 = root2.current.alternate, root2.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root2.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(
              root2.stateNode,
              value,
              rootRenderLanes
            ), enqueueCapturedUpdate(root2, rootRenderLanes), workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored)), false;
          var error = createCapturedValueAtFiber(
            Error(
              "There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.",
              { cause: value }
            ),
            sourceFiber
          );
          null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [error] : workInProgressRootConcurrentErrors.push(error);
          workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored);
          if (null === returnFiber) return true;
          value = createCapturedValueAtFiber(value, sourceFiber);
          sourceFiber = returnFiber;
          do {
            switch (sourceFiber.tag) {
              case 3:
                return sourceFiber.flags |= 65536, root2 = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root2, root2 = createRootErrorUpdate(
                  sourceFiber.stateNode,
                  value,
                  root2
                ), enqueueCapturedUpdate(sourceFiber, root2), false;
              case 1:
                if (returnFiber = sourceFiber.type, error = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && ("function" === typeof returnFiber.getDerivedStateFromError || null !== error && "function" === typeof error.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(error))))
                  return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(
                    rootRenderLanes,
                    root2,
                    sourceFiber,
                    value
                  ), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), false;
            }
            sourceFiber = sourceFiber.return;
          } while (null !== sourceFiber);
          return false;
        }
        function reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2) {
          workInProgress2.child = null === current2 ? mountChildFibers(workInProgress2, null, nextChildren, renderLanes2) : reconcileChildFibers(
            workInProgress2,
            current2.child,
            nextChildren,
            renderLanes2
          );
        }
        function updateForwardRef(current2, workInProgress2, Component, nextProps, renderLanes2) {
          Component = Component.render;
          var ref = workInProgress2.ref;
          if ("ref" in nextProps) {
            var propsWithoutRef = {};
            for (var key in nextProps)
              "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
          } else propsWithoutRef = nextProps;
          prepareToReadContext(workInProgress2);
          nextProps = renderWithHooks(
            current2,
            workInProgress2,
            Component,
            propsWithoutRef,
            ref,
            renderLanes2
          );
          key = checkDidRenderIdHook();
          if (null !== current2 && !didReceiveUpdate)
            return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          isHydrating && key && pushMaterializedTreeId(workInProgress2);
          workInProgress2.flags |= 1;
          reconcileChildren(current2, workInProgress2, nextProps, renderLanes2);
          return workInProgress2.child;
        }
        function updateMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
          if (null === current2) {
            var type = Component.type;
            if ("function" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component.compare)
              return Component = resolveFunctionForHotReloading(type), workInProgress2.tag = 15, workInProgress2.type = Component, validateFunctionComponentInDev(workInProgress2, type), updateSimpleMemoComponent(
                current2,
                workInProgress2,
                Component,
                nextProps,
                renderLanes2
              );
            current2 = createFiberFromTypeAndProps(
              Component.type,
              null,
              nextProps,
              workInProgress2,
              workInProgress2.mode,
              renderLanes2
            );
            current2.ref = workInProgress2.ref;
            current2.return = workInProgress2;
            return workInProgress2.child = current2;
          }
          type = current2.child;
          if (!checkScheduledUpdateOrContext(current2, renderLanes2)) {
            var prevProps = type.memoizedProps;
            Component = Component.compare;
            Component = null !== Component ? Component : shallowEqual;
            if (Component(prevProps, nextProps) && current2.ref === workInProgress2.ref)
              return bailoutOnAlreadyFinishedWork(
                current2,
                workInProgress2,
                renderLanes2
              );
          }
          workInProgress2.flags |= 1;
          current2 = createWorkInProgress(type, nextProps);
          current2.ref = workInProgress2.ref;
          current2.return = workInProgress2;
          return workInProgress2.child = current2;
        }
        function updateSimpleMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
          if (null !== current2) {
            var prevProps = current2.memoizedProps;
            if (shallowEqual(prevProps, nextProps) && current2.ref === workInProgress2.ref && workInProgress2.type === current2.type)
              if (didReceiveUpdate = false, workInProgress2.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current2, renderLanes2))
                0 !== (current2.flags & 131072) && (didReceiveUpdate = true);
              else
                return workInProgress2.lanes = current2.lanes, bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          }
          return updateFunctionComponent(
            current2,
            workInProgress2,
            Component,
            nextProps,
            renderLanes2
          );
        }
        function updateOffscreenComponent(current2, workInProgress2, renderLanes2, nextProps) {
          var nextChildren = nextProps.children, prevState = null !== current2 ? current2.memoizedState : null;
          null === current2 && null === workInProgress2.stateNode && (workInProgress2.stateNode = {
            _visibility: OffscreenVisible,
            _pendingMarkers: null,
            _retryCache: null,
            _transitions: null
          });
          if ("hidden" === nextProps.mode) {
            if (0 !== (workInProgress2.flags & 128)) {
              prevState = null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2;
              if (null !== current2) {
                nextProps = workInProgress2.child = current2.child;
                for (nextChildren = 0; null !== nextProps; )
                  nextChildren = nextChildren | nextProps.lanes | nextProps.childLanes, nextProps = nextProps.sibling;
                nextProps = nextChildren & ~prevState;
              } else nextProps = 0, workInProgress2.child = null;
              return deferHiddenOffscreenComponent(
                current2,
                workInProgress2,
                prevState,
                renderLanes2,
                nextProps
              );
            }
            if (0 !== (renderLanes2 & 536870912))
              workInProgress2.memoizedState = { baseLanes: 0, cachePool: null }, null !== current2 && pushTransition(
                workInProgress2,
                null !== prevState ? prevState.cachePool : null
              ), null !== prevState ? pushHiddenContext(workInProgress2, prevState) : reuseHiddenContextOnStack(workInProgress2), pushOffscreenSuspenseHandler(workInProgress2);
            else
              return nextProps = workInProgress2.lanes = 536870912, deferHiddenOffscreenComponent(
                current2,
                workInProgress2,
                null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2,
                renderLanes2,
                nextProps
              );
          } else
            null !== prevState ? (pushTransition(workInProgress2, prevState.cachePool), pushHiddenContext(workInProgress2, prevState), reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.memoizedState = null) : (null !== current2 && pushTransition(workInProgress2, null), reuseHiddenContextOnStack(workInProgress2), reuseSuspenseHandlerOnStack(workInProgress2));
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function bailoutOffscreenComponent(current2, workInProgress2) {
          null !== current2 && 22 === current2.tag || null !== workInProgress2.stateNode || (workInProgress2.stateNode = {
            _visibility: OffscreenVisible,
            _pendingMarkers: null,
            _retryCache: null,
            _transitions: null
          });
          return workInProgress2.sibling;
        }
        function deferHiddenOffscreenComponent(current2, workInProgress2, nextBaseLanes, renderLanes2, remainingChildLanes) {
          var JSCompiler_inline_result = peekCacheFromPool();
          JSCompiler_inline_result = null === JSCompiler_inline_result ? null : {
            parent: CacheContext._currentValue,
            pool: JSCompiler_inline_result
          };
          workInProgress2.memoizedState = {
            baseLanes: nextBaseLanes,
            cachePool: JSCompiler_inline_result
          };
          null !== current2 && pushTransition(workInProgress2, null);
          reuseHiddenContextOnStack(workInProgress2);
          pushOffscreenSuspenseHandler(workInProgress2);
          null !== current2 && propagateParentContextChanges(current2, workInProgress2, renderLanes2, true);
          workInProgress2.childLanes = remainingChildLanes;
          return null;
        }
        function mountActivityChildren(workInProgress2, nextProps) {
          var hiddenProp = nextProps.hidden;
          void 0 !== hiddenProp && console.error(
            `<Activity> doesn't accept a hidden prop. Use mode="hidden" instead.
- <Activity %s>
+ <Activity %s>`,
            true === hiddenProp ? "hidden" : false === hiddenProp ? "hidden={false}" : "hidden={...}",
            hiddenProp ? 'mode="hidden"' : 'mode="visible"'
          );
          nextProps = mountWorkInProgressOffscreenFiber(
            { mode: nextProps.mode, children: nextProps.children },
            workInProgress2.mode
          );
          nextProps.ref = workInProgress2.ref;
          workInProgress2.child = nextProps;
          nextProps.return = workInProgress2;
          return nextProps;
        }
        function retryActivityComponentWithoutHydrating(current2, workInProgress2, renderLanes2) {
          reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
          current2 = mountActivityChildren(
            workInProgress2,
            workInProgress2.pendingProps
          );
          current2.flags |= 2;
          popSuspenseHandler(workInProgress2);
          workInProgress2.memoizedState = null;
          return current2;
        }
        function updateActivityComponent(current2, workInProgress2, renderLanes2) {
          var nextProps = workInProgress2.pendingProps, didSuspend = 0 !== (workInProgress2.flags & 128);
          workInProgress2.flags &= -129;
          if (null === current2) {
            if (isHydrating) {
              if ("hidden" === nextProps.mode)
                return current2 = mountActivityChildren(workInProgress2, nextProps), workInProgress2.lanes = 536870912, bailoutOffscreenComponent(null, current2);
              pushDehydratedActivitySuspenseHandler(workInProgress2);
              (current2 = nextHydratableInstance) ? (renderLanes2 = canHydrateHydrationBoundary(
                current2,
                rootOrSingletonContext
              ), renderLanes2 = null !== renderLanes2 && renderLanes2.data === ACTIVITY_START_DATA ? renderLanes2 : null, null !== renderLanes2 && (nextProps = {
                dehydrated: renderLanes2,
                treeContext: getSuspendedTreeContext(),
                retryLane: 536870912,
                hydrationErrors: null
              }, workInProgress2.memoizedState = nextProps, nextProps = createFiberFromDehydratedFragment(renderLanes2), nextProps.return = workInProgress2, workInProgress2.child = nextProps, hydrationParentFiber = workInProgress2, nextHydratableInstance = null)) : renderLanes2 = null;
              if (null === renderLanes2)
                throw warnNonHydratedInstance(workInProgress2, current2), throwOnHydrationMismatch(workInProgress2);
              workInProgress2.lanes = 536870912;
              return null;
            }
            return mountActivityChildren(workInProgress2, nextProps);
          }
          var prevState = current2.memoizedState;
          if (null !== prevState) {
            var activityInstance = prevState.dehydrated;
            pushDehydratedActivitySuspenseHandler(workInProgress2);
            if (didSuspend)
              if (workInProgress2.flags & 256)
                workInProgress2.flags &= -257, workInProgress2 = retryActivityComponentWithoutHydrating(
                  current2,
                  workInProgress2,
                  renderLanes2
                );
              else if (null !== workInProgress2.memoizedState)
                workInProgress2.child = current2.child, workInProgress2.flags |= 128, workInProgress2 = null;
              else
                throw Error(
                  "Client rendering an Activity suspended it again. This is a bug in React."
                );
            else if (warnIfHydrating(), 0 !== (renderLanes2 & 536870912) && markRenderDerivedCause(workInProgress2), didReceiveUpdate || propagateParentContextChanges(
              current2,
              workInProgress2,
              renderLanes2,
              false
            ), didSuspend = 0 !== (renderLanes2 & current2.childLanes), didReceiveUpdate || didSuspend) {
              nextProps = workInProgressRoot;
              if (null !== nextProps && (activityInstance = getBumpedLaneForHydration(
                nextProps,
                renderLanes2
              ), 0 !== activityInstance && activityInstance !== prevState.retryLane))
                throw prevState.retryLane = activityInstance, enqueueConcurrentRenderForLane(current2, activityInstance), scheduleUpdateOnFiber(nextProps, current2, activityInstance), SelectiveHydrationException;
              renderDidSuspendDelayIfPossible();
              workInProgress2 = retryActivityComponentWithoutHydrating(
                current2,
                workInProgress2,
                renderLanes2
              );
            } else
              current2 = prevState.treeContext, nextHydratableInstance = getNextHydratable(
                activityInstance.nextSibling
              ), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, didSuspendOrErrorDEV = false, hydrationDiffRootDEV = null, rootOrSingletonContext = false, null !== current2 && restoreSuspendedTreeContext(workInProgress2, current2), workInProgress2 = mountActivityChildren(workInProgress2, nextProps), workInProgress2.flags |= 4096;
            return workInProgress2;
          }
          prevState = current2.child;
          nextProps = { mode: nextProps.mode, children: nextProps.children };
          0 !== (renderLanes2 & 536870912) && 0 !== (renderLanes2 & current2.lanes) && markRenderDerivedCause(workInProgress2);
          current2 = createWorkInProgress(prevState, nextProps);
          current2.ref = workInProgress2.ref;
          workInProgress2.child = current2;
          current2.return = workInProgress2;
          return current2;
        }
        function markRef(current2, workInProgress2) {
          var ref = workInProgress2.ref;
          if (null === ref)
            null !== current2 && null !== current2.ref && (workInProgress2.flags |= 4194816);
          else {
            if ("function" !== typeof ref && "object" !== typeof ref)
              throw Error(
                "Expected ref to be a function, an object returned by React.createRef(), or undefined/null."
              );
            if (null === current2 || current2.ref !== ref)
              workInProgress2.flags |= 4194816;
          }
        }
        function updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
          if (Component.prototype && "function" === typeof Component.prototype.render) {
            var componentName2 = getComponentNameFromType(Component) || "Unknown";
            didWarnAboutBadClass[componentName2] || (console.error(
              "The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.",
              componentName2,
              componentName2
            ), didWarnAboutBadClass[componentName2] = true);
          }
          workInProgress2.mode & StrictLegacyMode && ReactStrictModeWarnings.recordLegacyContextWarning(
            workInProgress2,
            null
          );
          null === current2 && (validateFunctionComponentInDev(workInProgress2, workInProgress2.type), Component.contextTypes && (componentName2 = getComponentNameFromType(Component) || "Unknown", didWarnAboutContextTypes[componentName2] || (didWarnAboutContextTypes[componentName2] = true, console.error(
            "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)",
            componentName2
          ))));
          prepareToReadContext(workInProgress2);
          Component = renderWithHooks(
            current2,
            workInProgress2,
            Component,
            nextProps,
            void 0,
            renderLanes2
          );
          nextProps = checkDidRenderIdHook();
          if (null !== current2 && !didReceiveUpdate)
            return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          isHydrating && nextProps && pushMaterializedTreeId(workInProgress2);
          workInProgress2.flags |= 1;
          reconcileChildren(current2, workInProgress2, Component, renderLanes2);
          return workInProgress2.child;
        }
        function replayFunctionComponent(current2, workInProgress2, nextProps, Component, secondArg, renderLanes2) {
          prepareToReadContext(workInProgress2);
          hookTypesUpdateIndexDev = -1;
          ignorePreviousDependencies = null !== current2 && current2.type !== workInProgress2.type;
          workInProgress2.updateQueue = null;
          nextProps = renderWithHooksAgain(
            workInProgress2,
            Component,
            nextProps,
            secondArg
          );
          finishRenderingHooks(current2, workInProgress2);
          Component = checkDidRenderIdHook();
          if (null !== current2 && !didReceiveUpdate)
            return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          isHydrating && Component && pushMaterializedTreeId(workInProgress2);
          workInProgress2.flags |= 1;
          reconcileChildren(current2, workInProgress2, nextProps, renderLanes2);
          return workInProgress2.child;
        }
        function updateClassComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
          switch (shouldErrorImpl(workInProgress2)) {
            case false:
              var _instance = workInProgress2.stateNode, state = new workInProgress2.type(
                workInProgress2.memoizedProps,
                _instance.context
              ).state;
              _instance.updater.enqueueSetState(_instance, state, null);
              break;
            case true:
              workInProgress2.flags |= 128;
              workInProgress2.flags |= 65536;
              _instance = Error("Simulated error coming from DevTools");
              var lane = renderLanes2 & -renderLanes2;
              workInProgress2.lanes |= lane;
              state = workInProgressRoot;
              if (null === state)
                throw Error(
                  "Expected a work-in-progress root. This is a bug in React. Please file an issue."
                );
              lane = createClassErrorUpdate(lane);
              initializeClassErrorUpdate(
                lane,
                state,
                workInProgress2,
                createCapturedValueAtFiber(_instance, workInProgress2)
              );
              enqueueCapturedUpdate(workInProgress2, lane);
          }
          prepareToReadContext(workInProgress2);
          if (null === workInProgress2.stateNode) {
            state = emptyContextObject;
            _instance = Component.contextType;
            "contextType" in Component && null !== _instance && (void 0 === _instance || _instance.$$typeof !== REACT_CONTEXT_TYPE) && !didWarnAboutInvalidateContextType.has(Component) && (didWarnAboutInvalidateContextType.add(Component), lane = void 0 === _instance ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : "object" !== typeof _instance ? " However, it is set to a " + typeof _instance + "." : _instance.$$typeof === REACT_CONSUMER_TYPE ? " Did you accidentally pass the Context.Consumer instead?" : " However, it is set to an object with keys {" + Object.keys(_instance).join(", ") + "}.", console.error(
              "%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s",
              getComponentNameFromType(Component) || "Component",
              lane
            ));
            "object" === typeof _instance && null !== _instance && (state = readContext(_instance));
            _instance = new Component(nextProps, state);
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                _instance = new Component(nextProps, state);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            state = workInProgress2.memoizedState = null !== _instance.state && void 0 !== _instance.state ? _instance.state : null;
            _instance.updater = classComponentUpdater;
            workInProgress2.stateNode = _instance;
            _instance._reactInternals = workInProgress2;
            _instance._reactInternalInstance = fakeInternalInstance;
            "function" === typeof Component.getDerivedStateFromProps && null === state && (state = getComponentNameFromType(Component) || "Component", didWarnAboutUninitializedState.has(state) || (didWarnAboutUninitializedState.add(state), console.error(
              "`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.",
              state,
              null === _instance.state ? "null" : "undefined",
              state
            )));
            if ("function" === typeof Component.getDerivedStateFromProps || "function" === typeof _instance.getSnapshotBeforeUpdate) {
              var foundWillUpdateName = lane = state = null;
              "function" === typeof _instance.componentWillMount && true !== _instance.componentWillMount.__suppressDeprecationWarning ? state = "componentWillMount" : "function" === typeof _instance.UNSAFE_componentWillMount && (state = "UNSAFE_componentWillMount");
              "function" === typeof _instance.componentWillReceiveProps && true !== _instance.componentWillReceiveProps.__suppressDeprecationWarning ? lane = "componentWillReceiveProps" : "function" === typeof _instance.UNSAFE_componentWillReceiveProps && (lane = "UNSAFE_componentWillReceiveProps");
              "function" === typeof _instance.componentWillUpdate && true !== _instance.componentWillUpdate.__suppressDeprecationWarning ? foundWillUpdateName = "componentWillUpdate" : "function" === typeof _instance.UNSAFE_componentWillUpdate && (foundWillUpdateName = "UNSAFE_componentWillUpdate");
              if (null !== state || null !== lane || null !== foundWillUpdateName) {
                _instance = getComponentNameFromType(Component) || "Component";
                var newApiName = "function" === typeof Component.getDerivedStateFromProps ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                didWarnAboutLegacyLifecyclesAndDerivedState.has(_instance) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(_instance), console.error(
                  "Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://react.dev/link/unsafe-component-lifecycles",
                  _instance,
                  newApiName,
                  null !== state ? "\n  " + state : "",
                  null !== lane ? "\n  " + lane : "",
                  null !== foundWillUpdateName ? "\n  " + foundWillUpdateName : ""
                ));
              }
            }
            _instance = workInProgress2.stateNode;
            state = getComponentNameFromType(Component) || "Component";
            _instance.render || (Component.prototype && "function" === typeof Component.prototype.render ? console.error(
              "No `render` method found on the %s instance: did you accidentally return an object from the constructor?",
              state
            ) : console.error(
              "No `render` method found on the %s instance: you may have forgotten to define `render`.",
              state
            ));
            !_instance.getInitialState || _instance.getInitialState.isReactClassApproved || _instance.state || console.error(
              "getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?",
              state
            );
            _instance.getDefaultProps && !_instance.getDefaultProps.isReactClassApproved && console.error(
              "getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.",
              state
            );
            _instance.contextType && console.error(
              "contextType was defined as an instance property on %s. Use a static property to define contextType instead.",
              state
            );
            Component.childContextTypes && !didWarnAboutChildContextTypes.has(Component) && (didWarnAboutChildContextTypes.add(Component), console.error(
              "%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)",
              state
            ));
            Component.contextTypes && !didWarnAboutContextTypes$1.has(Component) && (didWarnAboutContextTypes$1.add(Component), console.error(
              "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)",
              state
            ));
            "function" === typeof _instance.componentShouldUpdate && console.error(
              "%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.",
              state
            );
            Component.prototype && Component.prototype.isPureReactComponent && "undefined" !== typeof _instance.shouldComponentUpdate && console.error(
              "%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.",
              getComponentNameFromType(Component) || "A pure component"
            );
            "function" === typeof _instance.componentDidUnmount && console.error(
              "%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?",
              state
            );
            "function" === typeof _instance.componentDidReceiveProps && console.error(
              "%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().",
              state
            );
            "function" === typeof _instance.componentWillRecieveProps && console.error(
              "%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",
              state
            );
            "function" === typeof _instance.UNSAFE_componentWillRecieveProps && console.error(
              "%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?",
              state
            );
            lane = _instance.props !== nextProps;
            void 0 !== _instance.props && lane && console.error(
              "When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.",
              state
            );
            _instance.defaultProps && console.error(
              "Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.",
              state,
              state
            );
            "function" !== typeof _instance.getSnapshotBeforeUpdate || "function" === typeof _instance.componentDidUpdate || didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(Component) || (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(Component), console.error(
              "%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.",
              getComponentNameFromType(Component)
            ));
            "function" === typeof _instance.getDerivedStateFromProps && console.error(
              "%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
              state
            );
            "function" === typeof _instance.getDerivedStateFromError && console.error(
              "%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
              state
            );
            "function" === typeof Component.getSnapshotBeforeUpdate && console.error(
              "%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.",
              state
            );
            (lane = _instance.state) && ("object" !== typeof lane || isArrayImpl(lane)) && console.error("%s.state: must be set to an object or null", state);
            "function" === typeof _instance.getChildContext && "object" !== typeof Component.childContextTypes && console.error(
              "%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().",
              state
            );
            _instance = workInProgress2.stateNode;
            _instance.props = nextProps;
            _instance.state = workInProgress2.memoizedState;
            _instance.refs = {};
            initializeUpdateQueue(workInProgress2);
            state = Component.contextType;
            _instance.context = "object" === typeof state && null !== state ? readContext(state) : emptyContextObject;
            _instance.state === nextProps && (state = getComponentNameFromType(Component) || "Component", didWarnAboutDirectlyAssigningPropsToState.has(state) || (didWarnAboutDirectlyAssigningPropsToState.add(state), console.error(
              "%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.",
              state
            )));
            workInProgress2.mode & StrictLegacyMode && ReactStrictModeWarnings.recordLegacyContextWarning(
              workInProgress2,
              _instance
            );
            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(
              workInProgress2,
              _instance
            );
            _instance.state = workInProgress2.memoizedState;
            state = Component.getDerivedStateFromProps;
            "function" === typeof state && (applyDerivedStateFromProps(
              workInProgress2,
              Component,
              state,
              nextProps
            ), _instance.state = workInProgress2.memoizedState);
            "function" === typeof Component.getDerivedStateFromProps || "function" === typeof _instance.getSnapshotBeforeUpdate || "function" !== typeof _instance.UNSAFE_componentWillMount && "function" !== typeof _instance.componentWillMount || (state = _instance.state, "function" === typeof _instance.componentWillMount && _instance.componentWillMount(), "function" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount(), state !== _instance.state && (console.error(
              "%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
              getComponentNameFromFiber(workInProgress2) || "Component"
            ), classComponentUpdater.enqueueReplaceState(
              _instance,
              _instance.state,
              null
            )), processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction(), _instance.state = workInProgress2.memoizedState);
            "function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308);
            (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728);
            _instance = true;
          } else if (null === current2) {
            _instance = workInProgress2.stateNode;
            var unresolvedOldProps = workInProgress2.memoizedProps;
            lane = resolveClassComponentProps(Component, unresolvedOldProps);
            _instance.props = lane;
            var oldContext = _instance.context;
            foundWillUpdateName = Component.contextType;
            state = emptyContextObject;
            "object" === typeof foundWillUpdateName && null !== foundWillUpdateName && (state = readContext(foundWillUpdateName));
            newApiName = Component.getDerivedStateFromProps;
            foundWillUpdateName = "function" === typeof newApiName || "function" === typeof _instance.getSnapshotBeforeUpdate;
            unresolvedOldProps = workInProgress2.pendingProps !== unresolvedOldProps;
            foundWillUpdateName || "function" !== typeof _instance.UNSAFE_componentWillReceiveProps && "function" !== typeof _instance.componentWillReceiveProps || (unresolvedOldProps || oldContext !== state) && callComponentWillReceiveProps(
              workInProgress2,
              _instance,
              nextProps,
              state
            );
            hasForceUpdate = false;
            var oldState = workInProgress2.memoizedState;
            _instance.state = oldState;
            processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2);
            suspendIfUpdateReadFromEntangledAsyncAction();
            oldContext = workInProgress2.memoizedState;
            unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? ("function" === typeof newApiName && (applyDerivedStateFromProps(
              workInProgress2,
              Component,
              newApiName,
              nextProps
            ), oldContext = workInProgress2.memoizedState), (lane = hasForceUpdate || checkShouldComponentUpdate(
              workInProgress2,
              Component,
              lane,
              nextProps,
              oldState,
              oldContext,
              state
            )) ? (foundWillUpdateName || "function" !== typeof _instance.UNSAFE_componentWillMount && "function" !== typeof _instance.componentWillMount || ("function" === typeof _instance.componentWillMount && _instance.componentWillMount(), "function" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount()), "function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308), (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728)) : ("function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308), (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = oldContext), _instance.props = nextProps, _instance.state = oldContext, _instance.context = state, _instance = lane) : ("function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308), (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728), _instance = false);
          } else {
            _instance = workInProgress2.stateNode;
            cloneUpdateQueue(current2, workInProgress2);
            state = workInProgress2.memoizedProps;
            foundWillUpdateName = resolveClassComponentProps(Component, state);
            _instance.props = foundWillUpdateName;
            newApiName = workInProgress2.pendingProps;
            oldState = _instance.context;
            oldContext = Component.contextType;
            lane = emptyContextObject;
            "object" === typeof oldContext && null !== oldContext && (lane = readContext(oldContext));
            unresolvedOldProps = Component.getDerivedStateFromProps;
            (oldContext = "function" === typeof unresolvedOldProps || "function" === typeof _instance.getSnapshotBeforeUpdate) || "function" !== typeof _instance.UNSAFE_componentWillReceiveProps && "function" !== typeof _instance.componentWillReceiveProps || (state !== newApiName || oldState !== lane) && callComponentWillReceiveProps(
              workInProgress2,
              _instance,
              nextProps,
              lane
            );
            hasForceUpdate = false;
            oldState = workInProgress2.memoizedState;
            _instance.state = oldState;
            processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2);
            suspendIfUpdateReadFromEntangledAsyncAction();
            var newState = workInProgress2.memoizedState;
            state !== newApiName || oldState !== newState || hasForceUpdate || null !== current2 && null !== current2.dependencies && checkIfContextChanged(current2.dependencies) ? ("function" === typeof unresolvedOldProps && (applyDerivedStateFromProps(
              workInProgress2,
              Component,
              unresolvedOldProps,
              nextProps
            ), newState = workInProgress2.memoizedState), (foundWillUpdateName = hasForceUpdate || checkShouldComponentUpdate(
              workInProgress2,
              Component,
              foundWillUpdateName,
              nextProps,
              oldState,
              newState,
              lane
            ) || null !== current2 && null !== current2.dependencies && checkIfContextChanged(current2.dependencies)) ? (oldContext || "function" !== typeof _instance.UNSAFE_componentWillUpdate && "function" !== typeof _instance.componentWillUpdate || ("function" === typeof _instance.componentWillUpdate && _instance.componentWillUpdate(nextProps, newState, lane), "function" === typeof _instance.UNSAFE_componentWillUpdate && _instance.UNSAFE_componentWillUpdate(
              nextProps,
              newState,
              lane
            )), "function" === typeof _instance.componentDidUpdate && (workInProgress2.flags |= 4), "function" === typeof _instance.getSnapshotBeforeUpdate && (workInProgress2.flags |= 1024)) : ("function" !== typeof _instance.componentDidUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof _instance.getSnapshotBeforeUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 1024), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = newState), _instance.props = nextProps, _instance.state = newState, _instance.context = lane, _instance = foundWillUpdateName) : ("function" !== typeof _instance.componentDidUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof _instance.getSnapshotBeforeUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 1024), _instance = false);
          }
          lane = _instance;
          markRef(current2, workInProgress2);
          state = 0 !== (workInProgress2.flags & 128);
          if (lane || state) {
            lane = workInProgress2.stateNode;
            setCurrentFiber(workInProgress2);
            if (state && "function" !== typeof Component.getDerivedStateFromError)
              Component = null, profilerStartTime = -1;
            else if (Component = callRenderInDEV(lane), workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                callRenderInDEV(lane);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            workInProgress2.flags |= 1;
            null !== current2 && state ? (workInProgress2.child = reconcileChildFibers(
              workInProgress2,
              current2.child,
              null,
              renderLanes2
            ), workInProgress2.child = reconcileChildFibers(
              workInProgress2,
              null,
              Component,
              renderLanes2
            )) : reconcileChildren(current2, workInProgress2, Component, renderLanes2);
            workInProgress2.memoizedState = lane.state;
            current2 = workInProgress2.child;
          } else
            current2 = bailoutOnAlreadyFinishedWork(
              current2,
              workInProgress2,
              renderLanes2
            );
          renderLanes2 = workInProgress2.stateNode;
          _instance && renderLanes2.props !== nextProps && (didWarnAboutReassigningProps || console.error(
            "It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.",
            getComponentNameFromFiber(workInProgress2) || "a component"
          ), didWarnAboutReassigningProps = true);
          return current2;
        }
        function mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2) {
          resetHydrationState();
          workInProgress2.flags |= 256;
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function validateFunctionComponentInDev(workInProgress2, Component) {
          Component && Component.childContextTypes && console.error(
            "childContextTypes cannot be defined on a function component.\n  %s.childContextTypes = ...",
            Component.displayName || Component.name || "Component"
          );
          "function" === typeof Component.getDerivedStateFromProps && (workInProgress2 = getComponentNameFromType(Component) || "Unknown", didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress2] || (console.error(
            "%s: Function components do not support getDerivedStateFromProps.",
            workInProgress2
          ), didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress2] = true));
          "object" === typeof Component.contextType && null !== Component.contextType && (Component = getComponentNameFromType(Component) || "Unknown", didWarnAboutContextTypeOnFunctionComponent[Component] || (console.error(
            "%s: Function components do not support contextType.",
            Component
          ), didWarnAboutContextTypeOnFunctionComponent[Component] = true));
        }
        function mountSuspenseOffscreenState(renderLanes2) {
          return { baseLanes: renderLanes2, cachePool: getSuspendedCache() };
        }
        function getRemainingWorkInPrimaryTree(current2, primaryTreeDidDefer, renderLanes2) {
          current2 = null !== current2 ? current2.childLanes & ~renderLanes2 : 0;
          primaryTreeDidDefer && (current2 |= workInProgressDeferredLane);
          return current2;
        }
        function updateSuspenseComponent(current2, workInProgress2, renderLanes2) {
          var JSCompiler_object_inline_digest_2724;
          var JSCompiler_object_inline_stack_2725 = workInProgress2.pendingProps;
          shouldSuspendImpl(workInProgress2) && (workInProgress2.flags |= 128);
          var JSCompiler_object_inline_message_2723 = false;
          var didSuspend = 0 !== (workInProgress2.flags & 128);
          (JSCompiler_object_inline_digest_2724 = didSuspend) || (JSCompiler_object_inline_digest_2724 = null !== current2 && null === current2.memoizedState ? false : 0 !== (suspenseStackCursor.current & ForceSuspenseFallback));
          JSCompiler_object_inline_digest_2724 && (JSCompiler_object_inline_message_2723 = true, workInProgress2.flags &= -129);
          JSCompiler_object_inline_digest_2724 = 0 !== (workInProgress2.flags & 32);
          workInProgress2.flags &= -33;
          if (null === current2) {
            if (isHydrating) {
              JSCompiler_object_inline_message_2723 ? pushPrimaryTreeSuspenseHandler(workInProgress2) : reuseSuspenseHandlerOnStack(workInProgress2);
              (current2 = nextHydratableInstance) ? (renderLanes2 = canHydrateHydrationBoundary(
                current2,
                rootOrSingletonContext
              ), renderLanes2 = null !== renderLanes2 && renderLanes2.data !== ACTIVITY_START_DATA ? renderLanes2 : null, null !== renderLanes2 && (JSCompiler_object_inline_digest_2724 = {
                dehydrated: renderLanes2,
                treeContext: getSuspendedTreeContext(),
                retryLane: 536870912,
                hydrationErrors: null
              }, workInProgress2.memoizedState = JSCompiler_object_inline_digest_2724, JSCompiler_object_inline_digest_2724 = createFiberFromDehydratedFragment(renderLanes2), JSCompiler_object_inline_digest_2724.return = workInProgress2, workInProgress2.child = JSCompiler_object_inline_digest_2724, hydrationParentFiber = workInProgress2, nextHydratableInstance = null)) : renderLanes2 = null;
              if (null === renderLanes2)
                throw warnNonHydratedInstance(workInProgress2, current2), throwOnHydrationMismatch(workInProgress2);
              isSuspenseInstanceFallback(renderLanes2) ? workInProgress2.lanes = 32 : workInProgress2.lanes = 536870912;
              return null;
            }
            var nextPrimaryChildren = JSCompiler_object_inline_stack_2725.children;
            JSCompiler_object_inline_stack_2725 = JSCompiler_object_inline_stack_2725.fallback;
            if (JSCompiler_object_inline_message_2723) {
              reuseSuspenseHandlerOnStack(workInProgress2);
              var mode = workInProgress2.mode;
              nextPrimaryChildren = mountWorkInProgressOffscreenFiber(
                { mode: "hidden", children: nextPrimaryChildren },
                mode
              );
              JSCompiler_object_inline_stack_2725 = createFiberFromFragment(
                JSCompiler_object_inline_stack_2725,
                mode,
                renderLanes2,
                null
              );
              nextPrimaryChildren.return = workInProgress2;
              JSCompiler_object_inline_stack_2725.return = workInProgress2;
              nextPrimaryChildren.sibling = JSCompiler_object_inline_stack_2725;
              workInProgress2.child = nextPrimaryChildren;
              JSCompiler_object_inline_stack_2725 = workInProgress2.child;
              JSCompiler_object_inline_stack_2725.memoizedState = mountSuspenseOffscreenState(renderLanes2);
              JSCompiler_object_inline_stack_2725.childLanes = getRemainingWorkInPrimaryTree(
                current2,
                JSCompiler_object_inline_digest_2724,
                renderLanes2
              );
              workInProgress2.memoizedState = SUSPENDED_MARKER;
              return bailoutOffscreenComponent(
                null,
                JSCompiler_object_inline_stack_2725
              );
            }
            pushPrimaryTreeSuspenseHandler(workInProgress2);
            return mountSuspensePrimaryChildren(
              workInProgress2,
              nextPrimaryChildren
            );
          }
          var prevState = current2.memoizedState;
          if (null !== prevState) {
            var JSCompiler_object_inline_componentStack_2726 = prevState.dehydrated;
            if (null !== JSCompiler_object_inline_componentStack_2726) {
              if (didSuspend)
                workInProgress2.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags &= -257, workInProgress2 = retrySuspenseComponentWithoutHydrating(
                  current2,
                  workInProgress2,
                  renderLanes2
                )) : null !== workInProgress2.memoizedState ? (reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.child = current2.child, workInProgress2.flags |= 128, workInProgress2 = null) : (reuseSuspenseHandlerOnStack(workInProgress2), nextPrimaryChildren = JSCompiler_object_inline_stack_2725.fallback, mode = workInProgress2.mode, JSCompiler_object_inline_stack_2725 = mountWorkInProgressOffscreenFiber(
                  {
                    mode: "visible",
                    children: JSCompiler_object_inline_stack_2725.children
                  },
                  mode
                ), nextPrimaryChildren = createFiberFromFragment(
                  nextPrimaryChildren,
                  mode,
                  renderLanes2,
                  null
                ), nextPrimaryChildren.flags |= 2, JSCompiler_object_inline_stack_2725.return = workInProgress2, nextPrimaryChildren.return = workInProgress2, JSCompiler_object_inline_stack_2725.sibling = nextPrimaryChildren, workInProgress2.child = JSCompiler_object_inline_stack_2725, reconcileChildFibers(
                  workInProgress2,
                  current2.child,
                  null,
                  renderLanes2
                ), JSCompiler_object_inline_stack_2725 = workInProgress2.child, JSCompiler_object_inline_stack_2725.memoizedState = mountSuspenseOffscreenState(renderLanes2), JSCompiler_object_inline_stack_2725.childLanes = getRemainingWorkInPrimaryTree(
                  current2,
                  JSCompiler_object_inline_digest_2724,
                  renderLanes2
                ), workInProgress2.memoizedState = SUSPENDED_MARKER, workInProgress2 = bailoutOffscreenComponent(
                  null,
                  JSCompiler_object_inline_stack_2725
                ));
              else if (pushPrimaryTreeSuspenseHandler(workInProgress2), warnIfHydrating(), 0 !== (renderLanes2 & 536870912) && markRenderDerivedCause(workInProgress2), isSuspenseInstanceFallback(
                JSCompiler_object_inline_componentStack_2726
              )) {
                JSCompiler_object_inline_digest_2724 = JSCompiler_object_inline_componentStack_2726.nextSibling && JSCompiler_object_inline_componentStack_2726.nextSibling.dataset;
                if (JSCompiler_object_inline_digest_2724) {
                  nextPrimaryChildren = JSCompiler_object_inline_digest_2724.dgst;
                  var message = JSCompiler_object_inline_digest_2724.msg;
                  mode = JSCompiler_object_inline_digest_2724.stck;
                  var componentStack = JSCompiler_object_inline_digest_2724.cstck;
                }
                JSCompiler_object_inline_message_2723 = message;
                JSCompiler_object_inline_digest_2724 = nextPrimaryChildren;
                JSCompiler_object_inline_stack_2725 = mode;
                JSCompiler_object_inline_componentStack_2726 = componentStack;
                nextPrimaryChildren = JSCompiler_object_inline_message_2723;
                mode = JSCompiler_object_inline_componentStack_2726;
                nextPrimaryChildren = nextPrimaryChildren ? Error(nextPrimaryChildren) : Error(
                  "The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering."
                );
                nextPrimaryChildren.stack = JSCompiler_object_inline_stack_2725 || "";
                nextPrimaryChildren.digest = JSCompiler_object_inline_digest_2724;
                JSCompiler_object_inline_digest_2724 = void 0 === mode ? null : mode;
                JSCompiler_object_inline_stack_2725 = {
                  value: nextPrimaryChildren,
                  source: null,
                  stack: JSCompiler_object_inline_digest_2724
                };
                "string" === typeof JSCompiler_object_inline_digest_2724 && CapturedStacks.set(
                  nextPrimaryChildren,
                  JSCompiler_object_inline_stack_2725
                );
                queueHydrationError(JSCompiler_object_inline_stack_2725);
                workInProgress2 = retrySuspenseComponentWithoutHydrating(
                  current2,
                  workInProgress2,
                  renderLanes2
                );
              } else if (didReceiveUpdate || propagateParentContextChanges(
                current2,
                workInProgress2,
                renderLanes2,
                false
              ), JSCompiler_object_inline_digest_2724 = 0 !== (renderLanes2 & current2.childLanes), didReceiveUpdate || JSCompiler_object_inline_digest_2724) {
                JSCompiler_object_inline_digest_2724 = workInProgressRoot;
                if (null !== JSCompiler_object_inline_digest_2724 && (JSCompiler_object_inline_stack_2725 = getBumpedLaneForHydration(
                  JSCompiler_object_inline_digest_2724,
                  renderLanes2
                ), 0 !== JSCompiler_object_inline_stack_2725 && JSCompiler_object_inline_stack_2725 !== prevState.retryLane))
                  throw prevState.retryLane = JSCompiler_object_inline_stack_2725, enqueueConcurrentRenderForLane(
                    current2,
                    JSCompiler_object_inline_stack_2725
                  ), scheduleUpdateOnFiber(
                    JSCompiler_object_inline_digest_2724,
                    current2,
                    JSCompiler_object_inline_stack_2725
                  ), SelectiveHydrationException;
                isSuspenseInstancePending(
                  JSCompiler_object_inline_componentStack_2726
                ) || renderDidSuspendDelayIfPossible();
                workInProgress2 = retrySuspenseComponentWithoutHydrating(
                  current2,
                  workInProgress2,
                  renderLanes2
                );
              } else
                isSuspenseInstancePending(
                  JSCompiler_object_inline_componentStack_2726
                ) ? (workInProgress2.flags |= 192, workInProgress2.child = current2.child, workInProgress2 = null) : (current2 = prevState.treeContext, nextHydratableInstance = getNextHydratable(
                  JSCompiler_object_inline_componentStack_2726.nextSibling
                ), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, didSuspendOrErrorDEV = false, hydrationDiffRootDEV = null, rootOrSingletonContext = false, null !== current2 && restoreSuspendedTreeContext(workInProgress2, current2), workInProgress2 = mountSuspensePrimaryChildren(
                  workInProgress2,
                  JSCompiler_object_inline_stack_2725.children
                ), workInProgress2.flags |= 4096);
              return workInProgress2;
            }
          }
          if (JSCompiler_object_inline_message_2723)
            return reuseSuspenseHandlerOnStack(workInProgress2), nextPrimaryChildren = JSCompiler_object_inline_stack_2725.fallback, mode = workInProgress2.mode, componentStack = current2.child, JSCompiler_object_inline_componentStack_2726 = componentStack.sibling, JSCompiler_object_inline_stack_2725 = createWorkInProgress(
              componentStack,
              {
                mode: "hidden",
                children: JSCompiler_object_inline_stack_2725.children
              }
            ), JSCompiler_object_inline_stack_2725.subtreeFlags = componentStack.subtreeFlags & 65011712, null !== JSCompiler_object_inline_componentStack_2726 ? nextPrimaryChildren = createWorkInProgress(
              JSCompiler_object_inline_componentStack_2726,
              nextPrimaryChildren
            ) : (nextPrimaryChildren = createFiberFromFragment(
              nextPrimaryChildren,
              mode,
              renderLanes2,
              null
            ), nextPrimaryChildren.flags |= 2), nextPrimaryChildren.return = workInProgress2, JSCompiler_object_inline_stack_2725.return = workInProgress2, JSCompiler_object_inline_stack_2725.sibling = nextPrimaryChildren, workInProgress2.child = JSCompiler_object_inline_stack_2725, bailoutOffscreenComponent(null, JSCompiler_object_inline_stack_2725), JSCompiler_object_inline_stack_2725 = workInProgress2.child, nextPrimaryChildren = current2.child.memoizedState, null === nextPrimaryChildren ? nextPrimaryChildren = mountSuspenseOffscreenState(renderLanes2) : (mode = nextPrimaryChildren.cachePool, null !== mode ? (componentStack = CacheContext._currentValue, mode = mode.parent !== componentStack ? { parent: componentStack, pool: componentStack } : mode) : mode = getSuspendedCache(), nextPrimaryChildren = {
              baseLanes: nextPrimaryChildren.baseLanes | renderLanes2,
              cachePool: mode
            }), JSCompiler_object_inline_stack_2725.memoizedState = nextPrimaryChildren, JSCompiler_object_inline_stack_2725.childLanes = getRemainingWorkInPrimaryTree(
              current2,
              JSCompiler_object_inline_digest_2724,
              renderLanes2
            ), workInProgress2.memoizedState = SUSPENDED_MARKER, bailoutOffscreenComponent(
              current2.child,
              JSCompiler_object_inline_stack_2725
            );
          null !== prevState && (renderLanes2 & 62914560) === renderLanes2 && 0 !== (renderLanes2 & current2.lanes) && markRenderDerivedCause(workInProgress2);
          pushPrimaryTreeSuspenseHandler(workInProgress2);
          renderLanes2 = current2.child;
          current2 = renderLanes2.sibling;
          renderLanes2 = createWorkInProgress(renderLanes2, {
            mode: "visible",
            children: JSCompiler_object_inline_stack_2725.children
          });
          renderLanes2.return = workInProgress2;
          renderLanes2.sibling = null;
          null !== current2 && (JSCompiler_object_inline_digest_2724 = workInProgress2.deletions, null === JSCompiler_object_inline_digest_2724 ? (workInProgress2.deletions = [current2], workInProgress2.flags |= 16) : JSCompiler_object_inline_digest_2724.push(current2));
          workInProgress2.child = renderLanes2;
          workInProgress2.memoizedState = null;
          return renderLanes2;
        }
        function mountSuspensePrimaryChildren(workInProgress2, primaryChildren) {
          primaryChildren = mountWorkInProgressOffscreenFiber(
            { mode: "visible", children: primaryChildren },
            workInProgress2.mode
          );
          primaryChildren.return = workInProgress2;
          return workInProgress2.child = primaryChildren;
        }
        function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
          offscreenProps = createFiber(22, offscreenProps, null, mode);
          offscreenProps.lanes = 0;
          return offscreenProps;
        }
        function retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2) {
          reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
          current2 = mountSuspensePrimaryChildren(
            workInProgress2,
            workInProgress2.pendingProps.children
          );
          current2.flags |= 2;
          workInProgress2.memoizedState = null;
          return current2;
        }
        function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
          fiber.lanes |= renderLanes2;
          var alternate = fiber.alternate;
          null !== alternate && (alternate.lanes |= renderLanes2);
          scheduleContextWorkOnParentPath(
            fiber.return,
            renderLanes2,
            propagationRoot
          );
        }
        function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode, treeForkCount2) {
          var renderState = workInProgress2.memoizedState;
          null === renderState ? workInProgress2.memoizedState = {
            isBackwards,
            rendering: null,
            renderingStartTime: 0,
            last: lastContentRow,
            tail,
            tailMode,
            treeForkCount: treeForkCount2
          } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode, renderState.treeForkCount = treeForkCount2);
        }
        function updateSuspenseListComponent(current2, workInProgress2, renderLanes2) {
          var nextProps = workInProgress2.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail, newChildren = nextProps.children, suspenseContext = suspenseStackCursor.current;
          (nextProps = 0 !== (suspenseContext & ForceSuspenseFallback)) ? (suspenseContext = suspenseContext & SubtreeSuspenseContextMask | ForceSuspenseFallback, workInProgress2.flags |= 128) : suspenseContext &= SubtreeSuspenseContextMask;
          push(suspenseStackCursor, suspenseContext, workInProgress2);
          suspenseContext = null == revealOrder ? "null" : revealOrder;
          if ("forwards" !== revealOrder && "unstable_legacy-backwards" !== revealOrder && "together" !== revealOrder && "independent" !== revealOrder && !didWarnAboutRevealOrder[suspenseContext])
            if (didWarnAboutRevealOrder[suspenseContext] = true, null == revealOrder)
              console.error(
                'The default for the <SuspenseList revealOrder="..."> prop is changing. To be future compatible you must explictly specify either "independent" (the current default), "together", "forwards" or "legacy_unstable-backwards".'
              );
            else if ("backwards" === revealOrder)
              console.error(
                'The rendering order of <SuspenseList revealOrder="backwards"> is changing. To be future compatible you must specify revealOrder="legacy_unstable-backwards" instead.'
              );
            else if ("string" === typeof revealOrder)
              switch (revealOrder.toLowerCase()) {
                case "together":
                case "forwards":
                case "backwards":
                case "independent":
                  console.error(
                    '"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.',
                    revealOrder,
                    revealOrder.toLowerCase()
                  );
                  break;
                case "forward":
                case "backward":
                  console.error(
                    '"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.',
                    revealOrder,
                    revealOrder.toLowerCase()
                  );
                  break;
                default:
                  console.error(
                    '"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "independent", "together", "forwards" or "backwards"?',
                    revealOrder
                  );
              }
            else
              console.error(
                '%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "independent", "together", "forwards" or "backwards"?',
                revealOrder
              );
          suspenseContext = null == tailMode ? "null" : tailMode;
          if (!didWarnAboutTailOptions[suspenseContext])
            if (null == tailMode) {
              if ("forwards" === revealOrder || "backwards" === revealOrder || "unstable_legacy-backwards" === revealOrder)
                didWarnAboutTailOptions[suspenseContext] = true, console.error(
                  'The default for the <SuspenseList tail="..."> prop is changing. To be future compatible you must explictly specify either "visible" (the current default), "collapsed" or "hidden".'
                );
            } else
              "visible" !== tailMode && "collapsed" !== tailMode && "hidden" !== tailMode ? (didWarnAboutTailOptions[suspenseContext] = true, console.error(
                '"%s" is not a supported value for tail on <SuspenseList />. Did you mean "visible", "collapsed" or "hidden"?',
                tailMode
              )) : "forwards" !== revealOrder && "backwards" !== revealOrder && "unstable_legacy-backwards" !== revealOrder && (didWarnAboutTailOptions[suspenseContext] = true, console.error(
                '<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?',
                tailMode
              ));
          a: if (("forwards" === revealOrder || "backwards" === revealOrder || "unstable_legacy-backwards" === revealOrder) && void 0 !== newChildren && null !== newChildren && false !== newChildren)
            if (isArrayImpl(newChildren))
              for (suspenseContext = 0; suspenseContext < newChildren.length; suspenseContext++) {
                if (!validateSuspenseListNestedChild(
                  newChildren[suspenseContext],
                  suspenseContext
                ))
                  break a;
              }
            else if (suspenseContext = getIteratorFn(newChildren), "function" === typeof suspenseContext) {
              if (suspenseContext = suspenseContext.call(newChildren))
                for (var step = suspenseContext.next(), _i = 0; !step.done; step = suspenseContext.next()) {
                  if (!validateSuspenseListNestedChild(step.value, _i)) break a;
                  _i++;
                }
            } else
              console.error(
                'A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?',
                revealOrder
              );
          reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
          isHydrating ? (warnIfNotHydrating(), newChildren = treeForkCount) : newChildren = 0;
          if (!nextProps && null !== current2 && 0 !== (current2.flags & 128))
            a: for (current2 = workInProgress2.child; null !== current2; ) {
              if (13 === current2.tag)
                null !== current2.memoizedState && scheduleSuspenseWorkOnFiber(current2, renderLanes2, workInProgress2);
              else if (19 === current2.tag)
                scheduleSuspenseWorkOnFiber(current2, renderLanes2, workInProgress2);
              else if (null !== current2.child) {
                current2.child.return = current2;
                current2 = current2.child;
                continue;
              }
              if (current2 === workInProgress2) break a;
              for (; null === current2.sibling; ) {
                if (null === current2.return || current2.return === workInProgress2)
                  break a;
                current2 = current2.return;
              }
              current2.sibling.return = current2.return;
              current2 = current2.sibling;
            }
          switch (revealOrder) {
            case "forwards":
              renderLanes2 = workInProgress2.child;
              for (revealOrder = null; null !== renderLanes2; )
                current2 = renderLanes2.alternate, null !== current2 && null === findFirstSuspended(current2) && (revealOrder = renderLanes2), renderLanes2 = renderLanes2.sibling;
              renderLanes2 = revealOrder;
              null === renderLanes2 ? (revealOrder = workInProgress2.child, workInProgress2.child = null) : (revealOrder = renderLanes2.sibling, renderLanes2.sibling = null);
              initSuspenseListRenderState(
                workInProgress2,
                false,
                revealOrder,
                renderLanes2,
                tailMode,
                newChildren
              );
              break;
            case "backwards":
            case "unstable_legacy-backwards":
              renderLanes2 = null;
              revealOrder = workInProgress2.child;
              for (workInProgress2.child = null; null !== revealOrder; ) {
                current2 = revealOrder.alternate;
                if (null !== current2 && null === findFirstSuspended(current2)) {
                  workInProgress2.child = revealOrder;
                  break;
                }
                current2 = revealOrder.sibling;
                revealOrder.sibling = renderLanes2;
                renderLanes2 = revealOrder;
                revealOrder = current2;
              }
              initSuspenseListRenderState(
                workInProgress2,
                true,
                renderLanes2,
                null,
                tailMode,
                newChildren
              );
              break;
            case "together":
              initSuspenseListRenderState(
                workInProgress2,
                false,
                null,
                null,
                void 0,
                newChildren
              );
              break;
            default:
              workInProgress2.memoizedState = null;
          }
          return workInProgress2.child;
        }
        function bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2) {
          null !== current2 && (workInProgress2.dependencies = current2.dependencies);
          profilerStartTime = -1;
          workInProgressRootSkippedLanes |= workInProgress2.lanes;
          if (0 === (renderLanes2 & workInProgress2.childLanes))
            if (null !== current2) {
              if (propagateParentContextChanges(
                current2,
                workInProgress2,
                renderLanes2,
                false
              ), 0 === (renderLanes2 & workInProgress2.childLanes))
                return null;
            } else return null;
          if (null !== current2 && workInProgress2.child !== current2.child)
            throw Error("Resuming work not yet implemented.");
          if (null !== workInProgress2.child) {
            current2 = workInProgress2.child;
            renderLanes2 = createWorkInProgress(current2, current2.pendingProps);
            workInProgress2.child = renderLanes2;
            for (renderLanes2.return = workInProgress2; null !== current2.sibling; )
              current2 = current2.sibling, renderLanes2 = renderLanes2.sibling = createWorkInProgress(current2, current2.pendingProps), renderLanes2.return = workInProgress2;
            renderLanes2.sibling = null;
          }
          return workInProgress2.child;
        }
        function checkScheduledUpdateOrContext(current2, renderLanes2) {
          if (0 !== (current2.lanes & renderLanes2)) return true;
          current2 = current2.dependencies;
          return null !== current2 && checkIfContextChanged(current2) ? true : false;
        }
        function attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2) {
          switch (workInProgress2.tag) {
            case 3:
              pushHostContainer(
                workInProgress2,
                workInProgress2.stateNode.containerInfo
              );
              pushProvider(
                workInProgress2,
                CacheContext,
                current2.memoizedState.cache
              );
              resetHydrationState();
              break;
            case 27:
            case 5:
              pushHostContext(workInProgress2);
              break;
            case 4:
              pushHostContainer(
                workInProgress2,
                workInProgress2.stateNode.containerInfo
              );
              break;
            case 10:
              pushProvider(
                workInProgress2,
                workInProgress2.type,
                workInProgress2.memoizedProps.value
              );
              break;
            case 12:
              0 !== (renderLanes2 & workInProgress2.childLanes) && (workInProgress2.flags |= 4);
              workInProgress2.flags |= 2048;
              var stateNode = workInProgress2.stateNode;
              stateNode.effectDuration = -0;
              stateNode.passiveEffectDuration = -0;
              break;
            case 31:
              if (null !== workInProgress2.memoizedState)
                return workInProgress2.flags |= 128, pushDehydratedActivitySuspenseHandler(workInProgress2), null;
              break;
            case 13:
              stateNode = workInProgress2.memoizedState;
              if (null !== stateNode) {
                if (null !== stateNode.dehydrated)
                  return pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags |= 128, null;
                if (0 !== (renderLanes2 & workInProgress2.child.childLanes))
                  return updateSuspenseComponent(
                    current2,
                    workInProgress2,
                    renderLanes2
                  );
                pushPrimaryTreeSuspenseHandler(workInProgress2);
                current2 = bailoutOnAlreadyFinishedWork(
                  current2,
                  workInProgress2,
                  renderLanes2
                );
                return null !== current2 ? current2.sibling : null;
              }
              pushPrimaryTreeSuspenseHandler(workInProgress2);
              break;
            case 19:
              var didSuspendBefore = 0 !== (current2.flags & 128);
              stateNode = 0 !== (renderLanes2 & workInProgress2.childLanes);
              stateNode || (propagateParentContextChanges(
                current2,
                workInProgress2,
                renderLanes2,
                false
              ), stateNode = 0 !== (renderLanes2 & workInProgress2.childLanes));
              if (didSuspendBefore) {
                if (stateNode)
                  return updateSuspenseListComponent(
                    current2,
                    workInProgress2,
                    renderLanes2
                  );
                workInProgress2.flags |= 128;
              }
              didSuspendBefore = workInProgress2.memoizedState;
              null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
              push(
                suspenseStackCursor,
                suspenseStackCursor.current,
                workInProgress2
              );
              if (stateNode) break;
              else return null;
            case 22:
              return workInProgress2.lanes = 0, updateOffscreenComponent(
                current2,
                workInProgress2,
                renderLanes2,
                workInProgress2.pendingProps
              );
            case 24:
              pushProvider(
                workInProgress2,
                CacheContext,
                current2.memoizedState.cache
              );
          }
          return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
        }
        function beginWork(current2, workInProgress2, renderLanes2) {
          if (workInProgress2._debugNeedsRemount && null !== current2) {
            renderLanes2 = createFiberFromTypeAndProps(
              workInProgress2.type,
              workInProgress2.key,
              workInProgress2.pendingProps,
              workInProgress2._debugOwner || null,
              workInProgress2.mode,
              workInProgress2.lanes
            );
            renderLanes2._debugStack = workInProgress2._debugStack;
            renderLanes2._debugTask = workInProgress2._debugTask;
            var returnFiber = workInProgress2.return;
            if (null === returnFiber) throw Error("Cannot swap the root fiber.");
            current2.alternate = null;
            workInProgress2.alternate = null;
            renderLanes2.index = workInProgress2.index;
            renderLanes2.sibling = workInProgress2.sibling;
            renderLanes2.return = workInProgress2.return;
            renderLanes2.ref = workInProgress2.ref;
            renderLanes2._debugInfo = workInProgress2._debugInfo;
            if (workInProgress2 === returnFiber.child)
              returnFiber.child = renderLanes2;
            else {
              var prevSibling = returnFiber.child;
              if (null === prevSibling)
                throw Error("Expected parent to have a child.");
              for (; prevSibling.sibling !== workInProgress2; )
                if (prevSibling = prevSibling.sibling, null === prevSibling)
                  throw Error("Expected to find the previous sibling.");
              prevSibling.sibling = renderLanes2;
            }
            workInProgress2 = returnFiber.deletions;
            null === workInProgress2 ? (returnFiber.deletions = [current2], returnFiber.flags |= 16) : workInProgress2.push(current2);
            renderLanes2.flags |= 2;
            return renderLanes2;
          }
          if (null !== current2)
            if (current2.memoizedProps !== workInProgress2.pendingProps || workInProgress2.type !== current2.type)
              didReceiveUpdate = true;
            else {
              if (!checkScheduledUpdateOrContext(current2, renderLanes2) && 0 === (workInProgress2.flags & 128))
                return didReceiveUpdate = false, attemptEarlyBailoutIfNoScheduledUpdate(
                  current2,
                  workInProgress2,
                  renderLanes2
                );
              didReceiveUpdate = 0 !== (current2.flags & 131072) ? true : false;
            }
          else {
            didReceiveUpdate = false;
            if (returnFiber = isHydrating)
              warnIfNotHydrating(), returnFiber = 0 !== (workInProgress2.flags & 1048576);
            returnFiber && (returnFiber = workInProgress2.index, warnIfNotHydrating(), pushTreeId(workInProgress2, treeForkCount, returnFiber));
          }
          workInProgress2.lanes = 0;
          switch (workInProgress2.tag) {
            case 16:
              a: if (returnFiber = workInProgress2.pendingProps, current2 = resolveLazy(workInProgress2.elementType), workInProgress2.type = current2, "function" === typeof current2)
                shouldConstruct(current2) ? (returnFiber = resolveClassComponentProps(
                  current2,
                  returnFiber
                ), workInProgress2.tag = 1, workInProgress2.type = current2 = resolveFunctionForHotReloading(current2), workInProgress2 = updateClassComponent(
                  null,
                  workInProgress2,
                  current2,
                  returnFiber,
                  renderLanes2
                )) : (workInProgress2.tag = 0, validateFunctionComponentInDev(workInProgress2, current2), workInProgress2.type = current2 = resolveFunctionForHotReloading(current2), workInProgress2 = updateFunctionComponent(
                  null,
                  workInProgress2,
                  current2,
                  returnFiber,
                  renderLanes2
                ));
              else {
                if (void 0 !== current2 && null !== current2) {
                  if (prevSibling = current2.$$typeof, prevSibling === REACT_FORWARD_REF_TYPE) {
                    workInProgress2.tag = 11;
                    workInProgress2.type = current2 = resolveForwardRefForHotReloading(current2);
                    workInProgress2 = updateForwardRef(
                      null,
                      workInProgress2,
                      current2,
                      returnFiber,
                      renderLanes2
                    );
                    break a;
                  } else if (prevSibling === REACT_MEMO_TYPE) {
                    workInProgress2.tag = 14;
                    workInProgress2 = updateMemoComponent(
                      null,
                      workInProgress2,
                      current2,
                      returnFiber,
                      renderLanes2
                    );
                    break a;
                  }
                }
                workInProgress2 = "";
                null !== current2 && "object" === typeof current2 && current2.$$typeof === REACT_LAZY_TYPE && (workInProgress2 = " Did you wrap a component in React.lazy() more than once?");
                renderLanes2 = getComponentNameFromType(current2) || current2;
                throw Error(
                  "Element type is invalid. Received a promise that resolves to: " + renderLanes2 + ". Lazy element type must resolve to a class or function." + workInProgress2
                );
              }
              return workInProgress2;
            case 0:
              return updateFunctionComponent(
                current2,
                workInProgress2,
                workInProgress2.type,
                workInProgress2.pendingProps,
                renderLanes2
              );
            case 1:
              return returnFiber = workInProgress2.type, prevSibling = resolveClassComponentProps(
                returnFiber,
                workInProgress2.pendingProps
              ), updateClassComponent(
                current2,
                workInProgress2,
                returnFiber,
                prevSibling,
                renderLanes2
              );
            case 3:
              a: {
                pushHostContainer(
                  workInProgress2,
                  workInProgress2.stateNode.containerInfo
                );
                if (null === current2)
                  throw Error(
                    "Should have a current fiber. This is a bug in React."
                  );
                returnFiber = workInProgress2.pendingProps;
                var prevState = workInProgress2.memoizedState;
                prevSibling = prevState.element;
                cloneUpdateQueue(current2, workInProgress2);
                processUpdateQueue(workInProgress2, returnFiber, null, renderLanes2);
                var nextState = workInProgress2.memoizedState;
                returnFiber = nextState.cache;
                pushProvider(workInProgress2, CacheContext, returnFiber);
                returnFiber !== prevState.cache && propagateContextChanges(
                  workInProgress2,
                  [CacheContext],
                  renderLanes2,
                  true
                );
                suspendIfUpdateReadFromEntangledAsyncAction();
                returnFiber = nextState.element;
                if (prevState.isDehydrated)
                  if (prevState = {
                    element: returnFiber,
                    isDehydrated: false,
                    cache: nextState.cache
                  }, workInProgress2.updateQueue.baseState = prevState, workInProgress2.memoizedState = prevState, workInProgress2.flags & 256) {
                    workInProgress2 = mountHostRootWithoutHydrating(
                      current2,
                      workInProgress2,
                      returnFiber,
                      renderLanes2
                    );
                    break a;
                  } else if (returnFiber !== prevSibling) {
                    prevSibling = createCapturedValueAtFiber(
                      Error(
                        "This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."
                      ),
                      workInProgress2
                    );
                    queueHydrationError(prevSibling);
                    workInProgress2 = mountHostRootWithoutHydrating(
                      current2,
                      workInProgress2,
                      returnFiber,
                      renderLanes2
                    );
                    break a;
                  } else {
                    current2 = workInProgress2.stateNode.containerInfo;
                    switch (current2.nodeType) {
                      case 9:
                        current2 = current2.body;
                        break;
                      default:
                        current2 = "HTML" === current2.nodeName ? current2.ownerDocument.body : current2;
                    }
                    nextHydratableInstance = getNextHydratable(current2.firstChild);
                    hydrationParentFiber = workInProgress2;
                    isHydrating = true;
                    hydrationErrors = null;
                    didSuspendOrErrorDEV = false;
                    hydrationDiffRootDEV = null;
                    rootOrSingletonContext = true;
                    renderLanes2 = mountChildFibers(
                      workInProgress2,
                      null,
                      returnFiber,
                      renderLanes2
                    );
                    for (workInProgress2.child = renderLanes2; renderLanes2; )
                      renderLanes2.flags = renderLanes2.flags & -3 | 4096, renderLanes2 = renderLanes2.sibling;
                  }
                else {
                  resetHydrationState();
                  if (returnFiber === prevSibling) {
                    workInProgress2 = bailoutOnAlreadyFinishedWork(
                      current2,
                      workInProgress2,
                      renderLanes2
                    );
                    break a;
                  }
                  reconcileChildren(
                    current2,
                    workInProgress2,
                    returnFiber,
                    renderLanes2
                  );
                }
                workInProgress2 = workInProgress2.child;
              }
              return workInProgress2;
            case 26:
              return markRef(current2, workInProgress2), null === current2 ? (renderLanes2 = getResource(
                workInProgress2.type,
                null,
                workInProgress2.pendingProps,
                null
              )) ? workInProgress2.memoizedState = renderLanes2 : isHydrating || (renderLanes2 = workInProgress2.type, current2 = workInProgress2.pendingProps, returnFiber = requiredContext(
                rootInstanceStackCursor.current
              ), returnFiber = getOwnerDocumentFromRootContainer(
                returnFiber
              ).createElement(renderLanes2), returnFiber[internalInstanceKey] = workInProgress2, returnFiber[internalPropsKey] = current2, setInitialProperties(returnFiber, renderLanes2, current2), markNodeAsHoistable(returnFiber), workInProgress2.stateNode = returnFiber) : workInProgress2.memoizedState = getResource(
                workInProgress2.type,
                current2.memoizedProps,
                workInProgress2.pendingProps,
                current2.memoizedState
              ), null;
            case 27:
              return pushHostContext(workInProgress2), null === current2 && isHydrating && (returnFiber = requiredContext(rootInstanceStackCursor.current), prevSibling = getHostContext(), returnFiber = workInProgress2.stateNode = resolveSingletonInstance(
                workInProgress2.type,
                workInProgress2.pendingProps,
                returnFiber,
                prevSibling,
                false
              ), didSuspendOrErrorDEV || (prevSibling = diffHydratedProperties(
                returnFiber,
                workInProgress2.type,
                workInProgress2.pendingProps,
                prevSibling
              ), null !== prevSibling && (buildHydrationDiffNode(workInProgress2, 0).serverProps = prevSibling)), hydrationParentFiber = workInProgress2, rootOrSingletonContext = true, prevSibling = nextHydratableInstance, isSingletonScope(workInProgress2.type) ? (previousHydratableOnEnteringScopedSingleton = prevSibling, nextHydratableInstance = getNextHydratable(
                returnFiber.firstChild
              )) : nextHydratableInstance = prevSibling), reconcileChildren(
                current2,
                workInProgress2,
                workInProgress2.pendingProps.children,
                renderLanes2
              ), markRef(current2, workInProgress2), null === current2 && (workInProgress2.flags |= 4194304), workInProgress2.child;
            case 5:
              return null === current2 && isHydrating && (prevState = getHostContext(), returnFiber = validateDOMNesting(
                workInProgress2.type,
                prevState.ancestorInfo
              ), prevSibling = nextHydratableInstance, (nextState = !prevSibling) || (nextState = canHydrateInstance(
                prevSibling,
                workInProgress2.type,
                workInProgress2.pendingProps,
                rootOrSingletonContext
              ), null !== nextState ? (workInProgress2.stateNode = nextState, didSuspendOrErrorDEV || (prevState = diffHydratedProperties(
                nextState,
                workInProgress2.type,
                workInProgress2.pendingProps,
                prevState
              ), null !== prevState && (buildHydrationDiffNode(workInProgress2, 0).serverProps = prevState)), hydrationParentFiber = workInProgress2, nextHydratableInstance = getNextHydratable(
                nextState.firstChild
              ), rootOrSingletonContext = false, prevState = true) : prevState = false, nextState = !prevState), nextState && (returnFiber && warnNonHydratedInstance(workInProgress2, prevSibling), throwOnHydrationMismatch(workInProgress2))), pushHostContext(workInProgress2), prevSibling = workInProgress2.type, prevState = workInProgress2.pendingProps, nextState = null !== current2 ? current2.memoizedProps : null, returnFiber = prevState.children, shouldSetTextContent(prevSibling, prevState) ? returnFiber = null : null !== nextState && shouldSetTextContent(prevSibling, nextState) && (workInProgress2.flags |= 32), null !== workInProgress2.memoizedState && (prevSibling = renderWithHooks(
                current2,
                workInProgress2,
                TransitionAwareHostComponent,
                null,
                null,
                renderLanes2
              ), HostTransitionContext._currentValue = prevSibling), markRef(current2, workInProgress2), reconcileChildren(
                current2,
                workInProgress2,
                returnFiber,
                renderLanes2
              ), workInProgress2.child;
            case 6:
              return null === current2 && isHydrating && (renderLanes2 = workInProgress2.pendingProps, current2 = getHostContext(), returnFiber = current2.ancestorInfo.current, renderLanes2 = null != returnFiber ? validateTextNesting(
                renderLanes2,
                returnFiber.tag,
                current2.ancestorInfo.implicitRootScope
              ) : true, current2 = nextHydratableInstance, (returnFiber = !current2) || (returnFiber = canHydrateTextInstance(
                current2,
                workInProgress2.pendingProps,
                rootOrSingletonContext
              ), null !== returnFiber ? (workInProgress2.stateNode = returnFiber, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, returnFiber = true) : returnFiber = false, returnFiber = !returnFiber), returnFiber && (renderLanes2 && warnNonHydratedInstance(workInProgress2, current2), throwOnHydrationMismatch(workInProgress2))), null;
            case 13:
              return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
            case 4:
              return pushHostContainer(
                workInProgress2,
                workInProgress2.stateNode.containerInfo
              ), returnFiber = workInProgress2.pendingProps, null === current2 ? workInProgress2.child = reconcileChildFibers(
                workInProgress2,
                null,
                returnFiber,
                renderLanes2
              ) : reconcileChildren(
                current2,
                workInProgress2,
                returnFiber,
                renderLanes2
              ), workInProgress2.child;
            case 11:
              return updateForwardRef(
                current2,
                workInProgress2,
                workInProgress2.type,
                workInProgress2.pendingProps,
                renderLanes2
              );
            case 7:
              return reconcileChildren(
                current2,
                workInProgress2,
                workInProgress2.pendingProps,
                renderLanes2
              ), workInProgress2.child;
            case 8:
              return reconcileChildren(
                current2,
                workInProgress2,
                workInProgress2.pendingProps.children,
                renderLanes2
              ), workInProgress2.child;
            case 12:
              return workInProgress2.flags |= 4, workInProgress2.flags |= 2048, returnFiber = workInProgress2.stateNode, returnFiber.effectDuration = -0, returnFiber.passiveEffectDuration = -0, reconcileChildren(
                current2,
                workInProgress2,
                workInProgress2.pendingProps.children,
                renderLanes2
              ), workInProgress2.child;
            case 10:
              return returnFiber = workInProgress2.type, prevSibling = workInProgress2.pendingProps, prevState = prevSibling.value, "value" in prevSibling || hasWarnedAboutUsingNoValuePropOnContextProvider || (hasWarnedAboutUsingNoValuePropOnContextProvider = true, console.error(
                "The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"
              )), pushProvider(workInProgress2, returnFiber, prevState), reconcileChildren(
                current2,
                workInProgress2,
                prevSibling.children,
                renderLanes2
              ), workInProgress2.child;
            case 9:
              return prevSibling = workInProgress2.type._context, returnFiber = workInProgress2.pendingProps.children, "function" !== typeof returnFiber && console.error(
                "A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."
              ), prepareToReadContext(workInProgress2), prevSibling = readContext(prevSibling), returnFiber = callComponentInDEV(
                returnFiber,
                prevSibling,
                void 0
              ), workInProgress2.flags |= 1, reconcileChildren(
                current2,
                workInProgress2,
                returnFiber,
                renderLanes2
              ), workInProgress2.child;
            case 14:
              return updateMemoComponent(
                current2,
                workInProgress2,
                workInProgress2.type,
                workInProgress2.pendingProps,
                renderLanes2
              );
            case 15:
              return updateSimpleMemoComponent(
                current2,
                workInProgress2,
                workInProgress2.type,
                workInProgress2.pendingProps,
                renderLanes2
              );
            case 19:
              return updateSuspenseListComponent(
                current2,
                workInProgress2,
                renderLanes2
              );
            case 31:
              return updateActivityComponent(current2, workInProgress2, renderLanes2);
            case 22:
              return updateOffscreenComponent(
                current2,
                workInProgress2,
                renderLanes2,
                workInProgress2.pendingProps
              );
            case 24:
              return prepareToReadContext(workInProgress2), returnFiber = readContext(CacheContext), null === current2 ? (prevSibling = peekCacheFromPool(), null === prevSibling && (prevSibling = workInProgressRoot, prevState = createCache(), prevSibling.pooledCache = prevState, retainCache(prevState), null !== prevState && (prevSibling.pooledCacheLanes |= renderLanes2), prevSibling = prevState), workInProgress2.memoizedState = {
                parent: returnFiber,
                cache: prevSibling
              }, initializeUpdateQueue(workInProgress2), pushProvider(workInProgress2, CacheContext, prevSibling)) : (0 !== (current2.lanes & renderLanes2) && (cloneUpdateQueue(current2, workInProgress2), processUpdateQueue(workInProgress2, null, null, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction()), prevSibling = current2.memoizedState, prevState = workInProgress2.memoizedState, prevSibling.parent !== returnFiber ? (prevSibling = {
                parent: returnFiber,
                cache: returnFiber
              }, workInProgress2.memoizedState = prevSibling, 0 === workInProgress2.lanes && (workInProgress2.memoizedState = workInProgress2.updateQueue.baseState = prevSibling), pushProvider(workInProgress2, CacheContext, returnFiber)) : (returnFiber = prevState.cache, pushProvider(workInProgress2, CacheContext, returnFiber), returnFiber !== prevSibling.cache && propagateContextChanges(
                workInProgress2,
                [CacheContext],
                renderLanes2,
                true
              ))), reconcileChildren(
                current2,
                workInProgress2,
                workInProgress2.pendingProps.children,
                renderLanes2
              ), workInProgress2.child;
            case 29:
              throw workInProgress2.pendingProps;
          }
          throw Error(
            "Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue."
          );
        }
        function markUpdate(workInProgress2) {
          workInProgress2.flags |= 4;
        }
        function preloadInstanceAndSuspendIfNeeded(workInProgress2, type, oldProps, newProps, renderLanes2) {
          if (type = (workInProgress2.mode & SuspenseyImagesMode) !== NoMode)
            type = false;
          if (type) {
            if (workInProgress2.flags |= 16777216, (renderLanes2 & 335544128) === renderLanes2)
              if (workInProgress2.stateNode.complete) workInProgress2.flags |= 8192;
              else if (shouldRemainOnPreviousScreen()) workInProgress2.flags |= 8192;
              else
                throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
          } else workInProgress2.flags &= -16777217;
        }
        function preloadResourceAndSuspendIfNeeded(workInProgress2, resource) {
          if ("stylesheet" !== resource.type || (resource.state.loading & Inserted) !== NotLoaded)
            workInProgress2.flags &= -16777217;
          else if (workInProgress2.flags |= 16777216, !preloadResource(resource))
            if (shouldRemainOnPreviousScreen()) workInProgress2.flags |= 8192;
            else
              throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
        }
        function scheduleRetryEffect(workInProgress2, retryQueue) {
          null !== retryQueue && (workInProgress2.flags |= 4);
          workInProgress2.flags & 16384 && (retryQueue = 22 !== workInProgress2.tag ? claimNextRetryLane() : 536870912, workInProgress2.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
        }
        function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
          if (!isHydrating)
            switch (renderState.tailMode) {
              case "hidden":
                hasRenderedATailFallback = renderState.tail;
                for (var lastTailNode = null; null !== hasRenderedATailFallback; )
                  null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
                null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
                break;
              case "collapsed":
                lastTailNode = renderState.tail;
                for (var _lastTailNode = null; null !== lastTailNode; )
                  null !== lastTailNode.alternate && (_lastTailNode = lastTailNode), lastTailNode = lastTailNode.sibling;
                null === _lastTailNode ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : _lastTailNode.sibling = null;
            }
        }
        function bubbleProperties(completedWork) {
          var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;
          if (didBailout)
            if ((completedWork.mode & ProfileMode) !== NoMode) {
              for (var _treeBaseDuration = completedWork.selfBaseDuration, _child2 = completedWork.child; null !== _child2; )
                newChildLanes |= _child2.lanes | _child2.childLanes, subtreeFlags |= _child2.subtreeFlags & 65011712, subtreeFlags |= _child2.flags & 65011712, _treeBaseDuration += _child2.treeBaseDuration, _child2 = _child2.sibling;
              completedWork.treeBaseDuration = _treeBaseDuration;
            } else
              for (_treeBaseDuration = completedWork.child; null !== _treeBaseDuration; )
                newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags & 65011712, subtreeFlags |= _treeBaseDuration.flags & 65011712, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;
          else if ((completedWork.mode & ProfileMode) !== NoMode) {
            _treeBaseDuration = completedWork.actualDuration;
            _child2 = completedWork.selfBaseDuration;
            for (var child = completedWork.child; null !== child; )
              newChildLanes |= child.lanes | child.childLanes, subtreeFlags |= child.subtreeFlags, subtreeFlags |= child.flags, _treeBaseDuration += child.actualDuration, _child2 += child.treeBaseDuration, child = child.sibling;
            completedWork.actualDuration = _treeBaseDuration;
            completedWork.treeBaseDuration = _child2;
          } else
            for (_treeBaseDuration = completedWork.child; null !== _treeBaseDuration; )
              newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags, subtreeFlags |= _treeBaseDuration.flags, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;
          completedWork.subtreeFlags |= subtreeFlags;
          completedWork.childLanes = newChildLanes;
          return didBailout;
        }
        function completeWork(current2, workInProgress2, renderLanes2) {
          var newProps = workInProgress2.pendingProps;
          popTreeContext(workInProgress2);
          switch (workInProgress2.tag) {
            case 16:
            case 15:
            case 0:
            case 11:
            case 7:
            case 8:
            case 12:
            case 9:
            case 14:
              return bubbleProperties(workInProgress2), null;
            case 1:
              return bubbleProperties(workInProgress2), null;
            case 3:
              renderLanes2 = workInProgress2.stateNode;
              newProps = null;
              null !== current2 && (newProps = current2.memoizedState.cache);
              workInProgress2.memoizedState.cache !== newProps && (workInProgress2.flags |= 2048);
              popProvider(CacheContext, workInProgress2);
              popHostContainer(workInProgress2);
              renderLanes2.pendingContext && (renderLanes2.context = renderLanes2.pendingContext, renderLanes2.pendingContext = null);
              if (null === current2 || null === current2.child)
                popHydrationState(workInProgress2) ? (emitPendingHydrationWarnings(), markUpdate(workInProgress2)) : null === current2 || current2.memoizedState.isDehydrated && 0 === (workInProgress2.flags & 256) || (workInProgress2.flags |= 1024, upgradeHydrationErrorsToRecoverable());
              bubbleProperties(workInProgress2);
              return null;
            case 26:
              var type = workInProgress2.type, nextResource = workInProgress2.memoizedState;
              null === current2 ? (markUpdate(workInProgress2), null !== nextResource ? (bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(
                workInProgress2,
                nextResource
              )) : (bubbleProperties(workInProgress2), preloadInstanceAndSuspendIfNeeded(
                workInProgress2,
                type,
                null,
                newProps,
                renderLanes2
              ))) : nextResource ? nextResource !== current2.memoizedState ? (markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(
                workInProgress2,
                nextResource
              )) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217) : (current2 = current2.memoizedProps, current2 !== newProps && markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadInstanceAndSuspendIfNeeded(
                workInProgress2,
                type,
                current2,
                newProps,
                renderLanes2
              ));
              return null;
            case 27:
              popHostContext(workInProgress2);
              renderLanes2 = requiredContext(rootInstanceStackCursor.current);
              type = workInProgress2.type;
              if (null !== current2 && null != workInProgress2.stateNode)
                current2.memoizedProps !== newProps && markUpdate(workInProgress2);
              else {
                if (!newProps) {
                  if (null === workInProgress2.stateNode)
                    throw Error(
                      "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                    );
                  bubbleProperties(workInProgress2);
                  return null;
                }
                current2 = getHostContext();
                popHydrationState(workInProgress2) ? prepareToHydrateHostInstance(workInProgress2, current2) : (current2 = resolveSingletonInstance(
                  type,
                  newProps,
                  renderLanes2,
                  current2,
                  true
                ), workInProgress2.stateNode = current2, markUpdate(workInProgress2));
              }
              bubbleProperties(workInProgress2);
              return null;
            case 5:
              popHostContext(workInProgress2);
              type = workInProgress2.type;
              if (null !== current2 && null != workInProgress2.stateNode)
                current2.memoizedProps !== newProps && markUpdate(workInProgress2);
              else {
                if (!newProps) {
                  if (null === workInProgress2.stateNode)
                    throw Error(
                      "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                    );
                  bubbleProperties(workInProgress2);
                  return null;
                }
                var _currentHostContext = getHostContext();
                if (popHydrationState(workInProgress2))
                  prepareToHydrateHostInstance(workInProgress2, _currentHostContext);
                else {
                  nextResource = requiredContext(rootInstanceStackCursor.current);
                  validateDOMNesting(type, _currentHostContext.ancestorInfo);
                  _currentHostContext = _currentHostContext.context;
                  nextResource = getOwnerDocumentFromRootContainer(nextResource);
                  switch (_currentHostContext) {
                    case HostContextNamespaceSvg:
                      nextResource = nextResource.createElementNS(
                        SVG_NAMESPACE,
                        type
                      );
                      break;
                    case HostContextNamespaceMath:
                      nextResource = nextResource.createElementNS(
                        MATH_NAMESPACE,
                        type
                      );
                      break;
                    default:
                      switch (type) {
                        case "svg":
                          nextResource = nextResource.createElementNS(
                            SVG_NAMESPACE,
                            type
                          );
                          break;
                        case "math":
                          nextResource = nextResource.createElementNS(
                            MATH_NAMESPACE,
                            type
                          );
                          break;
                        case "script":
                          nextResource = nextResource.createElement("div");
                          nextResource.innerHTML = "<script><\/script>";
                          nextResource = nextResource.removeChild(
                            nextResource.firstChild
                          );
                          break;
                        case "select":
                          nextResource = "string" === typeof newProps.is ? nextResource.createElement("select", {
                            is: newProps.is
                          }) : nextResource.createElement("select");
                          newProps.multiple ? nextResource.multiple = true : newProps.size && (nextResource.size = newProps.size);
                          break;
                        default:
                          nextResource = "string" === typeof newProps.is ? nextResource.createElement(type, {
                            is: newProps.is
                          }) : nextResource.createElement(type), -1 === type.indexOf("-") && (type !== type.toLowerCase() && console.error(
                            "<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.",
                            type
                          ), "[object HTMLUnknownElement]" !== Object.prototype.toString.call(nextResource) || hasOwnProperty.call(warnedUnknownTags, type) || (warnedUnknownTags[type] = true, console.error(
                            "The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.",
                            type
                          )));
                      }
                  }
                  nextResource[internalInstanceKey] = workInProgress2;
                  nextResource[internalPropsKey] = newProps;
                  a: for (_currentHostContext = workInProgress2.child; null !== _currentHostContext; ) {
                    if (5 === _currentHostContext.tag || 6 === _currentHostContext.tag)
                      nextResource.appendChild(_currentHostContext.stateNode);
                    else if (4 !== _currentHostContext.tag && 27 !== _currentHostContext.tag && null !== _currentHostContext.child) {
                      _currentHostContext.child.return = _currentHostContext;
                      _currentHostContext = _currentHostContext.child;
                      continue;
                    }
                    if (_currentHostContext === workInProgress2) break a;
                    for (; null === _currentHostContext.sibling; ) {
                      if (null === _currentHostContext.return || _currentHostContext.return === workInProgress2)
                        break a;
                      _currentHostContext = _currentHostContext.return;
                    }
                    _currentHostContext.sibling.return = _currentHostContext.return;
                    _currentHostContext = _currentHostContext.sibling;
                  }
                  workInProgress2.stateNode = nextResource;
                  a: switch (setInitialProperties(nextResource, type, newProps), type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      newProps = !!newProps.autoFocus;
                      break a;
                    case "img":
                      newProps = true;
                      break a;
                    default:
                      newProps = false;
                  }
                  newProps && markUpdate(workInProgress2);
                }
              }
              bubbleProperties(workInProgress2);
              preloadInstanceAndSuspendIfNeeded(
                workInProgress2,
                workInProgress2.type,
                null === current2 ? null : current2.memoizedProps,
                workInProgress2.pendingProps,
                renderLanes2
              );
              return null;
            case 6:
              if (current2 && null != workInProgress2.stateNode)
                current2.memoizedProps !== newProps && markUpdate(workInProgress2);
              else {
                if ("string" !== typeof newProps && null === workInProgress2.stateNode)
                  throw Error(
                    "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                  );
                current2 = requiredContext(rootInstanceStackCursor.current);
                renderLanes2 = getHostContext();
                if (popHydrationState(workInProgress2)) {
                  current2 = workInProgress2.stateNode;
                  renderLanes2 = workInProgress2.memoizedProps;
                  type = !didSuspendOrErrorDEV;
                  newProps = null;
                  nextResource = hydrationParentFiber;
                  if (null !== nextResource)
                    switch (nextResource.tag) {
                      case 3:
                        type && (type = diffHydratedTextForDevWarnings(
                          current2,
                          renderLanes2,
                          newProps
                        ), null !== type && (buildHydrationDiffNode(workInProgress2, 0).serverProps = type));
                        break;
                      case 27:
                      case 5:
                        newProps = nextResource.memoizedProps, type && (type = diffHydratedTextForDevWarnings(
                          current2,
                          renderLanes2,
                          newProps
                        ), null !== type && (buildHydrationDiffNode(
                          workInProgress2,
                          0
                        ).serverProps = type));
                    }
                  current2[internalInstanceKey] = workInProgress2;
                  current2 = current2.nodeValue === renderLanes2 || null !== newProps && true === newProps.suppressHydrationWarning || checkForUnmatchedText(current2.nodeValue, renderLanes2) ? true : false;
                  current2 || throwOnHydrationMismatch(workInProgress2, true);
                } else
                  type = renderLanes2.ancestorInfo.current, null != type && validateTextNesting(
                    newProps,
                    type.tag,
                    renderLanes2.ancestorInfo.implicitRootScope
                  ), current2 = getOwnerDocumentFromRootContainer(current2).createTextNode(
                    newProps
                  ), current2[internalInstanceKey] = workInProgress2, workInProgress2.stateNode = current2;
              }
              bubbleProperties(workInProgress2);
              return null;
            case 31:
              renderLanes2 = workInProgress2.memoizedState;
              if (null === current2 || null !== current2.memoizedState) {
                newProps = popHydrationState(workInProgress2);
                if (null !== renderLanes2) {
                  if (null === current2) {
                    if (!newProps)
                      throw Error(
                        "A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React."
                      );
                    current2 = workInProgress2.memoizedState;
                    current2 = null !== current2 ? current2.dehydrated : null;
                    if (!current2)
                      throw Error(
                        "Expected to have a hydrated activity instance. This error is likely caused by a bug in React. Please file an issue."
                      );
                    current2[internalInstanceKey] = workInProgress2;
                    bubbleProperties(workInProgress2);
                    (workInProgress2.mode & ProfileMode) !== NoMode && null !== renderLanes2 && (current2 = workInProgress2.child, null !== current2 && (workInProgress2.treeBaseDuration -= current2.treeBaseDuration));
                  } else
                    emitPendingHydrationWarnings(), resetHydrationState(), 0 === (workInProgress2.flags & 128) && (renderLanes2 = workInProgress2.memoizedState = null), workInProgress2.flags |= 4, bubbleProperties(workInProgress2), (workInProgress2.mode & ProfileMode) !== NoMode && null !== renderLanes2 && (current2 = workInProgress2.child, null !== current2 && (workInProgress2.treeBaseDuration -= current2.treeBaseDuration));
                  current2 = false;
                } else
                  renderLanes2 = upgradeHydrationErrorsToRecoverable(), null !== current2 && null !== current2.memoizedState && (current2.memoizedState.hydrationErrors = renderLanes2), current2 = true;
                if (!current2) {
                  if (workInProgress2.flags & 256)
                    return popSuspenseHandler(workInProgress2), workInProgress2;
                  popSuspenseHandler(workInProgress2);
                  return null;
                }
                if (0 !== (workInProgress2.flags & 128))
                  throw Error(
                    "Client rendering an Activity suspended it again. This is a bug in React."
                  );
              }
              bubbleProperties(workInProgress2);
              return null;
            case 13:
              newProps = workInProgress2.memoizedState;
              if (null === current2 || null !== current2.memoizedState && null !== current2.memoizedState.dehydrated) {
                type = newProps;
                nextResource = popHydrationState(workInProgress2);
                if (null !== type && null !== type.dehydrated) {
                  if (null === current2) {
                    if (!nextResource)
                      throw Error(
                        "A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React."
                      );
                    nextResource = workInProgress2.memoizedState;
                    nextResource = null !== nextResource ? nextResource.dehydrated : null;
                    if (!nextResource)
                      throw Error(
                        "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
                      );
                    nextResource[internalInstanceKey] = workInProgress2;
                    bubbleProperties(workInProgress2);
                    (workInProgress2.mode & ProfileMode) !== NoMode && null !== type && (type = workInProgress2.child, null !== type && (workInProgress2.treeBaseDuration -= type.treeBaseDuration));
                  } else
                    emitPendingHydrationWarnings(), resetHydrationState(), 0 === (workInProgress2.flags & 128) && (type = workInProgress2.memoizedState = null), workInProgress2.flags |= 4, bubbleProperties(workInProgress2), (workInProgress2.mode & ProfileMode) !== NoMode && null !== type && (type = workInProgress2.child, null !== type && (workInProgress2.treeBaseDuration -= type.treeBaseDuration));
                  type = false;
                } else
                  type = upgradeHydrationErrorsToRecoverable(), null !== current2 && null !== current2.memoizedState && (current2.memoizedState.hydrationErrors = type), type = true;
                if (!type) {
                  if (workInProgress2.flags & 256)
                    return popSuspenseHandler(workInProgress2), workInProgress2;
                  popSuspenseHandler(workInProgress2);
                  return null;
                }
              }
              popSuspenseHandler(workInProgress2);
              if (0 !== (workInProgress2.flags & 128))
                return workInProgress2.lanes = renderLanes2, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2;
              renderLanes2 = null !== newProps;
              current2 = null !== current2 && null !== current2.memoizedState;
              renderLanes2 && (newProps = workInProgress2.child, type = null, null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (type = newProps.alternate.memoizedState.cachePool.pool), nextResource = null, null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (nextResource = newProps.memoizedState.cachePool.pool), nextResource !== type && (newProps.flags |= 2048));
              renderLanes2 !== current2 && renderLanes2 && (workInProgress2.child.flags |= 8192);
              scheduleRetryEffect(workInProgress2, workInProgress2.updateQueue);
              bubbleProperties(workInProgress2);
              (workInProgress2.mode & ProfileMode) !== NoMode && renderLanes2 && (current2 = workInProgress2.child, null !== current2 && (workInProgress2.treeBaseDuration -= current2.treeBaseDuration));
              return null;
            case 4:
              return popHostContainer(workInProgress2), null === current2 && listenToAllSupportedEvents(
                workInProgress2.stateNode.containerInfo
              ), bubbleProperties(workInProgress2), null;
            case 10:
              return popProvider(workInProgress2.type, workInProgress2), bubbleProperties(workInProgress2), null;
            case 19:
              pop(suspenseStackCursor, workInProgress2);
              newProps = workInProgress2.memoizedState;
              if (null === newProps) return bubbleProperties(workInProgress2), null;
              type = 0 !== (workInProgress2.flags & 128);
              nextResource = newProps.rendering;
              if (null === nextResource)
                if (type) cutOffTailIfNeeded(newProps, false);
                else {
                  if (workInProgressRootExitStatus !== RootInProgress || null !== current2 && 0 !== (current2.flags & 128))
                    for (current2 = workInProgress2.child; null !== current2; ) {
                      nextResource = findFirstSuspended(current2);
                      if (null !== nextResource) {
                        workInProgress2.flags |= 128;
                        cutOffTailIfNeeded(newProps, false);
                        current2 = nextResource.updateQueue;
                        workInProgress2.updateQueue = current2;
                        scheduleRetryEffect(workInProgress2, current2);
                        workInProgress2.subtreeFlags = 0;
                        current2 = renderLanes2;
                        for (renderLanes2 = workInProgress2.child; null !== renderLanes2; )
                          resetWorkInProgress(renderLanes2, current2), renderLanes2 = renderLanes2.sibling;
                        push(
                          suspenseStackCursor,
                          suspenseStackCursor.current & SubtreeSuspenseContextMask | ForceSuspenseFallback,
                          workInProgress2
                        );
                        isHydrating && pushTreeFork(workInProgress2, newProps.treeForkCount);
                        return workInProgress2.child;
                      }
                      current2 = current2.sibling;
                    }
                  null !== newProps.tail && now$1() > workInProgressRootRenderTargetTime && (workInProgress2.flags |= 128, type = true, cutOffTailIfNeeded(newProps, false), workInProgress2.lanes = 4194304);
                }
              else {
                if (!type)
                  if (current2 = findFirstSuspended(nextResource), null !== current2) {
                    if (workInProgress2.flags |= 128, type = true, current2 = current2.updateQueue, workInProgress2.updateQueue = current2, scheduleRetryEffect(workInProgress2, current2), cutOffTailIfNeeded(newProps, true), null === newProps.tail && "hidden" === newProps.tailMode && !nextResource.alternate && !isHydrating)
                      return bubbleProperties(workInProgress2), null;
                  } else
                    2 * now$1() - newProps.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes2 && (workInProgress2.flags |= 128, type = true, cutOffTailIfNeeded(newProps, false), workInProgress2.lanes = 4194304);
                newProps.isBackwards ? (nextResource.sibling = workInProgress2.child, workInProgress2.child = nextResource) : (current2 = newProps.last, null !== current2 ? current2.sibling = nextResource : workInProgress2.child = nextResource, newProps.last = nextResource);
              }
              if (null !== newProps.tail)
                return current2 = newProps.tail, newProps.rendering = current2, newProps.tail = current2.sibling, newProps.renderingStartTime = now$1(), current2.sibling = null, renderLanes2 = suspenseStackCursor.current, renderLanes2 = type ? renderLanes2 & SubtreeSuspenseContextMask | ForceSuspenseFallback : renderLanes2 & SubtreeSuspenseContextMask, push(suspenseStackCursor, renderLanes2, workInProgress2), isHydrating && pushTreeFork(workInProgress2, newProps.treeForkCount), current2;
              bubbleProperties(workInProgress2);
              return null;
            case 22:
            case 23:
              return popSuspenseHandler(workInProgress2), popHiddenContext(workInProgress2), newProps = null !== workInProgress2.memoizedState, null !== current2 ? null !== current2.memoizedState !== newProps && (workInProgress2.flags |= 8192) : newProps && (workInProgress2.flags |= 8192), newProps ? 0 !== (renderLanes2 & 536870912) && 0 === (workInProgress2.flags & 128) && (bubbleProperties(workInProgress2), workInProgress2.subtreeFlags & 6 && (workInProgress2.flags |= 8192)) : bubbleProperties(workInProgress2), renderLanes2 = workInProgress2.updateQueue, null !== renderLanes2 && scheduleRetryEffect(workInProgress2, renderLanes2.retryQueue), renderLanes2 = null, null !== current2 && null !== current2.memoizedState && null !== current2.memoizedState.cachePool && (renderLanes2 = current2.memoizedState.cachePool.pool), newProps = null, null !== workInProgress2.memoizedState && null !== workInProgress2.memoizedState.cachePool && (newProps = workInProgress2.memoizedState.cachePool.pool), newProps !== renderLanes2 && (workInProgress2.flags |= 2048), null !== current2 && pop(resumedCache, workInProgress2), null;
            case 24:
              return renderLanes2 = null, null !== current2 && (renderLanes2 = current2.memoizedState.cache), workInProgress2.memoizedState.cache !== renderLanes2 && (workInProgress2.flags |= 2048), popProvider(CacheContext, workInProgress2), bubbleProperties(workInProgress2), null;
            case 25:
              return null;
            case 30:
              return null;
          }
          throw Error(
            "Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue."
          );
        }
        function unwindWork(current2, workInProgress2) {
          popTreeContext(workInProgress2);
          switch (workInProgress2.tag) {
            case 1:
              return current2 = workInProgress2.flags, current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
            case 3:
              return popProvider(CacheContext, workInProgress2), popHostContainer(workInProgress2), current2 = workInProgress2.flags, 0 !== (current2 & 65536) && 0 === (current2 & 128) ? (workInProgress2.flags = current2 & -65537 | 128, workInProgress2) : null;
            case 26:
            case 27:
            case 5:
              return popHostContext(workInProgress2), null;
            case 31:
              if (null !== workInProgress2.memoizedState) {
                popSuspenseHandler(workInProgress2);
                if (null === workInProgress2.alternate)
                  throw Error(
                    "Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue."
                  );
                resetHydrationState();
              }
              current2 = workInProgress2.flags;
              return current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
            case 13:
              popSuspenseHandler(workInProgress2);
              current2 = workInProgress2.memoizedState;
              if (null !== current2 && null !== current2.dehydrated) {
                if (null === workInProgress2.alternate)
                  throw Error(
                    "Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue."
                  );
                resetHydrationState();
              }
              current2 = workInProgress2.flags;
              return current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
            case 19:
              return pop(suspenseStackCursor, workInProgress2), null;
            case 4:
              return popHostContainer(workInProgress2), null;
            case 10:
              return popProvider(workInProgress2.type, workInProgress2), null;
            case 22:
            case 23:
              return popSuspenseHandler(workInProgress2), popHiddenContext(workInProgress2), null !== current2 && pop(resumedCache, workInProgress2), current2 = workInProgress2.flags, current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
            case 24:
              return popProvider(CacheContext, workInProgress2), null;
            case 25:
              return null;
            default:
              return null;
          }
        }
        function unwindInterruptedWork(current2, interruptedWork) {
          popTreeContext(interruptedWork);
          switch (interruptedWork.tag) {
            case 3:
              popProvider(CacheContext, interruptedWork);
              popHostContainer(interruptedWork);
              break;
            case 26:
            case 27:
            case 5:
              popHostContext(interruptedWork);
              break;
            case 4:
              popHostContainer(interruptedWork);
              break;
            case 31:
              null !== interruptedWork.memoizedState && popSuspenseHandler(interruptedWork);
              break;
            case 13:
              popSuspenseHandler(interruptedWork);
              break;
            case 19:
              pop(suspenseStackCursor, interruptedWork);
              break;
            case 10:
              popProvider(interruptedWork.type, interruptedWork);
              break;
            case 22:
            case 23:
              popSuspenseHandler(interruptedWork);
              popHiddenContext(interruptedWork);
              null !== current2 && pop(resumedCache, interruptedWork);
              break;
            case 24:
              popProvider(CacheContext, interruptedWork);
          }
        }
        function shouldProfile(current2) {
          return (current2.mode & ProfileMode) !== NoMode;
        }
        function commitHookLayoutEffects(finishedWork, hookFlags) {
          shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);
        }
        function commitHookLayoutUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
          shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          ), recordEffectDuration()) : commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          );
        }
        function commitHookEffectListMount(flags, finishedWork) {
          try {
            var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
            if (null !== lastEffect) {
              var firstEffect = lastEffect.next;
              updateQueue = firstEffect;
              do {
                if ((updateQueue.tag & flags) === flags && (lastEffect = void 0, (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = true), lastEffect = runWithFiberInDEV(
                  finishedWork,
                  callCreateInDEV,
                  updateQueue
                ), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = false), void 0 !== lastEffect && "function" !== typeof lastEffect)) {
                  var hookName = void 0;
                  hookName = 0 !== (updateQueue.tag & Layout) ? "useLayoutEffect" : 0 !== (updateQueue.tag & Insertion) ? "useInsertionEffect" : "useEffect";
                  var addendum = void 0;
                  addendum = null === lastEffect ? " You returned null. If your effect does not require clean up, return undefined (or nothing)." : "function" === typeof lastEffect.then ? "\n\nIt looks like you wrote " + hookName + "(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n" + hookName + "(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching" : " You returned: " + lastEffect;
                  runWithFiberInDEV(
                    finishedWork,
                    function(n4, a5) {
                      console.error(
                        "%s must not return anything besides a function, which is used for clean-up.%s",
                        n4,
                        a5
                      );
                    },
                    hookName,
                    addendum
                  );
                }
                updateQueue = updateQueue.next;
              } while (updateQueue !== firstEffect);
            }
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {
          try {
            var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
            if (null !== lastEffect) {
              var firstEffect = lastEffect.next;
              updateQueue = firstEffect;
              do {
                if ((updateQueue.tag & flags) === flags) {
                  var inst = updateQueue.inst, destroy = inst.destroy;
                  void 0 !== destroy && (inst.destroy = void 0, (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = true), lastEffect = finishedWork, runWithFiberInDEV(
                    lastEffect,
                    callDestroyInDEV,
                    lastEffect,
                    nearestMountedAncestor,
                    destroy
                  ), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = false));
                }
                updateQueue = updateQueue.next;
              } while (updateQueue !== firstEffect);
            }
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function commitHookPassiveMountEffects(finishedWork, hookFlags) {
          shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);
        }
        function commitHookPassiveUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
          shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          ), recordEffectDuration()) : commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          );
        }
        function commitClassCallbacks(finishedWork) {
          var updateQueue = finishedWork.updateQueue;
          if (null !== updateQueue) {
            var instance = finishedWork.stateNode;
            finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (instance.props !== finishedWork.memoizedProps && console.error(
              "Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
              getComponentNameFromFiber(finishedWork) || "instance"
            ), instance.state !== finishedWork.memoizedState && console.error(
              "Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
              getComponentNameFromFiber(finishedWork) || "instance"
            ));
            try {
              runWithFiberInDEV(
                finishedWork,
                commitCallbacks,
                updateQueue,
                instance
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
        }
        function callGetSnapshotBeforeUpdates(instance, prevProps, prevState) {
          return instance.getSnapshotBeforeUpdate(prevProps, prevState);
        }
        function commitClassSnapshot(finishedWork, current2) {
          var prevProps = current2.memoizedProps, prevState = current2.memoizedState;
          current2 = finishedWork.stateNode;
          finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (current2.props !== finishedWork.memoizedProps && console.error(
            "Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
            getComponentNameFromFiber(finishedWork) || "instance"
          ), current2.state !== finishedWork.memoizedState && console.error(
            "Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
            getComponentNameFromFiber(finishedWork) || "instance"
          ));
          try {
            var resolvedPrevProps = resolveClassComponentProps(
              finishedWork.type,
              prevProps
            );
            var snapshot = runWithFiberInDEV(
              finishedWork,
              callGetSnapshotBeforeUpdates,
              current2,
              resolvedPrevProps,
              prevState
            );
            prevProps = didWarnAboutUndefinedSnapshotBeforeUpdate;
            void 0 !== snapshot || prevProps.has(finishedWork.type) || (prevProps.add(finishedWork.type), runWithFiberInDEV(finishedWork, function() {
              console.error(
                "%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.",
                getComponentNameFromFiber(finishedWork)
              );
            }));
            current2.__reactInternalSnapshotBeforeUpdate = snapshot;
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function safelyCallComponentWillUnmount(current2, nearestMountedAncestor, instance) {
          instance.props = resolveClassComponentProps(
            current2.type,
            current2.memoizedProps
          );
          instance.state = current2.memoizedState;
          shouldProfile(current2) ? (startEffectTimer(), runWithFiberInDEV(
            current2,
            callComponentWillUnmountInDEV,
            current2,
            nearestMountedAncestor,
            instance
          ), recordEffectDuration()) : runWithFiberInDEV(
            current2,
            callComponentWillUnmountInDEV,
            current2,
            nearestMountedAncestor,
            instance
          );
        }
        function commitAttachRef(finishedWork) {
          var ref = finishedWork.ref;
          if (null !== ref) {
            switch (finishedWork.tag) {
              case 26:
              case 27:
              case 5:
                var instanceToUse = finishedWork.stateNode;
                break;
              case 30:
                instanceToUse = finishedWork.stateNode;
                break;
              default:
                instanceToUse = finishedWork.stateNode;
            }
            if ("function" === typeof ref)
              if (shouldProfile(finishedWork))
                try {
                  startEffectTimer(), finishedWork.refCleanup = ref(instanceToUse);
                } finally {
                  recordEffectDuration();
                }
              else finishedWork.refCleanup = ref(instanceToUse);
            else
              "string" === typeof ref ? console.error("String refs are no longer supported.") : ref.hasOwnProperty("current") || console.error(
                "Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().",
                getComponentNameFromFiber(finishedWork)
              ), ref.current = instanceToUse;
          }
        }
        function safelyAttachRef(current2, nearestMountedAncestor) {
          try {
            runWithFiberInDEV(current2, commitAttachRef, current2);
          } catch (error) {
            captureCommitPhaseError(current2, nearestMountedAncestor, error);
          }
        }
        function safelyDetachRef(current2, nearestMountedAncestor) {
          var ref = current2.ref, refCleanup = current2.refCleanup;
          if (null !== ref)
            if ("function" === typeof refCleanup)
              try {
                if (shouldProfile(current2))
                  try {
                    startEffectTimer(), runWithFiberInDEV(current2, refCleanup);
                  } finally {
                    recordEffectDuration(current2);
                  }
                else runWithFiberInDEV(current2, refCleanup);
              } catch (error) {
                captureCommitPhaseError(current2, nearestMountedAncestor, error);
              } finally {
                current2.refCleanup = null, current2 = current2.alternate, null != current2 && (current2.refCleanup = null);
              }
            else if ("function" === typeof ref)
              try {
                if (shouldProfile(current2))
                  try {
                    startEffectTimer(), runWithFiberInDEV(current2, ref, null);
                  } finally {
                    recordEffectDuration(current2);
                  }
                else runWithFiberInDEV(current2, ref, null);
              } catch (error$7) {
                captureCommitPhaseError(current2, nearestMountedAncestor, error$7);
              }
            else ref.current = null;
        }
        function commitProfiler(finishedWork, current2, commitStartTime2, effectDuration) {
          var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onCommit = _finishedWork$memoize.onCommit;
          _finishedWork$memoize = _finishedWork$memoize.onRender;
          current2 = null === current2 ? "mount" : "update";
          currentUpdateIsNested && (current2 = "nested-update");
          "function" === typeof _finishedWork$memoize && _finishedWork$memoize(
            id,
            current2,
            finishedWork.actualDuration,
            finishedWork.treeBaseDuration,
            finishedWork.actualStartTime,
            commitStartTime2
          );
          "function" === typeof onCommit && onCommit(id, current2, effectDuration, commitStartTime2);
        }
        function commitProfilerPostCommitImpl(finishedWork, current2, commitStartTime2, passiveEffectDuration) {
          var _finishedWork$memoize2 = finishedWork.memoizedProps;
          finishedWork = _finishedWork$memoize2.id;
          _finishedWork$memoize2 = _finishedWork$memoize2.onPostCommit;
          current2 = null === current2 ? "mount" : "update";
          currentUpdateIsNested && (current2 = "nested-update");
          "function" === typeof _finishedWork$memoize2 && _finishedWork$memoize2(
            finishedWork,
            current2,
            passiveEffectDuration,
            commitStartTime2
          );
        }
        function commitHostMount(finishedWork) {
          var type = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;
          try {
            runWithFiberInDEV(
              finishedWork,
              commitMount,
              instance,
              type,
              props,
              finishedWork
            );
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function commitHostUpdate(finishedWork, newProps, oldProps) {
          try {
            runWithFiberInDEV(
              finishedWork,
              commitUpdate,
              finishedWork.stateNode,
              finishedWork.type,
              oldProps,
              newProps,
              finishedWork
            );
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function isHostParent(fiber) {
          return 5 === fiber.tag || 3 === fiber.tag || 26 === fiber.tag || 27 === fiber.tag && isSingletonScope(fiber.type) || 4 === fiber.tag;
        }
        function getHostSibling(fiber) {
          a: for (; ; ) {
            for (; null === fiber.sibling; ) {
              if (null === fiber.return || isHostParent(fiber.return)) return null;
              fiber = fiber.return;
            }
            fiber.sibling.return = fiber.return;
            for (fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag; ) {
              if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
              if (fiber.flags & 2) continue a;
              if (null === fiber.child || 4 === fiber.tag) continue a;
              else fiber.child.return = fiber, fiber = fiber.child;
            }
            if (!(fiber.flags & 2)) return fiber.stateNode;
          }
        }
        function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
          var tag = node.tag;
          if (5 === tag || 6 === tag)
            node = node.stateNode, before ? (warnForReactChildrenConflict(parent), (9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent).insertBefore(node, before)) : (warnForReactChildrenConflict(parent), before = 9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent, before.appendChild(node), parent = parent._reactRootContainer, null !== parent && void 0 !== parent || null !== before.onclick || (before.onclick = noop$1));
          else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode, before = null), node = node.child, null !== node))
            for (insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node; )
              insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;
        }
        function insertOrAppendPlacementNode(node, before, parent) {
          var tag = node.tag;
          if (5 === tag || 6 === tag)
            node = node.stateNode, before ? parent.insertBefore(node, before) : parent.appendChild(node);
          else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode), node = node.child, null !== node))
            for (insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node; )
              insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
        }
        function commitPlacement(finishedWork) {
          for (var hostParentFiber, parentFiber = finishedWork.return; null !== parentFiber; ) {
            if (isHostParent(parentFiber)) {
              hostParentFiber = parentFiber;
              break;
            }
            parentFiber = parentFiber.return;
          }
          if (null == hostParentFiber)
            throw Error(
              "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
            );
          switch (hostParentFiber.tag) {
            case 27:
              hostParentFiber = hostParentFiber.stateNode;
              parentFiber = getHostSibling(finishedWork);
              insertOrAppendPlacementNode(
                finishedWork,
                parentFiber,
                hostParentFiber
              );
              break;
            case 5:
              parentFiber = hostParentFiber.stateNode;
              hostParentFiber.flags & 32 && (resetTextContent(parentFiber), hostParentFiber.flags &= -33);
              hostParentFiber = getHostSibling(finishedWork);
              insertOrAppendPlacementNode(
                finishedWork,
                hostParentFiber,
                parentFiber
              );
              break;
            case 3:
            case 4:
              hostParentFiber = hostParentFiber.stateNode.containerInfo;
              parentFiber = getHostSibling(finishedWork);
              insertOrAppendPlacementNodeIntoContainer(
                finishedWork,
                parentFiber,
                hostParentFiber
              );
              break;
            default:
              throw Error(
                "Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue."
              );
          }
        }
        function commitHostSingletonAcquisition(finishedWork) {
          var singleton = finishedWork.stateNode, props = finishedWork.memoizedProps;
          try {
            runWithFiberInDEV(
              finishedWork,
              acquireSingletonInstance,
              finishedWork.type,
              props,
              singleton,
              finishedWork
            );
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function isHydratingParent(current2, finishedWork) {
          return 31 === finishedWork.tag ? (finishedWork = finishedWork.memoizedState, null !== current2.memoizedState && null === finishedWork) : 13 === finishedWork.tag ? (current2 = current2.memoizedState, finishedWork = finishedWork.memoizedState, null !== current2 && null !== current2.dehydrated && (null === finishedWork || null === finishedWork.dehydrated)) : 3 === finishedWork.tag ? current2.memoizedState.isDehydrated && 0 === (finishedWork.flags & 256) : false;
        }
        function commitBeforeMutationEffects(root2, firstChild) {
          root2 = root2.containerInfo;
          eventsEnabled = _enabled;
          root2 = getActiveElementDeep(root2);
          if (hasSelectionCapabilities(root2)) {
            if ("selectionStart" in root2)
              var JSCompiler_temp = {
                start: root2.selectionStart,
                end: root2.selectionEnd
              };
            else
              a: {
                JSCompiler_temp = (JSCompiler_temp = root2.ownerDocument) && JSCompiler_temp.defaultView || window;
                var selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
                if (selection && 0 !== selection.rangeCount) {
                  JSCompiler_temp = selection.anchorNode;
                  var anchorOffset = selection.anchorOffset, focusNode = selection.focusNode;
                  selection = selection.focusOffset;
                  try {
                    JSCompiler_temp.nodeType, focusNode.nodeType;
                  } catch (e$2) {
                    JSCompiler_temp = null;
                    break a;
                  }
                  var length = 0, start2 = -1, end = -1, indexWithinAnchor = 0, indexWithinFocus = 0, node = root2, parentNode = null;
                  b: for (; ; ) {
                    for (var next; ; ) {
                      node !== JSCompiler_temp || 0 !== anchorOffset && 3 !== node.nodeType || (start2 = length + anchorOffset);
                      node !== focusNode || 0 !== selection && 3 !== node.nodeType || (end = length + selection);
                      3 === node.nodeType && (length += node.nodeValue.length);
                      if (null === (next = node.firstChild)) break;
                      parentNode = node;
                      node = next;
                    }
                    for (; ; ) {
                      if (node === root2) break b;
                      parentNode === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start2 = length);
                      parentNode === focusNode && ++indexWithinFocus === selection && (end = length);
                      if (null !== (next = node.nextSibling)) break;
                      node = parentNode;
                      parentNode = node.parentNode;
                    }
                    node = next;
                  }
                  JSCompiler_temp = -1 === start2 || -1 === end ? null : { start: start2, end };
                } else JSCompiler_temp = null;
              }
            JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
          } else JSCompiler_temp = null;
          selectionInformation = {
            focusedElem: root2,
            selectionRange: JSCompiler_temp
          };
          _enabled = false;
          for (nextEffect = firstChild; null !== nextEffect; )
            if (firstChild = nextEffect, root2 = firstChild.child, 0 !== (firstChild.subtreeFlags & 1028) && null !== root2)
              root2.return = firstChild, nextEffect = root2;
            else
              for (; null !== nextEffect; ) {
                root2 = firstChild = nextEffect;
                JSCompiler_temp = root2.alternate;
                anchorOffset = root2.flags;
                switch (root2.tag) {
                  case 0:
                    if (0 !== (anchorOffset & 4) && (root2 = root2.updateQueue, root2 = null !== root2 ? root2.events : null, null !== root2))
                      for (JSCompiler_temp = 0; JSCompiler_temp < root2.length; JSCompiler_temp++)
                        anchorOffset = root2[JSCompiler_temp], anchorOffset.ref.impl = anchorOffset.nextImpl;
                    break;
                  case 11:
                  case 15:
                    break;
                  case 1:
                    0 !== (anchorOffset & 1024) && null !== JSCompiler_temp && commitClassSnapshot(root2, JSCompiler_temp);
                    break;
                  case 3:
                    if (0 !== (anchorOffset & 1024)) {
                      if (root2 = root2.stateNode.containerInfo, JSCompiler_temp = root2.nodeType, 9 === JSCompiler_temp)
                        clearContainerSparingly(root2);
                      else if (1 === JSCompiler_temp)
                        switch (root2.nodeName) {
                          case "HEAD":
                          case "HTML":
                          case "BODY":
                            clearContainerSparingly(root2);
                            break;
                          default:
                            root2.textContent = "";
                        }
                    }
                    break;
                  case 5:
                  case 26:
                  case 27:
                  case 6:
                  case 4:
                  case 17:
                    break;
                  default:
                    if (0 !== (anchorOffset & 1024))
                      throw Error(
                        "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."
                      );
                }
                root2 = firstChild.sibling;
                if (null !== root2) {
                  root2.return = firstChild.return;
                  nextEffect = root2;
                  break;
                }
                nextEffect = firstChild.return;
              }
        }
        function commitLayoutEffectOnFiber(finishedRoot, current2, finishedWork) {
          var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              flags & 4 && commitHookLayoutEffects(finishedWork, Layout | HasEffect);
              break;
            case 1:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              if (flags & 4)
                if (finishedRoot = finishedWork.stateNode, null === current2)
                  finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error(
                    "Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  ), finishedRoot.state !== finishedWork.memoizedState && console.error(
                    "Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  )), shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(
                    finishedWork,
                    callComponentDidMountInDEV,
                    finishedWork,
                    finishedRoot
                  ), recordEffectDuration()) : runWithFiberInDEV(
                    finishedWork,
                    callComponentDidMountInDEV,
                    finishedWork,
                    finishedRoot
                  );
                else {
                  var prevProps = resolveClassComponentProps(
                    finishedWork.type,
                    current2.memoizedProps
                  );
                  current2 = current2.memoizedState;
                  finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error(
                    "Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  ), finishedRoot.state !== finishedWork.memoizedState && console.error(
                    "Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  ));
                  shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(
                    finishedWork,
                    callComponentDidUpdateInDEV,
                    finishedWork,
                    finishedRoot,
                    prevProps,
                    current2,
                    finishedRoot.__reactInternalSnapshotBeforeUpdate
                  ), recordEffectDuration()) : runWithFiberInDEV(
                    finishedWork,
                    callComponentDidUpdateInDEV,
                    finishedWork,
                    finishedRoot,
                    prevProps,
                    current2,
                    finishedRoot.__reactInternalSnapshotBeforeUpdate
                  );
                }
              flags & 64 && commitClassCallbacks(finishedWork);
              flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 3:
              current2 = pushNestedEffectDurations();
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              if (flags & 64 && (flags = finishedWork.updateQueue, null !== flags)) {
                prevProps = null;
                if (null !== finishedWork.child)
                  switch (finishedWork.child.tag) {
                    case 27:
                    case 5:
                      prevProps = finishedWork.child.stateNode;
                      break;
                    case 1:
                      prevProps = finishedWork.child.stateNode;
                  }
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitCallbacks,
                    flags,
                    prevProps
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              }
              finishedRoot.effectDuration += popNestedEffectDurations(current2);
              break;
            case 27:
              null === current2 && flags & 4 && commitHostSingletonAcquisition(finishedWork);
            case 26:
            case 5:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              if (null === current2) {
                if (flags & 4) commitHostMount(finishedWork);
                else if (flags & 64) {
                  finishedRoot = finishedWork.type;
                  current2 = finishedWork.memoizedProps;
                  prevProps = finishedWork.stateNode;
                  try {
                    runWithFiberInDEV(
                      finishedWork,
                      commitHydratedInstance,
                      prevProps,
                      finishedRoot,
                      current2,
                      finishedWork
                    );
                  } catch (error) {
                    captureCommitPhaseError(
                      finishedWork,
                      finishedWork.return,
                      error
                    );
                  }
                }
              }
              flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 12:
              if (flags & 4) {
                flags = pushNestedEffectDurations();
                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                finishedRoot = finishedWork.stateNode;
                finishedRoot.effectDuration += bubbleNestedEffectDurations(flags);
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitProfiler,
                    finishedWork,
                    current2,
                    commitStartTime,
                    finishedRoot.effectDuration
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              } else recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              break;
            case 31:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
              break;
            case 13:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
              flags & 64 && (finishedRoot = finishedWork.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot && (flags = retryDehydratedSuspenseBoundary.bind(
                null,
                finishedWork
              ), registerSuspenseInstanceRetry(finishedRoot, flags))));
              break;
            case 22:
              flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
              if (!flags) {
                current2 = null !== current2 && null !== current2.memoizedState || offscreenSubtreeWasHidden;
                prevProps = offscreenSubtreeIsHidden;
                var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                offscreenSubtreeIsHidden = flags;
                (offscreenSubtreeWasHidden = current2) && !prevOffscreenSubtreeWasHidden ? (recursivelyTraverseReappearLayoutEffects(
                  finishedRoot,
                  finishedWork,
                  0 !== (finishedWork.subtreeFlags & 8772)
                ), (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentReappeared(
                  finishedWork,
                  componentEffectStartTime,
                  componentEffectEndTime
                )) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                offscreenSubtreeIsHidden = prevProps;
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
              }
              break;
            case 30:
              break;
            default:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          }
          (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && ((componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            componentEffectDuration,
            componentEffectErrors
          ), null === finishedWork.alternate && null !== finishedWork.return && null !== finishedWork.return.alternate && 0.05 < componentEffectEndTime - componentEffectStartTime && (isHydratingParent(
            finishedWork.return.alternate,
            finishedWork.return
          ) || logComponentTrigger(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            "Mount"
          )));
          popComponentEffectStart(prevEffectStart);
          popComponentEffectDuration(prevEffectDuration);
          componentEffectErrors = prevEffectErrors;
          componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
        }
        function detachFiberAfterEffects(fiber) {
          var alternate = fiber.alternate;
          null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
          fiber.child = null;
          fiber.deletions = null;
          fiber.sibling = null;
          5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));
          fiber.stateNode = null;
          fiber._debugOwner = null;
          fiber.return = null;
          fiber.dependencies = null;
          fiber.memoizedProps = null;
          fiber.memoizedState = null;
          fiber.pendingProps = null;
          fiber.stateNode = null;
          fiber.updateQueue = null;
        }
        function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
          for (parent = parent.child; null !== parent; )
            commitDeletionEffectsOnFiber(
              finishedRoot,
              nearestMountedAncestor,
              parent
            ), parent = parent.sibling;
        }
        function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
          if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
            try {
              injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
            } catch (err) {
              hasLoggedError || (hasLoggedError = true, console.error(
                "React instrumentation encountered an error: %o",
                err
              ));
            }
          var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
          switch (deletedFiber.tag) {
            case 26:
              offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && (finishedRoot = deletedFiber.stateNode, finishedRoot.parentNode.removeChild(finishedRoot));
              break;
            case 27:
              offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
              var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
              isSingletonScope(deletedFiber.type) && (hostParent = deletedFiber.stateNode, hostParentIsContainer = false);
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              runWithFiberInDEV(
                deletedFiber,
                releaseSingletonInstance,
                deletedFiber.stateNode
              );
              hostParent = prevHostParent;
              hostParentIsContainer = prevHostParentIsContainer;
              break;
            case 5:
              offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
            case 6:
              prevHostParent = hostParent;
              prevHostParentIsContainer = hostParentIsContainer;
              hostParent = null;
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              hostParent = prevHostParent;
              hostParentIsContainer = prevHostParentIsContainer;
              if (null !== hostParent)
                if (hostParentIsContainer)
                  try {
                    runWithFiberInDEV(
                      deletedFiber,
                      removeChildFromContainer,
                      hostParent,
                      deletedFiber.stateNode
                    );
                  } catch (error) {
                    captureCommitPhaseError(
                      deletedFiber,
                      nearestMountedAncestor,
                      error
                    );
                  }
                else
                  try {
                    runWithFiberInDEV(
                      deletedFiber,
                      removeChild,
                      hostParent,
                      deletedFiber.stateNode
                    );
                  } catch (error) {
                    captureCommitPhaseError(
                      deletedFiber,
                      nearestMountedAncestor,
                      error
                    );
                  }
              break;
            case 18:
              null !== hostParent && (hostParentIsContainer ? (finishedRoot = hostParent, clearHydrationBoundary(
                9 === finishedRoot.nodeType ? finishedRoot.body : "HTML" === finishedRoot.nodeName ? finishedRoot.ownerDocument.body : finishedRoot,
                deletedFiber.stateNode
              ), retryIfBlockedOn(finishedRoot)) : clearHydrationBoundary(hostParent, deletedFiber.stateNode));
              break;
            case 4:
              prevHostParent = hostParent;
              prevHostParentIsContainer = hostParentIsContainer;
              hostParent = deletedFiber.stateNode.containerInfo;
              hostParentIsContainer = true;
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              hostParent = prevHostParent;
              hostParentIsContainer = prevHostParentIsContainer;
              break;
            case 0:
            case 11:
            case 14:
            case 15:
              commitHookEffectListUnmount(
                Insertion,
                deletedFiber,
                nearestMountedAncestor
              );
              offscreenSubtreeWasHidden || commitHookLayoutUnmountEffects(
                deletedFiber,
                nearestMountedAncestor,
                Layout
              );
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              break;
            case 1:
              offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, "function" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(
                deletedFiber,
                nearestMountedAncestor,
                prevHostParent
              ));
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              break;
            case 21:
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              break;
            case 22:
              offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              offscreenSubtreeWasHidden = prevHostParent;
              break;
            default:
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
          }
          (deletedFiber.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
            deletedFiber,
            componentEffectStartTime,
            componentEffectEndTime,
            componentEffectDuration,
            componentEffectErrors
          );
          popComponentEffectStart(prevEffectStart);
          popComponentEffectDuration(prevEffectDuration);
          componentEffectErrors = prevEffectErrors;
          componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
        }
        function commitActivityHydrationCallbacks(finishedRoot, finishedWork) {
          if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot))) {
            finishedRoot = finishedRoot.dehydrated;
            try {
              runWithFiberInDEV(
                finishedWork,
                commitHydratedActivityInstance,
                finishedRoot
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
        }
        function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
          if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot))))
            try {
              runWithFiberInDEV(
                finishedWork,
                commitHydratedSuspenseInstance,
                finishedRoot
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
        }
        function getRetryCache(finishedWork) {
          switch (finishedWork.tag) {
            case 31:
            case 13:
            case 19:
              var retryCache = finishedWork.stateNode;
              null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
              return retryCache;
            case 22:
              return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;
            default:
              throw Error(
                "Unexpected Suspense handler tag (" + finishedWork.tag + "). This is a bug in React."
              );
          }
        }
        function attachSuspenseRetryListeners(finishedWork, wakeables) {
          var retryCache = getRetryCache(finishedWork);
          wakeables.forEach(function(wakeable) {
            if (!retryCache.has(wakeable)) {
              retryCache.add(wakeable);
              if (isDevToolsPresent)
                if (null !== inProgressLanes && null !== inProgressRoot)
                  restorePendingUpdaters(inProgressRoot, inProgressLanes);
                else
                  throw Error(
                    "Expected finished root and lanes to be set. This is a bug in React."
                  );
              var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
              wakeable.then(retry, retry);
            }
          });
        }
        function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
          var deletions = parentFiber.deletions;
          if (null !== deletions)
            for (var i5 = 0; i5 < deletions.length; i5++) {
              var root2 = root$jscomp$0, returnFiber = parentFiber, deletedFiber = deletions[i5], prevEffectStart = pushComponentEffectStart(), parent = returnFiber;
              a: for (; null !== parent; ) {
                switch (parent.tag) {
                  case 27:
                    if (isSingletonScope(parent.type)) {
                      hostParent = parent.stateNode;
                      hostParentIsContainer = false;
                      break a;
                    }
                    break;
                  case 5:
                    hostParent = parent.stateNode;
                    hostParentIsContainer = false;
                    break a;
                  case 3:
                  case 4:
                    hostParent = parent.stateNode.containerInfo;
                    hostParentIsContainer = true;
                    break a;
                }
                parent = parent.return;
              }
              if (null === hostParent)
                throw Error(
                  "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
                );
              commitDeletionEffectsOnFiber(root2, returnFiber, deletedFiber);
              hostParent = null;
              hostParentIsContainer = false;
              (deletedFiber.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(
                deletedFiber,
                componentEffectStartTime,
                componentEffectEndTime,
                "Unmount"
              );
              popComponentEffectStart(prevEffectStart);
              root2 = deletedFiber;
              returnFiber = root2.alternate;
              null !== returnFiber && (returnFiber.return = null);
              root2.return = null;
            }
          if (parentFiber.subtreeFlags & 13886)
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
        }
        function commitMutationEffectsOnFiber(finishedWork, root2) {
          var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), current2 = finishedWork.alternate, flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 4 && (commitHookEffectListUnmount(
                Insertion | HasEffect,
                finishedWork,
                finishedWork.return
              ), commitHookEffectListMount(Insertion | HasEffect, finishedWork), commitHookLayoutUnmountEffects(
                finishedWork,
                finishedWork.return,
                Layout | HasEffect
              ));
              break;
            case 1:
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
              if (flags & 64 && offscreenSubtreeIsHidden && (flags = finishedWork.updateQueue, null !== flags && (current2 = flags.callbacks, null !== current2))) {
                var existingHiddenCallbacks = flags.shared.hiddenCallbacks;
                flags.shared.hiddenCallbacks = null === existingHiddenCallbacks ? current2 : existingHiddenCallbacks.concat(current2);
              }
              break;
            case 26:
              existingHiddenCallbacks = currentHoistableRoot;
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
              if (flags & 4) {
                var currentResource = null !== current2 ? current2.memoizedState : null;
                flags = finishedWork.memoizedState;
                if (null === current2)
                  if (null === flags)
                    if (null === finishedWork.stateNode) {
                      a: {
                        flags = finishedWork.type;
                        current2 = finishedWork.memoizedProps;
                        existingHiddenCallbacks = existingHiddenCallbacks.ownerDocument || existingHiddenCallbacks;
                        b: switch (flags) {
                          case "title":
                            currentResource = existingHiddenCallbacks.getElementsByTagName(
                              "title"
                            )[0];
                            if (!currentResource || currentResource[internalHoistableMarker] || currentResource[internalInstanceKey] || currentResource.namespaceURI === SVG_NAMESPACE || currentResource.hasAttribute("itemprop"))
                              currentResource = existingHiddenCallbacks.createElement(flags), existingHiddenCallbacks.head.insertBefore(
                                currentResource,
                                existingHiddenCallbacks.querySelector(
                                  "head > title"
                                )
                              );
                            setInitialProperties(currentResource, flags, current2);
                            currentResource[internalInstanceKey] = finishedWork;
                            markNodeAsHoistable(currentResource);
                            flags = currentResource;
                            break a;
                          case "link":
                            var maybeNodes = getHydratableHoistableCache(
                              "link",
                              "href",
                              existingHiddenCallbacks
                            ).get(flags + (current2.href || ""));
                            if (maybeNodes) {
                              for (var i5 = 0; i5 < maybeNodes.length; i5++)
                                if (currentResource = maybeNodes[i5], currentResource.getAttribute("href") === (null == current2.href || "" === current2.href ? null : current2.href) && currentResource.getAttribute("rel") === (null == current2.rel ? null : current2.rel) && currentResource.getAttribute("title") === (null == current2.title ? null : current2.title) && currentResource.getAttribute("crossorigin") === (null == current2.crossOrigin ? null : current2.crossOrigin)) {
                                  maybeNodes.splice(i5, 1);
                                  break b;
                                }
                            }
                            currentResource = existingHiddenCallbacks.createElement(flags);
                            setInitialProperties(currentResource, flags, current2);
                            existingHiddenCallbacks.head.appendChild(
                              currentResource
                            );
                            break;
                          case "meta":
                            if (maybeNodes = getHydratableHoistableCache(
                              "meta",
                              "content",
                              existingHiddenCallbacks
                            ).get(flags + (current2.content || ""))) {
                              for (i5 = 0; i5 < maybeNodes.length; i5++)
                                if (currentResource = maybeNodes[i5], checkAttributeStringCoercion(
                                  current2.content,
                                  "content"
                                ), currentResource.getAttribute("content") === (null == current2.content ? null : "" + current2.content) && currentResource.getAttribute("name") === (null == current2.name ? null : current2.name) && currentResource.getAttribute("property") === (null == current2.property ? null : current2.property) && currentResource.getAttribute("http-equiv") === (null == current2.httpEquiv ? null : current2.httpEquiv) && currentResource.getAttribute("charset") === (null == current2.charSet ? null : current2.charSet)) {
                                  maybeNodes.splice(i5, 1);
                                  break b;
                                }
                            }
                            currentResource = existingHiddenCallbacks.createElement(flags);
                            setInitialProperties(currentResource, flags, current2);
                            existingHiddenCallbacks.head.appendChild(
                              currentResource
                            );
                            break;
                          default:
                            throw Error(
                              'getNodesForType encountered a type it did not expect: "' + flags + '". This is a bug in React.'
                            );
                        }
                        currentResource[internalInstanceKey] = finishedWork;
                        markNodeAsHoistable(currentResource);
                        flags = currentResource;
                      }
                      finishedWork.stateNode = flags;
                    } else
                      mountHoistable(
                        existingHiddenCallbacks,
                        finishedWork.type,
                        finishedWork.stateNode
                      );
                  else
                    finishedWork.stateNode = acquireResource(
                      existingHiddenCallbacks,
                      flags,
                      finishedWork.memoizedProps
                    );
                else
                  currentResource !== flags ? (null === currentResource ? null !== current2.stateNode && (current2 = current2.stateNode, current2.parentNode.removeChild(current2)) : currentResource.count--, null === flags ? mountHoistable(
                    existingHiddenCallbacks,
                    finishedWork.type,
                    finishedWork.stateNode
                  ) : acquireResource(
                    existingHiddenCallbacks,
                    flags,
                    finishedWork.memoizedProps
                  )) : null === flags && null !== finishedWork.stateNode && commitHostUpdate(
                    finishedWork,
                    finishedWork.memoizedProps,
                    current2.memoizedProps
                  );
              }
              break;
            case 27:
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
              null !== current2 && flags & 4 && commitHostUpdate(
                finishedWork,
                finishedWork.memoizedProps,
                current2.memoizedProps
              );
              break;
            case 5:
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
              if (finishedWork.flags & 32) {
                existingHiddenCallbacks = finishedWork.stateNode;
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    resetTextContent,
                    existingHiddenCallbacks
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              }
              flags & 4 && null != finishedWork.stateNode && (existingHiddenCallbacks = finishedWork.memoizedProps, commitHostUpdate(
                finishedWork,
                existingHiddenCallbacks,
                null !== current2 ? current2.memoizedProps : existingHiddenCallbacks
              ));
              flags & 1024 && (needsFormReset = true, "form" !== finishedWork.type && console.error(
                "Unexpected host component type. Expected a form. This is a bug in React."
              ));
              break;
            case 6:
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & 4) {
                if (null === finishedWork.stateNode)
                  throw Error(
                    "This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue."
                  );
                flags = finishedWork.memoizedProps;
                current2 = null !== current2 ? current2.memoizedProps : flags;
                existingHiddenCallbacks = finishedWork.stateNode;
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitTextUpdate,
                    existingHiddenCallbacks,
                    current2,
                    flags
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              }
              break;
            case 3:
              existingHiddenCallbacks = pushNestedEffectDurations();
              tagCaches = null;
              currentResource = currentHoistableRoot;
              currentHoistableRoot = getHoistableRoot(root2.containerInfo);
              recursivelyTraverseMutationEffects(root2, finishedWork);
              currentHoistableRoot = currentResource;
              commitReconciliationEffects(finishedWork);
              if (flags & 4 && null !== current2 && current2.memoizedState.isDehydrated)
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitHydratedContainer,
                    root2.containerInfo
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              needsFormReset && (needsFormReset = false, recursivelyResetForms(finishedWork));
              root2.effectDuration += popNestedEffectDurations(
                existingHiddenCallbacks
              );
              break;
            case 4:
              flags = currentHoistableRoot;
              currentHoistableRoot = getHoistableRoot(
                finishedWork.stateNode.containerInfo
              );
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              currentHoistableRoot = flags;
              break;
            case 12:
              flags = pushNestedEffectDurations();
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              finishedWork.stateNode.effectDuration += bubbleNestedEffectDurations(flags);
              break;
            case 31:
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
              break;
            case 13:
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current2 && null !== current2.memoizedState) && (globalMostRecentFallbackTime = now$1());
              flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
              break;
            case 22:
              existingHiddenCallbacks = null !== finishedWork.memoizedState;
              var wasHidden = null !== current2 && null !== current2.memoizedState, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
              offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || existingHiddenCallbacks;
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
              recursivelyTraverseMutationEffects(root2, finishedWork);
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
              offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
              wasHidden && !existingHiddenCallbacks && !prevOffscreenSubtreeIsHidden && !prevOffscreenSubtreeWasHidden && (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentReappeared(
                finishedWork,
                componentEffectStartTime,
                componentEffectEndTime
              );
              commitReconciliationEffects(finishedWork);
              if (flags & 8192)
                a: for (root2 = finishedWork.stateNode, root2._visibility = existingHiddenCallbacks ? root2._visibility & ~OffscreenVisible : root2._visibility | OffscreenVisible, !existingHiddenCallbacks || null === current2 || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || (recursivelyTraverseDisappearLayoutEffects(finishedWork), (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(
                  finishedWork,
                  componentEffectStartTime,
                  componentEffectEndTime,
                  "Disconnect"
                )), current2 = null, root2 = finishedWork; ; ) {
                  if (5 === root2.tag || 26 === root2.tag) {
                    if (null === current2) {
                      wasHidden = current2 = root2;
                      try {
                        currentResource = wasHidden.stateNode, existingHiddenCallbacks ? runWithFiberInDEV(
                          wasHidden,
                          hideInstance,
                          currentResource
                        ) : runWithFiberInDEV(
                          wasHidden,
                          unhideInstance,
                          wasHidden.stateNode,
                          wasHidden.memoizedProps
                        );
                      } catch (error) {
                        captureCommitPhaseError(wasHidden, wasHidden.return, error);
                      }
                    }
                  } else if (6 === root2.tag) {
                    if (null === current2) {
                      wasHidden = root2;
                      try {
                        maybeNodes = wasHidden.stateNode, existingHiddenCallbacks ? runWithFiberInDEV(
                          wasHidden,
                          hideTextInstance,
                          maybeNodes
                        ) : runWithFiberInDEV(
                          wasHidden,
                          unhideTextInstance,
                          maybeNodes,
                          wasHidden.memoizedProps
                        );
                      } catch (error) {
                        captureCommitPhaseError(wasHidden, wasHidden.return, error);
                      }
                    }
                  } else if (18 === root2.tag) {
                    if (null === current2) {
                      wasHidden = root2;
                      try {
                        i5 = wasHidden.stateNode, existingHiddenCallbacks ? runWithFiberInDEV(
                          wasHidden,
                          hideDehydratedBoundary,
                          i5
                        ) : runWithFiberInDEV(
                          wasHidden,
                          unhideDehydratedBoundary,
                          wasHidden.stateNode
                        );
                      } catch (error) {
                        captureCommitPhaseError(wasHidden, wasHidden.return, error);
                      }
                    }
                  } else if ((22 !== root2.tag && 23 !== root2.tag || null === root2.memoizedState || root2 === finishedWork) && null !== root2.child) {
                    root2.child.return = root2;
                    root2 = root2.child;
                    continue;
                  }
                  if (root2 === finishedWork) break a;
                  for (; null === root2.sibling; ) {
                    if (null === root2.return || root2.return === finishedWork)
                      break a;
                    current2 === root2 && (current2 = null);
                    root2 = root2.return;
                  }
                  current2 === root2 && (current2 = null);
                  root2.sibling.return = root2.return;
                  root2 = root2.sibling;
                }
              flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current2 = flags.retryQueue, null !== current2 && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current2))));
              break;
            case 19:
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
              break;
            case 30:
              break;
            case 21:
              break;
            default:
              recursivelyTraverseMutationEffects(root2, finishedWork), commitReconciliationEffects(finishedWork);
          }
          (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && ((componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            componentEffectDuration,
            componentEffectErrors
          ), null === finishedWork.alternate && null !== finishedWork.return && null !== finishedWork.return.alternate && 0.05 < componentEffectEndTime - componentEffectStartTime && (isHydratingParent(
            finishedWork.return.alternate,
            finishedWork.return
          ) || logComponentTrigger(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            "Mount"
          )));
          popComponentEffectStart(prevEffectStart);
          popComponentEffectDuration(prevEffectDuration);
          componentEffectErrors = prevEffectErrors;
          componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
        }
        function commitReconciliationEffects(finishedWork) {
          var flags = finishedWork.flags;
          if (flags & 2) {
            try {
              runWithFiberInDEV(finishedWork, commitPlacement, finishedWork);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
            finishedWork.flags &= -3;
          }
          flags & 4096 && (finishedWork.flags &= -4097);
        }
        function recursivelyResetForms(parentFiber) {
          if (parentFiber.subtreeFlags & 1024)
            for (parentFiber = parentFiber.child; null !== parentFiber; ) {
              var fiber = parentFiber;
              recursivelyResetForms(fiber);
              5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
              parentFiber = parentFiber.sibling;
            }
        }
        function recursivelyTraverseLayoutEffects(root2, parentFiber) {
          if (parentFiber.subtreeFlags & 8772)
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              commitLayoutEffectOnFiber(root2, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
        }
        function disappearLayoutEffects(finishedWork) {
          var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              commitHookLayoutUnmountEffects(
                finishedWork,
                finishedWork.return,
                Layout
              );
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 1:
              safelyDetachRef(finishedWork, finishedWork.return);
              var instance = finishedWork.stateNode;
              "function" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(
                finishedWork,
                finishedWork.return,
                instance
              );
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 27:
              runWithFiberInDEV(
                finishedWork,
                releaseSingletonInstance,
                finishedWork.stateNode
              );
            case 26:
            case 5:
              safelyDetachRef(finishedWork, finishedWork.return);
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 22:
              null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 30:
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            default:
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
          }
          (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            componentEffectDuration,
            componentEffectErrors
          );
          popComponentEffectStart(prevEffectStart);
          popComponentEffectDuration(prevEffectDuration);
          componentEffectErrors = prevEffectErrors;
          componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
        }
        function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            disappearLayoutEffects(parentFiber), parentFiber = parentFiber.sibling;
        }
        function reappearLayoutEffects(finishedRoot, current2, finishedWork, includeWorkInProgressEffects) {
          var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              commitHookLayoutEffects(finishedWork, Layout);
              break;
            case 1:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              current2 = finishedWork.stateNode;
              "function" === typeof current2.componentDidMount && runWithFiberInDEV(
                finishedWork,
                callComponentDidMountInDEV,
                finishedWork,
                current2
              );
              current2 = finishedWork.updateQueue;
              if (null !== current2) {
                finishedRoot = finishedWork.stateNode;
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitHiddenCallbacks,
                    current2,
                    finishedRoot
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              }
              includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 27:
              commitHostSingletonAcquisition(finishedWork);
            case 26:
            case 5:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && null === current2 && flags & 4 && commitHostMount(finishedWork);
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 12:
              if (includeWorkInProgressEffects && flags & 4) {
                flags = pushNestedEffectDurations();
                recursivelyTraverseReappearLayoutEffects(
                  finishedRoot,
                  finishedWork,
                  includeWorkInProgressEffects
                );
                includeWorkInProgressEffects = finishedWork.stateNode;
                includeWorkInProgressEffects.effectDuration += bubbleNestedEffectDurations(flags);
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitProfiler,
                    finishedWork,
                    current2,
                    commitStartTime,
                    includeWorkInProgressEffects.effectDuration
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              } else
                recursivelyTraverseReappearLayoutEffects(
                  finishedRoot,
                  finishedWork,
                  includeWorkInProgressEffects
                );
              break;
            case 31:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
              break;
            case 13:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
              break;
            case 22:
              null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 30:
              break;
            default:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
          }
          (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            componentEffectDuration,
            componentEffectErrors
          );
          popComponentEffectStart(prevEffectStart);
          popComponentEffectDuration(prevEffectDuration);
          componentEffectErrors = prevEffectErrors;
          componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
        }
        function recursivelyTraverseReappearLayoutEffects(finishedRoot, parentFiber, includeWorkInProgressEffects) {
          includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            reappearLayoutEffects(
              finishedRoot,
              parentFiber.alternate,
              parentFiber,
              includeWorkInProgressEffects
            ), parentFiber = parentFiber.sibling;
        }
        function commitOffscreenPassiveMountEffects(current2, finishedWork) {
          var previousCache = null;
          null !== current2 && null !== current2.memoizedState && null !== current2.memoizedState.cachePool && (previousCache = current2.memoizedState.cachePool.pool);
          current2 = null;
          null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current2 = finishedWork.memoizedState.cachePool.pool);
          current2 !== previousCache && (null != current2 && retainCache(current2), null != previousCache && releaseCache(previousCache));
        }
        function commitCachePassiveMountEffect(current2, finishedWork) {
          current2 = null;
          null !== finishedWork.alternate && (current2 = finishedWork.alternate.memoizedState.cache);
          finishedWork = finishedWork.memoizedState.cache;
          finishedWork !== current2 && (retainCache(finishedWork), null != current2 && releaseCache(current2));
        }
        function recursivelyTraversePassiveMountEffects(root2, parentFiber, committedLanes, committedTransitions, endTime) {
          if (parentFiber.subtreeFlags & 10256 || 0 !== parentFiber.actualDuration && (null === parentFiber.alternate || parentFiber.alternate.child !== parentFiber.child))
            for (parentFiber = parentFiber.child; null !== parentFiber; ) {
              var nextSibling = parentFiber.sibling;
              commitPassiveMountOnFiber(
                root2,
                parentFiber,
                committedLanes,
                committedTransitions,
                null !== nextSibling ? nextSibling.actualStartTime : endTime
              );
              parentFiber = nextSibling;
            }
        }
        function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime) {
          var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), prevDeepEquality = alreadyWarnedForDeepEquality, flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              (finishedWork.mode & ProfileMode) !== NoMode && 0 < finishedWork.actualStartTime && 0 !== (finishedWork.flags & 1) && logComponentRender(
                finishedWork,
                finishedWork.actualStartTime,
                endTime,
                inHydratedSubtree,
                committedLanes
              );
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              );
              flags & 2048 && commitHookPassiveMountEffects(finishedWork, Passive | HasEffect);
              break;
            case 1:
              (finishedWork.mode & ProfileMode) !== NoMode && 0 < finishedWork.actualStartTime && (0 !== (finishedWork.flags & 128) ? logComponentErrored(
                finishedWork,
                finishedWork.actualStartTime,
                endTime,
                []
              ) : 0 !== (finishedWork.flags & 1) && logComponentRender(
                finishedWork,
                finishedWork.actualStartTime,
                endTime,
                inHydratedSubtree,
                committedLanes
              ));
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              );
              break;
            case 3:
              var prevProfilerEffectDuration = pushNestedEffectDurations(), wasInHydratedSubtree = inHydratedSubtree;
              inHydratedSubtree = null !== finishedWork.alternate && finishedWork.alternate.memoizedState.isDehydrated && 0 === (finishedWork.flags & 256);
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              );
              inHydratedSubtree = wasInHydratedSubtree;
              flags & 2048 && (committedLanes = null, null !== finishedWork.alternate && (committedLanes = finishedWork.alternate.memoizedState.cache), committedTransitions = finishedWork.memoizedState.cache, committedTransitions !== committedLanes && (retainCache(committedTransitions), null != committedLanes && releaseCache(committedLanes)));
              finishedRoot.passiveEffectDuration += popNestedEffectDurations(
                prevProfilerEffectDuration
              );
              break;
            case 12:
              if (flags & 2048) {
                flags = pushNestedEffectDurations();
                recursivelyTraversePassiveMountEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions,
                  endTime
                );
                finishedRoot = finishedWork.stateNode;
                finishedRoot.passiveEffectDuration += bubbleNestedEffectDurations(flags);
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitProfilerPostCommitImpl,
                    finishedWork,
                    finishedWork.alternate,
                    commitStartTime,
                    finishedRoot.passiveEffectDuration
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              } else
                recursivelyTraversePassiveMountEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions,
                  endTime
                );
              break;
            case 31:
              flags = inHydratedSubtree;
              prevProfilerEffectDuration = null !== finishedWork.alternate ? finishedWork.alternate.memoizedState : null;
              wasInHydratedSubtree = finishedWork.memoizedState;
              null !== prevProfilerEffectDuration && null === wasInHydratedSubtree ? (wasInHydratedSubtree = finishedWork.deletions, null !== wasInHydratedSubtree && 0 < wasInHydratedSubtree.length && 18 === wasInHydratedSubtree[0].tag ? (inHydratedSubtree = false, prevProfilerEffectDuration = prevProfilerEffectDuration.hydrationErrors, null !== prevProfilerEffectDuration && logComponentErrored(
                finishedWork,
                finishedWork.actualStartTime,
                endTime,
                prevProfilerEffectDuration
              )) : inHydratedSubtree = true) : inHydratedSubtree = false;
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              );
              inHydratedSubtree = flags;
              break;
            case 13:
              flags = inHydratedSubtree;
              prevProfilerEffectDuration = null !== finishedWork.alternate ? finishedWork.alternate.memoizedState : null;
              wasInHydratedSubtree = finishedWork.memoizedState;
              null === prevProfilerEffectDuration || null === prevProfilerEffectDuration.dehydrated || null !== wasInHydratedSubtree && null !== wasInHydratedSubtree.dehydrated ? inHydratedSubtree = false : (wasInHydratedSubtree = finishedWork.deletions, null !== wasInHydratedSubtree && 0 < wasInHydratedSubtree.length && 18 === wasInHydratedSubtree[0].tag ? (inHydratedSubtree = false, prevProfilerEffectDuration = prevProfilerEffectDuration.hydrationErrors, null !== prevProfilerEffectDuration && logComponentErrored(
                finishedWork,
                finishedWork.actualStartTime,
                endTime,
                prevProfilerEffectDuration
              )) : inHydratedSubtree = true);
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              );
              inHydratedSubtree = flags;
              break;
            case 23:
              break;
            case 22:
              wasInHydratedSubtree = finishedWork.stateNode;
              prevProfilerEffectDuration = finishedWork.alternate;
              null !== finishedWork.memoizedState ? wasInHydratedSubtree._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              ) : recursivelyTraverseAtomicPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              ) : wasInHydratedSubtree._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              ) : (wasInHydratedSubtree._visibility |= OffscreenPassiveEffectsConnected, recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                0 !== (finishedWork.subtreeFlags & 10256) || 0 !== finishedWork.actualDuration && (null === finishedWork.alternate || finishedWork.alternate.child !== finishedWork.child),
                endTime
              ), (finishedWork.mode & ProfileMode) === NoMode || inHydratedSubtree || (finishedRoot = finishedWork.actualStartTime, 0 <= finishedRoot && 0.05 < endTime - finishedRoot && logComponentReappeared(finishedWork, finishedRoot, endTime), 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentReappeared(
                finishedWork,
                componentEffectStartTime,
                componentEffectEndTime
              )));
              flags & 2048 && commitOffscreenPassiveMountEffects(
                prevProfilerEffectDuration,
                finishedWork
              );
              break;
            case 24:
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              );
              flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
              break;
            default:
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              );
          }
          if ((finishedWork.mode & ProfileMode) !== NoMode) {
            if (finishedRoot = !inHydratedSubtree && null === finishedWork.alternate && null !== finishedWork.return && null !== finishedWork.return.alternate)
              committedLanes = finishedWork.actualStartTime, 0 <= committedLanes && 0.05 < endTime - committedLanes && logComponentTrigger(
                finishedWork,
                committedLanes,
                endTime,
                "Mount"
              );
            0 <= componentEffectStartTime && 0 <= componentEffectEndTime && ((componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
              finishedWork,
              componentEffectStartTime,
              componentEffectEndTime,
              componentEffectDuration,
              componentEffectErrors
            ), finishedRoot && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(
              finishedWork,
              componentEffectStartTime,
              componentEffectEndTime,
              "Mount"
            ));
          }
          popComponentEffectStart(prevEffectStart);
          popComponentEffectDuration(prevEffectDuration);
          componentEffectErrors = prevEffectErrors;
          componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
          alreadyWarnedForDeepEquality = prevDeepEquality;
        }
        function recursivelyTraverseReconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects, endTime) {
          includeWorkInProgressEffects = includeWorkInProgressEffects && (0 !== (parentFiber.subtreeFlags & 10256) || 0 !== parentFiber.actualDuration && (null === parentFiber.alternate || parentFiber.alternate.child !== parentFiber.child));
          for (parentFiber = parentFiber.child; null !== parentFiber; ) {
            var nextSibling = parentFiber.sibling;
            reconnectPassiveEffects(
              finishedRoot,
              parentFiber,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects,
              null !== nextSibling ? nextSibling.actualStartTime : endTime
            );
            parentFiber = nextSibling;
          }
        }
        function reconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects, endTime) {
          var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), prevDeepEquality = alreadyWarnedForDeepEquality;
          includeWorkInProgressEffects && (finishedWork.mode & ProfileMode) !== NoMode && 0 < finishedWork.actualStartTime && 0 !== (finishedWork.flags & 1) && logComponentRender(
            finishedWork,
            finishedWork.actualStartTime,
            endTime,
            inHydratedSubtree,
            committedLanes
          );
          var flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects,
                endTime
              );
              commitHookPassiveMountEffects(finishedWork, Passive);
              break;
            case 23:
              break;
            case 22:
              var _instance2 = finishedWork.stateNode;
              null !== finishedWork.memoizedState ? _instance2._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects,
                endTime
              ) : recursivelyTraverseAtomicPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              ) : (_instance2._visibility |= OffscreenPassiveEffectsConnected, recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects,
                endTime
              ));
              includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(
                finishedWork.alternate,
                finishedWork
              );
              break;
            case 24:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects,
                endTime
              );
              includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
              break;
            default:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects,
                endTime
              );
          }
          (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            componentEffectDuration,
            componentEffectErrors
          );
          popComponentEffectStart(prevEffectStart);
          popComponentEffectDuration(prevEffectDuration);
          componentEffectErrors = prevEffectErrors;
          componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
          alreadyWarnedForDeepEquality = prevDeepEquality;
        }
        function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber, committedLanes$jscomp$0, committedTransitions$jscomp$0, endTime$jscomp$0) {
          if (parentFiber.subtreeFlags & 10256 || 0 !== parentFiber.actualDuration && (null === parentFiber.alternate || parentFiber.alternate.child !== parentFiber.child))
            for (var child = parentFiber.child; null !== child; ) {
              parentFiber = child.sibling;
              var finishedRoot = finishedRoot$jscomp$0, committedLanes = committedLanes$jscomp$0, committedTransitions = committedTransitions$jscomp$0, endTime = null !== parentFiber ? parentFiber.actualStartTime : endTime$jscomp$0, prevDeepEquality = alreadyWarnedForDeepEquality;
              (child.mode & ProfileMode) !== NoMode && 0 < child.actualStartTime && 0 !== (child.flags & 1) && logComponentRender(
                child,
                child.actualStartTime,
                endTime,
                inHydratedSubtree,
                committedLanes
              );
              var flags = child.flags;
              switch (child.tag) {
                case 22:
                  recursivelyTraverseAtomicPassiveEffects(
                    finishedRoot,
                    child,
                    committedLanes,
                    committedTransitions,
                    endTime
                  );
                  flags & 2048 && commitOffscreenPassiveMountEffects(child.alternate, child);
                  break;
                case 24:
                  recursivelyTraverseAtomicPassiveEffects(
                    finishedRoot,
                    child,
                    committedLanes,
                    committedTransitions,
                    endTime
                  );
                  flags & 2048 && commitCachePassiveMountEffect(child.alternate, child);
                  break;
                default:
                  recursivelyTraverseAtomicPassiveEffects(
                    finishedRoot,
                    child,
                    committedLanes,
                    committedTransitions,
                    endTime
                  );
              }
              alreadyWarnedForDeepEquality = prevDeepEquality;
              child = parentFiber;
            }
        }
        function recursivelyAccumulateSuspenseyCommit(parentFiber, committedLanes, suspendedState) {
          if (parentFiber.subtreeFlags & suspenseyCommitFlag)
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              accumulateSuspenseyCommitOnFiber(
                parentFiber,
                committedLanes,
                suspendedState
              ), parentFiber = parentFiber.sibling;
        }
        function accumulateSuspenseyCommitOnFiber(fiber, committedLanes, suspendedState) {
          switch (fiber.tag) {
            case 26:
              recursivelyAccumulateSuspenseyCommit(
                fiber,
                committedLanes,
                suspendedState
              );
              fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState && suspendResource(
                suspendedState,
                currentHoistableRoot,
                fiber.memoizedState,
                fiber.memoizedProps
              );
              break;
            case 5:
              recursivelyAccumulateSuspenseyCommit(
                fiber,
                committedLanes,
                suspendedState
              );
              break;
            case 3:
            case 4:
              var previousHoistableRoot = currentHoistableRoot;
              currentHoistableRoot = getHoistableRoot(
                fiber.stateNode.containerInfo
              );
              recursivelyAccumulateSuspenseyCommit(
                fiber,
                committedLanes,
                suspendedState
              );
              currentHoistableRoot = previousHoistableRoot;
              break;
            case 22:
              null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(
                fiber,
                committedLanes,
                suspendedState
              ), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(
                fiber,
                committedLanes,
                suspendedState
              ));
              break;
            default:
              recursivelyAccumulateSuspenseyCommit(
                fiber,
                committedLanes,
                suspendedState
              );
          }
        }
        function detachAlternateSiblings(parentFiber) {
          var previousFiber = parentFiber.alternate;
          if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {
            previousFiber.child = null;
            do
              previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;
            while (null !== parentFiber);
          }
        }
        function recursivelyTraversePassiveUnmountEffects(parentFiber) {
          var deletions = parentFiber.deletions;
          if (0 !== (parentFiber.flags & 16)) {
            if (null !== deletions)
              for (var i5 = 0; i5 < deletions.length; i5++) {
                var childToDelete = deletions[i5], prevEffectStart = pushComponentEffectStart();
                nextEffect = childToDelete;
                commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                  childToDelete,
                  parentFiber
                );
                (childToDelete.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(
                  childToDelete,
                  componentEffectStartTime,
                  componentEffectEndTime,
                  "Unmount"
                );
                popComponentEffectStart(prevEffectStart);
              }
            detachAlternateSiblings(parentFiber);
          }
          if (parentFiber.subtreeFlags & 10256)
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
        }
        function commitPassiveUnmountOnFiber(finishedWork) {
          var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraversePassiveUnmountEffects(finishedWork);
              finishedWork.flags & 2048 && commitHookPassiveUnmountEffects(
                finishedWork,
                finishedWork.return,
                Passive | HasEffect
              );
              break;
            case 3:
              var prevProfilerEffectDuration = pushNestedEffectDurations();
              recursivelyTraversePassiveUnmountEffects(finishedWork);
              finishedWork.stateNode.passiveEffectDuration += popNestedEffectDurations(prevProfilerEffectDuration);
              break;
            case 12:
              prevProfilerEffectDuration = pushNestedEffectDurations();
              recursivelyTraversePassiveUnmountEffects(finishedWork);
              finishedWork.stateNode.passiveEffectDuration += bubbleNestedEffectDurations(prevProfilerEffectDuration);
              break;
            case 22:
              prevProfilerEffectDuration = finishedWork.stateNode;
              null !== finishedWork.memoizedState && prevProfilerEffectDuration._visibility & OffscreenPassiveEffectsConnected && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (prevProfilerEffectDuration._visibility &= ~OffscreenPassiveEffectsConnected, recursivelyTraverseDisconnectPassiveEffects(finishedWork), (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(
                finishedWork,
                componentEffectStartTime,
                componentEffectEndTime,
                "Disconnect"
              )) : recursivelyTraversePassiveUnmountEffects(finishedWork);
              break;
            default:
              recursivelyTraversePassiveUnmountEffects(finishedWork);
          }
          (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            componentEffectDuration,
            componentEffectErrors
          );
          popComponentEffectStart(prevEffectStart);
          popComponentEffectDuration(prevEffectDuration);
          componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
          componentEffectErrors = prevEffectErrors;
        }
        function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
          var deletions = parentFiber.deletions;
          if (0 !== (parentFiber.flags & 16)) {
            if (null !== deletions)
              for (var i5 = 0; i5 < deletions.length; i5++) {
                var childToDelete = deletions[i5], prevEffectStart = pushComponentEffectStart();
                nextEffect = childToDelete;
                commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                  childToDelete,
                  parentFiber
                );
                (childToDelete.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(
                  childToDelete,
                  componentEffectStartTime,
                  componentEffectEndTime,
                  "Unmount"
                );
                popComponentEffectStart(prevEffectStart);
              }
            detachAlternateSiblings(parentFiber);
          }
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            disconnectPassiveEffect(parentFiber), parentFiber = parentFiber.sibling;
        }
        function disconnectPassiveEffect(finishedWork) {
          var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              commitHookPassiveUnmountEffects(
                finishedWork,
                finishedWork.return,
                Passive
              );
              recursivelyTraverseDisconnectPassiveEffects(finishedWork);
              break;
            case 22:
              var instance = finishedWork.stateNode;
              instance._visibility & OffscreenPassiveEffectsConnected && (instance._visibility &= ~OffscreenPassiveEffectsConnected, recursivelyTraverseDisconnectPassiveEffects(finishedWork));
              break;
            default:
              recursivelyTraverseDisconnectPassiveEffects(finishedWork);
          }
          (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            componentEffectDuration,
            componentEffectErrors
          );
          popComponentEffectStart(prevEffectStart);
          popComponentEffectDuration(prevEffectDuration);
          componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
          componentEffectErrors = prevEffectErrors;
        }
        function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor$jscomp$0) {
          for (; null !== nextEffect; ) {
            var fiber = nextEffect, current2 = fiber, nearestMountedAncestor = nearestMountedAncestor$jscomp$0, prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
            switch (current2.tag) {
              case 0:
              case 11:
              case 15:
                commitHookPassiveUnmountEffects(
                  current2,
                  nearestMountedAncestor,
                  Passive
                );
                break;
              case 23:
              case 22:
                null !== current2.memoizedState && null !== current2.memoizedState.cachePool && (nearestMountedAncestor = current2.memoizedState.cachePool.pool, null != nearestMountedAncestor && retainCache(nearestMountedAncestor));
                break;
              case 24:
                releaseCache(current2.memoizedState.cache);
            }
            (current2.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
              current2,
              componentEffectStartTime,
              componentEffectEndTime,
              componentEffectDuration,
              componentEffectErrors
            );
            popComponentEffectStart(prevEffectStart);
            popComponentEffectDuration(prevEffectDuration);
            componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
            componentEffectErrors = prevEffectErrors;
            current2 = fiber.child;
            if (null !== current2) current2.return = fiber, nextEffect = current2;
            else
              a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
                current2 = nextEffect;
                prevEffectStart = current2.sibling;
                prevEffectDuration = current2.return;
                detachFiberAfterEffects(current2);
                if (current2 === fiber) {
                  nextEffect = null;
                  break a;
                }
                if (null !== prevEffectStart) {
                  prevEffectStart.return = prevEffectDuration;
                  nextEffect = prevEffectStart;
                  break a;
                }
                nextEffect = prevEffectDuration;
              }
          }
        }
        function onCommitRoot() {
          commitHooks.forEach(function(commitHook) {
            return commitHook();
          });
        }
        function isConcurrentActEnvironment() {
          var isReactActEnvironmentGlobal = "undefined" !== typeof IS_REACT_ACT_ENVIRONMENT ? IS_REACT_ACT_ENVIRONMENT : void 0;
          isReactActEnvironmentGlobal || null === ReactSharedInternals.actQueue || console.error(
            "The current testing environment is not configured to support act(...)"
          );
          return isReactActEnvironmentGlobal;
        }
        function requestUpdateLane(fiber) {
          if ((executionContext & RenderContext) !== NoContext && 0 !== workInProgressRootRenderLanes)
            return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
          var transition = ReactSharedInternals.T;
          return null !== transition ? (transition._updatedFibers || (transition._updatedFibers = /* @__PURE__ */ new Set()), transition._updatedFibers.add(fiber), requestTransitionLane()) : resolveUpdatePriority();
        }
        function requestDeferredLane() {
          if (0 === workInProgressDeferredLane)
            if (0 === (workInProgressRootRenderLanes & 536870912) || isHydrating) {
              var lane = nextTransitionDeferredLane;
              nextTransitionDeferredLane <<= 1;
              0 === (nextTransitionDeferredLane & 3932160) && (nextTransitionDeferredLane = 262144);
              workInProgressDeferredLane = lane;
            } else workInProgressDeferredLane = 536870912;
          lane = suspenseHandlerStackCursor.current;
          null !== lane && (lane.flags |= 32);
          return workInProgressDeferredLane;
        }
        function scheduleUpdateOnFiber(root2, fiber, lane) {
          isRunningInsertionEffect && console.error("useInsertionEffect must not schedule updates.");
          isFlushingPassiveEffects && (didScheduleUpdateDuringPassiveEffects = true);
          if (root2 === workInProgressRoot && (workInProgressSuspendedReason === SuspendedOnData || workInProgressSuspendedReason === SuspendedOnAction) || null !== root2.cancelPendingCommit)
            prepareFreshStack(root2, 0), markRootSuspended(
              root2,
              workInProgressRootRenderLanes,
              workInProgressDeferredLane,
              false
            );
          markRootUpdated$1(root2, lane);
          if ((executionContext & RenderContext) !== NoContext && root2 === workInProgressRoot) {
            if (isRendering)
              switch (fiber.tag) {
                case 0:
                case 11:
                case 15:
                  root2 = workInProgress && getComponentNameFromFiber(workInProgress) || "Unknown";
                  didWarnAboutUpdateInRenderForAnotherComponent.has(root2) || (didWarnAboutUpdateInRenderForAnotherComponent.add(root2), fiber = getComponentNameFromFiber(fiber) || "Unknown", console.error(
                    "Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://react.dev/link/setstate-in-render",
                    fiber,
                    root2,
                    root2
                  ));
                  break;
                case 1:
                  didWarnAboutUpdateInRender || (console.error(
                    "Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."
                  ), didWarnAboutUpdateInRender = true);
              }
          } else
            isDevToolsPresent && addFiberToLanesMap(root2, fiber, lane), warnIfUpdatesNotWrappedWithActDEV(fiber), root2 === workInProgressRoot && ((executionContext & RenderContext) === NoContext && (workInProgressRootInterleavedUpdatedLanes |= lane), workInProgressRootExitStatus === RootSuspendedWithDelay && markRootSuspended(
              root2,
              workInProgressRootRenderLanes,
              workInProgressDeferredLane,
              false
            )), ensureRootIsScheduled(root2);
        }
        function performWorkOnRoot(root2, lanes, forceSync) {
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
            throw Error("Should not already be working.");
          if (0 !== workInProgressRootRenderLanes && null !== workInProgress) {
            var yieldedFiber = workInProgress, yieldEndTime = now$1();
            switch (yieldReason) {
              case SuspendedOnImmediate:
              case SuspendedOnData:
                var startTime = yieldStartTime;
                supportsUserTiming && ((yieldedFiber = yieldedFiber._debugTask) ? yieldedFiber.run(
                  console.timeStamp.bind(
                    console,
                    "Suspended",
                    startTime,
                    yieldEndTime,
                    COMPONENTS_TRACK,
                    void 0,
                    "primary-light"
                  )
                ) : console.timeStamp(
                  "Suspended",
                  startTime,
                  yieldEndTime,
                  COMPONENTS_TRACK,
                  void 0,
                  "primary-light"
                ));
                break;
              case SuspendedOnAction:
                startTime = yieldStartTime;
                supportsUserTiming && ((yieldedFiber = yieldedFiber._debugTask) ? yieldedFiber.run(
                  console.timeStamp.bind(
                    console,
                    "Action",
                    startTime,
                    yieldEndTime,
                    COMPONENTS_TRACK,
                    void 0,
                    "primary-light"
                  )
                ) : console.timeStamp(
                  "Action",
                  startTime,
                  yieldEndTime,
                  COMPONENTS_TRACK,
                  void 0,
                  "primary-light"
                ));
                break;
              default:
                supportsUserTiming && (yieldedFiber = yieldEndTime - yieldStartTime, 3 > yieldedFiber || console.timeStamp(
                  "Blocked",
                  yieldStartTime,
                  yieldEndTime,
                  COMPONENTS_TRACK,
                  void 0,
                  5 > yieldedFiber ? "primary-light" : 10 > yieldedFiber ? "primary" : 100 > yieldedFiber ? "primary-dark" : "error"
                ));
            }
          }
          startTime = (forceSync = !forceSync && 0 === (lanes & 127) && 0 === (lanes & root2.expiredLanes) || checkIfRootIsPrerendering(root2, lanes)) ? renderRootConcurrent(root2, lanes) : renderRootSync(root2, lanes, true);
          var renderWasConcurrent = forceSync;
          do {
            if (startTime === RootInProgress) {
              workInProgressRootIsPrerendering && !forceSync && markRootSuspended(root2, lanes, 0, false);
              lanes = workInProgressSuspendedReason;
              yieldStartTime = now();
              yieldReason = lanes;
              break;
            } else {
              yieldedFiber = now$1();
              yieldEndTime = root2.current.alternate;
              if (renderWasConcurrent && !isRenderConsistentWithExternalStores(yieldEndTime)) {
                setCurrentTrackFromLanes(lanes);
                yieldEndTime = renderStartTime;
                startTime = yieldedFiber;
                !supportsUserTiming || startTime <= yieldEndTime || (workInProgressUpdateTask ? workInProgressUpdateTask.run(
                  console.timeStamp.bind(
                    console,
                    "Teared Render",
                    yieldEndTime,
                    startTime,
                    currentTrack,
                    LANES_TRACK_GROUP,
                    "error"
                  )
                ) : console.timeStamp(
                  "Teared Render",
                  yieldEndTime,
                  startTime,
                  currentTrack,
                  LANES_TRACK_GROUP,
                  "error"
                ));
                finalizeRender(lanes, yieldedFiber);
                startTime = renderRootSync(root2, lanes, false);
                renderWasConcurrent = false;
                continue;
              }
              if (startTime === RootErrored) {
                renderWasConcurrent = lanes;
                if (root2.errorRecoveryDisabledLanes & renderWasConcurrent)
                  var errorRetryLanes = 0;
                else
                  errorRetryLanes = root2.pendingLanes & -536870913, errorRetryLanes = 0 !== errorRetryLanes ? errorRetryLanes : errorRetryLanes & 536870912 ? 536870912 : 0;
                if (0 !== errorRetryLanes) {
                  setCurrentTrackFromLanes(lanes);
                  logErroredRenderPhase(
                    renderStartTime,
                    yieldedFiber,
                    lanes,
                    workInProgressUpdateTask
                  );
                  finalizeRender(lanes, yieldedFiber);
                  lanes = errorRetryLanes;
                  a: {
                    yieldedFiber = root2;
                    startTime = renderWasConcurrent;
                    renderWasConcurrent = workInProgressRootConcurrentErrors;
                    var wasRootDehydrated = yieldedFiber.current.memoizedState.isDehydrated;
                    wasRootDehydrated && (prepareFreshStack(yieldedFiber, errorRetryLanes).flags |= 256);
                    errorRetryLanes = renderRootSync(
                      yieldedFiber,
                      errorRetryLanes,
                      false
                    );
                    if (errorRetryLanes !== RootErrored) {
                      if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                        yieldedFiber.errorRecoveryDisabledLanes |= startTime;
                        workInProgressRootInterleavedUpdatedLanes |= startTime;
                        startTime = RootSuspendedWithDelay;
                        break a;
                      }
                      yieldedFiber = workInProgressRootRecoverableErrors;
                      workInProgressRootRecoverableErrors = renderWasConcurrent;
                      null !== yieldedFiber && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = yieldedFiber : workInProgressRootRecoverableErrors.push.apply(
                        workInProgressRootRecoverableErrors,
                        yieldedFiber
                      ));
                    }
                    startTime = errorRetryLanes;
                  }
                  renderWasConcurrent = false;
                  if (startTime !== RootErrored) continue;
                  else yieldedFiber = now$1();
                }
              }
              if (startTime === RootFatalErrored) {
                setCurrentTrackFromLanes(lanes);
                logErroredRenderPhase(
                  renderStartTime,
                  yieldedFiber,
                  lanes,
                  workInProgressUpdateTask
                );
                finalizeRender(lanes, yieldedFiber);
                prepareFreshStack(root2, 0);
                markRootSuspended(root2, lanes, 0, true);
                break;
              }
              a: {
                forceSync = root2;
                switch (startTime) {
                  case RootInProgress:
                  case RootFatalErrored:
                    throw Error("Root did not complete. This is a bug in React.");
                  case RootSuspendedWithDelay:
                    if ((lanes & 4194048) !== lanes) break;
                  case RootSuspendedAtTheShell:
                    setCurrentTrackFromLanes(lanes);
                    logSuspendedRenderPhase(
                      renderStartTime,
                      yieldedFiber,
                      lanes,
                      workInProgressUpdateTask
                    );
                    finalizeRender(lanes, yieldedFiber);
                    yieldEndTime = lanes;
                    0 !== (yieldEndTime & 127) ? blockingSuspendedTime = yieldedFiber : 0 !== (yieldEndTime & 4194048) && (transitionSuspendedTime = yieldedFiber);
                    markRootSuspended(
                      forceSync,
                      lanes,
                      workInProgressDeferredLane,
                      !workInProgressRootDidSkipSuspendedSiblings
                    );
                    break a;
                  case RootErrored:
                    workInProgressRootRecoverableErrors = null;
                    break;
                  case RootSuspended:
                  case RootCompleted:
                    break;
                  default:
                    throw Error("Unknown root exit status.");
                }
                if (null !== ReactSharedInternals.actQueue)
                  commitRoot(
                    forceSync,
                    yieldEndTime,
                    lanes,
                    workInProgressRootRecoverableErrors,
                    workInProgressTransitions,
                    workInProgressRootDidIncludeRecursiveRenderUpdate,
                    workInProgressDeferredLane,
                    workInProgressRootInterleavedUpdatedLanes,
                    workInProgressSuspendedRetryLanes,
                    startTime,
                    null,
                    null,
                    renderStartTime,
                    yieldedFiber
                  );
                else {
                  if ((lanes & 62914560) === lanes && (renderWasConcurrent = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now$1(), 10 < renderWasConcurrent)) {
                    markRootSuspended(
                      forceSync,
                      lanes,
                      workInProgressDeferredLane,
                      !workInProgressRootDidSkipSuspendedSiblings
                    );
                    if (0 !== getNextLanes(forceSync, 0, true)) break a;
                    pendingEffectsLanes = lanes;
                    forceSync.timeoutHandle = scheduleTimeout(
                      commitRootWhenReady.bind(
                        null,
                        forceSync,
                        yieldEndTime,
                        workInProgressRootRecoverableErrors,
                        workInProgressTransitions,
                        workInProgressRootDidIncludeRecursiveRenderUpdate,
                        lanes,
                        workInProgressDeferredLane,
                        workInProgressRootInterleavedUpdatedLanes,
                        workInProgressSuspendedRetryLanes,
                        workInProgressRootDidSkipSuspendedSiblings,
                        startTime,
                        "Throttled",
                        renderStartTime,
                        yieldedFiber
                      ),
                      renderWasConcurrent
                    );
                    break a;
                  }
                  commitRootWhenReady(
                    forceSync,
                    yieldEndTime,
                    workInProgressRootRecoverableErrors,
                    workInProgressTransitions,
                    workInProgressRootDidIncludeRecursiveRenderUpdate,
                    lanes,
                    workInProgressDeferredLane,
                    workInProgressRootInterleavedUpdatedLanes,
                    workInProgressSuspendedRetryLanes,
                    workInProgressRootDidSkipSuspendedSiblings,
                    startTime,
                    null,
                    renderStartTime,
                    yieldedFiber
                  );
                }
              }
            }
            break;
          } while (1);
          ensureRootIsScheduled(root2);
        }
        function commitRootWhenReady(root2, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
          root2.timeoutHandle = noTimeout;
          var subtreeFlags = finishedWork.subtreeFlags, suspendedState = null;
          if (subtreeFlags & 8192 || 16785408 === (subtreeFlags & 16785408)) {
            if (suspendedState = {
              stylesheets: null,
              count: 0,
              imgCount: 0,
              imgBytes: 0,
              suspenseyImages: [],
              waitingForImages: true,
              waitingForViewTransition: false,
              unsuspend: noop$1
            }, accumulateSuspenseyCommitOnFiber(finishedWork, lanes, suspendedState), subtreeFlags = (lanes & 62914560) === lanes ? globalMostRecentFallbackTime - now$1() : (lanes & 4194048) === lanes ? globalMostRecentTransitionTime - now$1() : 0, subtreeFlags = waitForCommitToBeReady(suspendedState, subtreeFlags), null !== subtreeFlags) {
              pendingEffectsLanes = lanes;
              root2.cancelPendingCommit = subtreeFlags(
                commitRoot.bind(
                  null,
                  root2,
                  finishedWork,
                  lanes,
                  recoverableErrors,
                  transitions,
                  didIncludeRenderPhaseUpdate,
                  spawnedLane,
                  updatedLanes,
                  suspendedRetryLanes,
                  exitStatus,
                  suspendedState,
                  suspendedState.waitingForViewTransition ? "Waiting for the previous Animation" : 0 < suspendedState.count ? 0 < suspendedState.imgCount ? "Suspended on CSS and Images" : "Suspended on CSS" : 1 === suspendedState.imgCount ? "Suspended on an Image" : 0 < suspendedState.imgCount ? "Suspended on Images" : null,
                  completedRenderStartTime,
                  completedRenderEndTime
                )
              );
              markRootSuspended(
                root2,
                lanes,
                spawnedLane,
                !didSkipSuspendedSiblings
              );
              return;
            }
          }
          commitRoot(
            root2,
            finishedWork,
            lanes,
            recoverableErrors,
            transitions,
            didIncludeRenderPhaseUpdate,
            spawnedLane,
            updatedLanes,
            suspendedRetryLanes,
            exitStatus,
            suspendedState,
            suspendedCommitReason,
            completedRenderStartTime,
            completedRenderEndTime
          );
        }
        function isRenderConsistentWithExternalStores(finishedWork) {
          for (var node = finishedWork; ; ) {
            var tag = node.tag;
            if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag)))
              for (var i5 = 0; i5 < tag.length; i5++) {
                var check = tag[i5], getSnapshot = check.getSnapshot;
                check = check.value;
                try {
                  if (!objectIs(getSnapshot(), check)) return false;
                } catch (error) {
                  return false;
                }
              }
            tag = node.child;
            if (node.subtreeFlags & 16384 && null !== tag)
              tag.return = node, node = tag;
            else {
              if (node === finishedWork) break;
              for (; null === node.sibling; ) {
                if (null === node.return || node.return === finishedWork) return true;
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
          }
          return true;
        }
        function markRootSuspended(root2, suspendedLanes, spawnedLane, didAttemptEntireTree) {
          suspendedLanes &= ~workInProgressRootPingedLanes;
          suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
          root2.suspendedLanes |= suspendedLanes;
          root2.pingedLanes &= ~suspendedLanes;
          didAttemptEntireTree && (root2.warmLanes |= suspendedLanes);
          didAttemptEntireTree = root2.expirationTimes;
          for (var lanes = suspendedLanes; 0 < lanes; ) {
            var index = 31 - clz32(lanes), lane = 1 << index;
            didAttemptEntireTree[index] = -1;
            lanes &= ~lane;
          }
          0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, suspendedLanes);
        }
        function flushSyncWork$1() {
          return (executionContext & (RenderContext | CommitContext)) === NoContext ? (flushSyncWorkAcrossRoots_impl(0, false), false) : true;
        }
        function resetWorkInProgressStack() {
          if (null !== workInProgress) {
            if (workInProgressSuspendedReason === NotSuspended)
              var interruptedWork = workInProgress.return;
            else
              interruptedWork = workInProgress, resetContextDependencies(), resetHooksOnUnwind(interruptedWork), thenableState$1 = null, thenableIndexCounter$1 = 0, interruptedWork = workInProgress;
            for (; null !== interruptedWork; )
              unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
            workInProgress = null;
          }
        }
        function finalizeRender(lanes, finalizationTime) {
          0 !== (lanes & 127) && (blockingClampTime = finalizationTime);
          0 !== (lanes & 4194048) && (transitionClampTime = finalizationTime);
          0 !== (lanes & 62914560) && (retryClampTime = finalizationTime);
          0 !== (lanes & 2080374784) && (idleClampTime = finalizationTime);
        }
        function prepareFreshStack(root2, lanes) {
          supportsUserTiming && (console.timeStamp(
            "Blocking Track",
            3e-3,
            3e-3,
            "Blocking",
            LANES_TRACK_GROUP,
            "primary-light"
          ), console.timeStamp(
            "Transition Track",
            3e-3,
            3e-3,
            "Transition",
            LANES_TRACK_GROUP,
            "primary-light"
          ), console.timeStamp(
            "Suspense Track",
            3e-3,
            3e-3,
            "Suspense",
            LANES_TRACK_GROUP,
            "primary-light"
          ), console.timeStamp(
            "Idle Track",
            3e-3,
            3e-3,
            "Idle",
            LANES_TRACK_GROUP,
            "primary-light"
          ));
          var previousRenderStartTime = renderStartTime;
          renderStartTime = now();
          if (0 !== workInProgressRootRenderLanes && 0 < previousRenderStartTime) {
            setCurrentTrackFromLanes(workInProgressRootRenderLanes);
            if (workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootSuspendedWithDelay)
              logSuspendedRenderPhase(
                previousRenderStartTime,
                renderStartTime,
                lanes,
                workInProgressUpdateTask
              );
            else {
              var endTime = renderStartTime, debugTask = workInProgressUpdateTask;
              if (supportsUserTiming && !(endTime <= previousRenderStartTime)) {
                var color = (lanes & 738197653) === lanes ? "tertiary-dark" : "primary-dark", label = (lanes & 536870912) === lanes ? "Prewarm" : (lanes & 201326741) === lanes ? "Interrupted Hydration" : "Interrupted Render";
                debugTask ? debugTask.run(
                  console.timeStamp.bind(
                    console,
                    label,
                    previousRenderStartTime,
                    endTime,
                    currentTrack,
                    LANES_TRACK_GROUP,
                    color
                  )
                ) : console.timeStamp(
                  label,
                  previousRenderStartTime,
                  endTime,
                  currentTrack,
                  LANES_TRACK_GROUP,
                  color
                );
              }
            }
            finalizeRender(workInProgressRootRenderLanes, renderStartTime);
          }
          previousRenderStartTime = workInProgressUpdateTask;
          workInProgressUpdateTask = null;
          if (0 !== (lanes & 127)) {
            workInProgressUpdateTask = blockingUpdateTask;
            debugTask = 0 <= blockingUpdateTime && blockingUpdateTime < blockingClampTime ? blockingClampTime : blockingUpdateTime;
            endTime = 0 <= blockingEventTime && blockingEventTime < blockingClampTime ? blockingClampTime : blockingEventTime;
            color = 0 <= endTime ? endTime : 0 <= debugTask ? debugTask : renderStartTime;
            0 <= blockingSuspendedTime ? (setCurrentTrackFromLanes(2), logSuspendedWithDelayPhase(
              blockingSuspendedTime,
              color,
              lanes,
              previousRenderStartTime
            )) : 0 !== (animatingLanes & 127) && (setCurrentTrackFromLanes(2), logAnimatingPhase(blockingClampTime, color, animatingTask));
            previousRenderStartTime = debugTask;
            var eventTime = endTime, eventType = blockingEventType, eventIsRepeat = 0 < blockingEventRepeatTime, isSpawnedUpdate = blockingUpdateType === SPAWNED_UPDATE, isPingedUpdate = blockingUpdateType === PINGED_UPDATE;
            debugTask = renderStartTime;
            endTime = blockingUpdateTask;
            color = blockingUpdateMethodName;
            label = blockingUpdateComponentName;
            if (supportsUserTiming) {
              currentTrack = "Blocking";
              0 < previousRenderStartTime ? previousRenderStartTime > debugTask && (previousRenderStartTime = debugTask) : previousRenderStartTime = debugTask;
              0 < eventTime ? eventTime > previousRenderStartTime && (eventTime = previousRenderStartTime) : eventTime = previousRenderStartTime;
              if (null !== eventType && previousRenderStartTime > eventTime) {
                var color$jscomp$0 = eventIsRepeat ? "secondary-light" : "warning";
                endTime ? endTime.run(
                  console.timeStamp.bind(
                    console,
                    eventIsRepeat ? "Consecutive" : "Event: " + eventType,
                    eventTime,
                    previousRenderStartTime,
                    currentTrack,
                    LANES_TRACK_GROUP,
                    color$jscomp$0
                  )
                ) : console.timeStamp(
                  eventIsRepeat ? "Consecutive" : "Event: " + eventType,
                  eventTime,
                  previousRenderStartTime,
                  currentTrack,
                  LANES_TRACK_GROUP,
                  color$jscomp$0
                );
              }
              debugTask > previousRenderStartTime && (eventTime = isSpawnedUpdate ? "error" : (lanes & 738197653) === lanes ? "tertiary-light" : "primary-light", isSpawnedUpdate = isPingedUpdate ? "Promise Resolved" : isSpawnedUpdate ? "Cascading Update" : 5 < debugTask - previousRenderStartTime ? "Update Blocked" : "Update", isPingedUpdate = [], null != label && isPingedUpdate.push(["Component name", label]), null != color && isPingedUpdate.push(["Method name", color]), previousRenderStartTime = {
                start: previousRenderStartTime,
                end: debugTask,
                detail: {
                  devtools: {
                    properties: isPingedUpdate,
                    track: currentTrack,
                    trackGroup: LANES_TRACK_GROUP,
                    color: eventTime
                  }
                }
              }, endTime ? endTime.run(
                performance.measure.bind(
                  performance,
                  isSpawnedUpdate,
                  previousRenderStartTime
                )
              ) : performance.measure(isSpawnedUpdate, previousRenderStartTime));
            }
            blockingUpdateTime = -1.1;
            blockingUpdateType = 0;
            blockingUpdateComponentName = blockingUpdateMethodName = null;
            blockingSuspendedTime = -1.1;
            blockingEventRepeatTime = blockingEventTime;
            blockingEventTime = -1.1;
            blockingClampTime = now();
          }
          0 !== (lanes & 4194048) && (workInProgressUpdateTask = transitionUpdateTask, debugTask = 0 <= transitionStartTime && transitionStartTime < transitionClampTime ? transitionClampTime : transitionStartTime, previousRenderStartTime = 0 <= transitionUpdateTime && transitionUpdateTime < transitionClampTime ? transitionClampTime : transitionUpdateTime, endTime = 0 <= transitionEventTime && transitionEventTime < transitionClampTime ? transitionClampTime : transitionEventTime, color = 0 <= endTime ? endTime : 0 <= previousRenderStartTime ? previousRenderStartTime : renderStartTime, 0 <= transitionSuspendedTime ? (setCurrentTrackFromLanes(256), logSuspendedWithDelayPhase(
            transitionSuspendedTime,
            color,
            lanes,
            workInProgressUpdateTask
          )) : 0 !== (animatingLanes & 4194048) && (setCurrentTrackFromLanes(256), logAnimatingPhase(transitionClampTime, color, animatingTask)), isPingedUpdate = endTime, eventTime = transitionEventType, eventType = 0 < transitionEventRepeatTime, eventIsRepeat = transitionUpdateType === PINGED_UPDATE, color = renderStartTime, endTime = transitionUpdateTask, label = transitionUpdateMethodName, isSpawnedUpdate = transitionUpdateComponentName, supportsUserTiming && (currentTrack = "Transition", 0 < previousRenderStartTime ? previousRenderStartTime > color && (previousRenderStartTime = color) : previousRenderStartTime = color, 0 < debugTask ? debugTask > previousRenderStartTime && (debugTask = previousRenderStartTime) : debugTask = previousRenderStartTime, 0 < isPingedUpdate ? isPingedUpdate > debugTask && (isPingedUpdate = debugTask) : isPingedUpdate = debugTask, debugTask > isPingedUpdate && null !== eventTime && (color$jscomp$0 = eventType ? "secondary-light" : "warning", endTime ? endTime.run(
            console.timeStamp.bind(
              console,
              eventType ? "Consecutive" : "Event: " + eventTime,
              isPingedUpdate,
              debugTask,
              currentTrack,
              LANES_TRACK_GROUP,
              color$jscomp$0
            )
          ) : console.timeStamp(
            eventType ? "Consecutive" : "Event: " + eventTime,
            isPingedUpdate,
            debugTask,
            currentTrack,
            LANES_TRACK_GROUP,
            color$jscomp$0
          )), previousRenderStartTime > debugTask && (endTime ? endTime.run(
            console.timeStamp.bind(
              console,
              "Action",
              debugTask,
              previousRenderStartTime,
              currentTrack,
              LANES_TRACK_GROUP,
              "primary-dark"
            )
          ) : console.timeStamp(
            "Action",
            debugTask,
            previousRenderStartTime,
            currentTrack,
            LANES_TRACK_GROUP,
            "primary-dark"
          )), color > previousRenderStartTime && (debugTask = eventIsRepeat ? "Promise Resolved" : 5 < color - previousRenderStartTime ? "Update Blocked" : "Update", isPingedUpdate = [], null != isSpawnedUpdate && isPingedUpdate.push(["Component name", isSpawnedUpdate]), null != label && isPingedUpdate.push(["Method name", label]), previousRenderStartTime = {
            start: previousRenderStartTime,
            end: color,
            detail: {
              devtools: {
                properties: isPingedUpdate,
                track: currentTrack,
                trackGroup: LANES_TRACK_GROUP,
                color: "primary-light"
              }
            }
          }, endTime ? endTime.run(
            performance.measure.bind(
              performance,
              debugTask,
              previousRenderStartTime
            )
          ) : performance.measure(debugTask, previousRenderStartTime))), transitionUpdateTime = transitionStartTime = -1.1, transitionUpdateType = 0, transitionSuspendedTime = -1.1, transitionEventRepeatTime = transitionEventTime, transitionEventTime = -1.1, transitionClampTime = now());
          0 !== (lanes & 62914560) && 0 !== (animatingLanes & 62914560) && (setCurrentTrackFromLanes(4194304), logAnimatingPhase(retryClampTime, renderStartTime, animatingTask));
          0 !== (lanes & 2080374784) && 0 !== (animatingLanes & 2080374784) && (setCurrentTrackFromLanes(268435456), logAnimatingPhase(idleClampTime, renderStartTime, animatingTask));
          previousRenderStartTime = root2.timeoutHandle;
          previousRenderStartTime !== noTimeout && (root2.timeoutHandle = noTimeout, cancelTimeout(previousRenderStartTime));
          previousRenderStartTime = root2.cancelPendingCommit;
          null !== previousRenderStartTime && (root2.cancelPendingCommit = null, previousRenderStartTime());
          pendingEffectsLanes = 0;
          resetWorkInProgressStack();
          workInProgressRoot = root2;
          workInProgress = previousRenderStartTime = createWorkInProgress(
            root2.current,
            null
          );
          workInProgressRootRenderLanes = lanes;
          workInProgressSuspendedReason = NotSuspended;
          workInProgressThrownValue = null;
          workInProgressRootDidSkipSuspendedSiblings = false;
          workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root2, lanes);
          workInProgressRootDidAttachPingListener = false;
          workInProgressRootExitStatus = RootInProgress;
          workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = 0;
          workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
          workInProgressRootDidIncludeRecursiveRenderUpdate = false;
          0 !== (lanes & 8) && (lanes |= lanes & 32);
          endTime = root2.entangledLanes;
          if (0 !== endTime)
            for (root2 = root2.entanglements, endTime &= lanes; 0 < endTime; )
              debugTask = 31 - clz32(endTime), color = 1 << debugTask, lanes |= root2[debugTask], endTime &= ~color;
          entangledRenderLanes = lanes;
          finishQueueingConcurrentUpdates();
          root2 = getCurrentTime();
          1e3 < root2 - lastResetTime && (ReactSharedInternals.recentlyCreatedOwnerStacks = 0, lastResetTime = root2);
          ReactStrictModeWarnings.discardPendingWarnings();
          return previousRenderStartTime;
        }
        function handleThrow(root2, thrownValue) {
          currentlyRenderingFiber = null;
          ReactSharedInternals.H = ContextOnlyDispatcher;
          ReactSharedInternals.getCurrentStack = null;
          isRendering = false;
          current = null;
          thrownValue === SuspenseException || thrownValue === SuspenseActionException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnImmediate) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnInstance) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? SuspendedOnHydration : null !== thrownValue && "object" === typeof thrownValue && "function" === typeof thrownValue.then ? SuspendedOnDeprecatedThrowPromise : SuspendedOnError;
          workInProgressThrownValue = thrownValue;
          var erroredWork = workInProgress;
          null === erroredWork ? (workInProgressRootExitStatus = RootFatalErrored, logUncaughtError(
            root2,
            createCapturedValueAtFiber(thrownValue, root2.current)
          )) : erroredWork.mode & ProfileMode && stopProfilerTimerIfRunningAndRecordDuration(erroredWork);
        }
        function shouldRemainOnPreviousScreen() {
          var handler = suspenseHandlerStackCursor.current;
          return null === handler ? true : (workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes ? null === shellBoundary ? true : false : (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes || 0 !== (workInProgressRootRenderLanes & 536870912) ? handler === shellBoundary : false;
        }
        function pushDispatcher() {
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = ContextOnlyDispatcher;
          return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
        }
        function pushAsyncDispatcher() {
          var prevAsyncDispatcher = ReactSharedInternals.A;
          ReactSharedInternals.A = DefaultAsyncDispatcher;
          return prevAsyncDispatcher;
        }
        function markRenderDerivedCause(fiber) {
          null === workInProgressUpdateTask && (workInProgressUpdateTask = null == fiber._debugTask ? null : fiber._debugTask);
        }
        function renderDidSuspendDelayIfPossible() {
          workInProgressRootExitStatus = RootSuspendedWithDelay;
          workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = true);
          0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(
            workInProgressRoot,
            workInProgressRootRenderLanes,
            workInProgressDeferredLane,
            false
          );
        }
        function renderRootSync(root2, lanes, shouldYieldForPrerendering) {
          var prevExecutionContext = executionContext;
          executionContext |= RenderContext;
          var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
          if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
            if (isDevToolsPresent) {
              var memoizedUpdaters = root2.memoizedUpdaters;
              0 < memoizedUpdaters.size && (restorePendingUpdaters(root2, workInProgressRootRenderLanes), memoizedUpdaters.clear());
              movePendingFibersToMemoized(root2, lanes);
            }
            workInProgressTransitions = null;
            prepareFreshStack(root2, lanes);
          }
          lanes = false;
          memoizedUpdaters = workInProgressRootExitStatus;
          a: do
            try {
              if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress) {
                var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;
                switch (workInProgressSuspendedReason) {
                  case SuspendedOnHydration:
                    resetWorkInProgressStack();
                    memoizedUpdaters = RootSuspendedAtTheShell;
                    break a;
                  case SuspendedOnImmediate:
                  case SuspendedOnData:
                  case SuspendedOnAction:
                  case SuspendedOnDeprecatedThrowPromise:
                    null === suspenseHandlerStackCursor.current && (lanes = true);
                    var reason = workInProgressSuspendedReason;
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
                    if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
                      memoizedUpdaters = RootInProgress;
                      break a;
                    }
                    break;
                  default:
                    reason = workInProgressSuspendedReason, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
                }
              }
              workLoopSync();
              memoizedUpdaters = workInProgressRootExitStatus;
              break;
            } catch (thrownValue$8) {
              handleThrow(root2, thrownValue$8);
            }
          while (1);
          lanes && root2.shellSuspendCounter++;
          resetContextDependencies();
          executionContext = prevExecutionContext;
          ReactSharedInternals.H = prevDispatcher;
          ReactSharedInternals.A = prevAsyncDispatcher;
          null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
          return memoizedUpdaters;
        }
        function workLoopSync() {
          for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
        }
        function renderRootConcurrent(root2, lanes) {
          var prevExecutionContext = executionContext;
          executionContext |= RenderContext;
          var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
          if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
            if (isDevToolsPresent) {
              var memoizedUpdaters = root2.memoizedUpdaters;
              0 < memoizedUpdaters.size && (restorePendingUpdaters(root2, workInProgressRootRenderLanes), memoizedUpdaters.clear());
              movePendingFibersToMemoized(root2, lanes);
            }
            workInProgressTransitions = null;
            workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS;
            prepareFreshStack(root2, lanes);
          } else
            workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
              root2,
              lanes
            );
          a: do
            try {
              if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress)
                b: switch (lanes = workInProgress, memoizedUpdaters = workInProgressThrownValue, workInProgressSuspendedReason) {
                  case SuspendedOnError:
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(
                      root2,
                      lanes,
                      memoizedUpdaters,
                      SuspendedOnError
                    );
                    break;
                  case SuspendedOnData:
                  case SuspendedOnAction:
                    if (isThenableResolved(memoizedUpdaters)) {
                      workInProgressSuspendedReason = NotSuspended;
                      workInProgressThrownValue = null;
                      replaySuspendedUnitOfWork(lanes);
                      break;
                    }
                    lanes = function() {
                      workInProgressSuspendedReason !== SuspendedOnData && workInProgressSuspendedReason !== SuspendedOnAction || workInProgressRoot !== root2 || (workInProgressSuspendedReason = SuspendedAndReadyToContinue);
                      ensureRootIsScheduled(root2);
                    };
                    memoizedUpdaters.then(lanes, lanes);
                    break a;
                  case SuspendedOnImmediate:
                    workInProgressSuspendedReason = SuspendedAndReadyToContinue;
                    break a;
                  case SuspendedOnInstance:
                    workInProgressSuspendedReason = SuspendedOnInstanceAndReadyToContinue;
                    break a;
                  case SuspendedAndReadyToContinue:
                    isThenableResolved(memoizedUpdaters) ? (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(
                      root2,
                      lanes,
                      memoizedUpdaters,
                      SuspendedAndReadyToContinue
                    ));
                    break;
                  case SuspendedOnInstanceAndReadyToContinue:
                    var resource = null;
                    switch (workInProgress.tag) {
                      case 26:
                        resource = workInProgress.memoizedState;
                      case 5:
                      case 27:
                        var hostFiber = workInProgress;
                        if (resource ? preloadResource(resource) : hostFiber.stateNode.complete) {
                          workInProgressSuspendedReason = NotSuspended;
                          workInProgressThrownValue = null;
                          var sibling = hostFiber.sibling;
                          if (null !== sibling) workInProgress = sibling;
                          else {
                            var returnFiber = hostFiber.return;
                            null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
                          }
                          break b;
                        }
                        break;
                      default:
                        console.error(
                          "Unexpected type of fiber triggered a suspensey commit. This is a bug in React."
                        );
                    }
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(
                      root2,
                      lanes,
                      memoizedUpdaters,
                      SuspendedOnInstanceAndReadyToContinue
                    );
                    break;
                  case SuspendedOnDeprecatedThrowPromise:
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(
                      root2,
                      lanes,
                      memoizedUpdaters,
                      SuspendedOnDeprecatedThrowPromise
                    );
                    break;
                  case SuspendedOnHydration:
                    resetWorkInProgressStack();
                    workInProgressRootExitStatus = RootSuspendedAtTheShell;
                    break a;
                  default:
                    throw Error(
                      "Unexpected SuspendedReason. This is a bug in React."
                    );
                }
              null !== ReactSharedInternals.actQueue ? workLoopSync() : workLoopConcurrentByScheduler();
              break;
            } catch (thrownValue$9) {
              handleThrow(root2, thrownValue$9);
            }
          while (1);
          resetContextDependencies();
          ReactSharedInternals.H = prevDispatcher;
          ReactSharedInternals.A = prevAsyncDispatcher;
          executionContext = prevExecutionContext;
          if (null !== workInProgress) return RootInProgress;
          workInProgressRoot = null;
          workInProgressRootRenderLanes = 0;
          finishQueueingConcurrentUpdates();
          return workInProgressRootExitStatus;
        }
        function workLoopConcurrentByScheduler() {
          for (; null !== workInProgress && !shouldYield(); )
            performUnitOfWork(workInProgress);
        }
        function performUnitOfWork(unitOfWork) {
          var current2 = unitOfWork.alternate;
          (unitOfWork.mode & ProfileMode) !== NoMode ? (startProfilerTimer(unitOfWork), current2 = runWithFiberInDEV(
            unitOfWork,
            beginWork,
            current2,
            unitOfWork,
            entangledRenderLanes
          ), stopProfilerTimerIfRunningAndRecordDuration(unitOfWork)) : current2 = runWithFiberInDEV(
            unitOfWork,
            beginWork,
            current2,
            unitOfWork,
            entangledRenderLanes
          );
          unitOfWork.memoizedProps = unitOfWork.pendingProps;
          null === current2 ? completeUnitOfWork(unitOfWork) : workInProgress = current2;
        }
        function replaySuspendedUnitOfWork(unitOfWork) {
          var next = runWithFiberInDEV(unitOfWork, replayBeginWork, unitOfWork);
          unitOfWork.memoizedProps = unitOfWork.pendingProps;
          null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
        }
        function replayBeginWork(unitOfWork) {
          var current2 = unitOfWork.alternate, isProfilingMode = (unitOfWork.mode & ProfileMode) !== NoMode;
          isProfilingMode && startProfilerTimer(unitOfWork);
          switch (unitOfWork.tag) {
            case 15:
            case 0:
              current2 = replayFunctionComponent(
                current2,
                unitOfWork,
                unitOfWork.pendingProps,
                unitOfWork.type,
                void 0,
                workInProgressRootRenderLanes
              );
              break;
            case 11:
              current2 = replayFunctionComponent(
                current2,
                unitOfWork,
                unitOfWork.pendingProps,
                unitOfWork.type.render,
                unitOfWork.ref,
                workInProgressRootRenderLanes
              );
              break;
            case 5:
              resetHooksOnUnwind(unitOfWork);
            default:
              unwindInterruptedWork(current2, unitOfWork), unitOfWork = workInProgress = resetWorkInProgress(unitOfWork, entangledRenderLanes), current2 = beginWork(current2, unitOfWork, entangledRenderLanes);
          }
          isProfilingMode && stopProfilerTimerIfRunningAndRecordDuration(unitOfWork);
          return current2;
        }
        function throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, suspendedReason) {
          resetContextDependencies();
          resetHooksOnUnwind(unitOfWork);
          thenableState$1 = null;
          thenableIndexCounter$1 = 0;
          var returnFiber = unitOfWork.return;
          try {
            if (throwException(
              root2,
              returnFiber,
              unitOfWork,
              thrownValue,
              workInProgressRootRenderLanes
            )) {
              workInProgressRootExitStatus = RootFatalErrored;
              logUncaughtError(
                root2,
                createCapturedValueAtFiber(thrownValue, root2.current)
              );
              workInProgress = null;
              return;
            }
          } catch (error) {
            if (null !== returnFiber) throw workInProgress = returnFiber, error;
            workInProgressRootExitStatus = RootFatalErrored;
            logUncaughtError(
              root2,
              createCapturedValueAtFiber(thrownValue, root2.current)
            );
            workInProgress = null;
            return;
          }
          if (unitOfWork.flags & 32768) {
            if (isHydrating || suspendedReason === SuspendedOnError) root2 = true;
            else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912))
              root2 = false;
            else if (workInProgressRootDidSkipSuspendedSiblings = root2 = true, suspendedReason === SuspendedOnData || suspendedReason === SuspendedOnAction || suspendedReason === SuspendedOnImmediate || suspendedReason === SuspendedOnDeprecatedThrowPromise)
              suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);
            unwindUnitOfWork(unitOfWork, root2);
          } else completeUnitOfWork(unitOfWork);
        }
        function completeUnitOfWork(unitOfWork) {
          var completedWork = unitOfWork;
          do {
            if (0 !== (completedWork.flags & 32768)) {
              unwindUnitOfWork(
                completedWork,
                workInProgressRootDidSkipSuspendedSiblings
              );
              return;
            }
            var current2 = completedWork.alternate;
            unitOfWork = completedWork.return;
            startProfilerTimer(completedWork);
            current2 = runWithFiberInDEV(
              completedWork,
              completeWork,
              current2,
              completedWork,
              entangledRenderLanes
            );
            (completedWork.mode & ProfileMode) !== NoMode && stopProfilerTimerIfRunningAndRecordIncompleteDuration(completedWork);
            if (null !== current2) {
              workInProgress = current2;
              return;
            }
            completedWork = completedWork.sibling;
            if (null !== completedWork) {
              workInProgress = completedWork;
              return;
            }
            workInProgress = completedWork = unitOfWork;
          } while (null !== completedWork);
          workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootCompleted);
        }
        function unwindUnitOfWork(unitOfWork, skipSiblings) {
          do {
            var next = unwindWork(unitOfWork.alternate, unitOfWork);
            if (null !== next) {
              next.flags &= 32767;
              workInProgress = next;
              return;
            }
            if ((unitOfWork.mode & ProfileMode) !== NoMode) {
              stopProfilerTimerIfRunningAndRecordIncompleteDuration(unitOfWork);
              next = unitOfWork.actualDuration;
              for (var child = unitOfWork.child; null !== child; )
                next += child.actualDuration, child = child.sibling;
              unitOfWork.actualDuration = next;
            }
            next = unitOfWork.return;
            null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);
            if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {
              workInProgress = unitOfWork;
              return;
            }
            workInProgress = unitOfWork = next;
          } while (null !== unitOfWork);
          workInProgressRootExitStatus = RootSuspendedAtTheShell;
          workInProgress = null;
        }
        function commitRoot(root2, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, exitStatus, suspendedState, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
          root2.cancelPendingCommit = null;
          do
            flushPendingEffects();
          while (pendingEffectsStatus !== NO_PENDING_EFFECTS);
          ReactStrictModeWarnings.flushLegacyContextWarning();
          ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
            throw Error("Should not already be working.");
          setCurrentTrackFromLanes(lanes);
          exitStatus === RootErrored ? logErroredRenderPhase(
            completedRenderStartTime,
            completedRenderEndTime,
            lanes,
            workInProgressUpdateTask
          ) : null !== recoverableErrors ? logRecoveredRenderPhase(
            completedRenderStartTime,
            completedRenderEndTime,
            lanes,
            recoverableErrors,
            null !== finishedWork && null !== finishedWork.alternate && finishedWork.alternate.memoizedState.isDehydrated && 0 !== (finishedWork.flags & 256),
            workInProgressUpdateTask
          ) : logRenderPhase(
            completedRenderStartTime,
            completedRenderEndTime,
            lanes,
            workInProgressUpdateTask
          );
          if (null !== finishedWork) {
            0 === lanes && console.error(
              "finishedLanes should not be empty during a commit. This is a bug in React."
            );
            if (finishedWork === root2.current)
              throw Error(
                "Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue."
              );
            didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
            didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
            markRootFinished(
              root2,
              lanes,
              didIncludeRenderPhaseUpdate,
              spawnedLane,
              updatedLanes,
              suspendedRetryLanes
            );
            root2 === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
            pendingFinishedWork = finishedWork;
            pendingEffectsRoot = root2;
            pendingEffectsLanes = lanes;
            pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
            pendingPassiveTransitions = transitions;
            pendingRecoverableErrors = recoverableErrors;
            pendingEffectsRenderEndTime = completedRenderEndTime;
            pendingSuspendedCommitReason = suspendedCommitReason;
            pendingDelayedCommitReason = IMMEDIATE_COMMIT;
            pendingSuspendedViewTransitionReason = null;
            0 !== finishedWork.actualDuration || 0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? (root2.callbackNode = null, root2.callbackPriority = 0, scheduleCallback$1(NormalPriority$1, function() {
              schedulerEvent = window.event;
              pendingDelayedCommitReason === IMMEDIATE_COMMIT && (pendingDelayedCommitReason = DELAYED_PASSIVE_COMMIT);
              flushPassiveEffects();
              return null;
            })) : (root2.callbackNode = null, root2.callbackPriority = 0);
            commitErrors = null;
            commitStartTime = now();
            null !== suspendedCommitReason && logSuspendedCommitPhase(
              completedRenderEndTime,
              commitStartTime,
              suspendedCommitReason,
              workInProgressUpdateTask
            );
            recoverableErrors = 0 !== (finishedWork.flags & 13878);
            if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
              recoverableErrors = ReactSharedInternals.T;
              ReactSharedInternals.T = null;
              transitions = ReactDOMSharedInternals.p;
              ReactDOMSharedInternals.p = DiscreteEventPriority;
              spawnedLane = executionContext;
              executionContext |= CommitContext;
              try {
                commitBeforeMutationEffects(root2, finishedWork, lanes);
              } finally {
                executionContext = spawnedLane, ReactDOMSharedInternals.p = transitions, ReactSharedInternals.T = recoverableErrors;
              }
            }
            pendingEffectsStatus = PENDING_MUTATION_PHASE;
            flushMutationEffects();
            flushLayoutEffects();
            flushSpawnedWork();
          }
        }
        function flushMutationEffects() {
          if (pendingEffectsStatus === PENDING_MUTATION_PHASE) {
            pendingEffectsStatus = NO_PENDING_EFFECTS;
            var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
            if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
              rootMutationHasEffect = ReactSharedInternals.T;
              ReactSharedInternals.T = null;
              var previousPriority = ReactDOMSharedInternals.p;
              ReactDOMSharedInternals.p = DiscreteEventPriority;
              var prevExecutionContext = executionContext;
              executionContext |= CommitContext;
              try {
                inProgressLanes = lanes;
                inProgressRoot = root2;
                resetComponentEffectTimers();
                commitMutationEffectsOnFiber(finishedWork, root2);
                inProgressRoot = inProgressLanes = null;
                lanes = selectionInformation;
                var curFocusedElem = getActiveElementDeep(root2.containerInfo), priorFocusedElem = lanes.focusedElem, priorSelectionRange = lanes.selectionRange;
                if (curFocusedElem !== priorFocusedElem && priorFocusedElem && priorFocusedElem.ownerDocument && containsNode(
                  priorFocusedElem.ownerDocument.documentElement,
                  priorFocusedElem
                )) {
                  if (null !== priorSelectionRange && hasSelectionCapabilities(priorFocusedElem)) {
                    var start2 = priorSelectionRange.start, end = priorSelectionRange.end;
                    void 0 === end && (end = start2);
                    if ("selectionStart" in priorFocusedElem)
                      priorFocusedElem.selectionStart = start2, priorFocusedElem.selectionEnd = Math.min(
                        end,
                        priorFocusedElem.value.length
                      );
                    else {
                      var doc = priorFocusedElem.ownerDocument || document, win = doc && doc.defaultView || window;
                      if (win.getSelection) {
                        var selection = win.getSelection(), length = priorFocusedElem.textContent.length, start$jscomp$0 = Math.min(
                          priorSelectionRange.start,
                          length
                        ), end$jscomp$0 = void 0 === priorSelectionRange.end ? start$jscomp$0 : Math.min(priorSelectionRange.end, length);
                        !selection.extend && start$jscomp$0 > end$jscomp$0 && (curFocusedElem = end$jscomp$0, end$jscomp$0 = start$jscomp$0, start$jscomp$0 = curFocusedElem);
                        var startMarker = getNodeForCharacterOffset(
                          priorFocusedElem,
                          start$jscomp$0
                        ), endMarker = getNodeForCharacterOffset(
                          priorFocusedElem,
                          end$jscomp$0
                        );
                        if (startMarker && endMarker && (1 !== selection.rangeCount || selection.anchorNode !== startMarker.node || selection.anchorOffset !== startMarker.offset || selection.focusNode !== endMarker.node || selection.focusOffset !== endMarker.offset)) {
                          var range = doc.createRange();
                          range.setStart(startMarker.node, startMarker.offset);
                          selection.removeAllRanges();
                          start$jscomp$0 > end$jscomp$0 ? (selection.addRange(range), selection.extend(endMarker.node, endMarker.offset)) : (range.setEnd(endMarker.node, endMarker.offset), selection.addRange(range));
                        }
                      }
                    }
                  }
                  doc = [];
                  for (selection = priorFocusedElem; selection = selection.parentNode; )
                    1 === selection.nodeType && doc.push({
                      element: selection,
                      left: selection.scrollLeft,
                      top: selection.scrollTop
                    });
                  "function" === typeof priorFocusedElem.focus && priorFocusedElem.focus();
                  for (priorFocusedElem = 0; priorFocusedElem < doc.length; priorFocusedElem++) {
                    var info = doc[priorFocusedElem];
                    info.element.scrollLeft = info.left;
                    info.element.scrollTop = info.top;
                  }
                }
                _enabled = !!eventsEnabled;
                selectionInformation = eventsEnabled = null;
              } finally {
                executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootMutationHasEffect;
              }
            }
            root2.current = finishedWork;
            pendingEffectsStatus = PENDING_LAYOUT_PHASE;
          }
        }
        function flushLayoutEffects() {
          if (pendingEffectsStatus === PENDING_LAYOUT_PHASE) {
            pendingEffectsStatus = NO_PENDING_EFFECTS;
            var suspendedViewTransitionReason = pendingSuspendedViewTransitionReason;
            if (null !== suspendedViewTransitionReason) {
              commitStartTime = now();
              var startTime = commitEndTime, endTime = commitStartTime;
              !supportsUserTiming || endTime <= startTime || (animatingTask ? animatingTask.run(
                console.timeStamp.bind(
                  console,
                  suspendedViewTransitionReason,
                  startTime,
                  endTime,
                  currentTrack,
                  LANES_TRACK_GROUP,
                  "secondary-light"
                )
              ) : console.timeStamp(
                suspendedViewTransitionReason,
                startTime,
                endTime,
                currentTrack,
                LANES_TRACK_GROUP,
                "secondary-light"
              ));
            }
            suspendedViewTransitionReason = pendingEffectsRoot;
            startTime = pendingFinishedWork;
            endTime = pendingEffectsLanes;
            var rootHasLayoutEffect = 0 !== (startTime.flags & 8772);
            if (0 !== (startTime.subtreeFlags & 8772) || rootHasLayoutEffect) {
              rootHasLayoutEffect = ReactSharedInternals.T;
              ReactSharedInternals.T = null;
              var _previousPriority = ReactDOMSharedInternals.p;
              ReactDOMSharedInternals.p = DiscreteEventPriority;
              var _prevExecutionContext = executionContext;
              executionContext |= CommitContext;
              try {
                inProgressLanes = endTime, inProgressRoot = suspendedViewTransitionReason, resetComponentEffectTimers(), commitLayoutEffectOnFiber(
                  suspendedViewTransitionReason,
                  startTime.alternate,
                  startTime
                ), inProgressRoot = inProgressLanes = null;
              } finally {
                executionContext = _prevExecutionContext, ReactDOMSharedInternals.p = _previousPriority, ReactSharedInternals.T = rootHasLayoutEffect;
              }
            }
            suspendedViewTransitionReason = pendingEffectsRenderEndTime;
            startTime = pendingSuspendedCommitReason;
            commitEndTime = now();
            suspendedViewTransitionReason = null === startTime ? suspendedViewTransitionReason : commitStartTime;
            startTime = commitEndTime;
            endTime = pendingDelayedCommitReason === ABORTED_VIEW_TRANSITION_COMMIT;
            rootHasLayoutEffect = workInProgressUpdateTask;
            null !== commitErrors ? logCommitErrored(
              suspendedViewTransitionReason,
              startTime,
              commitErrors,
              false,
              rootHasLayoutEffect
            ) : !supportsUserTiming || startTime <= suspendedViewTransitionReason || (rootHasLayoutEffect ? rootHasLayoutEffect.run(
              console.timeStamp.bind(
                console,
                endTime ? "Commit Interrupted View Transition" : "Commit",
                suspendedViewTransitionReason,
                startTime,
                currentTrack,
                LANES_TRACK_GROUP,
                endTime ? "error" : "secondary-dark"
              )
            ) : console.timeStamp(
              endTime ? "Commit Interrupted View Transition" : "Commit",
              suspendedViewTransitionReason,
              startTime,
              currentTrack,
              LANES_TRACK_GROUP,
              endTime ? "error" : "secondary-dark"
            ));
            pendingEffectsStatus = PENDING_AFTER_MUTATION_PHASE;
          }
        }
        function flushSpawnedWork() {
          if (pendingEffectsStatus === PENDING_SPAWNED_WORK || pendingEffectsStatus === PENDING_AFTER_MUTATION_PHASE) {
            if (pendingEffectsStatus === PENDING_SPAWNED_WORK) {
              var startViewTransitionStartTime = commitEndTime;
              commitEndTime = now();
              var endTime = commitEndTime, abortedViewTransition = pendingDelayedCommitReason === ABORTED_VIEW_TRANSITION_COMMIT;
              !supportsUserTiming || endTime <= startViewTransitionStartTime || (animatingTask ? animatingTask.run(
                console.timeStamp.bind(
                  console,
                  abortedViewTransition ? "Interrupted View Transition" : "Starting Animation",
                  startViewTransitionStartTime,
                  endTime,
                  currentTrack,
                  LANES_TRACK_GROUP,
                  abortedViewTransition ? "error" : "secondary-light"
                )
              ) : console.timeStamp(
                abortedViewTransition ? "Interrupted View Transition" : "Starting Animation",
                startViewTransitionStartTime,
                endTime,
                currentTrack,
                LANES_TRACK_GROUP,
                abortedViewTransition ? " error" : "secondary-light"
              ));
              pendingDelayedCommitReason !== ABORTED_VIEW_TRANSITION_COMMIT && (pendingDelayedCommitReason = ANIMATION_STARTED_COMMIT);
            }
            pendingEffectsStatus = NO_PENDING_EFFECTS;
            requestPaint();
            startViewTransitionStartTime = pendingEffectsRoot;
            var finishedWork = pendingFinishedWork;
            endTime = pendingEffectsLanes;
            abortedViewTransition = pendingRecoverableErrors;
            var rootDidHavePassiveEffects = 0 !== finishedWork.actualDuration || 0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256);
            rootDidHavePassiveEffects ? pendingEffectsStatus = PENDING_PASSIVE_PHASE : (pendingEffectsStatus = NO_PENDING_EFFECTS, pendingFinishedWork = pendingEffectsRoot = null, releaseRootPooledCache(
              startViewTransitionStartTime,
              startViewTransitionStartTime.pendingLanes
            ), nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null);
            var remainingLanes = startViewTransitionStartTime.pendingLanes;
            0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
            rootDidHavePassiveEffects || commitDoubleInvokeEffectsInDEV(startViewTransitionStartTime);
            remainingLanes = lanesToEventPriority(endTime);
            finishedWork = finishedWork.stateNode;
            if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
              try {
                var didError = 128 === (finishedWork.current.flags & 128);
                switch (remainingLanes) {
                  case DiscreteEventPriority:
                    var schedulerPriority = ImmediatePriority;
                    break;
                  case ContinuousEventPriority:
                    schedulerPriority = UserBlockingPriority;
                    break;
                  case DefaultEventPriority:
                    schedulerPriority = NormalPriority$1;
                    break;
                  case IdleEventPriority:
                    schedulerPriority = IdlePriority;
                    break;
                  default:
                    schedulerPriority = NormalPriority$1;
                }
                injectedHook.onCommitFiberRoot(
                  rendererID,
                  finishedWork,
                  schedulerPriority,
                  didError
                );
              } catch (err) {
                hasLoggedError || (hasLoggedError = true, console.error(
                  "React instrumentation encountered an error: %o",
                  err
                ));
              }
            isDevToolsPresent && startViewTransitionStartTime.memoizedUpdaters.clear();
            onCommitRoot();
            if (null !== abortedViewTransition) {
              didError = ReactSharedInternals.T;
              schedulerPriority = ReactDOMSharedInternals.p;
              ReactDOMSharedInternals.p = DiscreteEventPriority;
              ReactSharedInternals.T = null;
              try {
                var onRecoverableError = startViewTransitionStartTime.onRecoverableError;
                for (finishedWork = 0; finishedWork < abortedViewTransition.length; finishedWork++) {
                  var recoverableError = abortedViewTransition[finishedWork], errorInfo = makeErrorInfo(recoverableError.stack);
                  runWithFiberInDEV(
                    recoverableError.source,
                    onRecoverableError,
                    recoverableError.value,
                    errorInfo
                  );
                }
              } finally {
                ReactSharedInternals.T = didError, ReactDOMSharedInternals.p = schedulerPriority;
              }
            }
            0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
            ensureRootIsScheduled(startViewTransitionStartTime);
            remainingLanes = startViewTransitionStartTime.pendingLanes;
            0 !== (endTime & 261930) && 0 !== (remainingLanes & 42) ? (nestedUpdateScheduled = true, startViewTransitionStartTime === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = startViewTransitionStartTime)) : nestedUpdateCount = 0;
            rootDidHavePassiveEffects || finalizeRender(endTime, commitEndTime);
            flushSyncWorkAcrossRoots_impl(0, false);
          }
        }
        function makeErrorInfo(componentStack) {
          componentStack = { componentStack };
          Object.defineProperty(componentStack, "digest", {
            get: function() {
              console.error(
                'You are accessing "digest" from the errorInfo object passed to onRecoverableError. This property is no longer provided as part of errorInfo but can be accessed as a property of the Error instance itself.'
              );
            }
          });
          return componentStack;
        }
        function releaseRootPooledCache(root2, remainingLanes) {
          0 === (root2.pooledCacheLanes &= remainingLanes) && (remainingLanes = root2.pooledCache, null != remainingLanes && (root2.pooledCache = null, releaseCache(remainingLanes)));
        }
        function flushPendingEffects() {
          flushMutationEffects();
          flushLayoutEffects();
          flushSpawnedWork();
          return flushPassiveEffects();
        }
        function flushPassiveEffects() {
          if (pendingEffectsStatus !== PENDING_PASSIVE_PHASE) return false;
          var root2 = pendingEffectsRoot, remainingLanes = pendingEffectsRemainingLanes;
          pendingEffectsRemainingLanes = 0;
          var renderPriority = lanesToEventPriority(pendingEffectsLanes), priority = 0 === DefaultEventPriority || DefaultEventPriority > renderPriority ? DefaultEventPriority : renderPriority;
          renderPriority = ReactSharedInternals.T;
          var previousPriority = ReactDOMSharedInternals.p;
          try {
            ReactDOMSharedInternals.p = priority;
            ReactSharedInternals.T = null;
            var transitions = pendingPassiveTransitions;
            pendingPassiveTransitions = null;
            priority = pendingEffectsRoot;
            var lanes = pendingEffectsLanes;
            pendingEffectsStatus = NO_PENDING_EFFECTS;
            pendingFinishedWork = pendingEffectsRoot = null;
            pendingEffectsLanes = 0;
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
              throw Error("Cannot flush passive effects while already rendering.");
            setCurrentTrackFromLanes(lanes);
            isFlushingPassiveEffects = true;
            didScheduleUpdateDuringPassiveEffects = false;
            var passiveEffectStartTime = 0;
            commitErrors = null;
            passiveEffectStartTime = now$1();
            if (pendingDelayedCommitReason === ANIMATION_STARTED_COMMIT)
              logAnimatingPhase(
                commitEndTime,
                passiveEffectStartTime,
                animatingTask
              );
            else {
              var startTime = commitEndTime, endTime = passiveEffectStartTime, delayedUntilPaint = pendingDelayedCommitReason === DELAYED_PASSIVE_COMMIT;
              !supportsUserTiming || endTime <= startTime || (workInProgressUpdateTask ? workInProgressUpdateTask.run(
                console.timeStamp.bind(
                  console,
                  delayedUntilPaint ? "Waiting for Paint" : "Waiting",
                  startTime,
                  endTime,
                  currentTrack,
                  LANES_TRACK_GROUP,
                  "secondary-light"
                )
              ) : console.timeStamp(
                delayedUntilPaint ? "Waiting for Paint" : "Waiting",
                startTime,
                endTime,
                currentTrack,
                LANES_TRACK_GROUP,
                "secondary-light"
              ));
            }
            startTime = executionContext;
            executionContext |= CommitContext;
            var finishedWork = priority.current;
            resetComponentEffectTimers();
            commitPassiveUnmountOnFiber(finishedWork);
            var finishedWork$jscomp$0 = priority.current;
            finishedWork = pendingEffectsRenderEndTime;
            resetComponentEffectTimers();
            commitPassiveMountOnFiber(
              priority,
              finishedWork$jscomp$0,
              lanes,
              transitions,
              finishedWork
            );
            commitDoubleInvokeEffectsInDEV(priority);
            executionContext = startTime;
            var passiveEffectsEndTime = now$1();
            finishedWork$jscomp$0 = passiveEffectStartTime;
            finishedWork = workInProgressUpdateTask;
            null !== commitErrors ? logCommitErrored(
              finishedWork$jscomp$0,
              passiveEffectsEndTime,
              commitErrors,
              true,
              finishedWork
            ) : !supportsUserTiming || passiveEffectsEndTime <= finishedWork$jscomp$0 || (finishedWork ? finishedWork.run(
              console.timeStamp.bind(
                console,
                "Remaining Effects",
                finishedWork$jscomp$0,
                passiveEffectsEndTime,
                currentTrack,
                LANES_TRACK_GROUP,
                "secondary-dark"
              )
            ) : console.timeStamp(
              "Remaining Effects",
              finishedWork$jscomp$0,
              passiveEffectsEndTime,
              currentTrack,
              LANES_TRACK_GROUP,
              "secondary-dark"
            ));
            finalizeRender(lanes, passiveEffectsEndTime);
            flushSyncWorkAcrossRoots_impl(0, false);
            didScheduleUpdateDuringPassiveEffects ? priority === rootWithPassiveNestedUpdates ? nestedPassiveUpdateCount++ : (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = priority) : nestedPassiveUpdateCount = 0;
            didScheduleUpdateDuringPassiveEffects = isFlushingPassiveEffects = false;
            if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot)
              try {
                injectedHook.onPostCommitFiberRoot(rendererID, priority);
              } catch (err) {
                hasLoggedError || (hasLoggedError = true, console.error(
                  "React instrumentation encountered an error: %o",
                  err
                ));
              }
            var stateNode = priority.current.stateNode;
            stateNode.effectDuration = 0;
            stateNode.passiveEffectDuration = 0;
            return true;
          } finally {
            ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = renderPriority, releaseRootPooledCache(root2, remainingLanes);
          }
        }
        function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
          sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
          recordEffectError(sourceFiber);
          sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
          rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
          null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
        }
        function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
          isRunningInsertionEffect = false;
          if (3 === sourceFiber.tag)
            captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
          else {
            for (; null !== nearestMountedAncestor; ) {
              if (3 === nearestMountedAncestor.tag) {
                captureCommitPhaseErrorOnRoot(
                  nearestMountedAncestor,
                  sourceFiber,
                  error
                );
                return;
              }
              if (1 === nearestMountedAncestor.tag) {
                var instance = nearestMountedAncestor.stateNode;
                if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
                  sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
                  recordEffectError(sourceFiber);
                  error = createClassErrorUpdate(2);
                  instance = enqueueUpdate(nearestMountedAncestor, error, 2);
                  null !== instance && (initializeClassErrorUpdate(
                    error,
                    instance,
                    nearestMountedAncestor,
                    sourceFiber
                  ), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
                  return;
                }
              }
              nearestMountedAncestor = nearestMountedAncestor.return;
            }
            console.error(
              "Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Potential causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s",
              error
            );
          }
        }
        function attachPingListener(root2, wakeable, lanes) {
          var pingCache = root2.pingCache;
          if (null === pingCache) {
            pingCache = root2.pingCache = new PossiblyWeakMap();
            var threadIDs = /* @__PURE__ */ new Set();
            pingCache.set(wakeable, threadIDs);
          } else
            threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = /* @__PURE__ */ new Set(), pingCache.set(wakeable, threadIDs));
          threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = true, threadIDs.add(lanes), pingCache = pingSuspendedRoot.bind(null, root2, wakeable, lanes), isDevToolsPresent && restorePendingUpdaters(root2, lanes), wakeable.then(pingCache, pingCache));
        }
        function pingSuspendedRoot(root2, wakeable, pingedLanes) {
          var pingCache = root2.pingCache;
          null !== pingCache && pingCache.delete(wakeable);
          root2.pingedLanes |= root2.suspendedLanes & pingedLanes;
          root2.warmLanes &= ~pingedLanes;
          0 !== (pingedLanes & 127) ? 0 > blockingUpdateTime && (blockingClampTime = blockingUpdateTime = now(), blockingUpdateTask = createTask("Promise Resolved"), blockingUpdateType = PINGED_UPDATE) : 0 !== (pingedLanes & 4194048) && 0 > transitionUpdateTime && (transitionClampTime = transitionUpdateTime = now(), transitionUpdateTask = createTask("Promise Resolved"), transitionUpdateType = PINGED_UPDATE);
          isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && console.error(
            "A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() => {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act"
          );
          workInProgressRoot === root2 && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && now$1() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS ? (executionContext & RenderContext) === NoContext && prepareFreshStack(root2, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
          ensureRootIsScheduled(root2);
        }
        function retryTimedOutBoundary(boundaryFiber, retryLane) {
          0 === retryLane && (retryLane = claimNextRetryLane());
          boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
          null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
        }
        function retryDehydratedSuspenseBoundary(boundaryFiber) {
          var suspenseState = boundaryFiber.memoizedState, retryLane = 0;
          null !== suspenseState && (retryLane = suspenseState.retryLane);
          retryTimedOutBoundary(boundaryFiber, retryLane);
        }
        function resolveRetryWakeable(boundaryFiber, wakeable) {
          var retryLane = 0;
          switch (boundaryFiber.tag) {
            case 31:
            case 13:
              var retryCache = boundaryFiber.stateNode;
              var suspenseState = boundaryFiber.memoizedState;
              null !== suspenseState && (retryLane = suspenseState.retryLane);
              break;
            case 19:
              retryCache = boundaryFiber.stateNode;
              break;
            case 22:
              retryCache = boundaryFiber.stateNode._retryCache;
              break;
            default:
              throw Error(
                "Pinged unknown suspense boundary type. This is probably a bug in React."
              );
          }
          null !== retryCache && retryCache.delete(wakeable);
          retryTimedOutBoundary(boundaryFiber, retryLane);
        }
        function recursivelyTraverseAndDoubleInvokeEffectsInDEV(root$jscomp$0, parentFiber, isInStrictMode) {
          if (0 !== (parentFiber.subtreeFlags & 67117056))
            for (parentFiber = parentFiber.child; null !== parentFiber; ) {
              var root2 = root$jscomp$0, fiber = parentFiber, isStrictModeFiber = fiber.type === REACT_STRICT_MODE_TYPE;
              isStrictModeFiber = isInStrictMode || isStrictModeFiber;
              22 !== fiber.tag ? fiber.flags & 67108864 ? isStrictModeFiber && runWithFiberInDEV(
                fiber,
                doubleInvokeEffectsOnFiber,
                root2,
                fiber
              ) : recursivelyTraverseAndDoubleInvokeEffectsInDEV(
                root2,
                fiber,
                isStrictModeFiber
              ) : null === fiber.memoizedState && (isStrictModeFiber && fiber.flags & 8192 ? runWithFiberInDEV(
                fiber,
                doubleInvokeEffectsOnFiber,
                root2,
                fiber
              ) : fiber.subtreeFlags & 67108864 && runWithFiberInDEV(
                fiber,
                recursivelyTraverseAndDoubleInvokeEffectsInDEV,
                root2,
                fiber,
                isStrictModeFiber
              ));
              parentFiber = parentFiber.sibling;
            }
        }
        function doubleInvokeEffectsOnFiber(root2, fiber) {
          setIsStrictModeForDevtools(true);
          try {
            disappearLayoutEffects(fiber), disconnectPassiveEffect(fiber), reappearLayoutEffects(root2, fiber.alternate, fiber, false), reconnectPassiveEffects(root2, fiber, 0, null, false, 0);
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
        function commitDoubleInvokeEffectsInDEV(root2) {
          var doubleInvokeEffects = true;
          root2.current.mode & (StrictLegacyMode | StrictEffectsMode) || (doubleInvokeEffects = false);
          recursivelyTraverseAndDoubleInvokeEffectsInDEV(
            root2,
            root2.current,
            doubleInvokeEffects
          );
        }
        function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
          if ((executionContext & RenderContext) === NoContext) {
            var tag = fiber.tag;
            if (3 === tag || 1 === tag || 0 === tag || 11 === tag || 14 === tag || 15 === tag) {
              tag = getComponentNameFromFiber(fiber) || "ReactComponent";
              if (null !== didWarnStateUpdateForNotYetMountedComponent) {
                if (didWarnStateUpdateForNotYetMountedComponent.has(tag)) return;
                didWarnStateUpdateForNotYetMountedComponent.add(tag);
              } else didWarnStateUpdateForNotYetMountedComponent = /* @__PURE__ */ new Set([tag]);
              runWithFiberInDEV(fiber, function() {
                console.error(
                  "Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously tries to update the component. Move this work to useEffect instead."
                );
              });
            }
          }
        }
        function restorePendingUpdaters(root2, lanes) {
          isDevToolsPresent && root2.memoizedUpdaters.forEach(function(schedulingFiber) {
            addFiberToLanesMap(root2, schedulingFiber, lanes);
          });
        }
        function scheduleCallback$1(priorityLevel, callback) {
          var actQueue = ReactSharedInternals.actQueue;
          return null !== actQueue ? (actQueue.push(callback), fakeActCallbackNode$1) : scheduleCallback$3(priorityLevel, callback);
        }
        function warnIfUpdatesNotWrappedWithActDEV(fiber) {
          isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && runWithFiberInDEV(fiber, function() {
            console.error(
              "An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act",
              getComponentNameFromFiber(fiber)
            );
          });
        }
        function ensureRootIsScheduled(root2) {
          root2 !== lastScheduledRoot && null === root2.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root2 : lastScheduledRoot = lastScheduledRoot.next = root2);
          mightHavePendingSyncWork = true;
          null !== ReactSharedInternals.actQueue ? didScheduleMicrotask_act || (didScheduleMicrotask_act = true, scheduleImmediateRootScheduleTask()) : didScheduleMicrotask || (didScheduleMicrotask = true, scheduleImmediateRootScheduleTask());
        }
        function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
          if (!isFlushingWork && mightHavePendingSyncWork) {
            isFlushingWork = true;
            do {
              var didPerformSomeWork = false;
              for (var root2 = firstScheduledRoot; null !== root2; ) {
                if (!onlyLegacy)
                  if (0 !== syncTransitionLanes) {
                    var pendingLanes = root2.pendingLanes;
                    if (0 === pendingLanes) var nextLanes = 0;
                    else {
                      var suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes;
                      nextLanes = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
                      nextLanes &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
                      nextLanes = nextLanes & 201326741 ? nextLanes & 201326741 | 1 : nextLanes ? nextLanes | 2 : 0;
                    }
                    0 !== nextLanes && (didPerformSomeWork = true, performSyncWorkOnRoot(root2, nextLanes));
                  } else
                    nextLanes = workInProgressRootRenderLanes, nextLanes = getNextLanes(
                      root2,
                      root2 === workInProgressRoot ? nextLanes : 0,
                      null !== root2.cancelPendingCommit || root2.timeoutHandle !== noTimeout
                    ), 0 === (nextLanes & 3) || checkIfRootIsPrerendering(root2, nextLanes) || (didPerformSomeWork = true, performSyncWorkOnRoot(root2, nextLanes));
                root2 = root2.next;
              }
            } while (didPerformSomeWork);
            isFlushingWork = false;
          }
        }
        function processRootScheduleInImmediateTask() {
          schedulerEvent = window.event;
          processRootScheduleInMicrotask();
        }
        function processRootScheduleInMicrotask() {
          mightHavePendingSyncWork = didScheduleMicrotask_act = didScheduleMicrotask = false;
          var syncTransitionLanes = 0;
          0 !== currentEventTransitionLane && shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane);
          for (var currentTime = now$1(), prev = null, root2 = firstScheduledRoot; null !== root2; ) {
            var next = root2.next, nextLanes = scheduleTaskForRootDuringMicrotask(root2, currentTime);
            if (0 === nextLanes)
              root2.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);
            else if (prev = root2, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
              mightHavePendingSyncWork = true;
            root2 = next;
          }
          pendingEffectsStatus !== NO_PENDING_EFFECTS && pendingEffectsStatus !== PENDING_PASSIVE_PHASE || flushSyncWorkAcrossRoots_impl(syncTransitionLanes, false);
          0 !== currentEventTransitionLane && (currentEventTransitionLane = 0);
        }
        function scheduleTaskForRootDuringMicrotask(root2, currentTime) {
          for (var suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes, expirationTimes = root2.expirationTimes, lanes = root2.pendingLanes & -62914561; 0 < lanes; ) {
            var index = 31 - clz32(lanes), lane = 1 << index, expirationTime = expirationTimes[index];
            if (-1 === expirationTime) {
              if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
                expirationTimes[index] = computeExpirationTime(lane, currentTime);
            } else expirationTime <= currentTime && (root2.expiredLanes |= lane);
            lanes &= ~lane;
          }
          currentTime = workInProgressRoot;
          suspendedLanes = workInProgressRootRenderLanes;
          suspendedLanes = getNextLanes(
            root2,
            root2 === currentTime ? suspendedLanes : 0,
            null !== root2.cancelPendingCommit || root2.timeoutHandle !== noTimeout
          );
          pingedLanes = root2.callbackNode;
          if (0 === suspendedLanes || root2 === currentTime && (workInProgressSuspendedReason === SuspendedOnData || workInProgressSuspendedReason === SuspendedOnAction) || null !== root2.cancelPendingCommit)
            return null !== pingedLanes && cancelCallback(pingedLanes), root2.callbackNode = null, root2.callbackPriority = 0;
          if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root2, suspendedLanes)) {
            currentTime = suspendedLanes & -suspendedLanes;
            if (currentTime !== root2.callbackPriority || null !== ReactSharedInternals.actQueue && pingedLanes !== fakeActCallbackNode)
              cancelCallback(pingedLanes);
            else return currentTime;
            switch (lanesToEventPriority(suspendedLanes)) {
              case DiscreteEventPriority:
              case ContinuousEventPriority:
                suspendedLanes = UserBlockingPriority;
                break;
              case DefaultEventPriority:
                suspendedLanes = NormalPriority$1;
                break;
              case IdleEventPriority:
                suspendedLanes = IdlePriority;
                break;
              default:
                suspendedLanes = NormalPriority$1;
            }
            pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root2);
            null !== ReactSharedInternals.actQueue ? (ReactSharedInternals.actQueue.push(pingedLanes), suspendedLanes = fakeActCallbackNode) : suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
            root2.callbackPriority = currentTime;
            root2.callbackNode = suspendedLanes;
            return currentTime;
          }
          null !== pingedLanes && cancelCallback(pingedLanes);
          root2.callbackPriority = 2;
          root2.callbackNode = null;
          return 2;
        }
        function performWorkOnRootViaSchedulerTask(root2, didTimeout) {
          nestedUpdateScheduled = currentUpdateIsNested = false;
          schedulerEvent = window.event;
          if (pendingEffectsStatus !== NO_PENDING_EFFECTS && pendingEffectsStatus !== PENDING_PASSIVE_PHASE)
            return root2.callbackNode = null, root2.callbackPriority = 0, null;
          var originalCallbackNode = root2.callbackNode;
          pendingDelayedCommitReason === IMMEDIATE_COMMIT && (pendingDelayedCommitReason = DELAYED_PASSIVE_COMMIT);
          if (flushPendingEffects() && root2.callbackNode !== originalCallbackNode)
            return null;
          var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
          workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
            root2,
            root2 === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0,
            null !== root2.cancelPendingCommit || root2.timeoutHandle !== noTimeout
          );
          if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
          performWorkOnRoot(
            root2,
            workInProgressRootRenderLanes$jscomp$0,
            didTimeout
          );
          scheduleTaskForRootDuringMicrotask(root2, now$1());
          return null != root2.callbackNode && root2.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root2) : null;
        }
        function performSyncWorkOnRoot(root2, lanes) {
          if (flushPendingEffects()) return null;
          currentUpdateIsNested = nestedUpdateScheduled;
          nestedUpdateScheduled = false;
          performWorkOnRoot(root2, lanes, true);
        }
        function cancelCallback(callbackNode) {
          callbackNode !== fakeActCallbackNode && null !== callbackNode && cancelCallback$1(callbackNode);
        }
        function scheduleImmediateRootScheduleTask() {
          null !== ReactSharedInternals.actQueue && ReactSharedInternals.actQueue.push(function() {
            processRootScheduleInMicrotask();
            return null;
          });
          scheduleMicrotask(function() {
            (executionContext & (RenderContext | CommitContext)) !== NoContext ? scheduleCallback$3(
              ImmediatePriority,
              processRootScheduleInImmediateTask
            ) : processRootScheduleInMicrotask();
          });
        }
        function requestTransitionLane() {
          if (0 === currentEventTransitionLane) {
            var actionScopeLane = currentEntangledLane;
            0 === actionScopeLane && (actionScopeLane = nextTransitionUpdateLane, nextTransitionUpdateLane <<= 1, 0 === (nextTransitionUpdateLane & 261888) && (nextTransitionUpdateLane = 256));
            currentEventTransitionLane = actionScopeLane;
          }
          return currentEventTransitionLane;
        }
        function coerceFormActionProp(actionProp) {
          if (null == actionProp || "symbol" === typeof actionProp || "boolean" === typeof actionProp)
            return null;
          if ("function" === typeof actionProp) return actionProp;
          checkAttributeStringCoercion(actionProp, "action");
          return sanitizeURL("" + actionProp);
        }
        function createFormDataWithSubmitter(form, submitter) {
          var temp = submitter.ownerDocument.createElement("input");
          temp.name = submitter.name;
          temp.value = submitter.value;
          form.id && temp.setAttribute("form", form.id);
          submitter.parentNode.insertBefore(temp, submitter);
          form = new FormData(form);
          temp.parentNode.removeChild(temp);
          return form;
        }
        function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
          if ("submit" === domEventName && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
            var action = coerceFormActionProp(
              (nativeEventTarget[internalPropsKey] || null).action
            ), submitter = nativeEvent.submitter;
            submitter && (domEventName = (domEventName = submitter[internalPropsKey] || null) ? coerceFormActionProp(domEventName.formAction) : submitter.getAttribute("formAction"), null !== domEventName && (action = domEventName, submitter = null));
            var event = new SyntheticEvent(
              "action",
              "action",
              null,
              nativeEvent,
              nativeEventTarget
            );
            dispatchQueue.push({
              event,
              listeners: [
                {
                  instance: null,
                  listener: function() {
                    if (nativeEvent.defaultPrevented) {
                      if (0 !== currentEventTransitionLane) {
                        var formData = submitter ? createFormDataWithSubmitter(
                          nativeEventTarget,
                          submitter
                        ) : new FormData(nativeEventTarget), pendingState = {
                          pending: true,
                          data: formData,
                          method: nativeEventTarget.method,
                          action
                        };
                        Object.freeze(pendingState);
                        startHostTransition(
                          maybeTargetInst,
                          pendingState,
                          null,
                          formData
                        );
                      }
                    } else
                      "function" === typeof action && (event.preventDefault(), formData = submitter ? createFormDataWithSubmitter(
                        nativeEventTarget,
                        submitter
                      ) : new FormData(nativeEventTarget), pendingState = {
                        pending: true,
                        data: formData,
                        method: nativeEventTarget.method,
                        action
                      }, Object.freeze(pendingState), startHostTransition(
                        maybeTargetInst,
                        pendingState,
                        action,
                        formData
                      ));
                  },
                  currentTarget: nativeEventTarget
                }
              ]
            });
          }
        }
        function executeDispatch(event, listener, currentTarget) {
          event.currentTarget = currentTarget;
          try {
            listener(event);
          } catch (error) {
            reportGlobalError(error);
          }
          event.currentTarget = null;
        }
        function processDispatchQueue(dispatchQueue, eventSystemFlags) {
          eventSystemFlags = 0 !== (eventSystemFlags & 4);
          for (var i5 = 0; i5 < dispatchQueue.length; i5++) {
            var _dispatchQueue$i = dispatchQueue[i5];
            a: {
              var previousInstance = void 0, event = _dispatchQueue$i.event;
              _dispatchQueue$i = _dispatchQueue$i.listeners;
              if (eventSystemFlags)
                for (var i$jscomp$0 = _dispatchQueue$i.length - 1; 0 <= i$jscomp$0; i$jscomp$0--) {
                  var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget;
                  _dispatchListeners$i = _dispatchListeners$i.listener;
                  if (instance !== previousInstance && event.isPropagationStopped())
                    break a;
                  null !== instance ? runWithFiberInDEV(
                    instance,
                    executeDispatch,
                    event,
                    _dispatchListeners$i,
                    currentTarget
                  ) : executeDispatch(event, _dispatchListeners$i, currentTarget);
                  previousInstance = instance;
                }
              else
                for (i$jscomp$0 = 0; i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++) {
                  _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
                  instance = _dispatchListeners$i.instance;
                  currentTarget = _dispatchListeners$i.currentTarget;
                  _dispatchListeners$i = _dispatchListeners$i.listener;
                  if (instance !== previousInstance && event.isPropagationStopped())
                    break a;
                  null !== instance ? runWithFiberInDEV(
                    instance,
                    executeDispatch,
                    event,
                    _dispatchListeners$i,
                    currentTarget
                  ) : executeDispatch(event, _dispatchListeners$i, currentTarget);
                  previousInstance = instance;
                }
            }
          }
        }
        function listenToNonDelegatedEvent(domEventName, targetElement) {
          nonDelegatedEvents.has(domEventName) || console.error(
            'Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.',
            domEventName
          );
          var listenerSet = targetElement[internalEventHandlersKey];
          void 0 === listenerSet && (listenerSet = targetElement[internalEventHandlersKey] = /* @__PURE__ */ new Set());
          var listenerSetKey = domEventName + "__bubble";
          listenerSet.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, false), listenerSet.add(listenerSetKey));
        }
        function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
          nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener && console.error(
            'Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.',
            domEventName
          );
          var eventSystemFlags = 0;
          isCapturePhaseListener && (eventSystemFlags |= 4);
          addTrappedEventListener(
            target,
            domEventName,
            eventSystemFlags,
            isCapturePhaseListener
          );
        }
        function listenToAllSupportedEvents(rootContainerElement) {
          if (!rootContainerElement[listeningMarker]) {
            rootContainerElement[listeningMarker] = true;
            allNativeEvents.forEach(function(domEventName) {
              "selectionchange" !== domEventName && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, false, rootContainerElement), listenToNativeEvent(domEventName, true, rootContainerElement));
            });
            var ownerDocument = 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
            null === ownerDocument || ownerDocument[listeningMarker] || (ownerDocument[listeningMarker] = true, listenToNativeEvent("selectionchange", false, ownerDocument));
          }
        }
        function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
          switch (getEventPriority(domEventName)) {
            case DiscreteEventPriority:
              var listenerWrapper = dispatchDiscreteEvent;
              break;
            case ContinuousEventPriority:
              listenerWrapper = dispatchContinuousEvent;
              break;
            default:
              listenerWrapper = dispatchEvent;
          }
          eventSystemFlags = listenerWrapper.bind(
            null,
            domEventName,
            eventSystemFlags,
            targetContainer
          );
          listenerWrapper = void 0;
          !passiveBrowserEventsSupported || "touchstart" !== domEventName && "touchmove" !== domEventName && "wheel" !== domEventName || (listenerWrapper = true);
          isCapturePhaseListener ? void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
            capture: true,
            passive: listenerWrapper
          }) : targetContainer.addEventListener(domEventName, eventSystemFlags, true) : void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
            passive: listenerWrapper
          }) : targetContainer.addEventListener(
            domEventName,
            eventSystemFlags,
            false
          );
        }
        function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {
          var ancestorInst = targetInst$jscomp$0;
          if (0 === (eventSystemFlags & 1) && 0 === (eventSystemFlags & 2) && null !== targetInst$jscomp$0)
            a: for (; ; ) {
              if (null === targetInst$jscomp$0) return;
              var nodeTag = targetInst$jscomp$0.tag;
              if (3 === nodeTag || 4 === nodeTag) {
                var container = targetInst$jscomp$0.stateNode.containerInfo;
                if (container === targetContainer) break;
                if (4 === nodeTag)
                  for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
                    var grandTag = nodeTag.tag;
                    if ((3 === grandTag || 4 === grandTag) && nodeTag.stateNode.containerInfo === targetContainer)
                      return;
                    nodeTag = nodeTag.return;
                  }
                for (; null !== container; ) {
                  nodeTag = getClosestInstanceFromNode(container);
                  if (null === nodeTag) return;
                  grandTag = nodeTag.tag;
                  if (5 === grandTag || 6 === grandTag || 26 === grandTag || 27 === grandTag) {
                    targetInst$jscomp$0 = ancestorInst = nodeTag;
                    continue a;
                  }
                  container = container.parentNode;
                }
              }
              targetInst$jscomp$0 = targetInst$jscomp$0.return;
            }
          batchedUpdates$1(function() {
            var targetInst = ancestorInst, nativeEventTarget = getEventTarget(nativeEvent), dispatchQueue = [];
            a: {
              var reactName = topLevelEventsToReactNames.get(domEventName);
              if (void 0 !== reactName) {
                var SyntheticEventCtor = SyntheticEvent, reactEventType = domEventName;
                switch (domEventName) {
                  case "keypress":
                    if (0 === getEventCharCode(nativeEvent)) break a;
                  case "keydown":
                  case "keyup":
                    SyntheticEventCtor = SyntheticKeyboardEvent;
                    break;
                  case "focusin":
                    reactEventType = "focus";
                    SyntheticEventCtor = SyntheticFocusEvent;
                    break;
                  case "focusout":
                    reactEventType = "blur";
                    SyntheticEventCtor = SyntheticFocusEvent;
                    break;
                  case "beforeblur":
                  case "afterblur":
                    SyntheticEventCtor = SyntheticFocusEvent;
                    break;
                  case "click":
                    if (2 === nativeEvent.button) break a;
                  case "auxclick":
                  case "dblclick":
                  case "mousedown":
                  case "mousemove":
                  case "mouseup":
                  case "mouseout":
                  case "mouseover":
                  case "contextmenu":
                    SyntheticEventCtor = SyntheticMouseEvent;
                    break;
                  case "drag":
                  case "dragend":
                  case "dragenter":
                  case "dragexit":
                  case "dragleave":
                  case "dragover":
                  case "dragstart":
                  case "drop":
                    SyntheticEventCtor = SyntheticDragEvent;
                    break;
                  case "touchcancel":
                  case "touchend":
                  case "touchmove":
                  case "touchstart":
                    SyntheticEventCtor = SyntheticTouchEvent;
                    break;
                  case ANIMATION_END:
                  case ANIMATION_ITERATION:
                  case ANIMATION_START:
                    SyntheticEventCtor = SyntheticAnimationEvent;
                    break;
                  case TRANSITION_END:
                    SyntheticEventCtor = SyntheticTransitionEvent;
                    break;
                  case "scroll":
                  case "scrollend":
                    SyntheticEventCtor = SyntheticUIEvent;
                    break;
                  case "wheel":
                    SyntheticEventCtor = SyntheticWheelEvent;
                    break;
                  case "copy":
                  case "cut":
                  case "paste":
                    SyntheticEventCtor = SyntheticClipboardEvent;
                    break;
                  case "gotpointercapture":
                  case "lostpointercapture":
                  case "pointercancel":
                  case "pointerdown":
                  case "pointermove":
                  case "pointerout":
                  case "pointerover":
                  case "pointerup":
                    SyntheticEventCtor = SyntheticPointerEvent;
                    break;
                  case "toggle":
                  case "beforetoggle":
                    SyntheticEventCtor = SyntheticToggleEvent;
                }
                var inCapturePhase = 0 !== (eventSystemFlags & 4), accumulateTargetOnly = !inCapturePhase && ("scroll" === domEventName || "scrollend" === domEventName), reactEventName = inCapturePhase ? null !== reactName ? reactName + "Capture" : null : reactName;
                inCapturePhase = [];
                for (var instance = targetInst, lastHostComponent; null !== instance; ) {
                  var _instance2 = instance;
                  lastHostComponent = _instance2.stateNode;
                  _instance2 = _instance2.tag;
                  5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2 || null === lastHostComponent || null === reactEventName || (_instance2 = getListener(instance, reactEventName), null != _instance2 && inCapturePhase.push(
                    createDispatchListener(
                      instance,
                      _instance2,
                      lastHostComponent
                    )
                  ));
                  if (accumulateTargetOnly) break;
                  instance = instance.return;
                }
                0 < inCapturePhase.length && (reactName = new SyntheticEventCtor(
                  reactName,
                  reactEventType,
                  null,
                  nativeEvent,
                  nativeEventTarget
                ), dispatchQueue.push({
                  event: reactName,
                  listeners: inCapturePhase
                }));
              }
            }
            if (0 === (eventSystemFlags & 7)) {
              a: {
                reactName = "mouseover" === domEventName || "pointerover" === domEventName;
                SyntheticEventCtor = "mouseout" === domEventName || "pointerout" === domEventName;
                if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey]))
                  break a;
                if (SyntheticEventCtor || reactName) {
                  reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : (reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : window;
                  if (SyntheticEventCtor) {
                    if (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement, SyntheticEventCtor = targetInst, reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null, null !== reactEventType && (accumulateTargetOnly = getNearestMountedFiber(reactEventType), inCapturePhase = reactEventType.tag, reactEventType !== accumulateTargetOnly || 5 !== inCapturePhase && 27 !== inCapturePhase && 6 !== inCapturePhase))
                      reactEventType = null;
                  } else SyntheticEventCtor = null, reactEventType = targetInst;
                  if (SyntheticEventCtor !== reactEventType) {
                    inCapturePhase = SyntheticMouseEvent;
                    _instance2 = "onMouseLeave";
                    reactEventName = "onMouseEnter";
                    instance = "mouse";
                    if ("pointerout" === domEventName || "pointerover" === domEventName)
                      inCapturePhase = SyntheticPointerEvent, _instance2 = "onPointerLeave", reactEventName = "onPointerEnter", instance = "pointer";
                    accumulateTargetOnly = null == SyntheticEventCtor ? reactName : getNodeFromInstance(SyntheticEventCtor);
                    lastHostComponent = null == reactEventType ? reactName : getNodeFromInstance(reactEventType);
                    reactName = new inCapturePhase(
                      _instance2,
                      instance + "leave",
                      SyntheticEventCtor,
                      nativeEvent,
                      nativeEventTarget
                    );
                    reactName.target = accumulateTargetOnly;
                    reactName.relatedTarget = lastHostComponent;
                    _instance2 = null;
                    getClosestInstanceFromNode(nativeEventTarget) === targetInst && (inCapturePhase = new inCapturePhase(
                      reactEventName,
                      instance + "enter",
                      reactEventType,
                      nativeEvent,
                      nativeEventTarget
                    ), inCapturePhase.target = lastHostComponent, inCapturePhase.relatedTarget = accumulateTargetOnly, _instance2 = inCapturePhase);
                    accumulateTargetOnly = _instance2;
                    if (SyntheticEventCtor && reactEventType)
                      b: {
                        inCapturePhase = getParent;
                        reactEventName = SyntheticEventCtor;
                        instance = reactEventType;
                        lastHostComponent = 0;
                        for (_instance2 = reactEventName; _instance2; _instance2 = inCapturePhase(_instance2))
                          lastHostComponent++;
                        _instance2 = 0;
                        for (var tempB = instance; tempB; tempB = inCapturePhase(tempB))
                          _instance2++;
                        for (; 0 < lastHostComponent - _instance2; )
                          reactEventName = inCapturePhase(reactEventName), lastHostComponent--;
                        for (; 0 < _instance2 - lastHostComponent; )
                          instance = inCapturePhase(instance), _instance2--;
                        for (; lastHostComponent--; ) {
                          if (reactEventName === instance || null !== instance && reactEventName === instance.alternate) {
                            inCapturePhase = reactEventName;
                            break b;
                          }
                          reactEventName = inCapturePhase(reactEventName);
                          instance = inCapturePhase(instance);
                        }
                        inCapturePhase = null;
                      }
                    else inCapturePhase = null;
                    null !== SyntheticEventCtor && accumulateEnterLeaveListenersForEvent(
                      dispatchQueue,
                      reactName,
                      SyntheticEventCtor,
                      inCapturePhase,
                      false
                    );
                    null !== reactEventType && null !== accumulateTargetOnly && accumulateEnterLeaveListenersForEvent(
                      dispatchQueue,
                      accumulateTargetOnly,
                      reactEventType,
                      inCapturePhase,
                      true
                    );
                  }
                }
              }
              a: {
                reactName = targetInst ? getNodeFromInstance(targetInst) : window;
                SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
                if ("select" === SyntheticEventCtor || "input" === SyntheticEventCtor && "file" === reactName.type)
                  var getTargetInstFunc = getTargetInstForChangeEvent;
                else if (isTextInputElement(reactName))
                  if (isInputEventSupported)
                    getTargetInstFunc = getTargetInstForInputOrChangeEvent;
                  else {
                    getTargetInstFunc = getTargetInstForInputEventPolyfill;
                    var handleEventFunc = handleEventsForInputEventPolyfill;
                  }
                else
                  SyntheticEventCtor = reactName.nodeName, !SyntheticEventCtor || "input" !== SyntheticEventCtor.toLowerCase() || "checkbox" !== reactName.type && "radio" !== reactName.type ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunc = getTargetInstForChangeEvent) : getTargetInstFunc = getTargetInstForClickEvent;
                if (getTargetInstFunc && (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))) {
                  createAndAccumulateChangeEvent(
                    dispatchQueue,
                    getTargetInstFunc,
                    nativeEvent,
                    nativeEventTarget
                  );
                  break a;
                }
                handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
                "focusout" === domEventName && targetInst && "number" === reactName.type && null != targetInst.memoizedProps.value && setDefaultValue(reactName, "number", reactName.value);
              }
              handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
              switch (domEventName) {
                case "focusin":
                  if (isTextInputElement(handleEventFunc) || "true" === handleEventFunc.contentEditable)
                    activeElement = handleEventFunc, activeElementInst = targetInst, lastSelection = null;
                  break;
                case "focusout":
                  lastSelection = activeElementInst = activeElement = null;
                  break;
                case "mousedown":
                  mouseDown = true;
                  break;
                case "contextmenu":
                case "mouseup":
                case "dragend":
                  mouseDown = false;
                  constructSelectEvent(
                    dispatchQueue,
                    nativeEvent,
                    nativeEventTarget
                  );
                  break;
                case "selectionchange":
                  if (skipSelectionChangeEvent) break;
                case "keydown":
                case "keyup":
                  constructSelectEvent(
                    dispatchQueue,
                    nativeEvent,
                    nativeEventTarget
                  );
              }
              var fallbackData;
              if (canUseCompositionEvent)
                b: {
                  switch (domEventName) {
                    case "compositionstart":
                      var eventType = "onCompositionStart";
                      break b;
                    case "compositionend":
                      eventType = "onCompositionEnd";
                      break b;
                    case "compositionupdate":
                      eventType = "onCompositionUpdate";
                      break b;
                  }
                  eventType = void 0;
                }
              else
                isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : "keydown" === domEventName && nativeEvent.keyCode === START_KEYCODE && (eventType = "onCompositionStart");
              eventType && (useFallbackCompositionData && "ko" !== nativeEvent.locale && (isComposing || "onCompositionStart" !== eventType ? "onCompositionEnd" === eventType && isComposing && (fallbackData = getData()) : (root = nativeEventTarget, startText = "value" in root ? root.value : root.textContent, isComposing = true)), handleEventFunc = accumulateTwoPhaseListeners(
                targetInst,
                eventType
              ), 0 < handleEventFunc.length && (eventType = new SyntheticCompositionEvent(
                eventType,
                domEventName,
                null,
                nativeEvent,
                nativeEventTarget
              ), dispatchQueue.push({
                event: eventType,
                listeners: handleEventFunc
              }), fallbackData ? eventType.data = fallbackData : (fallbackData = getDataFromCustomEvent(nativeEvent), null !== fallbackData && (eventType.data = fallbackData))));
              if (fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent))
                eventType = accumulateTwoPhaseListeners(
                  targetInst,
                  "onBeforeInput"
                ), 0 < eventType.length && (handleEventFunc = new SyntheticInputEvent(
                  "onBeforeInput",
                  "beforeinput",
                  null,
                  nativeEvent,
                  nativeEventTarget
                ), dispatchQueue.push({
                  event: handleEventFunc,
                  listeners: eventType
                }), handleEventFunc.data = fallbackData);
              extractEvents$1(
                dispatchQueue,
                domEventName,
                targetInst,
                nativeEvent,
                nativeEventTarget
              );
            }
            processDispatchQueue(dispatchQueue, eventSystemFlags);
          });
        }
        function createDispatchListener(instance, listener, currentTarget) {
          return {
            instance,
            listener,
            currentTarget
          };
        }
        function accumulateTwoPhaseListeners(targetFiber, reactName) {
          for (var captureName = reactName + "Capture", listeners = []; null !== targetFiber; ) {
            var _instance3 = targetFiber, stateNode = _instance3.stateNode;
            _instance3 = _instance3.tag;
            5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3 || null === stateNode || (_instance3 = getListener(targetFiber, captureName), null != _instance3 && listeners.unshift(
              createDispatchListener(targetFiber, _instance3, stateNode)
            ), _instance3 = getListener(targetFiber, reactName), null != _instance3 && listeners.push(
              createDispatchListener(targetFiber, _instance3, stateNode)
            ));
            if (3 === targetFiber.tag) return listeners;
            targetFiber = targetFiber.return;
          }
          return [];
        }
        function getParent(inst) {
          if (null === inst) return null;
          do
            inst = inst.return;
          while (inst && 5 !== inst.tag && 27 !== inst.tag);
          return inst ? inst : null;
        }
        function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
          for (var registrationName = event._reactName, listeners = []; null !== target && target !== common; ) {
            var _instance4 = target, alternate = _instance4.alternate, stateNode = _instance4.stateNode;
            _instance4 = _instance4.tag;
            if (null !== alternate && alternate === common) break;
            5 !== _instance4 && 26 !== _instance4 && 27 !== _instance4 || null === stateNode || (alternate = stateNode, inCapturePhase ? (stateNode = getListener(target, registrationName), null != stateNode && listeners.unshift(
              createDispatchListener(target, stateNode, alternate)
            )) : inCapturePhase || (stateNode = getListener(target, registrationName), null != stateNode && listeners.push(
              createDispatchListener(target, stateNode, alternate)
            )));
            target = target.return;
          }
          0 !== listeners.length && dispatchQueue.push({ event, listeners });
        }
        function validatePropertiesInDevelopment(type, props) {
          validateProperties$2(type, props);
          "input" !== type && "textarea" !== type && "select" !== type || null == props || null !== props.value || didWarnValueNull || (didWarnValueNull = true, "select" === type && props.multiple ? console.error(
            "`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.",
            type
          ) : console.error(
            "`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.",
            type
          ));
          var eventRegistry = {
            registrationNameDependencies,
            possibleRegistrationNames
          };
          isCustomElement(type) || "string" === typeof props.is || warnUnknownProperties(type, props, eventRegistry);
          props.contentEditable && !props.suppressContentEditableWarning && null != props.children && console.error(
            "A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."
          );
        }
        function warnForPropDifference(propName, serverValue, clientValue, serverDifferences) {
          serverValue !== clientValue && (clientValue = normalizeMarkupForTextOrAttribute(clientValue), normalizeMarkupForTextOrAttribute(serverValue) !== clientValue && (serverDifferences[propName] = serverValue));
        }
        function warnForExtraAttributes(domElement, attributeNames, serverDifferences) {
          attributeNames.forEach(function(attributeName) {
            serverDifferences[getPropNameFromAttributeName(attributeName)] = "style" === attributeName ? getStylesObjectFromElement(domElement) : domElement.getAttribute(attributeName);
          });
        }
        function warnForInvalidEventListener(registrationName, listener) {
          false === listener ? console.error(
            "Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.",
            registrationName,
            registrationName,
            registrationName
          ) : console.error(
            "Expected `%s` listener to be a function, instead got a value of `%s` type.",
            registrationName,
            typeof listener
          );
        }
        function normalizeHTML(parent, html) {
          parent = parent.namespaceURI === MATH_NAMESPACE || parent.namespaceURI === SVG_NAMESPACE ? parent.ownerDocument.createElementNS(
            parent.namespaceURI,
            parent.tagName
          ) : parent.ownerDocument.createElement(parent.tagName);
          parent.innerHTML = html;
          return parent.innerHTML;
        }
        function normalizeMarkupForTextOrAttribute(markup) {
          willCoercionThrow(markup) && (console.error(
            "The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.",
            typeName(markup)
          ), testStringCoercion(markup));
          return ("string" === typeof markup ? markup : "" + markup).replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
        }
        function checkForUnmatchedText(serverText, clientText) {
          clientText = normalizeMarkupForTextOrAttribute(clientText);
          return normalizeMarkupForTextOrAttribute(serverText) === clientText ? true : false;
        }
        function setProp(domElement, tag, key, value, props, prevValue) {
          switch (key) {
            case "children":
              if ("string" === typeof value)
                validateTextNesting(value, tag, false), "body" === tag || "textarea" === tag && "" === value || setTextContent(domElement, value);
              else if ("number" === typeof value || "bigint" === typeof value)
                validateTextNesting("" + value, tag, false), "body" !== tag && setTextContent(domElement, "" + value);
              break;
            case "className":
              setValueForKnownAttribute(domElement, "class", value);
              break;
            case "tabIndex":
              setValueForKnownAttribute(domElement, "tabindex", value);
              break;
            case "dir":
            case "role":
            case "viewBox":
            case "width":
            case "height":
              setValueForKnownAttribute(domElement, key, value);
              break;
            case "style":
              setValueForStyles(domElement, value, prevValue);
              break;
            case "data":
              if ("object" !== tag) {
                setValueForKnownAttribute(domElement, "data", value);
                break;
              }
            case "src":
            case "href":
              if ("" === value && ("a" !== tag || "href" !== key)) {
                "src" === key ? console.error(
                  'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                  key,
                  key
                ) : console.error(
                  'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                  key,
                  key
                );
                domElement.removeAttribute(key);
                break;
              }
              if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) {
                domElement.removeAttribute(key);
                break;
              }
              checkAttributeStringCoercion(value, key);
              value = sanitizeURL("" + value);
              domElement.setAttribute(key, value);
              break;
            case "action":
            case "formAction":
              null != value && ("form" === tag ? "formAction" === key ? console.error(
                "You can only pass the formAction prop to <input> or <button>. Use the action prop on <form>."
              ) : "function" === typeof value && (null == props.encType && null == props.method || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error(
                "Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden."
              )), null == props.target || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error(
                "Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window."
              ))) : "input" === tag || "button" === tag ? "action" === key ? console.error(
                "You can only pass the action prop to <form>. Use the formAction prop on <input> or <button>."
              ) : "input" !== tag || "submit" === props.type || "image" === props.type || didWarnFormActionType ? "button" !== tag || null == props.type || "submit" === props.type || didWarnFormActionType ? "function" === typeof value && (null == props.name || didWarnFormActionName || (didWarnFormActionName = true, console.error(
                'Cannot specify a "name" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.'
              )), null == props.formEncType && null == props.formMethod || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error(
                "Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden."
              )), null == props.formTarget || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error(
                "Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window."
              ))) : (didWarnFormActionType = true, console.error(
                'A button can only specify a formAction along with type="submit" or no type.'
              )) : (didWarnFormActionType = true, console.error(
                'An input can only specify a formAction along with type="submit" or type="image".'
              )) : "action" === key ? console.error(
                "You can only pass the action prop to <form>."
              ) : console.error(
                "You can only pass the formAction prop to <input> or <button>."
              ));
              if ("function" === typeof value) {
                domElement.setAttribute(
                  key,
                  "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
                );
                break;
              } else
                "function" === typeof prevValue && ("formAction" === key ? ("input" !== tag && setProp(domElement, tag, "name", props.name, props, null), setProp(
                  domElement,
                  tag,
                  "formEncType",
                  props.formEncType,
                  props,
                  null
                ), setProp(
                  domElement,
                  tag,
                  "formMethod",
                  props.formMethod,
                  props,
                  null
                ), setProp(
                  domElement,
                  tag,
                  "formTarget",
                  props.formTarget,
                  props,
                  null
                )) : (setProp(
                  domElement,
                  tag,
                  "encType",
                  props.encType,
                  props,
                  null
                ), setProp(domElement, tag, "method", props.method, props, null), setProp(
                  domElement,
                  tag,
                  "target",
                  props.target,
                  props,
                  null
                )));
              if (null == value || "symbol" === typeof value || "boolean" === typeof value) {
                domElement.removeAttribute(key);
                break;
              }
              checkAttributeStringCoercion(value, key);
              value = sanitizeURL("" + value);
              domElement.setAttribute(key, value);
              break;
            case "onClick":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), domElement.onclick = noop$1);
              break;
            case "onScroll":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scroll", domElement));
              break;
            case "onScrollEnd":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scrollend", domElement));
              break;
            case "dangerouslySetInnerHTML":
              if (null != value) {
                if ("object" !== typeof value || !("__html" in value))
                  throw Error(
                    "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
                  );
                key = value.__html;
                if (null != key) {
                  if (null != props.children)
                    throw Error(
                      "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                    );
                  domElement.innerHTML = key;
                }
              }
              break;
            case "multiple":
              domElement.multiple = value && "function" !== typeof value && "symbol" !== typeof value;
              break;
            case "muted":
              domElement.muted = value && "function" !== typeof value && "symbol" !== typeof value;
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
            case "defaultValue":
            case "defaultChecked":
            case "innerHTML":
            case "ref":
              break;
            case "autoFocus":
              break;
            case "xlinkHref":
              if (null == value || "function" === typeof value || "boolean" === typeof value || "symbol" === typeof value) {
                domElement.removeAttribute("xlink:href");
                break;
              }
              checkAttributeStringCoercion(value, key);
              key = sanitizeURL("" + value);
              domElement.setAttributeNS(xlinkNamespace, "xlink:href", key);
              break;
            case "contentEditable":
            case "spellCheck":
            case "draggable":
            case "value":
            case "autoReverse":
            case "externalResourcesRequired":
            case "focusable":
            case "preserveAlpha":
              null != value && "function" !== typeof value && "symbol" !== typeof value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, "" + value)) : domElement.removeAttribute(key);
              break;
            case "inert":
              "" !== value || didWarnForNewBooleanPropsWithEmptyValue[key] || (didWarnForNewBooleanPropsWithEmptyValue[key] = true, console.error(
                "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
                key
              ));
            case "allowFullScreen":
            case "async":
            case "autoPlay":
            case "controls":
            case "default":
            case "defer":
            case "disabled":
            case "disablePictureInPicture":
            case "disableRemotePlayback":
            case "formNoValidate":
            case "hidden":
            case "loop":
            case "noModule":
            case "noValidate":
            case "open":
            case "playsInline":
            case "readOnly":
            case "required":
            case "reversed":
            case "scoped":
            case "seamless":
            case "itemScope":
              value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "") : domElement.removeAttribute(key);
              break;
            case "capture":
            case "download":
              true === value ? domElement.setAttribute(key, "") : false !== value && null != value && "function" !== typeof value && "symbol" !== typeof value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value)) : domElement.removeAttribute(key);
              break;
            case "cols":
            case "rows":
            case "size":
            case "span":
              null != value && "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value)) : domElement.removeAttribute(key);
              break;
            case "rowSpan":
            case "start":
              null == value || "function" === typeof value || "symbol" === typeof value || isNaN(value) ? domElement.removeAttribute(key) : (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value));
              break;
            case "popover":
              listenToNonDelegatedEvent("beforetoggle", domElement);
              listenToNonDelegatedEvent("toggle", domElement);
              setValueForAttribute(domElement, "popover", value);
              break;
            case "xlinkActuate":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:actuate",
                value
              );
              break;
            case "xlinkArcrole":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:arcrole",
                value
              );
              break;
            case "xlinkRole":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:role",
                value
              );
              break;
            case "xlinkShow":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:show",
                value
              );
              break;
            case "xlinkTitle":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:title",
                value
              );
              break;
            case "xlinkType":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:type",
                value
              );
              break;
            case "xmlBase":
              setValueForNamespacedAttribute(
                domElement,
                xmlNamespace,
                "xml:base",
                value
              );
              break;
            case "xmlLang":
              setValueForNamespacedAttribute(
                domElement,
                xmlNamespace,
                "xml:lang",
                value
              );
              break;
            case "xmlSpace":
              setValueForNamespacedAttribute(
                domElement,
                xmlNamespace,
                "xml:space",
                value
              );
              break;
            case "is":
              null != prevValue && console.error(
                'Cannot update the "is" prop after it has been initialized.'
              );
              setValueForAttribute(domElement, "is", value);
              break;
            case "innerText":
            case "textContent":
              break;
            case "popoverTarget":
              didWarnPopoverTargetObject || null == value || "object" !== typeof value || (didWarnPopoverTargetObject = true, console.error(
                "The `popoverTarget` prop expects the ID of an Element as a string. Received %s instead.",
                value
              ));
            default:
              !(2 < key.length) || "o" !== key[0] && "O" !== key[0] || "n" !== key[1] && "N" !== key[1] ? (key = getAttributeAlias(key), setValueForAttribute(domElement, key, value)) : registrationNameDependencies.hasOwnProperty(key) && null != value && "function" !== typeof value && warnForInvalidEventListener(key, value);
          }
        }
        function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
          switch (key) {
            case "style":
              setValueForStyles(domElement, value, prevValue);
              break;
            case "dangerouslySetInnerHTML":
              if (null != value) {
                if ("object" !== typeof value || !("__html" in value))
                  throw Error(
                    "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
                  );
                key = value.__html;
                if (null != key) {
                  if (null != props.children)
                    throw Error(
                      "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                    );
                  domElement.innerHTML = key;
                }
              }
              break;
            case "children":
              "string" === typeof value ? setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && setTextContent(domElement, "" + value);
              break;
            case "onScroll":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scroll", domElement));
              break;
            case "onScrollEnd":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scrollend", domElement));
              break;
            case "onClick":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), domElement.onclick = noop$1);
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
            case "innerHTML":
            case "ref":
              break;
            case "innerText":
            case "textContent":
              break;
            default:
              if (registrationNameDependencies.hasOwnProperty(key))
                null != value && "function" !== typeof value && warnForInvalidEventListener(key, value);
              else
                a: {
                  if ("o" === key[0] && "n" === key[1] && (props = key.endsWith("Capture"), tag = key.slice(2, props ? key.length - 7 : void 0), prevValue = domElement[internalPropsKey] || null, prevValue = null != prevValue ? prevValue[key] : null, "function" === typeof prevValue && domElement.removeEventListener(tag, prevValue, props), "function" === typeof value)) {
                    "function" !== typeof prevValue && null !== prevValue && (key in domElement ? domElement[key] = null : domElement.hasAttribute(key) && domElement.removeAttribute(key));
                    domElement.addEventListener(tag, value, props);
                    break a;
                  }
                  key in domElement ? domElement[key] = value : true === value ? domElement.setAttribute(key, "") : setValueForAttribute(domElement, key, value);
                }
          }
        }
        function setInitialProperties(domElement, tag, props) {
          validatePropertiesInDevelopment(tag, props);
          switch (tag) {
            case "div":
            case "span":
            case "svg":
            case "path":
            case "a":
            case "g":
            case "p":
            case "li":
              break;
            case "img":
              listenToNonDelegatedEvent("error", domElement);
              listenToNonDelegatedEvent("load", domElement);
              var hasSrc = false, hasSrcSet = false, propKey;
              for (propKey in props)
                if (props.hasOwnProperty(propKey)) {
                  var propValue = props[propKey];
                  if (null != propValue)
                    switch (propKey) {
                      case "src":
                        hasSrc = true;
                        break;
                      case "srcSet":
                        hasSrcSet = true;
                        break;
                      case "children":
                      case "dangerouslySetInnerHTML":
                        throw Error(
                          tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                        );
                      default:
                        setProp(domElement, tag, propKey, propValue, props, null);
                    }
                }
              hasSrcSet && setProp(domElement, tag, "srcSet", props.srcSet, props, null);
              hasSrc && setProp(domElement, tag, "src", props.src, props, null);
              return;
            case "input":
              checkControlledValueProps("input", props);
              listenToNonDelegatedEvent("invalid", domElement);
              var defaultValue = propKey = propValue = hasSrcSet = null, checked = null, defaultChecked = null;
              for (hasSrc in props)
                if (props.hasOwnProperty(hasSrc)) {
                  var _propValue = props[hasSrc];
                  if (null != _propValue)
                    switch (hasSrc) {
                      case "name":
                        hasSrcSet = _propValue;
                        break;
                      case "type":
                        propValue = _propValue;
                        break;
                      case "checked":
                        checked = _propValue;
                        break;
                      case "defaultChecked":
                        defaultChecked = _propValue;
                        break;
                      case "value":
                        propKey = _propValue;
                        break;
                      case "defaultValue":
                        defaultValue = _propValue;
                        break;
                      case "children":
                      case "dangerouslySetInnerHTML":
                        if (null != _propValue)
                          throw Error(
                            tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                          );
                        break;
                      default:
                        setProp(domElement, tag, hasSrc, _propValue, props, null);
                    }
                }
              validateInputProps(domElement, props);
              initInput(
                domElement,
                propKey,
                defaultValue,
                checked,
                defaultChecked,
                propValue,
                hasSrcSet,
                false
              );
              return;
            case "select":
              checkControlledValueProps("select", props);
              listenToNonDelegatedEvent("invalid", domElement);
              hasSrc = propValue = propKey = null;
              for (hasSrcSet in props)
                if (props.hasOwnProperty(hasSrcSet) && (defaultValue = props[hasSrcSet], null != defaultValue))
                  switch (hasSrcSet) {
                    case "value":
                      propKey = defaultValue;
                      break;
                    case "defaultValue":
                      propValue = defaultValue;
                      break;
                    case "multiple":
                      hasSrc = defaultValue;
                    default:
                      setProp(
                        domElement,
                        tag,
                        hasSrcSet,
                        defaultValue,
                        props,
                        null
                      );
                  }
              validateSelectProps(domElement, props);
              tag = propKey;
              props = propValue;
              domElement.multiple = !!hasSrc;
              null != tag ? updateOptions(domElement, !!hasSrc, tag, false) : null != props && updateOptions(domElement, !!hasSrc, props, true);
              return;
            case "textarea":
              checkControlledValueProps("textarea", props);
              listenToNonDelegatedEvent("invalid", domElement);
              propKey = hasSrcSet = hasSrc = null;
              for (propValue in props)
                if (props.hasOwnProperty(propValue) && (defaultValue = props[propValue], null != defaultValue))
                  switch (propValue) {
                    case "value":
                      hasSrc = defaultValue;
                      break;
                    case "defaultValue":
                      hasSrcSet = defaultValue;
                      break;
                    case "children":
                      propKey = defaultValue;
                      break;
                    case "dangerouslySetInnerHTML":
                      if (null != defaultValue)
                        throw Error(
                          "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                        );
                      break;
                    default:
                      setProp(
                        domElement,
                        tag,
                        propValue,
                        defaultValue,
                        props,
                        null
                      );
                  }
              validateTextareaProps(domElement, props);
              initTextarea(domElement, hasSrc, hasSrcSet, propKey);
              return;
            case "option":
              validateOptionProps(domElement, props);
              for (checked in props)
                if (props.hasOwnProperty(checked) && (hasSrc = props[checked], null != hasSrc))
                  switch (checked) {
                    case "selected":
                      domElement.selected = hasSrc && "function" !== typeof hasSrc && "symbol" !== typeof hasSrc;
                      break;
                    default:
                      setProp(domElement, tag, checked, hasSrc, props, null);
                  }
              return;
            case "dialog":
              listenToNonDelegatedEvent("beforetoggle", domElement);
              listenToNonDelegatedEvent("toggle", domElement);
              listenToNonDelegatedEvent("cancel", domElement);
              listenToNonDelegatedEvent("close", domElement);
              break;
            case "iframe":
            case "object":
              listenToNonDelegatedEvent("load", domElement);
              break;
            case "video":
            case "audio":
              for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
                listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
              break;
            case "image":
              listenToNonDelegatedEvent("error", domElement);
              listenToNonDelegatedEvent("load", domElement);
              break;
            case "details":
              listenToNonDelegatedEvent("toggle", domElement);
              break;
            case "embed":
            case "source":
            case "link":
              listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
            case "area":
            case "base":
            case "br":
            case "col":
            case "hr":
            case "keygen":
            case "meta":
            case "param":
            case "track":
            case "wbr":
            case "menuitem":
              for (defaultChecked in props)
                if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], null != hasSrc))
                  switch (defaultChecked) {
                    case "children":
                    case "dangerouslySetInnerHTML":
                      throw Error(
                        tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                      );
                    default:
                      setProp(domElement, tag, defaultChecked, hasSrc, props, null);
                  }
              return;
            default:
              if (isCustomElement(tag)) {
                for (_propValue in props)
                  props.hasOwnProperty(_propValue) && (hasSrc = props[_propValue], void 0 !== hasSrc && setPropOnCustomElement(
                    domElement,
                    tag,
                    _propValue,
                    hasSrc,
                    props,
                    void 0
                  ));
                return;
              }
          }
          for (defaultValue in props)
            props.hasOwnProperty(defaultValue) && (hasSrc = props[defaultValue], null != hasSrc && setProp(domElement, tag, defaultValue, hasSrc, props, null));
        }
        function updateProperties(domElement, tag, lastProps, nextProps) {
          validatePropertiesInDevelopment(tag, nextProps);
          switch (tag) {
            case "div":
            case "span":
            case "svg":
            case "path":
            case "a":
            case "g":
            case "p":
            case "li":
              break;
            case "input":
              var name = null, type = null, value = null, defaultValue = null, lastDefaultValue = null, checked = null, defaultChecked = null;
              for (propKey in lastProps) {
                var lastProp = lastProps[propKey];
                if (lastProps.hasOwnProperty(propKey) && null != lastProp)
                  switch (propKey) {
                    case "checked":
                      break;
                    case "value":
                      break;
                    case "defaultValue":
                      lastDefaultValue = lastProp;
                    default:
                      nextProps.hasOwnProperty(propKey) || setProp(
                        domElement,
                        tag,
                        propKey,
                        null,
                        nextProps,
                        lastProp
                      );
                  }
              }
              for (var _propKey8 in nextProps) {
                var propKey = nextProps[_propKey8];
                lastProp = lastProps[_propKey8];
                if (nextProps.hasOwnProperty(_propKey8) && (null != propKey || null != lastProp))
                  switch (_propKey8) {
                    case "type":
                      type = propKey;
                      break;
                    case "name":
                      name = propKey;
                      break;
                    case "checked":
                      checked = propKey;
                      break;
                    case "defaultChecked":
                      defaultChecked = propKey;
                      break;
                    case "value":
                      value = propKey;
                      break;
                    case "defaultValue":
                      defaultValue = propKey;
                      break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                      if (null != propKey)
                        throw Error(
                          tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                        );
                      break;
                    default:
                      propKey !== lastProp && setProp(
                        domElement,
                        tag,
                        _propKey8,
                        propKey,
                        nextProps,
                        lastProp
                      );
                  }
              }
              tag = "checkbox" === lastProps.type || "radio" === lastProps.type ? null != lastProps.checked : null != lastProps.value;
              nextProps = "checkbox" === nextProps.type || "radio" === nextProps.type ? null != nextProps.checked : null != nextProps.value;
              tag || !nextProps || didWarnUncontrolledToControlled || (console.error(
                "A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"
              ), didWarnUncontrolledToControlled = true);
              !tag || nextProps || didWarnControlledToUncontrolled || (console.error(
                "A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"
              ), didWarnControlledToUncontrolled = true);
              updateInput(
                domElement,
                value,
                defaultValue,
                lastDefaultValue,
                checked,
                defaultChecked,
                type,
                name
              );
              return;
            case "select":
              propKey = value = defaultValue = _propKey8 = null;
              for (type in lastProps)
                if (lastDefaultValue = lastProps[type], lastProps.hasOwnProperty(type) && null != lastDefaultValue)
                  switch (type) {
                    case "value":
                      break;
                    case "multiple":
                      propKey = lastDefaultValue;
                    default:
                      nextProps.hasOwnProperty(type) || setProp(
                        domElement,
                        tag,
                        type,
                        null,
                        nextProps,
                        lastDefaultValue
                      );
                  }
              for (name in nextProps)
                if (type = nextProps[name], lastDefaultValue = lastProps[name], nextProps.hasOwnProperty(name) && (null != type || null != lastDefaultValue))
                  switch (name) {
                    case "value":
                      _propKey8 = type;
                      break;
                    case "defaultValue":
                      defaultValue = type;
                      break;
                    case "multiple":
                      value = type;
                    default:
                      type !== lastDefaultValue && setProp(
                        domElement,
                        tag,
                        name,
                        type,
                        nextProps,
                        lastDefaultValue
                      );
                  }
              nextProps = defaultValue;
              tag = value;
              lastProps = propKey;
              null != _propKey8 ? updateOptions(domElement, !!tag, _propKey8, false) : !!lastProps !== !!tag && (null != nextProps ? updateOptions(domElement, !!tag, nextProps, true) : updateOptions(domElement, !!tag, tag ? [] : "", false));
              return;
            case "textarea":
              propKey = _propKey8 = null;
              for (defaultValue in lastProps)
                if (name = lastProps[defaultValue], lastProps.hasOwnProperty(defaultValue) && null != name && !nextProps.hasOwnProperty(defaultValue))
                  switch (defaultValue) {
                    case "value":
                      break;
                    case "children":
                      break;
                    default:
                      setProp(domElement, tag, defaultValue, null, nextProps, name);
                  }
              for (value in nextProps)
                if (name = nextProps[value], type = lastProps[value], nextProps.hasOwnProperty(value) && (null != name || null != type))
                  switch (value) {
                    case "value":
                      _propKey8 = name;
                      break;
                    case "defaultValue":
                      propKey = name;
                      break;
                    case "children":
                      break;
                    case "dangerouslySetInnerHTML":
                      if (null != name)
                        throw Error(
                          "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                        );
                      break;
                    default:
                      name !== type && setProp(domElement, tag, value, name, nextProps, type);
                  }
              updateTextarea(domElement, _propKey8, propKey);
              return;
            case "option":
              for (var _propKey13 in lastProps)
                if (_propKey8 = lastProps[_propKey13], lastProps.hasOwnProperty(_propKey13) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey13))
                  switch (_propKey13) {
                    case "selected":
                      domElement.selected = false;
                      break;
                    default:
                      setProp(
                        domElement,
                        tag,
                        _propKey13,
                        null,
                        nextProps,
                        _propKey8
                      );
                  }
              for (lastDefaultValue in nextProps)
                if (_propKey8 = nextProps[lastDefaultValue], propKey = lastProps[lastDefaultValue], nextProps.hasOwnProperty(lastDefaultValue) && _propKey8 !== propKey && (null != _propKey8 || null != propKey))
                  switch (lastDefaultValue) {
                    case "selected":
                      domElement.selected = _propKey8 && "function" !== typeof _propKey8 && "symbol" !== typeof _propKey8;
                      break;
                    default:
                      setProp(
                        domElement,
                        tag,
                        lastDefaultValue,
                        _propKey8,
                        nextProps,
                        propKey
                      );
                  }
              return;
            case "img":
            case "link":
            case "area":
            case "base":
            case "br":
            case "col":
            case "embed":
            case "hr":
            case "keygen":
            case "meta":
            case "param":
            case "source":
            case "track":
            case "wbr":
            case "menuitem":
              for (var _propKey15 in lastProps)
                _propKey8 = lastProps[_propKey15], lastProps.hasOwnProperty(_propKey15) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey15) && setProp(
                  domElement,
                  tag,
                  _propKey15,
                  null,
                  nextProps,
                  _propKey8
                );
              for (checked in nextProps)
                if (_propKey8 = nextProps[checked], propKey = lastProps[checked], nextProps.hasOwnProperty(checked) && _propKey8 !== propKey && (null != _propKey8 || null != propKey))
                  switch (checked) {
                    case "children":
                    case "dangerouslySetInnerHTML":
                      if (null != _propKey8)
                        throw Error(
                          tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                        );
                      break;
                    default:
                      setProp(
                        domElement,
                        tag,
                        checked,
                        _propKey8,
                        nextProps,
                        propKey
                      );
                  }
              return;
            default:
              if (isCustomElement(tag)) {
                for (var _propKey17 in lastProps)
                  _propKey8 = lastProps[_propKey17], lastProps.hasOwnProperty(_propKey17) && void 0 !== _propKey8 && !nextProps.hasOwnProperty(_propKey17) && setPropOnCustomElement(
                    domElement,
                    tag,
                    _propKey17,
                    void 0,
                    nextProps,
                    _propKey8
                  );
                for (defaultChecked in nextProps)
                  _propKey8 = nextProps[defaultChecked], propKey = lastProps[defaultChecked], !nextProps.hasOwnProperty(defaultChecked) || _propKey8 === propKey || void 0 === _propKey8 && void 0 === propKey || setPropOnCustomElement(
                    domElement,
                    tag,
                    defaultChecked,
                    _propKey8,
                    nextProps,
                    propKey
                  );
                return;
              }
          }
          for (var _propKey19 in lastProps)
            _propKey8 = lastProps[_propKey19], lastProps.hasOwnProperty(_propKey19) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey19) && setProp(domElement, tag, _propKey19, null, nextProps, _propKey8);
          for (lastProp in nextProps)
            _propKey8 = nextProps[lastProp], propKey = lastProps[lastProp], !nextProps.hasOwnProperty(lastProp) || _propKey8 === propKey || null == _propKey8 && null == propKey || setProp(domElement, tag, lastProp, _propKey8, nextProps, propKey);
        }
        function getPropNameFromAttributeName(attrName) {
          switch (attrName) {
            case "class":
              return "className";
            case "for":
              return "htmlFor";
            default:
              return attrName;
          }
        }
        function getStylesObjectFromElement(domElement) {
          var serverValueInObjectForm = {};
          domElement = domElement.style;
          for (var i5 = 0; i5 < domElement.length; i5++) {
            var styleName = domElement[i5];
            serverValueInObjectForm[styleName] = domElement.getPropertyValue(styleName);
          }
          return serverValueInObjectForm;
        }
        function diffHydratedStyles(domElement, value$jscomp$0, serverDifferences) {
          if (null != value$jscomp$0 && "object" !== typeof value$jscomp$0)
            console.error(
              "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
            );
          else {
            var clientValue;
            var delimiter = clientValue = "", styleName;
            for (styleName in value$jscomp$0)
              if (value$jscomp$0.hasOwnProperty(styleName)) {
                var value = value$jscomp$0[styleName];
                null != value && "boolean" !== typeof value && "" !== value && (0 === styleName.indexOf("--") ? (checkCSSPropertyStringCoercion(value, styleName), clientValue += delimiter + styleName + ":" + ("" + value).trim()) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? (checkCSSPropertyStringCoercion(value, styleName), clientValue += delimiter + styleName.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-") + ":" + ("" + value).trim()) : clientValue += delimiter + styleName.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-") + ":" + value + "px", delimiter = ";");
              }
            clientValue = clientValue || null;
            value$jscomp$0 = domElement.getAttribute("style");
            value$jscomp$0 !== clientValue && (clientValue = normalizeMarkupForTextOrAttribute(clientValue), normalizeMarkupForTextOrAttribute(value$jscomp$0) !== clientValue && (serverDifferences.style = getStylesObjectFromElement(domElement)));
          }
        }
        function hydrateAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
          extraAttributes.delete(attributeName);
          domElement = domElement.getAttribute(attributeName);
          if (null === domElement)
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                return;
            }
          else if (null != value)
            switch (typeof value) {
              case "function":
              case "symbol":
              case "boolean":
                break;
              default:
                if (checkAttributeStringCoercion(value, propKey), domElement === "" + value)
                  return;
            }
          warnForPropDifference(propKey, domElement, value, serverDifferences);
        }
        function hydrateBooleanAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
          extraAttributes.delete(attributeName);
          domElement = domElement.getAttribute(attributeName);
          if (null === domElement) {
            switch (typeof value) {
              case "function":
              case "symbol":
                return;
            }
            if (!value) return;
          } else
            switch (typeof value) {
              case "function":
              case "symbol":
                break;
              default:
                if (value) return;
            }
          warnForPropDifference(propKey, domElement, value, serverDifferences);
        }
        function hydrateBooleanishAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
          extraAttributes.delete(attributeName);
          domElement = domElement.getAttribute(attributeName);
          if (null === domElement)
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
                return;
            }
          else if (null != value)
            switch (typeof value) {
              case "function":
              case "symbol":
                break;
              default:
                if (checkAttributeStringCoercion(value, attributeName), domElement === "" + value)
                  return;
            }
          warnForPropDifference(propKey, domElement, value, serverDifferences);
        }
        function hydrateNumericAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
          extraAttributes.delete(attributeName);
          domElement = domElement.getAttribute(attributeName);
          if (null === domElement)
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                return;
              default:
                if (isNaN(value)) return;
            }
          else if (null != value)
            switch (typeof value) {
              case "function":
              case "symbol":
              case "boolean":
                break;
              default:
                if (!isNaN(value) && (checkAttributeStringCoercion(value, propKey), domElement === "" + value))
                  return;
            }
          warnForPropDifference(propKey, domElement, value, serverDifferences);
        }
        function hydrateSanitizedAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
          extraAttributes.delete(attributeName);
          domElement = domElement.getAttribute(attributeName);
          if (null === domElement)
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                return;
            }
          else if (null != value)
            switch (typeof value) {
              case "function":
              case "symbol":
              case "boolean":
                break;
              default:
                if (checkAttributeStringCoercion(value, propKey), attributeName = sanitizeURL("" + value), domElement === attributeName)
                  return;
            }
          warnForPropDifference(propKey, domElement, value, serverDifferences);
        }
        function diffHydratedProperties(domElement, tag, props, hostContext) {
          for (var serverDifferences = {}, extraAttributes = /* @__PURE__ */ new Set(), attributes = domElement.attributes, i5 = 0; i5 < attributes.length; i5++)
            switch (attributes[i5].name.toLowerCase()) {
              case "value":
                break;
              case "checked":
                break;
              case "selected":
                break;
              default:
                extraAttributes.add(attributes[i5].name);
            }
          if (isCustomElement(tag))
            for (var propKey in props) {
              if (props.hasOwnProperty(propKey)) {
                var value = props[propKey];
                if (null != value) {
                  if (registrationNameDependencies.hasOwnProperty(propKey))
                    "function" !== typeof value && warnForInvalidEventListener(propKey, value);
                  else if (true !== props.suppressHydrationWarning)
                    switch (propKey) {
                      case "children":
                        "string" !== typeof value && "number" !== typeof value || warnForPropDifference(
                          "children",
                          domElement.textContent,
                          value,
                          serverDifferences
                        );
                        continue;
                      case "suppressContentEditableWarning":
                      case "suppressHydrationWarning":
                      case "defaultValue":
                      case "defaultChecked":
                      case "innerHTML":
                      case "ref":
                        continue;
                      case "dangerouslySetInnerHTML":
                        attributes = domElement.innerHTML;
                        value = value ? value.__html : void 0;
                        null != value && (value = normalizeHTML(domElement, value), warnForPropDifference(
                          propKey,
                          attributes,
                          value,
                          serverDifferences
                        ));
                        continue;
                      case "style":
                        extraAttributes.delete(propKey);
                        diffHydratedStyles(domElement, value, serverDifferences);
                        continue;
                      case "offsetParent":
                      case "offsetTop":
                      case "offsetLeft":
                      case "offsetWidth":
                      case "offsetHeight":
                      case "isContentEditable":
                      case "outerText":
                      case "outerHTML":
                        extraAttributes.delete(propKey.toLowerCase());
                        console.error(
                          "Assignment to read-only property will result in a no-op: `%s`",
                          propKey
                        );
                        continue;
                      case "className":
                        extraAttributes.delete("class");
                        attributes = getValueForAttributeOnCustomComponent(
                          domElement,
                          "class",
                          value
                        );
                        warnForPropDifference(
                          "className",
                          attributes,
                          value,
                          serverDifferences
                        );
                        continue;
                      default:
                        hostContext.context === HostContextNamespaceNone && "svg" !== tag && "math" !== tag ? extraAttributes.delete(propKey.toLowerCase()) : extraAttributes.delete(propKey), attributes = getValueForAttributeOnCustomComponent(
                          domElement,
                          propKey,
                          value
                        ), warnForPropDifference(
                          propKey,
                          attributes,
                          value,
                          serverDifferences
                        );
                    }
                }
              }
            }
          else
            for (value in props)
              if (props.hasOwnProperty(value) && (propKey = props[value], null != propKey)) {
                if (registrationNameDependencies.hasOwnProperty(value))
                  "function" !== typeof propKey && warnForInvalidEventListener(value, propKey);
                else if (true !== props.suppressHydrationWarning)
                  switch (value) {
                    case "children":
                      "string" !== typeof propKey && "number" !== typeof propKey || warnForPropDifference(
                        "children",
                        domElement.textContent,
                        propKey,
                        serverDifferences
                      );
                      continue;
                    case "suppressContentEditableWarning":
                    case "suppressHydrationWarning":
                    case "value":
                    case "checked":
                    case "selected":
                    case "defaultValue":
                    case "defaultChecked":
                    case "innerHTML":
                    case "ref":
                      continue;
                    case "dangerouslySetInnerHTML":
                      attributes = domElement.innerHTML;
                      propKey = propKey ? propKey.__html : void 0;
                      null != propKey && (propKey = normalizeHTML(domElement, propKey), attributes !== propKey && (serverDifferences[value] = { __html: attributes }));
                      continue;
                    case "className":
                      hydrateAttribute(
                        domElement,
                        value,
                        "class",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "tabIndex":
                      hydrateAttribute(
                        domElement,
                        value,
                        "tabindex",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "style":
                      extraAttributes.delete(value);
                      diffHydratedStyles(domElement, propKey, serverDifferences);
                      continue;
                    case "multiple":
                      extraAttributes.delete(value);
                      warnForPropDifference(
                        value,
                        domElement.multiple,
                        propKey,
                        serverDifferences
                      );
                      continue;
                    case "muted":
                      extraAttributes.delete(value);
                      warnForPropDifference(
                        value,
                        domElement.muted,
                        propKey,
                        serverDifferences
                      );
                      continue;
                    case "autoFocus":
                      extraAttributes.delete("autofocus");
                      warnForPropDifference(
                        value,
                        domElement.autofocus,
                        propKey,
                        serverDifferences
                      );
                      continue;
                    case "data":
                      if ("object" !== tag) {
                        extraAttributes.delete(value);
                        attributes = domElement.getAttribute("data");
                        warnForPropDifference(
                          value,
                          attributes,
                          propKey,
                          serverDifferences
                        );
                        continue;
                      }
                    case "src":
                    case "href":
                      if (!("" !== propKey || "a" === tag && "href" === value || "object" === tag && "data" === value)) {
                        "src" === value ? console.error(
                          'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                          value,
                          value
                        ) : console.error(
                          'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                          value,
                          value
                        );
                        continue;
                      }
                      hydrateSanitizedAttribute(
                        domElement,
                        value,
                        value,
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "action":
                    case "formAction":
                      attributes = domElement.getAttribute(value);
                      if ("function" === typeof propKey) {
                        extraAttributes.delete(value.toLowerCase());
                        "formAction" === value ? (extraAttributes.delete("name"), extraAttributes.delete("formenctype"), extraAttributes.delete("formmethod"), extraAttributes.delete("formtarget")) : (extraAttributes.delete("enctype"), extraAttributes.delete("method"), extraAttributes.delete("target"));
                        continue;
                      } else if (attributes === EXPECTED_FORM_ACTION_URL) {
                        extraAttributes.delete(value.toLowerCase());
                        warnForPropDifference(
                          value,
                          "function",
                          propKey,
                          serverDifferences
                        );
                        continue;
                      }
                      hydrateSanitizedAttribute(
                        domElement,
                        value,
                        value.toLowerCase(),
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkHref":
                      hydrateSanitizedAttribute(
                        domElement,
                        value,
                        "xlink:href",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "contentEditable":
                      hydrateBooleanishAttribute(
                        domElement,
                        value,
                        "contenteditable",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "spellCheck":
                      hydrateBooleanishAttribute(
                        domElement,
                        value,
                        "spellcheck",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "draggable":
                    case "autoReverse":
                    case "externalResourcesRequired":
                    case "focusable":
                    case "preserveAlpha":
                      hydrateBooleanishAttribute(
                        domElement,
                        value,
                        value,
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "allowFullScreen":
                    case "async":
                    case "autoPlay":
                    case "controls":
                    case "default":
                    case "defer":
                    case "disabled":
                    case "disablePictureInPicture":
                    case "disableRemotePlayback":
                    case "formNoValidate":
                    case "hidden":
                    case "loop":
                    case "noModule":
                    case "noValidate":
                    case "open":
                    case "playsInline":
                    case "readOnly":
                    case "required":
                    case "reversed":
                    case "scoped":
                    case "seamless":
                    case "itemScope":
                      hydrateBooleanAttribute(
                        domElement,
                        value,
                        value.toLowerCase(),
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "capture":
                    case "download":
                      a: {
                        i5 = domElement;
                        var attributeName = attributes = value, serverDifferences$jscomp$0 = serverDifferences;
                        extraAttributes.delete(attributeName);
                        i5 = i5.getAttribute(attributeName);
                        if (null === i5)
                          switch (typeof propKey) {
                            case "undefined":
                            case "function":
                            case "symbol":
                              break a;
                            default:
                              if (false === propKey) break a;
                          }
                        else if (null != propKey)
                          switch (typeof propKey) {
                            case "function":
                            case "symbol":
                              break;
                            case "boolean":
                              if (true === propKey && "" === i5) break a;
                              break;
                            default:
                              if (checkAttributeStringCoercion(propKey, attributes), i5 === "" + propKey)
                                break a;
                          }
                        warnForPropDifference(
                          attributes,
                          i5,
                          propKey,
                          serverDifferences$jscomp$0
                        );
                      }
                      continue;
                    case "cols":
                    case "rows":
                    case "size":
                    case "span":
                      a: {
                        i5 = domElement;
                        attributeName = attributes = value;
                        serverDifferences$jscomp$0 = serverDifferences;
                        extraAttributes.delete(attributeName);
                        i5 = i5.getAttribute(attributeName);
                        if (null === i5)
                          switch (typeof propKey) {
                            case "undefined":
                            case "function":
                            case "symbol":
                            case "boolean":
                              break a;
                            default:
                              if (isNaN(propKey) || 1 > propKey) break a;
                          }
                        else if (null != propKey)
                          switch (typeof propKey) {
                            case "function":
                            case "symbol":
                            case "boolean":
                              break;
                            default:
                              if (!(isNaN(propKey) || 1 > propKey) && (checkAttributeStringCoercion(propKey, attributes), i5 === "" + propKey))
                                break a;
                          }
                        warnForPropDifference(
                          attributes,
                          i5,
                          propKey,
                          serverDifferences$jscomp$0
                        );
                      }
                      continue;
                    case "rowSpan":
                      hydrateNumericAttribute(
                        domElement,
                        value,
                        "rowspan",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "start":
                      hydrateNumericAttribute(
                        domElement,
                        value,
                        value,
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xHeight":
                      hydrateAttribute(
                        domElement,
                        value,
                        "x-height",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkActuate":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:actuate",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkArcrole":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:arcrole",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkRole":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:role",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkShow":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:show",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkTitle":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:title",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkType":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:type",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xmlBase":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xml:base",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xmlLang":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xml:lang",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xmlSpace":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xml:space",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "inert":
                      "" !== propKey || didWarnForNewBooleanPropsWithEmptyValue[value] || (didWarnForNewBooleanPropsWithEmptyValue[value] = true, console.error(
                        "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
                        value
                      ));
                      hydrateBooleanAttribute(
                        domElement,
                        value,
                        value,
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    default:
                      if (!(2 < value.length) || "o" !== value[0] && "O" !== value[0] || "n" !== value[1] && "N" !== value[1]) {
                        i5 = getAttributeAlias(value);
                        attributes = false;
                        hostContext.context === HostContextNamespaceNone && "svg" !== tag && "math" !== tag ? extraAttributes.delete(i5.toLowerCase()) : (attributeName = value.toLowerCase(), attributeName = possibleStandardNames.hasOwnProperty(
                          attributeName
                        ) ? possibleStandardNames[attributeName] || null : null, null !== attributeName && attributeName !== value && (attributes = true, extraAttributes.delete(attributeName)), extraAttributes.delete(i5));
                        a: if (attributeName = domElement, serverDifferences$jscomp$0 = i5, i5 = propKey, isAttributeNameSafe(serverDifferences$jscomp$0))
                          if (attributeName.hasAttribute(serverDifferences$jscomp$0))
                            attributeName = attributeName.getAttribute(
                              serverDifferences$jscomp$0
                            ), checkAttributeStringCoercion(
                              i5,
                              serverDifferences$jscomp$0
                            ), i5 = attributeName === "" + i5 ? i5 : attributeName;
                          else {
                            switch (typeof i5) {
                              case "function":
                              case "symbol":
                                break a;
                              case "boolean":
                                if (attributeName = serverDifferences$jscomp$0.toLowerCase().slice(0, 5), "data-" !== attributeName && "aria-" !== attributeName)
                                  break a;
                            }
                            i5 = void 0 === i5 ? void 0 : null;
                          }
                        else i5 = void 0;
                        attributes || warnForPropDifference(
                          value,
                          i5,
                          propKey,
                          serverDifferences
                        );
                      }
                  }
              }
          0 < extraAttributes.size && true !== props.suppressHydrationWarning && warnForExtraAttributes(domElement, extraAttributes, serverDifferences);
          return 0 === Object.keys(serverDifferences).length ? null : serverDifferences;
        }
        function propNamesListJoin(list, combinator) {
          switch (list.length) {
            case 0:
              return "";
            case 1:
              return list[0];
            case 2:
              return list[0] + " " + combinator + " " + list[1];
            default:
              return list.slice(0, -1).join(", ") + ", " + combinator + " " + list[list.length - 1];
          }
        }
        function isLikelyStaticResource(initiatorType) {
          switch (initiatorType) {
            case "css":
            case "script":
            case "font":
            case "img":
            case "image":
            case "input":
            case "link":
              return true;
            default:
              return false;
          }
        }
        function estimateBandwidth() {
          if ("function" === typeof performance.getEntriesByType) {
            for (var count = 0, bits = 0, resourceEntries = performance.getEntriesByType("resource"), i5 = 0; i5 < resourceEntries.length; i5++) {
              var entry = resourceEntries[i5], transferSize = entry.transferSize, initiatorType = entry.initiatorType, duration = entry.duration;
              if (transferSize && duration && isLikelyStaticResource(initiatorType)) {
                initiatorType = 0;
                duration = entry.responseEnd;
                for (i5 += 1; i5 < resourceEntries.length; i5++) {
                  var overlapEntry = resourceEntries[i5], overlapStartTime = overlapEntry.startTime;
                  if (overlapStartTime > duration) break;
                  var overlapTransferSize = overlapEntry.transferSize, overlapInitiatorType = overlapEntry.initiatorType;
                  overlapTransferSize && isLikelyStaticResource(overlapInitiatorType) && (overlapEntry = overlapEntry.responseEnd, initiatorType += overlapTransferSize * (overlapEntry < duration ? 1 : (duration - overlapStartTime) / (overlapEntry - overlapStartTime)));
                }
                --i5;
                bits += 8 * (transferSize + initiatorType) / (entry.duration / 1e3);
                count++;
                if (10 < count) break;
              }
            }
            if (0 < count) return bits / count / 1e6;
          }
          return navigator.connection && (count = navigator.connection.downlink, "number" === typeof count) ? count : 5;
        }
        function getOwnerDocumentFromRootContainer(rootContainerElement) {
          return 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
        }
        function getOwnHostContext(namespaceURI) {
          switch (namespaceURI) {
            case SVG_NAMESPACE:
              return HostContextNamespaceSvg;
            case MATH_NAMESPACE:
              return HostContextNamespaceMath;
            default:
              return HostContextNamespaceNone;
          }
        }
        function getChildHostContextProd(parentNamespace, type) {
          if (parentNamespace === HostContextNamespaceNone)
            switch (type) {
              case "svg":
                return HostContextNamespaceSvg;
              case "math":
                return HostContextNamespaceMath;
              default:
                return HostContextNamespaceNone;
            }
          return parentNamespace === HostContextNamespaceSvg && "foreignObject" === type ? HostContextNamespaceNone : parentNamespace;
        }
        function shouldSetTextContent(type, props) {
          return "textarea" === type || "noscript" === type || "string" === typeof props.children || "number" === typeof props.children || "bigint" === typeof props.children || "object" === typeof props.dangerouslySetInnerHTML && null !== props.dangerouslySetInnerHTML && null != props.dangerouslySetInnerHTML.__html;
        }
        function shouldAttemptEagerTransition() {
          var event = window.event;
          if (event && "popstate" === event.type) {
            if (event === currentPopstateTransitionEvent) return false;
            currentPopstateTransitionEvent = event;
            return true;
          }
          currentPopstateTransitionEvent = null;
          return false;
        }
        function resolveEventType() {
          var event = window.event;
          return event && event !== schedulerEvent ? event.type : null;
        }
        function resolveEventTimeStamp() {
          var event = window.event;
          return event && event !== schedulerEvent ? event.timeStamp : -1.1;
        }
        function handleErrorInNextTick(error) {
          setTimeout(function() {
            throw error;
          });
        }
        function commitMount(domElement, type, newProps) {
          switch (type) {
            case "button":
            case "input":
            case "select":
            case "textarea":
              newProps.autoFocus && domElement.focus();
              break;
            case "img":
              newProps.src ? domElement.src = newProps.src : newProps.srcSet && (domElement.srcset = newProps.srcSet);
          }
        }
        function commitHydratedInstance() {
        }
        function commitUpdate(domElement, type, oldProps, newProps) {
          updateProperties(domElement, type, oldProps, newProps);
          domElement[internalPropsKey] = newProps;
        }
        function resetTextContent(domElement) {
          setTextContent(domElement, "");
        }
        function commitTextUpdate(textInstance, oldText, newText) {
          textInstance.nodeValue = newText;
        }
        function warnForReactChildrenConflict(container) {
          if (!container.__reactWarnedAboutChildrenConflict) {
            var props = container[internalPropsKey] || null;
            if (null !== props) {
              var fiber = getInstanceFromNode(container);
              null !== fiber && ("string" === typeof props.children || "number" === typeof props.children ? (container.__reactWarnedAboutChildrenConflict = true, runWithFiberInDEV(fiber, function() {
                console.error(
                  'Cannot use a ref on a React element as a container to `createRoot` or `createPortal` if that element also sets "children" text content using React. It should be a leaf with no children. Otherwise it\'s ambiguous which children should be used.'
                );
              })) : null != props.dangerouslySetInnerHTML && (container.__reactWarnedAboutChildrenConflict = true, runWithFiberInDEV(fiber, function() {
                console.error(
                  'Cannot use a ref on a React element as a container to `createRoot` or `createPortal` if that element also sets "dangerouslySetInnerHTML" using React. It should be a leaf with no children. Otherwise it\'s ambiguous which children should be used.'
                );
              })));
            }
          }
        }
        function isSingletonScope(type) {
          return "head" === type;
        }
        function removeChild(parentInstance, child) {
          parentInstance.removeChild(child);
        }
        function removeChildFromContainer(container, child) {
          (9 === container.nodeType ? container.body : "HTML" === container.nodeName ? container.ownerDocument.body : container).removeChild(child);
        }
        function clearHydrationBoundary(parentInstance, hydrationInstance) {
          var node = hydrationInstance, depth = 0;
          do {
            var nextNode = node.nextSibling;
            parentInstance.removeChild(node);
            if (nextNode && 8 === nextNode.nodeType)
              if (node = nextNode.data, node === SUSPENSE_END_DATA || node === ACTIVITY_END_DATA) {
                if (0 === depth) {
                  parentInstance.removeChild(nextNode);
                  retryIfBlockedOn(hydrationInstance);
                  return;
                }
                depth--;
              } else if (node === SUSPENSE_START_DATA || node === SUSPENSE_PENDING_START_DATA || node === SUSPENSE_QUEUED_START_DATA || node === SUSPENSE_FALLBACK_START_DATA || node === ACTIVITY_START_DATA)
                depth++;
              else if (node === PREAMBLE_CONTRIBUTION_HTML)
                releaseSingletonInstance(
                  parentInstance.ownerDocument.documentElement
                );
              else if (node === PREAMBLE_CONTRIBUTION_HEAD) {
                node = parentInstance.ownerDocument.head;
                releaseSingletonInstance(node);
                for (var node$jscomp$0 = node.firstChild; node$jscomp$0; ) {
                  var nextNode$jscomp$0 = node$jscomp$0.nextSibling, nodeName = node$jscomp$0.nodeName;
                  node$jscomp$0[internalHoistableMarker] || "SCRIPT" === nodeName || "STYLE" === nodeName || "LINK" === nodeName && "stylesheet" === node$jscomp$0.rel.toLowerCase() || node.removeChild(node$jscomp$0);
                  node$jscomp$0 = nextNode$jscomp$0;
                }
              } else
                node === PREAMBLE_CONTRIBUTION_BODY && releaseSingletonInstance(parentInstance.ownerDocument.body);
            node = nextNode;
          } while (node);
          retryIfBlockedOn(hydrationInstance);
        }
        function hideOrUnhideDehydratedBoundary(suspenseInstance, isHidden) {
          var node = suspenseInstance;
          suspenseInstance = 0;
          do {
            var nextNode = node.nextSibling;
            1 === node.nodeType ? isHidden ? (node._stashedDisplay = node.style.display, node.style.display = "none") : (node.style.display = node._stashedDisplay || "", "" === node.getAttribute("style") && node.removeAttribute("style")) : 3 === node.nodeType && (isHidden ? (node._stashedText = node.nodeValue, node.nodeValue = "") : node.nodeValue = node._stashedText || "");
            if (nextNode && 8 === nextNode.nodeType)
              if (node = nextNode.data, node === SUSPENSE_END_DATA)
                if (0 === suspenseInstance) break;
                else suspenseInstance--;
              else
                node !== SUSPENSE_START_DATA && node !== SUSPENSE_PENDING_START_DATA && node !== SUSPENSE_QUEUED_START_DATA && node !== SUSPENSE_FALLBACK_START_DATA || suspenseInstance++;
            node = nextNode;
          } while (node);
        }
        function hideDehydratedBoundary(suspenseInstance) {
          hideOrUnhideDehydratedBoundary(suspenseInstance, true);
        }
        function hideInstance(instance) {
          instance = instance.style;
          "function" === typeof instance.setProperty ? instance.setProperty("display", "none", "important") : instance.display = "none";
        }
        function hideTextInstance(textInstance) {
          textInstance.nodeValue = "";
        }
        function unhideDehydratedBoundary(dehydratedInstance) {
          hideOrUnhideDehydratedBoundary(dehydratedInstance, false);
        }
        function unhideInstance(instance, props) {
          props = props[STYLE];
          props = void 0 !== props && null !== props && props.hasOwnProperty("display") ? props.display : null;
          instance.style.display = null == props || "boolean" === typeof props ? "" : ("" + props).trim();
        }
        function unhideTextInstance(textInstance, text) {
          textInstance.nodeValue = text;
        }
        function clearContainerSparingly(container) {
          var nextNode = container.firstChild;
          nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
          for (; nextNode; ) {
            var node = nextNode;
            nextNode = nextNode.nextSibling;
            switch (node.nodeName) {
              case "HTML":
              case "HEAD":
              case "BODY":
                clearContainerSparingly(node);
                detachDeletedInstance(node);
                continue;
              case "SCRIPT":
              case "STYLE":
                continue;
              case "LINK":
                if ("stylesheet" === node.rel.toLowerCase()) continue;
            }
            container.removeChild(node);
          }
        }
        function canHydrateInstance(instance, type, props, inRootOrSingleton) {
          for (; 1 === instance.nodeType; ) {
            var anyProps = props;
            if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
              if (!inRootOrSingleton && ("INPUT" !== instance.nodeName || "hidden" !== instance.type))
                break;
            } else if (!inRootOrSingleton)
              if ("input" === type && "hidden" === instance.type) {
                checkAttributeStringCoercion(anyProps.name, "name");
                var name = null == anyProps.name ? null : "" + anyProps.name;
                if ("hidden" === anyProps.type && instance.getAttribute("name") === name)
                  return instance;
              } else return instance;
            else if (!instance[internalHoistableMarker])
              switch (type) {
                case "meta":
                  if (!instance.hasAttribute("itemprop")) break;
                  return instance;
                case "link":
                  name = instance.getAttribute("rel");
                  if ("stylesheet" === name && instance.hasAttribute("data-precedence"))
                    break;
                  else if (name !== anyProps.rel || instance.getAttribute("href") !== (null == anyProps.href || "" === anyProps.href ? null : anyProps.href) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) || instance.getAttribute("title") !== (null == anyProps.title ? null : anyProps.title))
                    break;
                  return instance;
                case "style":
                  if (instance.hasAttribute("data-precedence")) break;
                  return instance;
                case "script":
                  name = instance.getAttribute("src");
                  if ((name !== (null == anyProps.src ? null : anyProps.src) || instance.getAttribute("type") !== (null == anyProps.type ? null : anyProps.type) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) && name && instance.hasAttribute("async") && !instance.hasAttribute("itemprop"))
                    break;
                  return instance;
                default:
                  return instance;
              }
            instance = getNextHydratable(instance.nextSibling);
            if (null === instance) break;
          }
          return null;
        }
        function canHydrateTextInstance(instance, text, inRootOrSingleton) {
          if ("" === text) return null;
          for (; 3 !== instance.nodeType; ) {
            if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
              return null;
            instance = getNextHydratable(instance.nextSibling);
            if (null === instance) return null;
          }
          return instance;
        }
        function canHydrateHydrationBoundary(instance, inRootOrSingleton) {
          for (; 8 !== instance.nodeType; ) {
            if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
              return null;
            instance = getNextHydratable(instance.nextSibling);
            if (null === instance) return null;
          }
          return instance;
        }
        function isSuspenseInstancePending(instance) {
          return instance.data === SUSPENSE_PENDING_START_DATA || instance.data === SUSPENSE_QUEUED_START_DATA;
        }
        function isSuspenseInstanceFallback(instance) {
          return instance.data === SUSPENSE_FALLBACK_START_DATA || instance.data === SUSPENSE_PENDING_START_DATA && instance.ownerDocument.readyState !== DOCUMENT_READY_STATE_LOADING;
        }
        function registerSuspenseInstanceRetry(instance, callback) {
          var ownerDocument = instance.ownerDocument;
          if (instance.data === SUSPENSE_QUEUED_START_DATA)
            instance._reactRetry = callback;
          else if (instance.data !== SUSPENSE_PENDING_START_DATA || ownerDocument.readyState !== DOCUMENT_READY_STATE_LOADING)
            callback();
          else {
            var listener = function() {
              callback();
              ownerDocument.removeEventListener("DOMContentLoaded", listener);
            };
            ownerDocument.addEventListener("DOMContentLoaded", listener);
            instance._reactRetry = listener;
          }
        }
        function getNextHydratable(node) {
          for (; null != node; node = node.nextSibling) {
            var nodeType = node.nodeType;
            if (1 === nodeType || 3 === nodeType) break;
            if (8 === nodeType) {
              nodeType = node.data;
              if (nodeType === SUSPENSE_START_DATA || nodeType === SUSPENSE_FALLBACK_START_DATA || nodeType === SUSPENSE_PENDING_START_DATA || nodeType === SUSPENSE_QUEUED_START_DATA || nodeType === ACTIVITY_START_DATA || nodeType === FORM_STATE_IS_MATCHING || nodeType === FORM_STATE_IS_NOT_MATCHING)
                break;
              if (nodeType === SUSPENSE_END_DATA || nodeType === ACTIVITY_END_DATA)
                return null;
            }
          }
          return node;
        }
        function describeHydratableInstanceForDevWarnings(instance) {
          if (1 === instance.nodeType) {
            for (var JSCompiler_temp_const = instance.nodeName.toLowerCase(), serverDifferences = {}, attributes = instance.attributes, i5 = 0; i5 < attributes.length; i5++) {
              var attr = attributes[i5];
              serverDifferences[getPropNameFromAttributeName(attr.name)] = "style" === attr.name.toLowerCase() ? getStylesObjectFromElement(instance) : attr.value;
            }
            return { type: JSCompiler_temp_const, props: serverDifferences };
          }
          return 8 === instance.nodeType ? instance.data === ACTIVITY_START_DATA ? { type: "Activity", props: {} } : { type: "Suspense", props: {} } : instance.nodeValue;
        }
        function diffHydratedTextForDevWarnings(textInstance, text, parentProps) {
          return null === parentProps || true !== parentProps[SUPPRESS_HYDRATION_WARNING] ? (textInstance.nodeValue === text ? textInstance = null : (text = normalizeMarkupForTextOrAttribute(text), textInstance = normalizeMarkupForTextOrAttribute(textInstance.nodeValue) === text ? null : textInstance.nodeValue), textInstance) : null;
        }
        function getNextHydratableInstanceAfterHydrationBoundary(hydrationInstance) {
          hydrationInstance = hydrationInstance.nextSibling;
          for (var depth = 0; hydrationInstance; ) {
            if (8 === hydrationInstance.nodeType) {
              var data = hydrationInstance.data;
              if (data === SUSPENSE_END_DATA || data === ACTIVITY_END_DATA) {
                if (0 === depth)
                  return getNextHydratable(hydrationInstance.nextSibling);
                depth--;
              } else
                data !== SUSPENSE_START_DATA && data !== SUSPENSE_FALLBACK_START_DATA && data !== SUSPENSE_PENDING_START_DATA && data !== SUSPENSE_QUEUED_START_DATA && data !== ACTIVITY_START_DATA || depth++;
            }
            hydrationInstance = hydrationInstance.nextSibling;
          }
          return null;
        }
        function getParentHydrationBoundary(targetInstance) {
          targetInstance = targetInstance.previousSibling;
          for (var depth = 0; targetInstance; ) {
            if (8 === targetInstance.nodeType) {
              var data = targetInstance.data;
              if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA || data === SUSPENSE_QUEUED_START_DATA || data === ACTIVITY_START_DATA) {
                if (0 === depth) return targetInstance;
                depth--;
              } else
                data !== SUSPENSE_END_DATA && data !== ACTIVITY_END_DATA || depth++;
            }
            targetInstance = targetInstance.previousSibling;
          }
          return null;
        }
        function commitHydratedContainer(container) {
          retryIfBlockedOn(container);
        }
        function commitHydratedActivityInstance(activityInstance) {
          retryIfBlockedOn(activityInstance);
        }
        function commitHydratedSuspenseInstance(suspenseInstance) {
          retryIfBlockedOn(suspenseInstance);
        }
        function resolveSingletonInstance(type, props, rootContainerInstance, hostContext, validateDOMNestingDev) {
          validateDOMNestingDev && validateDOMNesting(type, hostContext.ancestorInfo);
          props = getOwnerDocumentFromRootContainer(rootContainerInstance);
          switch (type) {
            case "html":
              type = props.documentElement;
              if (!type)
                throw Error(
                  "React expected an <html> element (document.documentElement) to exist in the Document but one was not found. React never removes the documentElement for any Document it renders into so the cause is likely in some other script running on this page."
                );
              return type;
            case "head":
              type = props.head;
              if (!type)
                throw Error(
                  "React expected a <head> element (document.head) to exist in the Document but one was not found. React never removes the head for any Document it renders into so the cause is likely in some other script running on this page."
                );
              return type;
            case "body":
              type = props.body;
              if (!type)
                throw Error(
                  "React expected a <body> element (document.body) to exist in the Document but one was not found. React never removes the body for any Document it renders into so the cause is likely in some other script running on this page."
                );
              return type;
            default:
              throw Error(
                "resolveSingletonInstance was called with an element type that is not supported. This is a bug in React."
              );
          }
        }
        function acquireSingletonInstance(type, props, instance, internalInstanceHandle) {
          if (!instance[internalContainerInstanceKey] && getInstanceFromNode(instance)) {
            var tagName = instance.tagName.toLowerCase();
            console.error(
              "You are mounting a new %s component when a previous one has not first unmounted. It is an error to render more than one %s component at a time and attributes and children of these components will likely fail in unpredictable ways. Please only render a single instance of <%s> and if you need to mount a new one, ensure any previous ones have unmounted first.",
              tagName,
              tagName,
              tagName
            );
          }
          switch (type) {
            case "html":
            case "head":
            case "body":
              break;
            default:
              console.error(
                "acquireSingletonInstance was called with an element type that is not supported. This is a bug in React."
              );
          }
          for (tagName = instance.attributes; tagName.length; )
            instance.removeAttributeNode(tagName[0]);
          setInitialProperties(instance, type, props);
          instance[internalInstanceKey] = internalInstanceHandle;
          instance[internalPropsKey] = props;
        }
        function releaseSingletonInstance(instance) {
          for (var attributes = instance.attributes; attributes.length; )
            instance.removeAttributeNode(attributes[0]);
          detachDeletedInstance(instance);
        }
        function getHoistableRoot(container) {
          return "function" === typeof container.getRootNode ? container.getRootNode() : 9 === container.nodeType ? container : container.ownerDocument;
        }
        function preconnectAs(rel, href, crossOrigin) {
          var ownerDocument = globalDocument;
          if (ownerDocument && "string" === typeof href && href) {
            var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
            limitedEscapedHref = 'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
            "string" === typeof crossOrigin && (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
            preconnectsSet.has(limitedEscapedHref) || (preconnectsSet.add(limitedEscapedHref), rel = { rel, crossOrigin, href }, null === ownerDocument.querySelector(limitedEscapedHref) && (href = ownerDocument.createElement("link"), setInitialProperties(href, "link", rel), markNodeAsHoistable(href), ownerDocument.head.appendChild(href)));
          }
        }
        function getResource(type, currentProps, pendingProps, currentResource) {
          var resourceRoot = (resourceRoot = rootInstanceStackCursor.current) ? getHoistableRoot(resourceRoot) : null;
          if (!resourceRoot)
            throw Error(
              '"resourceRoot" was expected to exist. This is a bug in React.'
            );
          switch (type) {
            case "meta":
            case "title":
              return null;
            case "style":
              return "string" === typeof pendingProps.precedence && "string" === typeof pendingProps.href ? (pendingProps = getStyleKey(pendingProps.href), currentProps = getResourcesFromRoot(resourceRoot).hoistableStyles, currentResource = currentProps.get(pendingProps), currentResource || (currentResource = {
                type: "style",
                instance: null,
                count: 0,
                state: null
              }, currentProps.set(pendingProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
            case "link":
              if ("stylesheet" === pendingProps.rel && "string" === typeof pendingProps.href && "string" === typeof pendingProps.precedence) {
                type = getStyleKey(pendingProps.href);
                var _styles = getResourcesFromRoot(resourceRoot).hoistableStyles, _resource = _styles.get(type);
                if (!_resource && (resourceRoot = resourceRoot.ownerDocument || resourceRoot, _resource = {
                  type: "stylesheet",
                  instance: null,
                  count: 0,
                  state: { loading: NotLoaded, preload: null }
                }, _styles.set(type, _resource), (_styles = resourceRoot.querySelector(
                  getStylesheetSelectorFromKey(type)
                )) && !_styles._p && (_resource.instance = _styles, _resource.state.loading = Loaded | Inserted), !preloadPropsMap.has(type))) {
                  var preloadProps = {
                    rel: "preload",
                    as: "style",
                    href: pendingProps.href,
                    crossOrigin: pendingProps.crossOrigin,
                    integrity: pendingProps.integrity,
                    media: pendingProps.media,
                    hrefLang: pendingProps.hrefLang,
                    referrerPolicy: pendingProps.referrerPolicy
                  };
                  preloadPropsMap.set(type, preloadProps);
                  _styles || preloadStylesheet(
                    resourceRoot,
                    type,
                    preloadProps,
                    _resource.state
                  );
                }
                if (currentProps && null === currentResource)
                  throw pendingProps = "\n\n  - " + describeLinkForResourceErrorDEV(currentProps) + "\n  + " + describeLinkForResourceErrorDEV(pendingProps), Error(
                    "Expected <link> not to update to be updated to a stylesheet with precedence. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + pendingProps
                  );
                return _resource;
              }
              if (currentProps && null !== currentResource)
                throw pendingProps = "\n\n  - " + describeLinkForResourceErrorDEV(currentProps) + "\n  + " + describeLinkForResourceErrorDEV(pendingProps), Error(
                  "Expected stylesheet with precedence to not be updated to a different kind of <link>. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + pendingProps
                );
              return null;
            case "script":
              return currentProps = pendingProps.async, pendingProps = pendingProps.src, "string" === typeof pendingProps && currentProps && "function" !== typeof currentProps && "symbol" !== typeof currentProps ? (pendingProps = getScriptKey(pendingProps), currentProps = getResourcesFromRoot(resourceRoot).hoistableScripts, currentResource = currentProps.get(pendingProps), currentResource || (currentResource = {
                type: "script",
                instance: null,
                count: 0,
                state: null
              }, currentProps.set(pendingProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
            default:
              throw Error(
                'getResource encountered a type it did not expect: "' + type + '". this is a bug in React.'
              );
          }
        }
        function describeLinkForResourceErrorDEV(props) {
          var describedProps = 0, description = "<link";
          "string" === typeof props.rel ? (describedProps++, description += ' rel="' + props.rel + '"') : hasOwnProperty.call(props, "rel") && (describedProps++, description += ' rel="' + (null === props.rel ? "null" : "invalid type " + typeof props.rel) + '"');
          "string" === typeof props.href ? (describedProps++, description += ' href="' + props.href + '"') : hasOwnProperty.call(props, "href") && (describedProps++, description += ' href="' + (null === props.href ? "null" : "invalid type " + typeof props.href) + '"');
          "string" === typeof props.precedence ? (describedProps++, description += ' precedence="' + props.precedence + '"') : hasOwnProperty.call(props, "precedence") && (describedProps++, description += " precedence={" + (null === props.precedence ? "null" : "invalid type " + typeof props.precedence) + "}");
          Object.getOwnPropertyNames(props).length > describedProps && (description += " ...");
          return description + " />";
        }
        function getStyleKey(href) {
          return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
        }
        function getStylesheetSelectorFromKey(key) {
          return 'link[rel="stylesheet"][' + key + "]";
        }
        function stylesheetPropsFromRawProps(rawProps) {
          return assign({}, rawProps, {
            "data-precedence": rawProps.precedence,
            precedence: null
          });
        }
        function preloadStylesheet(ownerDocument, key, preloadProps, state) {
          ownerDocument.querySelector(
            'link[rel="preload"][as="style"][' + key + "]"
          ) ? state.loading = Loaded : (key = ownerDocument.createElement("link"), state.preload = key, key.addEventListener("load", function() {
            return state.loading |= Loaded;
          }), key.addEventListener("error", function() {
            return state.loading |= Errored;
          }), setInitialProperties(key, "link", preloadProps), markNodeAsHoistable(key), ownerDocument.head.appendChild(key));
        }
        function getScriptKey(src) {
          return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
        }
        function getScriptSelectorFromKey(key) {
          return "script[async]" + key;
        }
        function acquireResource(hoistableRoot, resource, props) {
          resource.count++;
          if (null === resource.instance)
            switch (resource.type) {
              case "style":
                var instance = hoistableRoot.querySelector(
                  'style[data-href~="' + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + '"]'
                );
                if (instance)
                  return resource.instance = instance, markNodeAsHoistable(instance), instance;
                var styleProps = assign({}, props, {
                  "data-href": props.href,
                  "data-precedence": props.precedence,
                  href: null,
                  precedence: null
                });
                instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement("style");
                markNodeAsHoistable(instance);
                setInitialProperties(instance, "style", styleProps);
                insertStylesheet(instance, props.precedence, hoistableRoot);
                return resource.instance = instance;
              case "stylesheet":
                styleProps = getStyleKey(props.href);
                var _instance = hoistableRoot.querySelector(
                  getStylesheetSelectorFromKey(styleProps)
                );
                if (_instance)
                  return resource.state.loading |= Inserted, resource.instance = _instance, markNodeAsHoistable(_instance), _instance;
                instance = stylesheetPropsFromRawProps(props);
                (styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance, styleProps);
                _instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement("link");
                markNodeAsHoistable(_instance);
                var linkInstance = _instance;
                linkInstance._p = new Promise(function(resolve, reject) {
                  linkInstance.onload = resolve;
                  linkInstance.onerror = reject;
                });
                setInitialProperties(_instance, "link", instance);
                resource.state.loading |= Inserted;
                insertStylesheet(_instance, props.precedence, hoistableRoot);
                return resource.instance = _instance;
              case "script":
                _instance = getScriptKey(props.src);
                if (styleProps = hoistableRoot.querySelector(
                  getScriptSelectorFromKey(_instance)
                ))
                  return resource.instance = styleProps, markNodeAsHoistable(styleProps), styleProps;
                instance = props;
                if (styleProps = preloadPropsMap.get(_instance))
                  instance = assign({}, props), adoptPreloadPropsForScript(instance, styleProps);
                hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
                styleProps = hoistableRoot.createElement("script");
                markNodeAsHoistable(styleProps);
                setInitialProperties(styleProps, "link", instance);
                hoistableRoot.head.appendChild(styleProps);
                return resource.instance = styleProps;
              case "void":
                return null;
              default:
                throw Error(
                  'acquireResource encountered a resource type it did not expect: "' + resource.type + '". this is a bug in React.'
                );
            }
          else
            "stylesheet" === resource.type && (resource.state.loading & Inserted) === NotLoaded && (instance = resource.instance, resource.state.loading |= Inserted, insertStylesheet(instance, props.precedence, hoistableRoot));
          return resource.instance;
        }
        function insertStylesheet(instance, precedence, root2) {
          for (var nodes = root2.querySelectorAll(
            'link[rel="stylesheet"][data-precedence],style[data-precedence]'
          ), last = nodes.length ? nodes[nodes.length - 1] : null, prior = last, i5 = 0; i5 < nodes.length; i5++) {
            var node = nodes[i5];
            if (node.dataset.precedence === precedence) prior = node;
            else if (prior !== last) break;
          }
          prior ? prior.parentNode.insertBefore(instance, prior.nextSibling) : (precedence = 9 === root2.nodeType ? root2.head : root2, precedence.insertBefore(instance, precedence.firstChild));
        }
        function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
          null == stylesheetProps.crossOrigin && (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
          null == stylesheetProps.referrerPolicy && (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
          null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
        }
        function adoptPreloadPropsForScript(scriptProps, preloadProps) {
          null == scriptProps.crossOrigin && (scriptProps.crossOrigin = preloadProps.crossOrigin);
          null == scriptProps.referrerPolicy && (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
          null == scriptProps.integrity && (scriptProps.integrity = preloadProps.integrity);
        }
        function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
          if (null === tagCaches) {
            var cache = /* @__PURE__ */ new Map();
            var caches = tagCaches = /* @__PURE__ */ new Map();
            caches.set(ownerDocument, cache);
          } else
            caches = tagCaches, cache = caches.get(ownerDocument), cache || (cache = /* @__PURE__ */ new Map(), caches.set(ownerDocument, cache));
          if (cache.has(type)) return cache;
          cache.set(type, null);
          ownerDocument = ownerDocument.getElementsByTagName(type);
          for (caches = 0; caches < ownerDocument.length; caches++) {
            var node = ownerDocument[caches];
            if (!(node[internalHoistableMarker] || node[internalInstanceKey] || "link" === type && "stylesheet" === node.getAttribute("rel")) && node.namespaceURI !== SVG_NAMESPACE) {
              var nodeKey = node.getAttribute(keyAttribute) || "";
              nodeKey = type + nodeKey;
              var existing = cache.get(nodeKey);
              existing ? existing.push(node) : cache.set(nodeKey, [node]);
            }
          }
          return cache;
        }
        function mountHoistable(hoistableRoot, type, instance) {
          hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
          hoistableRoot.head.insertBefore(
            instance,
            "title" === type ? hoistableRoot.querySelector("head > title") : null
          );
        }
        function isHostHoistableType(type, props, hostContext) {
          var outsideHostContainerContext = !hostContext.ancestorInfo.containerTagInScope;
          if (hostContext.context === HostContextNamespaceSvg || null != props.itemProp)
            return !outsideHostContainerContext || null == props.itemProp || "meta" !== type && "title" !== type && "style" !== type && "link" !== type && "script" !== type || console.error(
              "Cannot render a <%s> outside the main document if it has an `itemProp` prop. `itemProp` suggests the tag belongs to an `itemScope` which can appear anywhere in the DOM. If you were intending for React to hoist this <%s> remove the `itemProp` prop. Otherwise, try moving this tag into the <head> or <body> of the Document.",
              type,
              type
            ), false;
          switch (type) {
            case "meta":
            case "title":
              return true;
            case "style":
              if ("string" !== typeof props.precedence || "string" !== typeof props.href || "" === props.href) {
                outsideHostContainerContext && console.error(
                  'Cannot render a <style> outside the main document without knowing its precedence and a unique href key. React can hoist and deduplicate <style> tags if you provide a `precedence` prop along with an `href` prop that does not conflict with the `href` values used in any other hoisted <style> or <link rel="stylesheet" ...> tags.  Note that hoisting <style> tags is considered an advanced feature that most will not use directly. Consider moving the <style> tag to the <head> or consider adding a `precedence="default"` and `href="some unique resource identifier"`.'
                );
                break;
              }
              return true;
            case "link":
              if ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href || props.onLoad || props.onError) {
                if ("stylesheet" === props.rel && "string" === typeof props.precedence) {
                  type = props.href;
                  var onError = props.onError, disabled = props.disabled;
                  hostContext = [];
                  props.onLoad && hostContext.push("`onLoad`");
                  onError && hostContext.push("`onError`");
                  null != disabled && hostContext.push("`disabled`");
                  onError = propNamesListJoin(hostContext, "and");
                  onError += 1 === hostContext.length ? " prop" : " props";
                  disabled = 1 === hostContext.length ? "an " + onError : "the " + onError;
                  hostContext.length && console.error(
                    'React encountered a <link rel="stylesheet" href="%s" ... /> with a `precedence` prop that also included %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.',
                    type,
                    disabled,
                    onError
                  );
                }
                outsideHostContainerContext && ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href ? console.error(
                  "Cannot render a <link> outside the main document without a `rel` and `href` prop. Try adding a `rel` and/or `href` prop to this <link> or moving the link into the <head> tag"
                ) : (props.onError || props.onLoad) && console.error(
                  "Cannot render a <link> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."
                ));
                break;
              }
              switch (props.rel) {
                case "stylesheet":
                  return type = props.precedence, props = props.disabled, "string" !== typeof type && outsideHostContainerContext && console.error(
                    'Cannot render a <link rel="stylesheet" /> outside the main document without knowing its precedence. Consider adding precedence="default" or moving it into the root <head> tag.'
                  ), "string" === typeof type && null == props;
                default:
                  return true;
              }
            case "script":
              type = props.async && "function" !== typeof props.async && "symbol" !== typeof props.async;
              if (!type || props.onLoad || props.onError || !props.src || "string" !== typeof props.src) {
                outsideHostContainerContext && (type ? props.onLoad || props.onError ? console.error(
                  "Cannot render a <script> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."
                ) : console.error(
                  "Cannot render a <script> outside the main document without `async={true}` and a non-empty `src` prop. Ensure there is a valid `src` and either make the script async or move it into the root <head> tag or somewhere in the <body>."
                ) : console.error(
                  'Cannot render a sync or defer <script> outside the main document without knowing its order. Try adding async="" or moving it into the root <head> tag.'
                ));
                break;
              }
              return true;
            case "noscript":
            case "template":
              outsideHostContainerContext && console.error(
                "Cannot render <%s> outside the main document. Try moving it into the root <head> tag.",
                type
              );
          }
          return false;
        }
        function preloadResource(resource) {
          return "stylesheet" === resource.type && (resource.state.loading & Settled) === NotLoaded ? false : true;
        }
        function suspendResource(state, hoistableRoot, resource, props) {
          if ("stylesheet" === resource.type && ("string" !== typeof props.media || false !== matchMedia(props.media).matches) && (resource.state.loading & Inserted) === NotLoaded) {
            if (null === resource.instance) {
              var key = getStyleKey(props.href), instance = hoistableRoot.querySelector(
                getStylesheetSelectorFromKey(key)
              );
              if (instance) {
                hoistableRoot = instance._p;
                null !== hoistableRoot && "object" === typeof hoistableRoot && "function" === typeof hoistableRoot.then && (state.count++, state = onUnsuspend.bind(state), hoistableRoot.then(state, state));
                resource.state.loading |= Inserted;
                resource.instance = instance;
                markNodeAsHoistable(instance);
                return;
              }
              instance = hoistableRoot.ownerDocument || hoistableRoot;
              props = stylesheetPropsFromRawProps(props);
              (key = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(props, key);
              instance = instance.createElement("link");
              markNodeAsHoistable(instance);
              var linkInstance = instance;
              linkInstance._p = new Promise(function(resolve, reject) {
                linkInstance.onload = resolve;
                linkInstance.onerror = reject;
              });
              setInitialProperties(instance, "link", props);
              resource.instance = instance;
            }
            null === state.stylesheets && (state.stylesheets = /* @__PURE__ */ new Map());
            state.stylesheets.set(resource, hoistableRoot);
            (hoistableRoot = resource.state.preload) && (resource.state.loading & Settled) === NotLoaded && (state.count++, resource = onUnsuspend.bind(state), hoistableRoot.addEventListener("load", resource), hoistableRoot.addEventListener("error", resource));
          }
        }
        function waitForCommitToBeReady(state, timeoutOffset) {
          state.stylesheets && 0 === state.count && insertSuspendedStylesheets(state, state.stylesheets);
          return 0 < state.count || 0 < state.imgCount ? function(commit) {
            var stylesheetTimer = setTimeout(function() {
              state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets);
              if (state.unsuspend) {
                var unsuspend = state.unsuspend;
                state.unsuspend = null;
                unsuspend();
              }
            }, SUSPENSEY_STYLESHEET_TIMEOUT + timeoutOffset);
            0 < state.imgBytes && 0 === estimatedBytesWithinLimit && (estimatedBytesWithinLimit = 125 * estimateBandwidth() * SUSPENSEY_IMAGE_TIME_ESTIMATE);
            var imgTimer = setTimeout(
              function() {
                state.waitingForImages = false;
                if (0 === state.count && (state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets), state.unsuspend)) {
                  var unsuspend = state.unsuspend;
                  state.unsuspend = null;
                  unsuspend();
                }
              },
              (state.imgBytes > estimatedBytesWithinLimit ? 50 : SUSPENSEY_IMAGE_TIMEOUT) + timeoutOffset
            );
            state.unsuspend = commit;
            return function() {
              state.unsuspend = null;
              clearTimeout(stylesheetTimer);
              clearTimeout(imgTimer);
            };
          } : null;
        }
        function onUnsuspend() {
          this.count--;
          if (0 === this.count && (0 === this.imgCount || !this.waitingForImages)) {
            if (this.stylesheets)
              insertSuspendedStylesheets(this, this.stylesheets);
            else if (this.unsuspend) {
              var unsuspend = this.unsuspend;
              this.unsuspend = null;
              unsuspend();
            }
          }
        }
        function insertSuspendedStylesheets(state, resources) {
          state.stylesheets = null;
          null !== state.unsuspend && (state.count++, precedencesByRoot = /* @__PURE__ */ new Map(), resources.forEach(insertStylesheetIntoRoot, state), precedencesByRoot = null, onUnsuspend.call(state));
        }
        function insertStylesheetIntoRoot(root2, resource) {
          if (!(resource.state.loading & Inserted)) {
            var precedences = precedencesByRoot.get(root2);
            if (precedences) var last = precedences.get(LAST_PRECEDENCE);
            else {
              precedences = /* @__PURE__ */ new Map();
              precedencesByRoot.set(root2, precedences);
              for (var nodes = root2.querySelectorAll(
                "link[data-precedence],style[data-precedence]"
              ), i5 = 0; i5 < nodes.length; i5++) {
                var node = nodes[i5];
                if ("LINK" === node.nodeName || "not all" !== node.getAttribute("media"))
                  precedences.set(node.dataset.precedence, node), last = node;
              }
              last && precedences.set(LAST_PRECEDENCE, last);
            }
            nodes = resource.instance;
            node = nodes.getAttribute("data-precedence");
            i5 = precedences.get(node) || last;
            i5 === last && precedences.set(LAST_PRECEDENCE, nodes);
            precedences.set(node, nodes);
            this.count++;
            last = onUnsuspend.bind(this);
            nodes.addEventListener("load", last);
            nodes.addEventListener("error", last);
            i5 ? i5.parentNode.insertBefore(nodes, i5.nextSibling) : (root2 = 9 === root2.nodeType ? root2.head : root2, root2.insertBefore(nodes, root2.firstChild));
            resource.state.loading |= Inserted;
          }
        }
        function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator, formState) {
          this.tag = 1;
          this.containerInfo = containerInfo;
          this.pingCache = this.current = this.pendingChildren = null;
          this.timeoutHandle = noTimeout;
          this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
          this.callbackPriority = 0;
          this.expirationTimes = createLaneMap(-1);
          this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
          this.entanglements = createLaneMap(0);
          this.hiddenUpdates = createLaneMap(null);
          this.identifierPrefix = identifierPrefix;
          this.onUncaughtError = onUncaughtError;
          this.onCaughtError = onCaughtError;
          this.onRecoverableError = onRecoverableError;
          this.pooledCache = null;
          this.pooledCacheLanes = 0;
          this.formState = formState;
          this.incompleteTransitions = /* @__PURE__ */ new Map();
          this.passiveEffectDuration = this.effectDuration = -0;
          this.memoizedUpdaters = /* @__PURE__ */ new Set();
          containerInfo = this.pendingUpdatersLaneMap = [];
          for (tag = 0; 31 > tag; tag++) containerInfo.push(/* @__PURE__ */ new Set());
          this._debugRootType = hydrate ? "hydrateRoot()" : "createRoot()";
        }
        function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, formState, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator) {
          containerInfo = new FiberRootNode(
            containerInfo,
            tag,
            hydrate,
            identifierPrefix,
            onUncaughtError,
            onCaughtError,
            onRecoverableError,
            onDefaultTransitionIndicator,
            formState
          );
          tag = ConcurrentMode;
          true === isStrictMode && (tag |= StrictLegacyMode | StrictEffectsMode);
          tag |= ProfileMode;
          isStrictMode = createFiber(3, null, null, tag);
          containerInfo.current = isStrictMode;
          isStrictMode.stateNode = containerInfo;
          tag = createCache();
          retainCache(tag);
          containerInfo.pooledCache = tag;
          retainCache(tag);
          isStrictMode.memoizedState = {
            element: initialChildren,
            isDehydrated: hydrate,
            cache: tag
          };
          initializeUpdateQueue(isStrictMode);
          return containerInfo;
        }
        function getContextForSubtree(parentComponent) {
          if (!parentComponent) return emptyContextObject;
          parentComponent = emptyContextObject;
          return parentComponent;
        }
        function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {
          if (injectedHook && "function" === typeof injectedHook.onScheduleFiberRoot)
            try {
              injectedHook.onScheduleFiberRoot(rendererID, container, element);
            } catch (err) {
              hasLoggedError || (hasLoggedError = true, console.error(
                "React instrumentation encountered an error: %o",
                err
              ));
            }
          parentComponent = getContextForSubtree(parentComponent);
          null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;
          isRendering && null !== current && !didWarnAboutNestedUpdates && (didWarnAboutNestedUpdates = true, console.error(
            "Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.",
            getComponentNameFromFiber(current) || "Unknown"
          ));
          container = createUpdate(lane);
          container.payload = { element };
          callback = void 0 === callback ? null : callback;
          null !== callback && ("function" !== typeof callback && console.error(
            "Expected the last optional `callback` argument to be a function. Instead received: %s.",
            callback
          ), container.callback = callback);
          element = enqueueUpdate(rootFiber, container, lane);
          null !== element && (startUpdateTimerByLane(lane, "root.render()", null), scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
        }
        function markRetryLaneImpl(fiber, retryLane) {
          fiber = fiber.memoizedState;
          if (null !== fiber && null !== fiber.dehydrated) {
            var a5 = fiber.retryLane;
            fiber.retryLane = 0 !== a5 && a5 < retryLane ? a5 : retryLane;
          }
        }
        function markRetryLaneIfNotHydrated(fiber, retryLane) {
          markRetryLaneImpl(fiber, retryLane);
          (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
        }
        function attemptContinuousHydration(fiber) {
          if (13 === fiber.tag || 31 === fiber.tag) {
            var root2 = enqueueConcurrentRenderForLane(fiber, 67108864);
            null !== root2 && scheduleUpdateOnFiber(root2, fiber, 67108864);
            markRetryLaneIfNotHydrated(fiber, 67108864);
          }
        }
        function attemptHydrationAtCurrentPriority(fiber) {
          if (13 === fiber.tag || 31 === fiber.tag) {
            var lane = requestUpdateLane(fiber);
            lane = getBumpedLaneForHydrationByLane(lane);
            var root2 = enqueueConcurrentRenderForLane(fiber, lane);
            null !== root2 && scheduleUpdateOnFiber(root2, fiber, lane);
            markRetryLaneIfNotHydrated(fiber, lane);
          }
        }
        function getCurrentFiberForDevTools() {
          return current;
        }
        function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
          var prevTransition = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          var previousPriority = ReactDOMSharedInternals.p;
          try {
            ReactDOMSharedInternals.p = DiscreteEventPriority, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
          } finally {
            ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
          }
        }
        function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
          var prevTransition = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          var previousPriority = ReactDOMSharedInternals.p;
          try {
            ReactDOMSharedInternals.p = ContinuousEventPriority, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
          } finally {
            ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
          }
        }
        function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          if (_enabled) {
            var blockedOn = findInstanceBlockingEvent(nativeEvent);
            if (null === blockedOn)
              dispatchEventForPluginEventSystem(
                domEventName,
                eventSystemFlags,
                nativeEvent,
                return_targetInst,
                targetContainer
              ), clearIfContinuousEvent(domEventName, nativeEvent);
            else if (queueIfContinuousEvent(
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            ))
              nativeEvent.stopPropagation();
            else if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)) {
              for (; null !== blockedOn; ) {
                var fiber = getInstanceFromNode(blockedOn);
                if (null !== fiber)
                  switch (fiber.tag) {
                    case 3:
                      fiber = fiber.stateNode;
                      if (fiber.current.memoizedState.isDehydrated) {
                        var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                        if (0 !== lanes) {
                          var root2 = fiber;
                          root2.pendingLanes |= 2;
                          for (root2.entangledLanes |= 2; lanes; ) {
                            var lane = 1 << 31 - clz32(lanes);
                            root2.entanglements[1] |= lane;
                            lanes &= ~lane;
                          }
                          ensureRootIsScheduled(fiber);
                          (executionContext & (RenderContext | CommitContext)) === NoContext && (workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS, flushSyncWorkAcrossRoots_impl(0, false));
                        }
                      }
                      break;
                    case 31:
                    case 13:
                      root2 = enqueueConcurrentRenderForLane(fiber, 2), null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);
                  }
                fiber = findInstanceBlockingEvent(nativeEvent);
                null === fiber && dispatchEventForPluginEventSystem(
                  domEventName,
                  eventSystemFlags,
                  nativeEvent,
                  return_targetInst,
                  targetContainer
                );
                if (fiber === blockedOn) break;
                blockedOn = fiber;
              }
              null !== blockedOn && nativeEvent.stopPropagation();
            } else
              dispatchEventForPluginEventSystem(
                domEventName,
                eventSystemFlags,
                nativeEvent,
                null,
                targetContainer
              );
          }
        }
        function findInstanceBlockingEvent(nativeEvent) {
          nativeEvent = getEventTarget(nativeEvent);
          return findInstanceBlockingTarget(nativeEvent);
        }
        function findInstanceBlockingTarget(targetNode) {
          return_targetInst = null;
          targetNode = getClosestInstanceFromNode(targetNode);
          if (null !== targetNode) {
            var nearestMounted = getNearestMountedFiber(targetNode);
            if (null === nearestMounted) targetNode = null;
            else {
              var tag = nearestMounted.tag;
              if (13 === tag) {
                targetNode = getSuspenseInstanceFromFiber(nearestMounted);
                if (null !== targetNode) return targetNode;
                targetNode = null;
              } else if (31 === tag) {
                targetNode = getActivityInstanceFromFiber(nearestMounted);
                if (null !== targetNode) return targetNode;
                targetNode = null;
              } else if (3 === tag) {
                if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
                  return 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
                targetNode = null;
              } else nearestMounted !== targetNode && (targetNode = null);
            }
          }
          return_targetInst = targetNode;
          return null;
        }
        function getEventPriority(domEventName) {
          switch (domEventName) {
            case "beforetoggle":
            case "cancel":
            case "click":
            case "close":
            case "contextmenu":
            case "copy":
            case "cut":
            case "auxclick":
            case "dblclick":
            case "dragend":
            case "dragstart":
            case "drop":
            case "focusin":
            case "focusout":
            case "input":
            case "invalid":
            case "keydown":
            case "keypress":
            case "keyup":
            case "mousedown":
            case "mouseup":
            case "paste":
            case "pause":
            case "play":
            case "pointercancel":
            case "pointerdown":
            case "pointerup":
            case "ratechange":
            case "reset":
            case "resize":
            case "seeked":
            case "submit":
            case "toggle":
            case "touchcancel":
            case "touchend":
            case "touchstart":
            case "volumechange":
            case "change":
            case "selectionchange":
            case "textInput":
            case "compositionstart":
            case "compositionend":
            case "compositionupdate":
            case "beforeblur":
            case "afterblur":
            case "beforeinput":
            case "blur":
            case "fullscreenchange":
            case "focus":
            case "hashchange":
            case "popstate":
            case "select":
            case "selectstart":
              return DiscreteEventPriority;
            case "drag":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "mousemove":
            case "mouseout":
            case "mouseover":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "scroll":
            case "touchmove":
            case "wheel":
            case "mouseenter":
            case "mouseleave":
            case "pointerenter":
            case "pointerleave":
              return ContinuousEventPriority;
            case "message":
              switch (getCurrentPriorityLevel()) {
                case ImmediatePriority:
                  return DiscreteEventPriority;
                case UserBlockingPriority:
                  return ContinuousEventPriority;
                case NormalPriority$1:
                case LowPriority:
                  return DefaultEventPriority;
                case IdlePriority:
                  return IdleEventPriority;
                default:
                  return DefaultEventPriority;
              }
            default:
              return DefaultEventPriority;
          }
        }
        function clearIfContinuousEvent(domEventName, nativeEvent) {
          switch (domEventName) {
            case "focusin":
            case "focusout":
              queuedFocus = null;
              break;
            case "dragenter":
            case "dragleave":
              queuedDrag = null;
              break;
            case "mouseover":
            case "mouseout":
              queuedMouse = null;
              break;
            case "pointerover":
            case "pointerout":
              queuedPointers.delete(nativeEvent.pointerId);
              break;
            case "gotpointercapture":
            case "lostpointercapture":
              queuedPointerCaptures.delete(nativeEvent.pointerId);
          }
        }
        function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          if (null === existingQueuedEvent || existingQueuedEvent.nativeEvent !== nativeEvent)
            return existingQueuedEvent = {
              blockedOn,
              domEventName,
              eventSystemFlags,
              nativeEvent,
              targetContainers: [targetContainer]
            }, null !== blockedOn && (blockedOn = getInstanceFromNode(blockedOn), null !== blockedOn && attemptContinuousHydration(blockedOn)), existingQueuedEvent;
          existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
          blockedOn = existingQueuedEvent.targetContainers;
          null !== targetContainer && -1 === blockedOn.indexOf(targetContainer) && blockedOn.push(targetContainer);
          return existingQueuedEvent;
        }
        function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          switch (domEventName) {
            case "focusin":
              return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedFocus,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              ), true;
            case "dragenter":
              return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedDrag,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              ), true;
            case "mouseover":
              return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedMouse,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              ), true;
            case "pointerover":
              var pointerId = nativeEvent.pointerId;
              queuedPointers.set(
                pointerId,
                accumulateOrCreateContinuousQueuedReplayableEvent(
                  queuedPointers.get(pointerId) || null,
                  blockedOn,
                  domEventName,
                  eventSystemFlags,
                  targetContainer,
                  nativeEvent
                )
              );
              return true;
            case "gotpointercapture":
              return pointerId = nativeEvent.pointerId, queuedPointerCaptures.set(
                pointerId,
                accumulateOrCreateContinuousQueuedReplayableEvent(
                  queuedPointerCaptures.get(pointerId) || null,
                  blockedOn,
                  domEventName,
                  eventSystemFlags,
                  targetContainer,
                  nativeEvent
                )
              ), true;
          }
          return false;
        }
        function attemptExplicitHydrationTarget(queuedTarget) {
          var targetInst = getClosestInstanceFromNode(queuedTarget.target);
          if (null !== targetInst) {
            var nearestMounted = getNearestMountedFiber(targetInst);
            if (null !== nearestMounted) {
              if (targetInst = nearestMounted.tag, 13 === targetInst) {
                if (targetInst = getSuspenseInstanceFromFiber(nearestMounted), null !== targetInst) {
                  queuedTarget.blockedOn = targetInst;
                  runWithPriority(queuedTarget.priority, function() {
                    attemptHydrationAtCurrentPriority(nearestMounted);
                  });
                  return;
                }
              } else if (31 === targetInst) {
                if (targetInst = getActivityInstanceFromFiber(nearestMounted), null !== targetInst) {
                  queuedTarget.blockedOn = targetInst;
                  runWithPriority(queuedTarget.priority, function() {
                    attemptHydrationAtCurrentPriority(nearestMounted);
                  });
                  return;
                }
              } else if (3 === targetInst && nearestMounted.stateNode.current.memoizedState.isDehydrated) {
                queuedTarget.blockedOn = 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
                return;
              }
            }
          }
          queuedTarget.blockedOn = null;
        }
        function attemptReplayContinuousQueuedEvent(queuedEvent) {
          if (null !== queuedEvent.blockedOn) return false;
          for (var targetContainers = queuedEvent.targetContainers; 0 < targetContainers.length; ) {
            var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
            if (null === nextBlockedOn) {
              nextBlockedOn = queuedEvent.nativeEvent;
              var nativeEventClone = new nextBlockedOn.constructor(
                nextBlockedOn.type,
                nextBlockedOn
              ), event = nativeEventClone;
              null !== currentReplayingEvent && console.error(
                "Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."
              );
              currentReplayingEvent = event;
              nextBlockedOn.target.dispatchEvent(nativeEventClone);
              null === currentReplayingEvent && console.error(
                "Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."
              );
              currentReplayingEvent = null;
            } else
              return targetContainers = getInstanceFromNode(nextBlockedOn), null !== targetContainers && attemptContinuousHydration(targetContainers), queuedEvent.blockedOn = nextBlockedOn, false;
            targetContainers.shift();
          }
          return true;
        }
        function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
          attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
        }
        function replayUnblockedEvents() {
          hasScheduledReplayAttempt = false;
          null !== queuedFocus && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);
          null !== queuedDrag && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);
          null !== queuedMouse && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);
          queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
          queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
        }
        function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
          queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = true, Scheduler.unstable_scheduleCallback(
            Scheduler.unstable_NormalPriority,
            replayUnblockedEvents
          )));
        }
        function scheduleReplayQueueIfNeeded(formReplayingQueue) {
          lastScheduledReplayQueue !== formReplayingQueue && (lastScheduledReplayQueue = formReplayingQueue, Scheduler.unstable_scheduleCallback(
            Scheduler.unstable_NormalPriority,
            function() {
              lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
              for (var i5 = 0; i5 < formReplayingQueue.length; i5 += 3) {
                var form = formReplayingQueue[i5], submitterOrAction = formReplayingQueue[i5 + 1], formData = formReplayingQueue[i5 + 2];
                if ("function" !== typeof submitterOrAction)
                  if (null === findInstanceBlockingTarget(submitterOrAction || form))
                    continue;
                  else break;
                var formInst = getInstanceFromNode(form);
                null !== formInst && (formReplayingQueue.splice(i5, 3), i5 -= 3, form = {
                  pending: true,
                  data: formData,
                  method: form.method,
                  action: submitterOrAction
                }, Object.freeze(form), startHostTransition(
                  formInst,
                  form,
                  submitterOrAction,
                  formData
                ));
              }
            }
          ));
        }
        function retryIfBlockedOn(unblocked) {
          function unblock(queuedEvent) {
            return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
          }
          null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
          null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
          null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
          queuedPointers.forEach(unblock);
          queuedPointerCaptures.forEach(unblock);
          for (var i5 = 0; i5 < queuedExplicitHydrationTargets.length; i5++) {
            var queuedTarget = queuedExplicitHydrationTargets[i5];
            queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
          }
          for (; 0 < queuedExplicitHydrationTargets.length && (i5 = queuedExplicitHydrationTargets[0], null === i5.blockedOn); )
            attemptExplicitHydrationTarget(i5), null === i5.blockedOn && queuedExplicitHydrationTargets.shift();
          i5 = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
          if (null != i5)
            for (queuedTarget = 0; queuedTarget < i5.length; queuedTarget += 3) {
              var form = i5[queuedTarget], submitterOrAction = i5[queuedTarget + 1], formProps = form[internalPropsKey] || null;
              if ("function" === typeof submitterOrAction)
                formProps || scheduleReplayQueueIfNeeded(i5);
              else if (formProps) {
                var action = null;
                if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))
                  if (form = submitterOrAction, formProps = submitterOrAction[internalPropsKey] || null)
                    action = formProps.formAction;
                  else {
                    if (null !== findInstanceBlockingTarget(form)) continue;
                  }
                else action = formProps.action;
                "function" === typeof action ? i5[queuedTarget + 1] = action : (i5.splice(queuedTarget, 3), queuedTarget -= 3);
                scheduleReplayQueueIfNeeded(i5);
              }
            }
        }
        function defaultOnDefaultTransitionIndicator() {
          function handleNavigate(event) {
            event.canIntercept && "react-transition" === event.info && event.intercept({
              handler: function() {
                return new Promise(function(resolve) {
                  return pendingResolve = resolve;
                });
              },
              focusReset: "manual",
              scroll: "manual"
            });
          }
          function handleNavigateComplete() {
            null !== pendingResolve && (pendingResolve(), pendingResolve = null);
            isCancelled || setTimeout(startFakeNavigation, 20);
          }
          function startFakeNavigation() {
            if (!isCancelled && !navigation.transition) {
              var currentEntry = navigation.currentEntry;
              currentEntry && null != currentEntry.url && navigation.navigate(currentEntry.url, {
                state: currentEntry.getState(),
                info: "react-transition",
                history: "replace"
              });
            }
          }
          if ("object" === typeof navigation) {
            var isCancelled = false, pendingResolve = null;
            navigation.addEventListener("navigate", handleNavigate);
            navigation.addEventListener("navigatesuccess", handleNavigateComplete);
            navigation.addEventListener("navigateerror", handleNavigateComplete);
            setTimeout(startFakeNavigation, 100);
            return function() {
              isCancelled = true;
              navigation.removeEventListener("navigate", handleNavigate);
              navigation.removeEventListener(
                "navigatesuccess",
                handleNavigateComplete
              );
              navigation.removeEventListener(
                "navigateerror",
                handleNavigateComplete
              );
              null !== pendingResolve && (pendingResolve(), pendingResolve = null);
            };
          }
        }
        function ReactDOMRoot(internalRoot) {
          this._internalRoot = internalRoot;
        }
        function ReactDOMHydrationRoot(internalRoot) {
          this._internalRoot = internalRoot;
        }
        function warnIfReactDOMContainerInDEV(container) {
          container[internalContainerInstanceKey] && (container._reactRootContainer ? console.error(
            "You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported."
          ) : console.error(
            "You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."
          ));
        }
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
        var Scheduler = require_scheduler(), React2 = require_react(), ReactDOM = require_react_dom(), assign = Object.assign, REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy");
        Symbol.for("react.scope");
        var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
        Symbol.for("react.legacy_hidden");
        Symbol.for("react.tracing_marker");
        var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
        Symbol.for("react.view_transition");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), isArrayImpl = Array.isArray, ReactSharedInternals = React2.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, NotPending = Object.freeze({
          pending: false,
          data: null,
          method: null,
          action: null
        }), valueStack = [];
        var fiberStack = [];
        var index$jscomp$0 = -1, contextStackCursor = createCursor(null), contextFiberStackCursor = createCursor(null), rootInstanceStackCursor = createCursor(null), hostTransitionProviderCursor = createCursor(null), disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
        disabledLog.__reactDisabledLog = true;
        var prefix, suffix, reentry = false;
        var componentFrameCache = new ("function" === typeof WeakMap ? WeakMap : Map)();
        var current = null, isRendering = false, hasOwnProperty = Object.prototype.hasOwnProperty, scheduleCallback$3 = Scheduler.unstable_scheduleCallback, cancelCallback$1 = Scheduler.unstable_cancelCallback, shouldYield = Scheduler.unstable_shouldYield, requestPaint = Scheduler.unstable_requestPaint, now$1 = Scheduler.unstable_now, getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel, ImmediatePriority = Scheduler.unstable_ImmediatePriority, UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, NormalPriority$1 = Scheduler.unstable_NormalPriority, LowPriority = Scheduler.unstable_LowPriority, IdlePriority = Scheduler.unstable_IdlePriority, log$1 = Scheduler.log, unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue, rendererID = null, injectedHook = null, hasLoggedError = false, isDevToolsPresent = "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__, clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log = Math.log, LN2 = Math.LN2, nextTransitionUpdateLane = 256, nextTransitionDeferredLane = 262144, nextRetryLane = 4194304, DiscreteEventPriority = 2, ContinuousEventPriority = 8, DefaultEventPriority = 32, IdleEventPriority = 268435456, randomKey = Math.random().toString(36).slice(2), internalInstanceKey = "__reactFiber$" + randomKey, internalPropsKey = "__reactProps$" + randomKey, internalContainerInstanceKey = "__reactContainer$" + randomKey, internalEventHandlersKey = "__reactEvents$" + randomKey, internalEventHandlerListenersKey = "__reactListeners$" + randomKey, internalEventHandlesSetKey = "__reactHandles$" + randomKey, internalRootNodeResourcesKey = "__reactResources$" + randomKey, internalHoistableMarker = "__reactMarker$" + randomKey, allNativeEvents = /* @__PURE__ */ new Set(), registrationNameDependencies = {}, possibleRegistrationNames = {}, hasReadOnlyValue = {
          button: true,
          checkbox: true,
          image: true,
          hidden: true,
          radio: true,
          reset: true,
          submit: true
        }, VALID_ATTRIBUTE_NAME_REGEX = RegExp(
          "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), illegalAttributeNameCache = {}, validatedAttributeNameCache = {}, escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g, didWarnValueDefaultValue$1 = false, didWarnCheckedDefaultChecked = false, didWarnSelectedSetOnOption = false, didWarnInvalidChild = false, didWarnInvalidInnerHTML = false;
        var didWarnValueDefaultValue = false;
        var valuePropNames = ["value", "defaultValue"], didWarnValDefaultVal = false, needsEscaping = /["'&<>\n\t]|^\s|\s$/, specialTags = "address applet area article aside base basefont bgsound blockquote body br button caption center col colgroup dd details dir div dl dt embed fieldset figcaption figure footer form frame frameset h1 h2 h3 h4 h5 h6 head header hgroup hr html iframe img input isindex li link listing main marquee menu menuitem meta nav noembed noframes noscript object ol p param plaintext pre script section select source style summary table tbody td template textarea tfoot th thead title tr track ul wbr xmp".split(
          " "
        ), inScopeTags = "applet caption html table td th marquee object template foreignObject desc title".split(
          " "
        ), buttonScopeTags = inScopeTags.concat(["button"]), impliedEndTags = "dd dt li option optgroup p rp rt".split(" "), emptyAncestorInfoDev = {
          current: null,
          formTag: null,
          aTagInScope: null,
          buttonTagInScope: null,
          nobrTagInScope: null,
          pTagInButtonScope: null,
          listItemTagAutoclosing: null,
          dlItemTagAutoclosing: null,
          containerTagInScope: null,
          implicitRootScope: false
        }, didWarn = {}, shorthandToLonghand = {
          animation: "animationDelay animationDirection animationDuration animationFillMode animationIterationCount animationName animationPlayState animationTimingFunction".split(
            " "
          ),
          background: "backgroundAttachment backgroundClip backgroundColor backgroundImage backgroundOrigin backgroundPositionX backgroundPositionY backgroundRepeat backgroundSize".split(
            " "
          ),
          backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
          border: "borderBottomColor borderBottomStyle borderBottomWidth borderImageOutset borderImageRepeat borderImageSlice borderImageSource borderImageWidth borderLeftColor borderLeftStyle borderLeftWidth borderRightColor borderRightStyle borderRightWidth borderTopColor borderTopStyle borderTopWidth".split(
            " "
          ),
          borderBlockEnd: [
            "borderBlockEndColor",
            "borderBlockEndStyle",
            "borderBlockEndWidth"
          ],
          borderBlockStart: [
            "borderBlockStartColor",
            "borderBlockStartStyle",
            "borderBlockStartWidth"
          ],
          borderBottom: [
            "borderBottomColor",
            "borderBottomStyle",
            "borderBottomWidth"
          ],
          borderColor: [
            "borderBottomColor",
            "borderLeftColor",
            "borderRightColor",
            "borderTopColor"
          ],
          borderImage: [
            "borderImageOutset",
            "borderImageRepeat",
            "borderImageSlice",
            "borderImageSource",
            "borderImageWidth"
          ],
          borderInlineEnd: [
            "borderInlineEndColor",
            "borderInlineEndStyle",
            "borderInlineEndWidth"
          ],
          borderInlineStart: [
            "borderInlineStartColor",
            "borderInlineStartStyle",
            "borderInlineStartWidth"
          ],
          borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
          borderRadius: [
            "borderBottomLeftRadius",
            "borderBottomRightRadius",
            "borderTopLeftRadius",
            "borderTopRightRadius"
          ],
          borderRight: [
            "borderRightColor",
            "borderRightStyle",
            "borderRightWidth"
          ],
          borderStyle: [
            "borderBottomStyle",
            "borderLeftStyle",
            "borderRightStyle",
            "borderTopStyle"
          ],
          borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
          borderWidth: [
            "borderBottomWidth",
            "borderLeftWidth",
            "borderRightWidth",
            "borderTopWidth"
          ],
          columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
          columns: ["columnCount", "columnWidth"],
          flex: ["flexBasis", "flexGrow", "flexShrink"],
          flexFlow: ["flexDirection", "flexWrap"],
          font: "fontFamily fontFeatureSettings fontKerning fontLanguageOverride fontSize fontSizeAdjust fontStretch fontStyle fontVariant fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition fontWeight lineHeight".split(
            " "
          ),
          fontVariant: "fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition".split(
            " "
          ),
          gap: ["columnGap", "rowGap"],
          grid: "gridAutoColumns gridAutoFlow gridAutoRows gridTemplateAreas gridTemplateColumns gridTemplateRows".split(
            " "
          ),
          gridArea: [
            "gridColumnEnd",
            "gridColumnStart",
            "gridRowEnd",
            "gridRowStart"
          ],
          gridColumn: ["gridColumnEnd", "gridColumnStart"],
          gridColumnGap: ["columnGap"],
          gridGap: ["columnGap", "rowGap"],
          gridRow: ["gridRowEnd", "gridRowStart"],
          gridRowGap: ["rowGap"],
          gridTemplate: [
            "gridTemplateAreas",
            "gridTemplateColumns",
            "gridTemplateRows"
          ],
          listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
          margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
          marker: ["markerEnd", "markerMid", "markerStart"],
          mask: "maskClip maskComposite maskImage maskMode maskOrigin maskPositionX maskPositionY maskRepeat maskSize".split(
            " "
          ),
          maskPosition: ["maskPositionX", "maskPositionY"],
          outline: ["outlineColor", "outlineStyle", "outlineWidth"],
          overflow: ["overflowX", "overflowY"],
          padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
          placeContent: ["alignContent", "justifyContent"],
          placeItems: ["alignItems", "justifyItems"],
          placeSelf: ["alignSelf", "justifySelf"],
          textDecoration: [
            "textDecorationColor",
            "textDecorationLine",
            "textDecorationStyle"
          ],
          textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
          transition: [
            "transitionDelay",
            "transitionDuration",
            "transitionProperty",
            "transitionTimingFunction"
          ],
          wordWrap: ["overflowWrap"]
        }, uppercasePattern = /([A-Z])/g, msPattern$1 = /^ms-/, badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/, msPattern = /^-ms-/, hyphenPattern = /-(.)/g, badStyleValueWithSemicolonPattern = /;\s*$/, warnedStyleNames = {}, warnedStyleValues = {}, warnedForNaNValue = false, warnedForInfinityValue = false, unitlessNumbers = new Set(
          "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
            " "
          )
        ), MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML", SVG_NAMESPACE = "http://www.w3.org/2000/svg", aliases = /* @__PURE__ */ new Map([
          ["acceptCharset", "accept-charset"],
          ["htmlFor", "for"],
          ["httpEquiv", "http-equiv"],
          ["crossOrigin", "crossorigin"],
          ["accentHeight", "accent-height"],
          ["alignmentBaseline", "alignment-baseline"],
          ["arabicForm", "arabic-form"],
          ["baselineShift", "baseline-shift"],
          ["capHeight", "cap-height"],
          ["clipPath", "clip-path"],
          ["clipRule", "clip-rule"],
          ["colorInterpolation", "color-interpolation"],
          ["colorInterpolationFilters", "color-interpolation-filters"],
          ["colorProfile", "color-profile"],
          ["colorRendering", "color-rendering"],
          ["dominantBaseline", "dominant-baseline"],
          ["enableBackground", "enable-background"],
          ["fillOpacity", "fill-opacity"],
          ["fillRule", "fill-rule"],
          ["floodColor", "flood-color"],
          ["floodOpacity", "flood-opacity"],
          ["fontFamily", "font-family"],
          ["fontSize", "font-size"],
          ["fontSizeAdjust", "font-size-adjust"],
          ["fontStretch", "font-stretch"],
          ["fontStyle", "font-style"],
          ["fontVariant", "font-variant"],
          ["fontWeight", "font-weight"],
          ["glyphName", "glyph-name"],
          ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
          ["glyphOrientationVertical", "glyph-orientation-vertical"],
          ["horizAdvX", "horiz-adv-x"],
          ["horizOriginX", "horiz-origin-x"],
          ["imageRendering", "image-rendering"],
          ["letterSpacing", "letter-spacing"],
          ["lightingColor", "lighting-color"],
          ["markerEnd", "marker-end"],
          ["markerMid", "marker-mid"],
          ["markerStart", "marker-start"],
          ["overlinePosition", "overline-position"],
          ["overlineThickness", "overline-thickness"],
          ["paintOrder", "paint-order"],
          ["panose-1", "panose-1"],
          ["pointerEvents", "pointer-events"],
          ["renderingIntent", "rendering-intent"],
          ["shapeRendering", "shape-rendering"],
          ["stopColor", "stop-color"],
          ["stopOpacity", "stop-opacity"],
          ["strikethroughPosition", "strikethrough-position"],
          ["strikethroughThickness", "strikethrough-thickness"],
          ["strokeDasharray", "stroke-dasharray"],
          ["strokeDashoffset", "stroke-dashoffset"],
          ["strokeLinecap", "stroke-linecap"],
          ["strokeLinejoin", "stroke-linejoin"],
          ["strokeMiterlimit", "stroke-miterlimit"],
          ["strokeOpacity", "stroke-opacity"],
          ["strokeWidth", "stroke-width"],
          ["textAnchor", "text-anchor"],
          ["textDecoration", "text-decoration"],
          ["textRendering", "text-rendering"],
          ["transformOrigin", "transform-origin"],
          ["underlinePosition", "underline-position"],
          ["underlineThickness", "underline-thickness"],
          ["unicodeBidi", "unicode-bidi"],
          ["unicodeRange", "unicode-range"],
          ["unitsPerEm", "units-per-em"],
          ["vAlphabetic", "v-alphabetic"],
          ["vHanging", "v-hanging"],
          ["vIdeographic", "v-ideographic"],
          ["vMathematical", "v-mathematical"],
          ["vectorEffect", "vector-effect"],
          ["vertAdvY", "vert-adv-y"],
          ["vertOriginX", "vert-origin-x"],
          ["vertOriginY", "vert-origin-y"],
          ["wordSpacing", "word-spacing"],
          ["writingMode", "writing-mode"],
          ["xmlnsXlink", "xmlns:xlink"],
          ["xHeight", "x-height"]
        ]), possibleStandardNames = {
          accept: "accept",
          acceptcharset: "acceptCharset",
          "accept-charset": "acceptCharset",
          accesskey: "accessKey",
          action: "action",
          allowfullscreen: "allowFullScreen",
          alt: "alt",
          as: "as",
          async: "async",
          autocapitalize: "autoCapitalize",
          autocomplete: "autoComplete",
          autocorrect: "autoCorrect",
          autofocus: "autoFocus",
          autoplay: "autoPlay",
          autosave: "autoSave",
          capture: "capture",
          cellpadding: "cellPadding",
          cellspacing: "cellSpacing",
          challenge: "challenge",
          charset: "charSet",
          checked: "checked",
          children: "children",
          cite: "cite",
          class: "className",
          classid: "classID",
          classname: "className",
          cols: "cols",
          colspan: "colSpan",
          content: "content",
          contenteditable: "contentEditable",
          contextmenu: "contextMenu",
          controls: "controls",
          controlslist: "controlsList",
          coords: "coords",
          crossorigin: "crossOrigin",
          dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
          data: "data",
          datetime: "dateTime",
          default: "default",
          defaultchecked: "defaultChecked",
          defaultvalue: "defaultValue",
          defer: "defer",
          dir: "dir",
          disabled: "disabled",
          disablepictureinpicture: "disablePictureInPicture",
          disableremoteplayback: "disableRemotePlayback",
          download: "download",
          draggable: "draggable",
          enctype: "encType",
          enterkeyhint: "enterKeyHint",
          fetchpriority: "fetchPriority",
          for: "htmlFor",
          form: "form",
          formmethod: "formMethod",
          formaction: "formAction",
          formenctype: "formEncType",
          formnovalidate: "formNoValidate",
          formtarget: "formTarget",
          frameborder: "frameBorder",
          headers: "headers",
          height: "height",
          hidden: "hidden",
          high: "high",
          href: "href",
          hreflang: "hrefLang",
          htmlfor: "htmlFor",
          httpequiv: "httpEquiv",
          "http-equiv": "httpEquiv",
          icon: "icon",
          id: "id",
          imagesizes: "imageSizes",
          imagesrcset: "imageSrcSet",
          inert: "inert",
          innerhtml: "innerHTML",
          inputmode: "inputMode",
          integrity: "integrity",
          is: "is",
          itemid: "itemID",
          itemprop: "itemProp",
          itemref: "itemRef",
          itemscope: "itemScope",
          itemtype: "itemType",
          keyparams: "keyParams",
          keytype: "keyType",
          kind: "kind",
          label: "label",
          lang: "lang",
          list: "list",
          loop: "loop",
          low: "low",
          manifest: "manifest",
          marginwidth: "marginWidth",
          marginheight: "marginHeight",
          max: "max",
          maxlength: "maxLength",
          media: "media",
          mediagroup: "mediaGroup",
          method: "method",
          min: "min",
          minlength: "minLength",
          multiple: "multiple",
          muted: "muted",
          name: "name",
          nomodule: "noModule",
          nonce: "nonce",
          novalidate: "noValidate",
          open: "open",
          optimum: "optimum",
          pattern: "pattern",
          placeholder: "placeholder",
          playsinline: "playsInline",
          poster: "poster",
          preload: "preload",
          profile: "profile",
          radiogroup: "radioGroup",
          readonly: "readOnly",
          referrerpolicy: "referrerPolicy",
          rel: "rel",
          required: "required",
          reversed: "reversed",
          role: "role",
          rows: "rows",
          rowspan: "rowSpan",
          sandbox: "sandbox",
          scope: "scope",
          scoped: "scoped",
          scrolling: "scrolling",
          seamless: "seamless",
          selected: "selected",
          shape: "shape",
          size: "size",
          sizes: "sizes",
          span: "span",
          spellcheck: "spellCheck",
          src: "src",
          srcdoc: "srcDoc",
          srclang: "srcLang",
          srcset: "srcSet",
          start: "start",
          step: "step",
          style: "style",
          summary: "summary",
          tabindex: "tabIndex",
          target: "target",
          title: "title",
          type: "type",
          usemap: "useMap",
          value: "value",
          width: "width",
          wmode: "wmode",
          wrap: "wrap",
          about: "about",
          accentheight: "accentHeight",
          "accent-height": "accentHeight",
          accumulate: "accumulate",
          additive: "additive",
          alignmentbaseline: "alignmentBaseline",
          "alignment-baseline": "alignmentBaseline",
          allowreorder: "allowReorder",
          alphabetic: "alphabetic",
          amplitude: "amplitude",
          arabicform: "arabicForm",
          "arabic-form": "arabicForm",
          ascent: "ascent",
          attributename: "attributeName",
          attributetype: "attributeType",
          autoreverse: "autoReverse",
          azimuth: "azimuth",
          basefrequency: "baseFrequency",
          baselineshift: "baselineShift",
          "baseline-shift": "baselineShift",
          baseprofile: "baseProfile",
          bbox: "bbox",
          begin: "begin",
          bias: "bias",
          by: "by",
          calcmode: "calcMode",
          capheight: "capHeight",
          "cap-height": "capHeight",
          clip: "clip",
          clippath: "clipPath",
          "clip-path": "clipPath",
          clippathunits: "clipPathUnits",
          cliprule: "clipRule",
          "clip-rule": "clipRule",
          color: "color",
          colorinterpolation: "colorInterpolation",
          "color-interpolation": "colorInterpolation",
          colorinterpolationfilters: "colorInterpolationFilters",
          "color-interpolation-filters": "colorInterpolationFilters",
          colorprofile: "colorProfile",
          "color-profile": "colorProfile",
          colorrendering: "colorRendering",
          "color-rendering": "colorRendering",
          contentscripttype: "contentScriptType",
          contentstyletype: "contentStyleType",
          cursor: "cursor",
          cx: "cx",
          cy: "cy",
          d: "d",
          datatype: "datatype",
          decelerate: "decelerate",
          descent: "descent",
          diffuseconstant: "diffuseConstant",
          direction: "direction",
          display: "display",
          divisor: "divisor",
          dominantbaseline: "dominantBaseline",
          "dominant-baseline": "dominantBaseline",
          dur: "dur",
          dx: "dx",
          dy: "dy",
          edgemode: "edgeMode",
          elevation: "elevation",
          enablebackground: "enableBackground",
          "enable-background": "enableBackground",
          end: "end",
          exponent: "exponent",
          externalresourcesrequired: "externalResourcesRequired",
          fill: "fill",
          fillopacity: "fillOpacity",
          "fill-opacity": "fillOpacity",
          fillrule: "fillRule",
          "fill-rule": "fillRule",
          filter: "filter",
          filterres: "filterRes",
          filterunits: "filterUnits",
          floodopacity: "floodOpacity",
          "flood-opacity": "floodOpacity",
          floodcolor: "floodColor",
          "flood-color": "floodColor",
          focusable: "focusable",
          fontfamily: "fontFamily",
          "font-family": "fontFamily",
          fontsize: "fontSize",
          "font-size": "fontSize",
          fontsizeadjust: "fontSizeAdjust",
          "font-size-adjust": "fontSizeAdjust",
          fontstretch: "fontStretch",
          "font-stretch": "fontStretch",
          fontstyle: "fontStyle",
          "font-style": "fontStyle",
          fontvariant: "fontVariant",
          "font-variant": "fontVariant",
          fontweight: "fontWeight",
          "font-weight": "fontWeight",
          format: "format",
          from: "from",
          fx: "fx",
          fy: "fy",
          g1: "g1",
          g2: "g2",
          glyphname: "glyphName",
          "glyph-name": "glyphName",
          glyphorientationhorizontal: "glyphOrientationHorizontal",
          "glyph-orientation-horizontal": "glyphOrientationHorizontal",
          glyphorientationvertical: "glyphOrientationVertical",
          "glyph-orientation-vertical": "glyphOrientationVertical",
          glyphref: "glyphRef",
          gradienttransform: "gradientTransform",
          gradientunits: "gradientUnits",
          hanging: "hanging",
          horizadvx: "horizAdvX",
          "horiz-adv-x": "horizAdvX",
          horizoriginx: "horizOriginX",
          "horiz-origin-x": "horizOriginX",
          ideographic: "ideographic",
          imagerendering: "imageRendering",
          "image-rendering": "imageRendering",
          in2: "in2",
          in: "in",
          inlist: "inlist",
          intercept: "intercept",
          k1: "k1",
          k2: "k2",
          k3: "k3",
          k4: "k4",
          k: "k",
          kernelmatrix: "kernelMatrix",
          kernelunitlength: "kernelUnitLength",
          kerning: "kerning",
          keypoints: "keyPoints",
          keysplines: "keySplines",
          keytimes: "keyTimes",
          lengthadjust: "lengthAdjust",
          letterspacing: "letterSpacing",
          "letter-spacing": "letterSpacing",
          lightingcolor: "lightingColor",
          "lighting-color": "lightingColor",
          limitingconeangle: "limitingConeAngle",
          local: "local",
          markerend: "markerEnd",
          "marker-end": "markerEnd",
          markerheight: "markerHeight",
          markermid: "markerMid",
          "marker-mid": "markerMid",
          markerstart: "markerStart",
          "marker-start": "markerStart",
          markerunits: "markerUnits",
          markerwidth: "markerWidth",
          mask: "mask",
          maskcontentunits: "maskContentUnits",
          maskunits: "maskUnits",
          mathematical: "mathematical",
          mode: "mode",
          numoctaves: "numOctaves",
          offset: "offset",
          opacity: "opacity",
          operator: "operator",
          order: "order",
          orient: "orient",
          orientation: "orientation",
          origin: "origin",
          overflow: "overflow",
          overlineposition: "overlinePosition",
          "overline-position": "overlinePosition",
          overlinethickness: "overlineThickness",
          "overline-thickness": "overlineThickness",
          paintorder: "paintOrder",
          "paint-order": "paintOrder",
          panose1: "panose1",
          "panose-1": "panose1",
          pathlength: "pathLength",
          patterncontentunits: "patternContentUnits",
          patterntransform: "patternTransform",
          patternunits: "patternUnits",
          pointerevents: "pointerEvents",
          "pointer-events": "pointerEvents",
          points: "points",
          pointsatx: "pointsAtX",
          pointsaty: "pointsAtY",
          pointsatz: "pointsAtZ",
          popover: "popover",
          popovertarget: "popoverTarget",
          popovertargetaction: "popoverTargetAction",
          prefix: "prefix",
          preservealpha: "preserveAlpha",
          preserveaspectratio: "preserveAspectRatio",
          primitiveunits: "primitiveUnits",
          property: "property",
          r: "r",
          radius: "radius",
          refx: "refX",
          refy: "refY",
          renderingintent: "renderingIntent",
          "rendering-intent": "renderingIntent",
          repeatcount: "repeatCount",
          repeatdur: "repeatDur",
          requiredextensions: "requiredExtensions",
          requiredfeatures: "requiredFeatures",
          resource: "resource",
          restart: "restart",
          result: "result",
          results: "results",
          rotate: "rotate",
          rx: "rx",
          ry: "ry",
          scale: "scale",
          security: "security",
          seed: "seed",
          shaperendering: "shapeRendering",
          "shape-rendering": "shapeRendering",
          slope: "slope",
          spacing: "spacing",
          specularconstant: "specularConstant",
          specularexponent: "specularExponent",
          speed: "speed",
          spreadmethod: "spreadMethod",
          startoffset: "startOffset",
          stddeviation: "stdDeviation",
          stemh: "stemh",
          stemv: "stemv",
          stitchtiles: "stitchTiles",
          stopcolor: "stopColor",
          "stop-color": "stopColor",
          stopopacity: "stopOpacity",
          "stop-opacity": "stopOpacity",
          strikethroughposition: "strikethroughPosition",
          "strikethrough-position": "strikethroughPosition",
          strikethroughthickness: "strikethroughThickness",
          "strikethrough-thickness": "strikethroughThickness",
          string: "string",
          stroke: "stroke",
          strokedasharray: "strokeDasharray",
          "stroke-dasharray": "strokeDasharray",
          strokedashoffset: "strokeDashoffset",
          "stroke-dashoffset": "strokeDashoffset",
          strokelinecap: "strokeLinecap",
          "stroke-linecap": "strokeLinecap",
          strokelinejoin: "strokeLinejoin",
          "stroke-linejoin": "strokeLinejoin",
          strokemiterlimit: "strokeMiterlimit",
          "stroke-miterlimit": "strokeMiterlimit",
          strokewidth: "strokeWidth",
          "stroke-width": "strokeWidth",
          strokeopacity: "strokeOpacity",
          "stroke-opacity": "strokeOpacity",
          suppresscontenteditablewarning: "suppressContentEditableWarning",
          suppresshydrationwarning: "suppressHydrationWarning",
          surfacescale: "surfaceScale",
          systemlanguage: "systemLanguage",
          tablevalues: "tableValues",
          targetx: "targetX",
          targety: "targetY",
          textanchor: "textAnchor",
          "text-anchor": "textAnchor",
          textdecoration: "textDecoration",
          "text-decoration": "textDecoration",
          textlength: "textLength",
          textrendering: "textRendering",
          "text-rendering": "textRendering",
          to: "to",
          transform: "transform",
          transformorigin: "transformOrigin",
          "transform-origin": "transformOrigin",
          typeof: "typeof",
          u1: "u1",
          u2: "u2",
          underlineposition: "underlinePosition",
          "underline-position": "underlinePosition",
          underlinethickness: "underlineThickness",
          "underline-thickness": "underlineThickness",
          unicode: "unicode",
          unicodebidi: "unicodeBidi",
          "unicode-bidi": "unicodeBidi",
          unicoderange: "unicodeRange",
          "unicode-range": "unicodeRange",
          unitsperem: "unitsPerEm",
          "units-per-em": "unitsPerEm",
          unselectable: "unselectable",
          valphabetic: "vAlphabetic",
          "v-alphabetic": "vAlphabetic",
          values: "values",
          vectoreffect: "vectorEffect",
          "vector-effect": "vectorEffect",
          version: "version",
          vertadvy: "vertAdvY",
          "vert-adv-y": "vertAdvY",
          vertoriginx: "vertOriginX",
          "vert-origin-x": "vertOriginX",
          vertoriginy: "vertOriginY",
          "vert-origin-y": "vertOriginY",
          vhanging: "vHanging",
          "v-hanging": "vHanging",
          videographic: "vIdeographic",
          "v-ideographic": "vIdeographic",
          viewbox: "viewBox",
          viewtarget: "viewTarget",
          visibility: "visibility",
          vmathematical: "vMathematical",
          "v-mathematical": "vMathematical",
          vocab: "vocab",
          widths: "widths",
          wordspacing: "wordSpacing",
          "word-spacing": "wordSpacing",
          writingmode: "writingMode",
          "writing-mode": "writingMode",
          x1: "x1",
          x2: "x2",
          x: "x",
          xchannelselector: "xChannelSelector",
          xheight: "xHeight",
          "x-height": "xHeight",
          xlinkactuate: "xlinkActuate",
          "xlink:actuate": "xlinkActuate",
          xlinkarcrole: "xlinkArcrole",
          "xlink:arcrole": "xlinkArcrole",
          xlinkhref: "xlinkHref",
          "xlink:href": "xlinkHref",
          xlinkrole: "xlinkRole",
          "xlink:role": "xlinkRole",
          xlinkshow: "xlinkShow",
          "xlink:show": "xlinkShow",
          xlinktitle: "xlinkTitle",
          "xlink:title": "xlinkTitle",
          xlinktype: "xlinkType",
          "xlink:type": "xlinkType",
          xmlbase: "xmlBase",
          "xml:base": "xmlBase",
          xmllang: "xmlLang",
          "xml:lang": "xmlLang",
          xmlns: "xmlns",
          "xml:space": "xmlSpace",
          xmlnsxlink: "xmlnsXlink",
          "xmlns:xlink": "xmlnsXlink",
          xmlspace: "xmlSpace",
          y1: "y1",
          y2: "y2",
          y: "y",
          ychannelselector: "yChannelSelector",
          z: "z",
          zoomandpan: "zoomAndPan"
        }, ariaProperties = {
          "aria-current": 0,
          "aria-description": 0,
          "aria-details": 0,
          "aria-disabled": 0,
          "aria-hidden": 0,
          "aria-invalid": 0,
          "aria-keyshortcuts": 0,
          "aria-label": 0,
          "aria-roledescription": 0,
          "aria-autocomplete": 0,
          "aria-checked": 0,
          "aria-expanded": 0,
          "aria-haspopup": 0,
          "aria-level": 0,
          "aria-modal": 0,
          "aria-multiline": 0,
          "aria-multiselectable": 0,
          "aria-orientation": 0,
          "aria-placeholder": 0,
          "aria-pressed": 0,
          "aria-readonly": 0,
          "aria-required": 0,
          "aria-selected": 0,
          "aria-sort": 0,
          "aria-valuemax": 0,
          "aria-valuemin": 0,
          "aria-valuenow": 0,
          "aria-valuetext": 0,
          "aria-atomic": 0,
          "aria-busy": 0,
          "aria-live": 0,
          "aria-relevant": 0,
          "aria-dropeffect": 0,
          "aria-grabbed": 0,
          "aria-activedescendant": 0,
          "aria-colcount": 0,
          "aria-colindex": 0,
          "aria-colspan": 0,
          "aria-controls": 0,
          "aria-describedby": 0,
          "aria-errormessage": 0,
          "aria-flowto": 0,
          "aria-labelledby": 0,
          "aria-owns": 0,
          "aria-posinset": 0,
          "aria-rowcount": 0,
          "aria-rowindex": 0,
          "aria-rowspan": 0,
          "aria-setsize": 0,
          "aria-braillelabel": 0,
          "aria-brailleroledescription": 0,
          "aria-colindextext": 0,
          "aria-rowindextext": 0
        }, warnedProperties$1 = {}, rARIA$1 = RegExp(
          "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), rARIACamel$1 = RegExp(
          "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), didWarnValueNull = false, warnedProperties = {}, EVENT_NAME_REGEX = /^on./, INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/, rARIA = RegExp(
          "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), rARIACamel = RegExp(
          "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i, currentReplayingEvent = null, restoreTarget = null, restoreQueue = null, isInsideEventHandler = false, canUseDOM = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), passiveBrowserEventsSupported = false;
        if (canUseDOM)
          try {
            var options$jscomp$0 = {};
            Object.defineProperty(options$jscomp$0, "passive", {
              get: function() {
                passiveBrowserEventsSupported = true;
              }
            });
            window.addEventListener("test", options$jscomp$0, options$jscomp$0);
            window.removeEventListener("test", options$jscomp$0, options$jscomp$0);
          } catch (e2) {
            passiveBrowserEventsSupported = false;
          }
        var root = null, startText = null, fallbackText = null, EventInterface = {
          eventPhase: 0,
          bubbles: 0,
          cancelable: 0,
          timeStamp: function(event) {
            return event.timeStamp || Date.now();
          },
          defaultPrevented: 0,
          isTrusted: 0
        }, SyntheticEvent = createSyntheticEvent(EventInterface), UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 }), SyntheticUIEvent = createSyntheticEvent(UIEventInterface), lastMovementX, lastMovementY, lastMouseEvent, MouseEventInterface = assign({}, UIEventInterface, {
          screenX: 0,
          screenY: 0,
          clientX: 0,
          clientY: 0,
          pageX: 0,
          pageY: 0,
          ctrlKey: 0,
          shiftKey: 0,
          altKey: 0,
          metaKey: 0,
          getModifierState: getEventModifierState,
          button: 0,
          buttons: 0,
          relatedTarget: function(event) {
            return void 0 === event.relatedTarget ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
          },
          movementX: function(event) {
            if ("movementX" in event) return event.movementX;
            event !== lastMouseEvent && (lastMouseEvent && "mousemove" === event.type ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = event);
            return lastMovementX;
          },
          movementY: function(event) {
            return "movementY" in event ? event.movementY : lastMovementY;
          }
        }), SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface), DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 }), SyntheticDragEvent = createSyntheticEvent(DragEventInterface), FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 }), SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface), AnimationEventInterface = assign({}, EventInterface, {
          animationName: 0,
          elapsedTime: 0,
          pseudoElement: 0
        }), SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface), ClipboardEventInterface = assign({}, EventInterface, {
          clipboardData: function(event) {
            return "clipboardData" in event ? event.clipboardData : window.clipboardData;
          }
        }), SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface), CompositionEventInterface = assign({}, EventInterface, { data: 0 }), SyntheticCompositionEvent = createSyntheticEvent(
          CompositionEventInterface
        ), SyntheticInputEvent = SyntheticCompositionEvent, normalizeKey = {
          Esc: "Escape",
          Spacebar: " ",
          Left: "ArrowLeft",
          Up: "ArrowUp",
          Right: "ArrowRight",
          Down: "ArrowDown",
          Del: "Delete",
          Win: "OS",
          Menu: "ContextMenu",
          Apps: "ContextMenu",
          Scroll: "ScrollLock",
          MozPrintableKey: "Unidentified"
        }, translateToKey = {
          8: "Backspace",
          9: "Tab",
          12: "Clear",
          13: "Enter",
          16: "Shift",
          17: "Control",
          18: "Alt",
          19: "Pause",
          20: "CapsLock",
          27: "Escape",
          32: " ",
          33: "PageUp",
          34: "PageDown",
          35: "End",
          36: "Home",
          37: "ArrowLeft",
          38: "ArrowUp",
          39: "ArrowRight",
          40: "ArrowDown",
          45: "Insert",
          46: "Delete",
          112: "F1",
          113: "F2",
          114: "F3",
          115: "F4",
          116: "F5",
          117: "F6",
          118: "F7",
          119: "F8",
          120: "F9",
          121: "F10",
          122: "F11",
          123: "F12",
          144: "NumLock",
          145: "ScrollLock",
          224: "Meta"
        }, modifierKeyToProp = {
          Alt: "altKey",
          Control: "ctrlKey",
          Meta: "metaKey",
          Shift: "shiftKey"
        }, KeyboardEventInterface = assign({}, UIEventInterface, {
          key: function(nativeEvent) {
            if (nativeEvent.key) {
              var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
              if ("Unidentified" !== key) return key;
            }
            return "keypress" === nativeEvent.type ? (nativeEvent = getEventCharCode(nativeEvent), 13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent)) : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
          },
          code: 0,
          location: 0,
          ctrlKey: 0,
          shiftKey: 0,
          altKey: 0,
          metaKey: 0,
          repeat: 0,
          locale: 0,
          getModifierState: getEventModifierState,
          charCode: function(event) {
            return "keypress" === event.type ? getEventCharCode(event) : 0;
          },
          keyCode: function(event) {
            return "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
          },
          which: function(event) {
            return "keypress" === event.type ? getEventCharCode(event) : "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
          }
        }), SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface), PointerEventInterface = assign({}, MouseEventInterface, {
          pointerId: 0,
          width: 0,
          height: 0,
          pressure: 0,
          tangentialPressure: 0,
          tiltX: 0,
          tiltY: 0,
          twist: 0,
          pointerType: 0,
          isPrimary: 0
        }), SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface), TouchEventInterface = assign({}, UIEventInterface, {
          touches: 0,
          targetTouches: 0,
          changedTouches: 0,
          altKey: 0,
          metaKey: 0,
          ctrlKey: 0,
          shiftKey: 0,
          getModifierState: getEventModifierState
        }), SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface), TransitionEventInterface = assign({}, EventInterface, {
          propertyName: 0,
          elapsedTime: 0,
          pseudoElement: 0
        }), SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface), WheelEventInterface = assign({}, MouseEventInterface, {
          deltaX: function(event) {
            return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
          },
          deltaY: function(event) {
            return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
          },
          deltaZ: 0,
          deltaMode: 0
        }), SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface), ToggleEventInterface = assign({}, EventInterface, {
          newState: 0,
          oldState: 0
        }), SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface), END_KEYCODES = [9, 13, 27, 32], START_KEYCODE = 229, canUseCompositionEvent = canUseDOM && "CompositionEvent" in window, documentMode = null;
        canUseDOM && "documentMode" in document && (documentMode = document.documentMode);
        var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode, useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode), SPACEBAR_CODE = 32, SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE), hasSpaceKeypress = false, isComposing = false, supportedInputTypes = {
          color: true,
          date: true,
          datetime: true,
          "datetime-local": true,
          email: true,
          month: true,
          number: true,
          password: true,
          range: true,
          search: true,
          tel: true,
          text: true,
          time: true,
          url: true,
          week: true
        }, activeElement$1 = null, activeElementInst$1 = null, isInputEventSupported = false;
        canUseDOM && (isInputEventSupported = isEventSupported("input") && (!document.documentMode || 9 < document.documentMode));
        var objectIs = "function" === typeof Object.is ? Object.is : is, skipSelectionChangeEvent = canUseDOM && "documentMode" in document && 11 >= document.documentMode, activeElement = null, activeElementInst = null, lastSelection = null, mouseDown = false, vendorPrefixes = {
          animationend: makePrefixMap("Animation", "AnimationEnd"),
          animationiteration: makePrefixMap("Animation", "AnimationIteration"),
          animationstart: makePrefixMap("Animation", "AnimationStart"),
          transitionrun: makePrefixMap("Transition", "TransitionRun"),
          transitionstart: makePrefixMap("Transition", "TransitionStart"),
          transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
          transitionend: makePrefixMap("Transition", "TransitionEnd")
        }, prefixedEventNames = {}, style = {};
        canUseDOM && (style = document.createElement("div").style, "AnimationEvent" in window || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), "TransitionEvent" in window || delete vendorPrefixes.transitionend.transition);
        var ANIMATION_END = getVendorPrefixedEventName("animationend"), ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"), ANIMATION_START = getVendorPrefixedEventName("animationstart"), TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"), TRANSITION_START = getVendorPrefixedEventName("transitionstart"), TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"), TRANSITION_END = getVendorPrefixedEventName("transitionend"), topLevelEventsToReactNames = /* @__PURE__ */ new Map(), simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
          " "
        );
        simpleEventPluginEvents.push("scrollEnd");
        var lastResetTime = 0;
        if ("object" === typeof performance && "function" === typeof performance.now) {
          var localPerformance = performance;
          var getCurrentTime = function() {
            return localPerformance.now();
          };
        } else {
          var localDate = Date;
          getCurrentTime = function() {
            return localDate.now();
          };
        }
        var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
          if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
            var event = new window.ErrorEvent("error", {
              bubbles: true,
              cancelable: true,
              message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
              error
            });
            if (!window.dispatchEvent(event)) return;
          } else if ("object" === typeof process && "function" === typeof process.emit) {
            process.emit("uncaughtException", error);
            return;
          }
          console.error(error);
        }, OMITTED_PROP_ERROR = "This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects.", EMPTY_ARRAY = 0, COMPLEX_ARRAY = 1, PRIMITIVE_ARRAY = 2, ENTRIES_ARRAY = 3, REMOVED = "\u2013\xA0", ADDED = "+\xA0", UNCHANGED = "\u2007\xA0", supportsUserTiming = "undefined" !== typeof console && "function" === typeof console.timeStamp && "undefined" !== typeof performance && "function" === typeof performance.measure, COMPONENTS_TRACK = "Components \u269B", LANES_TRACK_GROUP = "Scheduler \u269B", currentTrack = "Blocking", alreadyWarnedForDeepEquality = false, reusableComponentDevToolDetails = {
          color: "primary",
          properties: null,
          tooltipText: "",
          track: COMPONENTS_TRACK
        }, reusableComponentOptions = {
          start: -0,
          end: -0,
          detail: { devtools: reusableComponentDevToolDetails }
        }, resuableChangedPropsEntry = ["Changed Props", ""], DEEP_EQUALITY_WARNING = "This component received deeply equal props. It might benefit from useMemo or the React Compiler in its owner.", reusableDeeplyEqualPropsEntry = ["Changed Props", DEEP_EQUALITY_WARNING], OffscreenVisible = 1, OffscreenPassiveEffectsConnected = 2, concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0, emptyContextObject = {};
        Object.freeze(emptyContextObject);
        var resolveFamily = null, failedBoundaries = null, NoMode = 0, ConcurrentMode = 1, ProfileMode = 2, StrictLegacyMode = 8, StrictEffectsMode = 16, SuspenseyImagesMode = 32;
        var hasBadMapPolyfill = false;
        try {
          var nonExtensibleObject = Object.preventExtensions({});
          /* @__PURE__ */ new Map([[nonExtensibleObject, null]]);
          /* @__PURE__ */ new Set([nonExtensibleObject]);
        } catch (e$3) {
          hasBadMapPolyfill = true;
        }
        var CapturedStacks = /* @__PURE__ */ new WeakMap(), forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = "", hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = false, didSuspendOrErrorDEV = false, hydrationDiffRootDEV = null, hydrationErrors = null, rootOrSingletonContext = false, HydrationMismatchException = Error(
          "Hydration Mismatch Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
        ), valueCursor = createCursor(null);
        var rendererCursorDEV = createCursor(null);
        var rendererSigil = {};
        var currentlyRenderingFiber$1 = null, lastContextDependency = null, isDisallowedContextReadInDEV = false, AbortControllerLocal = "undefined" !== typeof AbortController ? AbortController : function() {
          var listeners = [], signal = this.signal = {
            aborted: false,
            addEventListener: function(type, listener) {
              listeners.push(listener);
            }
          };
          this.abort = function() {
            signal.aborted = true;
            listeners.forEach(function(listener) {
              return listener();
            });
          };
        }, scheduleCallback$2 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority, CacheContext = {
          $$typeof: REACT_CONTEXT_TYPE,
          Consumer: null,
          Provider: null,
          _currentValue: null,
          _currentValue2: null,
          _threadCount: 0,
          _currentRenderer: null,
          _currentRenderer2: null
        }, now = Scheduler.unstable_now, createTask = console.createTask ? console.createTask : function() {
          return null;
        }, SPAWNED_UPDATE = 1, PINGED_UPDATE = 2, renderStartTime = -0, commitStartTime = -0, commitEndTime = -0, commitErrors = null, profilerStartTime = -1.1, profilerEffectDuration = -0, componentEffectDuration = -0, componentEffectStartTime = -1.1, componentEffectEndTime = -1.1, componentEffectErrors = null, componentEffectSpawnedUpdate = false, blockingClampTime = -0, blockingUpdateTime = -1.1, blockingUpdateTask = null, blockingUpdateType = 0, blockingUpdateMethodName = null, blockingUpdateComponentName = null, blockingEventTime = -1.1, blockingEventType = null, blockingEventRepeatTime = -1.1, blockingSuspendedTime = -1.1, transitionClampTime = -0, transitionStartTime = -1.1, transitionUpdateTime = -1.1, transitionUpdateType = 0, transitionUpdateTask = null, transitionUpdateMethodName = null, transitionUpdateComponentName = null, transitionEventTime = -1.1, transitionEventType = null, transitionEventRepeatTime = -1.1, transitionSuspendedTime = -1.1, retryClampTime = -0, idleClampTime = -0, animatingLanes = 0, animatingTask = null, yieldReason = 0, yieldStartTime = -1.1, currentUpdateIsNested = false, nestedUpdateScheduled = false, currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null, prevOnStartTransitionFinish = ReactSharedInternals.S;
        ReactSharedInternals.S = function(transition, returnValue) {
          globalMostRecentTransitionTime = now$1();
          if ("object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then) {
            if (0 > transitionStartTime && 0 > transitionUpdateTime) {
              transitionStartTime = now();
              var newEventTime = resolveEventTimeStamp(), newEventType = resolveEventType();
              if (newEventTime !== transitionEventRepeatTime || newEventType !== transitionEventType)
                transitionEventRepeatTime = -1.1;
              transitionEventTime = newEventTime;
              transitionEventType = newEventType;
            }
            entangleAsyncAction(transition, returnValue);
          }
          null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);
        };
        var resumedCache = createCursor(null), ReactStrictModeWarnings = {
          recordUnsafeLifecycleWarnings: function() {
          },
          flushPendingUnsafeLifecycleWarnings: function() {
          },
          recordLegacyContextWarning: function() {
          },
          flushLegacyContextWarning: function() {
          },
          discardPendingWarnings: function() {
          }
        }, pendingComponentWillMountWarnings = [], pendingUNSAFE_ComponentWillMountWarnings = [], pendingComponentWillReceivePropsWarnings = [], pendingUNSAFE_ComponentWillReceivePropsWarnings = [], pendingComponentWillUpdateWarnings = [], pendingUNSAFE_ComponentWillUpdateWarnings = [], didWarnAboutUnsafeLifecycles = /* @__PURE__ */ new Set();
        ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {
          didWarnAboutUnsafeLifecycles.has(fiber.type) || ("function" === typeof instance.componentWillMount && true !== instance.componentWillMount.__suppressDeprecationWarning && pendingComponentWillMountWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillMount && pendingUNSAFE_ComponentWillMountWarnings.push(fiber), "function" === typeof instance.componentWillReceiveProps && true !== instance.componentWillReceiveProps.__suppressDeprecationWarning && pendingComponentWillReceivePropsWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillReceiveProps && pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber), "function" === typeof instance.componentWillUpdate && true !== instance.componentWillUpdate.__suppressDeprecationWarning && pendingComponentWillUpdateWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillUpdate && pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber));
        };
        ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
          var componentWillMountUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingComponentWillMountWarnings.length && (pendingComponentWillMountWarnings.forEach(function(fiber) {
            componentWillMountUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingComponentWillMountWarnings = []);
          var UNSAFE_componentWillMountUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingUNSAFE_ComponentWillMountWarnings.length && (pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
            UNSAFE_componentWillMountUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingUNSAFE_ComponentWillMountWarnings = []);
          var componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingComponentWillReceivePropsWarnings.length && (pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
            componentWillReceivePropsUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingComponentWillReceivePropsWarnings = []);
          var UNSAFE_componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingUNSAFE_ComponentWillReceivePropsWarnings.length && (pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(
            function(fiber) {
              UNSAFE_componentWillReceivePropsUniqueNames.add(
                getComponentNameFromFiber(fiber) || "Component"
              );
              didWarnAboutUnsafeLifecycles.add(fiber.type);
            }
          ), pendingUNSAFE_ComponentWillReceivePropsWarnings = []);
          var componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingComponentWillUpdateWarnings.length && (pendingComponentWillUpdateWarnings.forEach(function(fiber) {
            componentWillUpdateUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingComponentWillUpdateWarnings = []);
          var UNSAFE_componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingUNSAFE_ComponentWillUpdateWarnings.length && (pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
            UNSAFE_componentWillUpdateUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingUNSAFE_ComponentWillUpdateWarnings = []);
          if (0 < UNSAFE_componentWillMountUniqueNames.size) {
            var sortedNames = setToSortedString(
              UNSAFE_componentWillMountUniqueNames
            );
            console.error(
              "Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s",
              sortedNames
            );
          }
          0 < UNSAFE_componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(
            UNSAFE_componentWillReceivePropsUniqueNames
          ), console.error(
            "Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n\nPlease update the following components: %s",
            sortedNames
          ));
          0 < UNSAFE_componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(
            UNSAFE_componentWillUpdateUniqueNames
          ), console.error(
            "Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s",
            sortedNames
          ));
          0 < componentWillMountUniqueNames.size && (sortedNames = setToSortedString(componentWillMountUniqueNames), console.warn(
            "componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
            sortedNames
          ));
          0 < componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(
            componentWillReceivePropsUniqueNames
          ), console.warn(
            "componentWillReceiveProps has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
            sortedNames
          ));
          0 < componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(componentWillUpdateUniqueNames), console.warn(
            "componentWillUpdate has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
            sortedNames
          ));
        };
        var pendingLegacyContextWarning = /* @__PURE__ */ new Map(), didWarnAboutLegacyContext = /* @__PURE__ */ new Set();
        ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {
          var strictRoot = null;
          for (var node = fiber; null !== node; )
            node.mode & StrictLegacyMode && (strictRoot = node), node = node.return;
          null === strictRoot ? console.error(
            "Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue."
          ) : !didWarnAboutLegacyContext.has(fiber.type) && (node = pendingLegacyContextWarning.get(strictRoot), null != fiber.type.contextTypes || null != fiber.type.childContextTypes || null !== instance && "function" === typeof instance.getChildContext) && (void 0 === node && (node = [], pendingLegacyContextWarning.set(strictRoot, node)), node.push(fiber));
        };
        ReactStrictModeWarnings.flushLegacyContextWarning = function() {
          pendingLegacyContextWarning.forEach(function(fiberArray) {
            if (0 !== fiberArray.length) {
              var firstFiber = fiberArray[0], uniqueNames = /* @__PURE__ */ new Set();
              fiberArray.forEach(function(fiber) {
                uniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutLegacyContext.add(fiber.type);
              });
              var sortedNames = setToSortedString(uniqueNames);
              runWithFiberInDEV(firstFiber, function() {
                console.error(
                  "Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://react.dev/link/legacy-context",
                  sortedNames
                );
              });
            }
          });
        };
        ReactStrictModeWarnings.discardPendingWarnings = function() {
          pendingComponentWillMountWarnings = [];
          pendingUNSAFE_ComponentWillMountWarnings = [];
          pendingComponentWillReceivePropsWarnings = [];
          pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
          pendingComponentWillUpdateWarnings = [];
          pendingUNSAFE_ComponentWillUpdateWarnings = [];
          pendingLegacyContextWarning = /* @__PURE__ */ new Map();
        };
        var callComponent = {
          react_stack_bottom_frame: function(Component, props, secondArg) {
            var wasRendering = isRendering;
            isRendering = true;
            try {
              return Component(props, secondArg);
            } finally {
              isRendering = wasRendering;
            }
          }
        }, callComponentInDEV = callComponent.react_stack_bottom_frame.bind(callComponent), callRender = {
          react_stack_bottom_frame: function(instance) {
            var wasRendering = isRendering;
            isRendering = true;
            try {
              return instance.render();
            } finally {
              isRendering = wasRendering;
            }
          }
        }, callRenderInDEV = callRender.react_stack_bottom_frame.bind(callRender), callComponentDidMount = {
          react_stack_bottom_frame: function(finishedWork, instance) {
            try {
              instance.componentDidMount();
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
        }, callComponentDidMountInDEV = callComponentDidMount.react_stack_bottom_frame.bind(
          callComponentDidMount
        ), callComponentDidUpdate = {
          react_stack_bottom_frame: function(finishedWork, instance, prevProps, prevState, snapshot) {
            try {
              instance.componentDidUpdate(prevProps, prevState, snapshot);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
        }, callComponentDidUpdateInDEV = callComponentDidUpdate.react_stack_bottom_frame.bind(
          callComponentDidUpdate
        ), callComponentDidCatch = {
          react_stack_bottom_frame: function(instance, errorInfo) {
            var stack = errorInfo.stack;
            instance.componentDidCatch(errorInfo.value, {
              componentStack: null !== stack ? stack : ""
            });
          }
        }, callComponentDidCatchInDEV = callComponentDidCatch.react_stack_bottom_frame.bind(
          callComponentDidCatch
        ), callComponentWillUnmount = {
          react_stack_bottom_frame: function(current2, nearestMountedAncestor, instance) {
            try {
              instance.componentWillUnmount();
            } catch (error) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error);
            }
          }
        }, callComponentWillUnmountInDEV = callComponentWillUnmount.react_stack_bottom_frame.bind(
          callComponentWillUnmount
        ), callCreate = {
          react_stack_bottom_frame: function(effect) {
            var create2 = effect.create;
            effect = effect.inst;
            create2 = create2();
            return effect.destroy = create2;
          }
        }, callCreateInDEV = callCreate.react_stack_bottom_frame.bind(callCreate), callDestroy = {
          react_stack_bottom_frame: function(current2, nearestMountedAncestor, destroy) {
            try {
              destroy();
            } catch (error) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error);
            }
          }
        }, callDestroyInDEV = callDestroy.react_stack_bottom_frame.bind(callDestroy), callLazyInit = {
          react_stack_bottom_frame: function(lazy) {
            var init = lazy._init;
            return init(lazy._payload);
          }
        }, callLazyInitInDEV = callLazyInit.react_stack_bottom_frame.bind(callLazyInit), SuspenseException = Error(
          "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."
        ), SuspenseyCommitException = Error(
          "Suspense Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
        ), SuspenseActionException = Error(
          "Suspense Exception: This is not a real error! It's an implementation detail of `useActionState` to interrupt the current render. You must either rethrow it immediately, or move the `useActionState` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary."
        ), noopSuspenseyCommitThenable = {
          then: function() {
            console.error(
              'Internal React error: A listener was unexpectedly attached to a "noop" thenable. This is a bug in React. Please file an issue.'
            );
          }
        }, suspendedThenable = null, needsToResetSuspendedThenableDEV = false, thenableState$1 = null, thenableIndexCounter$1 = 0, currentDebugInfo = null, didWarnAboutMaps;
        var didWarnAboutGenerators = didWarnAboutMaps = false;
        var ownerHasKeyUseWarning = {};
        var ownerHasFunctionTypeWarning = {};
        var ownerHasSymbolTypeWarning = {};
        warnForMissingKey = function(returnFiber, workInProgress2, child) {
          if (null !== child && "object" === typeof child && child._store && (!child._store.validated && null == child.key || 2 === child._store.validated)) {
            if ("object" !== typeof child._store)
              throw Error(
                "React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue."
              );
            child._store.validated = 1;
            var componentName2 = getComponentNameFromFiber(returnFiber), componentKey = componentName2 || "null";
            if (!ownerHasKeyUseWarning[componentKey]) {
              ownerHasKeyUseWarning[componentKey] = true;
              child = child._owner;
              returnFiber = returnFiber._debugOwner;
              var currentComponentErrorInfo = "";
              returnFiber && "number" === typeof returnFiber.tag && (componentKey = getComponentNameFromFiber(returnFiber)) && (currentComponentErrorInfo = "\n\nCheck the render method of `" + componentKey + "`.");
              currentComponentErrorInfo || componentName2 && (currentComponentErrorInfo = "\n\nCheck the top-level render call using <" + componentName2 + ">.");
              var childOwnerAppendix = "";
              null != child && returnFiber !== child && (componentName2 = null, "number" === typeof child.tag ? componentName2 = getComponentNameFromFiber(child) : "string" === typeof child.name && (componentName2 = child.name), componentName2 && (childOwnerAppendix = " It was passed a child from " + componentName2 + "."));
              runWithFiberInDEV(workInProgress2, function() {
                console.error(
                  'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
                  currentComponentErrorInfo,
                  childOwnerAppendix
                );
              });
            }
          }
        };
        var reconcileChildFibers = createChildReconciler(true), mountChildFibers = createChildReconciler(false), UpdateState = 0, ReplaceState = 1, ForceUpdate = 2, CaptureUpdate = 3, hasForceUpdate = false;
        var didWarnUpdateInsideUpdate = false;
        var currentlyProcessingQueue = null;
        var didReadFromEntangledAsyncAction = false, currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0), suspenseHandlerStackCursor = createCursor(null), shellBoundary = null, SubtreeSuspenseContextMask = 1, ForceSuspenseFallback = 2, suspenseStackCursor = createCursor(0), NoFlags = 0, HasEffect = 1, Insertion = 2, Layout = 4, Passive = 8, didWarnUncachedGetSnapshot;
        var didWarnAboutMismatchedHooksForComponent = /* @__PURE__ */ new Set();
        var didWarnAboutUseWrappedInTryCatch = /* @__PURE__ */ new Set();
        var didWarnAboutAsyncClientComponent = /* @__PURE__ */ new Set();
        var didWarnAboutUseFormState = /* @__PURE__ */ new Set();
        var renderLanes = 0, currentlyRenderingFiber = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = false, didScheduleRenderPhaseUpdateDuringThisPass = false, shouldDoubleInvokeUserFnsInHooksDEV = false, localIdCounter = 0, thenableIndexCounter = 0, thenableState = null, globalClientIdCounter = 0, RE_RENDER_LIMIT = 25, currentHookNameInDev = null, hookTypesDev = null, hookTypesUpdateIndexDev = -1, ignorePreviousDependencies = false, ContextOnlyDispatcher = {
          readContext,
          use,
          useCallback: throwInvalidHookError,
          useContext: throwInvalidHookError,
          useEffect: throwInvalidHookError,
          useImperativeHandle: throwInvalidHookError,
          useLayoutEffect: throwInvalidHookError,
          useInsertionEffect: throwInvalidHookError,
          useMemo: throwInvalidHookError,
          useReducer: throwInvalidHookError,
          useRef: throwInvalidHookError,
          useState: throwInvalidHookError,
          useDebugValue: throwInvalidHookError,
          useDeferredValue: throwInvalidHookError,
          useTransition: throwInvalidHookError,
          useSyncExternalStore: throwInvalidHookError,
          useId: throwInvalidHookError,
          useHostTransitionStatus: throwInvalidHookError,
          useFormState: throwInvalidHookError,
          useActionState: throwInvalidHookError,
          useOptimistic: throwInvalidHookError,
          useMemoCache: throwInvalidHookError,
          useCacheRefresh: throwInvalidHookError
        };
        ContextOnlyDispatcher.useEffectEvent = throwInvalidHookError;
        var HooksDispatcherOnMountInDEV = null, HooksDispatcherOnMountWithHookTypesInDEV = null, HooksDispatcherOnUpdateInDEV = null, HooksDispatcherOnRerenderInDEV = null, InvalidNestedHooksDispatcherOnMountInDEV = null, InvalidNestedHooksDispatcherOnUpdateInDEV = null, InvalidNestedHooksDispatcherOnRerenderInDEV = null;
        HooksDispatcherOnMountInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          use,
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            mountHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create2, deps) {
            currentHookNameInDev = "useEffect";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountEffect(create2, deps);
          },
          useImperativeHandle: function(ref, create2, deps) {
            currentHookNameInDev = "useImperativeHandle";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountImperativeHandle(ref, create2, deps);
          },
          useInsertionEffect: function(create2, deps) {
            currentHookNameInDev = "useInsertionEffect";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            mountEffectImpl(4, Insertion, create2, deps);
          },
          useLayoutEffect: function(create2, deps) {
            currentHookNameInDev = "useLayoutEffect";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountLayoutEffect(create2, deps);
          },
          useMemo: function(create2, deps) {
            currentHookNameInDev = "useMemo";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountMemo(create2, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            mountHookTypesDev();
            return mountRef(initialValue);
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState";
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountState(initialState);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            mountHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            mountHookTypesDev();
            return mountDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            mountHookTypesDev();
            return mountTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            mountHookTypesDev();
            return mountSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            mountHookTypesDev();
            return mountId();
          },
          useFormState: function(action, initialState) {
            currentHookNameInDev = "useFormState";
            mountHookTypesDev();
            warnOnUseFormStateInDev();
            return mountActionState(action, initialState);
          },
          useActionState: function(action, initialState) {
            currentHookNameInDev = "useActionState";
            mountHookTypesDev();
            return mountActionState(action, initialState);
          },
          useOptimistic: function(passthrough) {
            currentHookNameInDev = "useOptimistic";
            mountHookTypesDev();
            return mountOptimistic(passthrough);
          },
          useHostTransitionStatus,
          useMemoCache,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            mountHookTypesDev();
            return mountRefresh();
          },
          useEffectEvent: function(callback) {
            currentHookNameInDev = "useEffectEvent";
            mountHookTypesDev();
            return mountEvent(callback);
          }
        };
        HooksDispatcherOnMountWithHookTypesInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          use,
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            updateHookTypesDev();
            return mountCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create2, deps) {
            currentHookNameInDev = "useEffect";
            updateHookTypesDev();
            return mountEffect(create2, deps);
          },
          useImperativeHandle: function(ref, create2, deps) {
            currentHookNameInDev = "useImperativeHandle";
            updateHookTypesDev();
            return mountImperativeHandle(ref, create2, deps);
          },
          useInsertionEffect: function(create2, deps) {
            currentHookNameInDev = "useInsertionEffect";
            updateHookTypesDev();
            mountEffectImpl(4, Insertion, create2, deps);
          },
          useLayoutEffect: function(create2, deps) {
            currentHookNameInDev = "useLayoutEffect";
            updateHookTypesDev();
            return mountLayoutEffect(create2, deps);
          },
          useMemo: function(create2, deps) {
            currentHookNameInDev = "useMemo";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountMemo(create2, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            updateHookTypesDev();
            return mountRef(initialValue);
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountState(initialState);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            updateHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            updateHookTypesDev();
            return mountDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            updateHookTypesDev();
            return mountTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            updateHookTypesDev();
            return mountSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            updateHookTypesDev();
            return mountId();
          },
          useActionState: function(action, initialState) {
            currentHookNameInDev = "useActionState";
            updateHookTypesDev();
            return mountActionState(action, initialState);
          },
          useFormState: function(action, initialState) {
            currentHookNameInDev = "useFormState";
            updateHookTypesDev();
            warnOnUseFormStateInDev();
            return mountActionState(action, initialState);
          },
          useOptimistic: function(passthrough) {
            currentHookNameInDev = "useOptimistic";
            updateHookTypesDev();
            return mountOptimistic(passthrough);
          },
          useHostTransitionStatus,
          useMemoCache,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return mountRefresh();
          },
          useEffectEvent: function(callback) {
            currentHookNameInDev = "useEffectEvent";
            updateHookTypesDev();
            return mountEvent(callback);
          }
        };
        HooksDispatcherOnUpdateInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          use,
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create2, deps) {
            currentHookNameInDev = "useEffect";
            updateHookTypesDev();
            updateEffectImpl(2048, Passive, create2, deps);
          },
          useImperativeHandle: function(ref, create2, deps) {
            currentHookNameInDev = "useImperativeHandle";
            updateHookTypesDev();
            return updateImperativeHandle(ref, create2, deps);
          },
          useInsertionEffect: function(create2, deps) {
            currentHookNameInDev = "useInsertionEffect";
            updateHookTypesDev();
            return updateEffectImpl(4, Insertion, create2, deps);
          },
          useLayoutEffect: function(create2, deps) {
            currentHookNameInDev = "useLayoutEffect";
            updateHookTypesDev();
            return updateEffectImpl(4, Layout, create2, deps);
          },
          useMemo: function(create2, deps) {
            currentHookNameInDev = "useMemo";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateMemo(create2, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function() {
            currentHookNameInDev = "useRef";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useState: function() {
            currentHookNameInDev = "useState";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(basicStateReducer);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            updateHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            updateHookTypesDev();
            return updateDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            updateHookTypesDev();
            return updateTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            updateHookTypesDev();
            return updateSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useFormState: function(action) {
            currentHookNameInDev = "useFormState";
            updateHookTypesDev();
            warnOnUseFormStateInDev();
            return updateActionState(action);
          },
          useActionState: function(action) {
            currentHookNameInDev = "useActionState";
            updateHookTypesDev();
            return updateActionState(action);
          },
          useOptimistic: function(passthrough, reducer) {
            currentHookNameInDev = "useOptimistic";
            updateHookTypesDev();
            return updateOptimistic(passthrough, reducer);
          },
          useHostTransitionStatus,
          useMemoCache,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useEffectEvent: function(callback) {
            currentHookNameInDev = "useEffectEvent";
            updateHookTypesDev();
            return updateEvent(callback);
          }
        };
        HooksDispatcherOnRerenderInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          use,
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create2, deps) {
            currentHookNameInDev = "useEffect";
            updateHookTypesDev();
            updateEffectImpl(2048, Passive, create2, deps);
          },
          useImperativeHandle: function(ref, create2, deps) {
            currentHookNameInDev = "useImperativeHandle";
            updateHookTypesDev();
            return updateImperativeHandle(ref, create2, deps);
          },
          useInsertionEffect: function(create2, deps) {
            currentHookNameInDev = "useInsertionEffect";
            updateHookTypesDev();
            return updateEffectImpl(4, Insertion, create2, deps);
          },
          useLayoutEffect: function(create2, deps) {
            currentHookNameInDev = "useLayoutEffect";
            updateHookTypesDev();
            return updateEffectImpl(4, Layout, create2, deps);
          },
          useMemo: function(create2, deps) {
            currentHookNameInDev = "useMemo";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
              return updateMemo(create2, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
              return rerenderReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function() {
            currentHookNameInDev = "useRef";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useState: function() {
            currentHookNameInDev = "useState";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
              return rerenderReducer(basicStateReducer);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            updateHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            updateHookTypesDev();
            return rerenderDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            updateHookTypesDev();
            return rerenderTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            updateHookTypesDev();
            return updateSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useFormState: function(action) {
            currentHookNameInDev = "useFormState";
            updateHookTypesDev();
            warnOnUseFormStateInDev();
            return rerenderActionState(action);
          },
          useActionState: function(action) {
            currentHookNameInDev = "useActionState";
            updateHookTypesDev();
            return rerenderActionState(action);
          },
          useOptimistic: function(passthrough, reducer) {
            currentHookNameInDev = "useOptimistic";
            updateHookTypesDev();
            return rerenderOptimistic(passthrough, reducer);
          },
          useHostTransitionStatus,
          useMemoCache,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useEffectEvent: function(callback) {
            currentHookNameInDev = "useEffectEvent";
            updateHookTypesDev();
            return updateEvent(callback);
          }
        };
        InvalidNestedHooksDispatcherOnMountInDEV = {
          readContext: function(context) {
            warnInvalidContextAccess();
            return readContext(context);
          },
          use: function(usable) {
            warnInvalidHookAccess();
            return use(usable);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create2, deps) {
            currentHookNameInDev = "useEffect";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountEffect(create2, deps);
          },
          useImperativeHandle: function(ref, create2, deps) {
            currentHookNameInDev = "useImperativeHandle";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountImperativeHandle(ref, create2, deps);
          },
          useInsertionEffect: function(create2, deps) {
            currentHookNameInDev = "useInsertionEffect";
            warnInvalidHookAccess();
            mountHookTypesDev();
            mountEffectImpl(4, Insertion, create2, deps);
          },
          useLayoutEffect: function(create2, deps) {
            currentHookNameInDev = "useLayoutEffect";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountLayoutEffect(create2, deps);
          },
          useMemo: function(create2, deps) {
            currentHookNameInDev = "useMemo";
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountMemo(create2, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountRef(initialValue);
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState";
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountState(initialState);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            warnInvalidHookAccess();
            mountHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountId();
          },
          useFormState: function(action, initialState) {
            currentHookNameInDev = "useFormState";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountActionState(action, initialState);
          },
          useActionState: function(action, initialState) {
            currentHookNameInDev = "useActionState";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountActionState(action, initialState);
          },
          useOptimistic: function(passthrough) {
            currentHookNameInDev = "useOptimistic";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountOptimistic(passthrough);
          },
          useMemoCache: function(size) {
            warnInvalidHookAccess();
            return useMemoCache(size);
          },
          useHostTransitionStatus,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            mountHookTypesDev();
            return mountRefresh();
          },
          useEffectEvent: function(callback) {
            currentHookNameInDev = "useEffectEvent";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountEvent(callback);
          }
        };
        InvalidNestedHooksDispatcherOnUpdateInDEV = {
          readContext: function(context) {
            warnInvalidContextAccess();
            return readContext(context);
          },
          use: function(usable) {
            warnInvalidHookAccess();
            return use(usable);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create2, deps) {
            currentHookNameInDev = "useEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            updateEffectImpl(2048, Passive, create2, deps);
          },
          useImperativeHandle: function(ref, create2, deps) {
            currentHookNameInDev = "useImperativeHandle";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateImperativeHandle(ref, create2, deps);
          },
          useInsertionEffect: function(create2, deps) {
            currentHookNameInDev = "useInsertionEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffectImpl(4, Insertion, create2, deps);
          },
          useLayoutEffect: function(create2, deps) {
            currentHookNameInDev = "useLayoutEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffectImpl(4, Layout, create2, deps);
          },
          useMemo: function(create2, deps) {
            currentHookNameInDev = "useMemo";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateMemo(create2, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function() {
            currentHookNameInDev = "useRef";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useState: function() {
            currentHookNameInDev = "useState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(basicStateReducer);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useFormState: function(action) {
            currentHookNameInDev = "useFormState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateActionState(action);
          },
          useActionState: function(action) {
            currentHookNameInDev = "useActionState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateActionState(action);
          },
          useOptimistic: function(passthrough, reducer) {
            currentHookNameInDev = "useOptimistic";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateOptimistic(passthrough, reducer);
          },
          useMemoCache: function(size) {
            warnInvalidHookAccess();
            return useMemoCache(size);
          },
          useHostTransitionStatus,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useEffectEvent: function(callback) {
            currentHookNameInDev = "useEffectEvent";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEvent(callback);
          }
        };
        InvalidNestedHooksDispatcherOnRerenderInDEV = {
          readContext: function(context) {
            warnInvalidContextAccess();
            return readContext(context);
          },
          use: function(usable) {
            warnInvalidHookAccess();
            return use(usable);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create2, deps) {
            currentHookNameInDev = "useEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            updateEffectImpl(2048, Passive, create2, deps);
          },
          useImperativeHandle: function(ref, create2, deps) {
            currentHookNameInDev = "useImperativeHandle";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateImperativeHandle(ref, create2, deps);
          },
          useInsertionEffect: function(create2, deps) {
            currentHookNameInDev = "useInsertionEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffectImpl(4, Insertion, create2, deps);
          },
          useLayoutEffect: function(create2, deps) {
            currentHookNameInDev = "useLayoutEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffectImpl(4, Layout, create2, deps);
          },
          useMemo: function(create2, deps) {
            currentHookNameInDev = "useMemo";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateMemo(create2, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return rerenderReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function() {
            currentHookNameInDev = "useRef";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useState: function() {
            currentHookNameInDev = "useState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return rerenderReducer(basicStateReducer);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useFormState: function(action) {
            currentHookNameInDev = "useFormState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderActionState(action);
          },
          useActionState: function(action) {
            currentHookNameInDev = "useActionState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderActionState(action);
          },
          useOptimistic: function(passthrough, reducer) {
            currentHookNameInDev = "useOptimistic";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderOptimistic(passthrough, reducer);
          },
          useMemoCache: function(size) {
            warnInvalidHookAccess();
            return useMemoCache(size);
          },
          useHostTransitionStatus,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useEffectEvent: function(callback) {
            currentHookNameInDev = "useEffectEvent";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEvent(callback);
          }
        };
        var fakeInternalInstance = {};
        var didWarnAboutStateAssignmentForComponent = /* @__PURE__ */ new Set();
        var didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
        var didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
        var didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
        var didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
        var didWarnAboutContextTypes$1 = /* @__PURE__ */ new Set();
        var didWarnAboutChildContextTypes = /* @__PURE__ */ new Set();
        var didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
        var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
        Object.freeze(fakeInternalInstance);
        var classComponentUpdater = {
          enqueueSetState: function(inst, payload, callback) {
            inst = inst._reactInternals;
            var lane = requestUpdateLane(inst), update = createUpdate(lane);
            update.payload = payload;
            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
            payload = enqueueUpdate(inst, update, lane);
            null !== payload && (startUpdateTimerByLane(lane, "this.setState()", inst), scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
          },
          enqueueReplaceState: function(inst, payload, callback) {
            inst = inst._reactInternals;
            var lane = requestUpdateLane(inst), update = createUpdate(lane);
            update.tag = ReplaceState;
            update.payload = payload;
            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
            payload = enqueueUpdate(inst, update, lane);
            null !== payload && (startUpdateTimerByLane(lane, "this.replaceState()", inst), scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
          },
          enqueueForceUpdate: function(inst, callback) {
            inst = inst._reactInternals;
            var lane = requestUpdateLane(inst), update = createUpdate(lane);
            update.tag = ForceUpdate;
            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
            callback = enqueueUpdate(inst, update, lane);
            null !== callback && (startUpdateTimerByLane(lane, "this.forceUpdate()", inst), scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
          }
        }, componentName = null, errorBoundaryName = null, SelectiveHydrationException = Error(
          "This is not a real error. It's an implementation detail of React's selective hydration feature. If this leaks into userspace, it's a bug in React. Please file an issue."
        ), didReceiveUpdate = false;
        var didWarnAboutBadClass = {};
        var didWarnAboutContextTypeOnFunctionComponent = {};
        var didWarnAboutContextTypes = {};
        var didWarnAboutGetDerivedStateOnFunctionComponent = {};
        var didWarnAboutReassigningProps = false;
        var didWarnAboutRevealOrder = {};
        var didWarnAboutTailOptions = {};
        var SUSPENDED_MARKER = {
          dehydrated: null,
          treeContext: null,
          retryLane: 0,
          hydrationErrors: null
        }, hasWarnedAboutUsingNoValuePropOnContextProvider = false, didWarnAboutUndefinedSnapshotBeforeUpdate = null;
        didWarnAboutUndefinedSnapshotBeforeUpdate = /* @__PURE__ */ new Set();
        var offscreenSubtreeIsHidden = false, offscreenSubtreeWasHidden = false, needsFormReset = false, PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set, nextEffect = null, inProgressLanes = null, inProgressRoot = null, hostParent = null, hostParentIsContainer = false, currentHoistableRoot = null, inHydratedSubtree = false, suspenseyCommitFlag = 8192, DefaultAsyncDispatcher = {
          getCacheForType: function(resourceType) {
            var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);
            void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));
            return cacheForType;
          },
          cacheSignal: function() {
            return readContext(CacheContext).controller.signal;
          },
          getOwner: function() {
            return current;
          }
        };
        if ("function" === typeof Symbol && Symbol.for) {
          var symbolFor = Symbol.for;
          symbolFor("selector.component");
          symbolFor("selector.has_pseudo_class");
          symbolFor("selector.role");
          symbolFor("selector.test_id");
          symbolFor("selector.text");
        }
        var commitHooks = [], PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map, NoContext = 0, RenderContext = 2, CommitContext = 4, RootInProgress = 0, RootFatalErrored = 1, RootErrored = 2, RootSuspended = 3, RootSuspendedWithDelay = 4, RootSuspendedAtTheShell = 6, RootCompleted = 5, executionContext = NoContext, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, NotSuspended = 0, SuspendedOnError = 1, SuspendedOnData = 2, SuspendedOnImmediate = 3, SuspendedOnInstance = 4, SuspendedOnInstanceAndReadyToContinue = 5, SuspendedOnDeprecatedThrowPromise = 6, SuspendedAndReadyToContinue = 7, SuspendedOnHydration = 8, SuspendedOnAction = 9, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = false, workInProgressRootIsPrerendering = false, workInProgressRootDidAttachPingListener = false, entangledRenderLanes = 0, workInProgressRootExitStatus = RootInProgress, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = false, globalMostRecentFallbackTime = 0, globalMostRecentTransitionTime = 0, FALLBACK_THROTTLE_MS = 300, workInProgressRootRenderTargetTime = Infinity, RENDER_TIMEOUT_MS = 500, workInProgressTransitions = null, workInProgressUpdateTask = null, legacyErrorBoundariesThatAlreadyFailed = null, IMMEDIATE_COMMIT = 0, ABORTED_VIEW_TRANSITION_COMMIT = 1, DELAYED_PASSIVE_COMMIT = 2, ANIMATION_STARTED_COMMIT = 3, NO_PENDING_EFFECTS = 0, PENDING_MUTATION_PHASE = 1, PENDING_LAYOUT_PHASE = 2, PENDING_AFTER_MUTATION_PHASE = 3, PENDING_SPAWNED_WORK = 4, PENDING_PASSIVE_PHASE = 5, pendingEffectsStatus = 0, pendingEffectsRoot = null, pendingFinishedWork = null, pendingEffectsLanes = 0, pendingEffectsRemainingLanes = 0, pendingEffectsRenderEndTime = -0, pendingPassiveTransitions = null, pendingRecoverableErrors = null, pendingSuspendedCommitReason = null, pendingDelayedCommitReason = IMMEDIATE_COMMIT, pendingSuspendedViewTransitionReason = null, NESTED_UPDATE_LIMIT = 50, nestedUpdateCount = 0, rootWithNestedUpdates = null, isFlushingPassiveEffects = false, didScheduleUpdateDuringPassiveEffects = false, NESTED_PASSIVE_UPDATE_LIMIT = 50, nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, isRunningInsertionEffect = false, didWarnStateUpdateForNotYetMountedComponent = null, didWarnAboutUpdateInRender = false;
        var didWarnAboutUpdateInRenderForAnotherComponent = /* @__PURE__ */ new Set();
        var fakeActCallbackNode$1 = {}, firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = false, didScheduleMicrotask_act = false, mightHavePendingSyncWork = false, isFlushingWork = false, currentEventTransitionLane = 0, fakeActCallbackNode = {};
        (function() {
          for (var i5 = 0; i5 < simpleEventPluginEvents.length; i5++) {
            var eventName = simpleEventPluginEvents[i5], domEventName = eventName.toLowerCase();
            eventName = eventName[0].toUpperCase() + eventName.slice(1);
            registerSimpleEvent(domEventName, "on" + eventName);
          }
          registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
          registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
          registerSimpleEvent(ANIMATION_START, "onAnimationStart");
          registerSimpleEvent("dblclick", "onDoubleClick");
          registerSimpleEvent("focusin", "onFocus");
          registerSimpleEvent("focusout", "onBlur");
          registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
          registerSimpleEvent(TRANSITION_START, "onTransitionStart");
          registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
          registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
        })();
        registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
        registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
        registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
        registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
        registerTwoPhaseEvent(
          "onChange",
          "change click focusin focusout input keydown keyup selectionchange".split(
            " "
          )
        );
        registerTwoPhaseEvent(
          "onSelect",
          "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
            " "
          )
        );
        registerTwoPhaseEvent("onBeforeInput", [
          "compositionend",
          "keypress",
          "textInput",
          "paste"
        ]);
        registerTwoPhaseEvent(
          "onCompositionEnd",
          "compositionend focusout keydown keypress keyup mousedown".split(" ")
        );
        registerTwoPhaseEvent(
          "onCompositionStart",
          "compositionstart focusout keydown keypress keyup mousedown".split(" ")
        );
        registerTwoPhaseEvent(
          "onCompositionUpdate",
          "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
        );
        var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
          " "
        ), nonDelegatedEvents = new Set(
          "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes)
        ), listeningMarker = "_reactListening" + Math.random().toString(36).slice(2), didWarnControlledToUncontrolled = false, didWarnUncontrolledToControlled = false, didWarnFormActionType = false, didWarnFormActionName = false, didWarnFormActionTarget = false, didWarnFormActionMethod = false, didWarnPopoverTargetObject = false;
        var didWarnForNewBooleanPropsWithEmptyValue = {};
        var NORMALIZE_NEWLINES_REGEX = /\r\n?/g, NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g, xlinkNamespace = "http://www.w3.org/1999/xlink", xmlNamespace = "http://www.w3.org/XML/1998/namespace", EXPECTED_FORM_ACTION_URL = "javascript:throw new Error('React form unexpectedly submitted.')", SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning", ACTIVITY_START_DATA = "&", ACTIVITY_END_DATA = "/&", SUSPENSE_START_DATA = "$", SUSPENSE_END_DATA = "/$", SUSPENSE_PENDING_START_DATA = "$?", SUSPENSE_QUEUED_START_DATA = "$~", SUSPENSE_FALLBACK_START_DATA = "$!", PREAMBLE_CONTRIBUTION_HTML = "html", PREAMBLE_CONTRIBUTION_BODY = "body", PREAMBLE_CONTRIBUTION_HEAD = "head", FORM_STATE_IS_MATCHING = "F!", FORM_STATE_IS_NOT_MATCHING = "F", DOCUMENT_READY_STATE_LOADING = "loading", STYLE = "style", HostContextNamespaceNone = 0, HostContextNamespaceSvg = 1, HostContextNamespaceMath = 2, eventsEnabled = null, selectionInformation = null, warnedUnknownTags = { dialog: true, webview: true }, currentPopstateTransitionEvent = null, schedulerEvent = void 0, scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0, cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0, noTimeout = -1, localPromise = "function" === typeof Promise ? Promise : void 0, scheduleMicrotask = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof localPromise ? function(callback) {
          return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
        } : scheduleTimeout, previousHydratableOnEnteringScopedSingleton = null, NotLoaded = 0, Loaded = 1, Errored = 2, Settled = 3, Inserted = 4, preloadPropsMap = /* @__PURE__ */ new Map(), preconnectsSet = /* @__PURE__ */ new Set(), previousDispatcher = ReactDOMSharedInternals.d;
        ReactDOMSharedInternals.d = {
          f: function() {
            var previousWasRendering = previousDispatcher.f(), wasRendering = flushSyncWork$1();
            return previousWasRendering || wasRendering;
          },
          r: function(form) {
            var formInst = getInstanceFromNode(form);
            null !== formInst && 5 === formInst.tag && "form" === formInst.type ? requestFormReset$1(formInst) : previousDispatcher.r(form);
          },
          D: function(href) {
            previousDispatcher.D(href);
            preconnectAs("dns-prefetch", href, null);
          },
          C: function(href, crossOrigin) {
            previousDispatcher.C(href, crossOrigin);
            preconnectAs("preconnect", href, crossOrigin);
          },
          L: function(href, as, options) {
            previousDispatcher.L(href, as, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && href && as) {
              var preloadSelector = 'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"]';
              "image" === as ? options && options.imageSrcSet ? (preloadSelector += '[imagesrcset="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                options.imageSrcSet
              ) + '"]', "string" === typeof options.imageSizes && (preloadSelector += '[imagesizes="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                options.imageSizes
              ) + '"]')) : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]' : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]';
              var key = preloadSelector;
              switch (as) {
                case "style":
                  key = getStyleKey(href);
                  break;
                case "script":
                  key = getScriptKey(href);
              }
              preloadPropsMap.has(key) || (href = assign(
                {
                  rel: "preload",
                  href: "image" === as && options && options.imageSrcSet ? void 0 : href,
                  as
                },
                options
              ), preloadPropsMap.set(key, href), null !== ownerDocument.querySelector(preloadSelector) || "style" === as && ownerDocument.querySelector(
                getStylesheetSelectorFromKey(key)
              ) || "script" === as && ownerDocument.querySelector(getScriptSelectorFromKey(key)) || (as = ownerDocument.createElement("link"), setInitialProperties(as, "link", href), markNodeAsHoistable(as), ownerDocument.head.appendChild(as)));
            }
          },
          m: function(href, options) {
            previousDispatcher.m(href, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && href) {
              var as = options && "string" === typeof options.as ? options.as : "script", preloadSelector = 'link[rel="modulepreload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"][href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]', key = preloadSelector;
              switch (as) {
                case "audioworklet":
                case "paintworklet":
                case "serviceworker":
                case "sharedworker":
                case "worker":
                case "script":
                  key = getScriptKey(href);
              }
              if (!preloadPropsMap.has(key) && (href = assign({ rel: "modulepreload", href }, options), preloadPropsMap.set(key, href), null === ownerDocument.querySelector(preloadSelector))) {
                switch (as) {
                  case "audioworklet":
                  case "paintworklet":
                  case "serviceworker":
                  case "sharedworker":
                  case "worker":
                  case "script":
                    if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
                      return;
                }
                as = ownerDocument.createElement("link");
                setInitialProperties(as, "link", href);
                markNodeAsHoistable(as);
                ownerDocument.head.appendChild(as);
              }
            }
          },
          X: function(src, options) {
            previousDispatcher.X(src, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && src) {
              var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
              resource || (resource = ownerDocument.querySelector(
                getScriptSelectorFromKey(key)
              ), resource || (src = assign({ src, async: true }, options), (options = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
                type: "script",
                instance: resource,
                count: 1,
                state: null
              }, scripts.set(key, resource));
            }
          },
          S: function(href, precedence, options) {
            previousDispatcher.S(href, precedence, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && href) {
              var styles = getResourcesFromRoot(ownerDocument).hoistableStyles, key = getStyleKey(href);
              precedence = precedence || "default";
              var resource = styles.get(key);
              if (!resource) {
                var state = { loading: NotLoaded, preload: null };
                if (resource = ownerDocument.querySelector(
                  getStylesheetSelectorFromKey(key)
                ))
                  state.loading = Loaded | Inserted;
                else {
                  href = assign(
                    {
                      rel: "stylesheet",
                      href,
                      "data-precedence": precedence
                    },
                    options
                  );
                  (options = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(href, options);
                  var link = resource = ownerDocument.createElement("link");
                  markNodeAsHoistable(link);
                  setInitialProperties(link, "link", href);
                  link._p = new Promise(function(resolve, reject) {
                    link.onload = resolve;
                    link.onerror = reject;
                  });
                  link.addEventListener("load", function() {
                    state.loading |= Loaded;
                  });
                  link.addEventListener("error", function() {
                    state.loading |= Errored;
                  });
                  state.loading |= Inserted;
                  insertStylesheet(resource, precedence, ownerDocument);
                }
                resource = {
                  type: "stylesheet",
                  instance: resource,
                  count: 1,
                  state
                };
                styles.set(key, resource);
              }
            }
          },
          M: function(src, options) {
            previousDispatcher.M(src, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && src) {
              var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
              resource || (resource = ownerDocument.querySelector(
                getScriptSelectorFromKey(key)
              ), resource || (src = assign({ src, async: true, type: "module" }, options), (options = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
                type: "script",
                instance: resource,
                count: 1,
                state: null
              }, scripts.set(key, resource));
            }
          }
        };
        var globalDocument = "undefined" === typeof document ? null : document, tagCaches = null, SUSPENSEY_STYLESHEET_TIMEOUT = 6e4, SUSPENSEY_IMAGE_TIMEOUT = 800, SUSPENSEY_IMAGE_TIME_ESTIMATE = 500, estimatedBytesWithinLimit = 0, LAST_PRECEDENCE = null, precedencesByRoot = null, NotPendingTransition = NotPending, HostTransitionContext = {
          $$typeof: REACT_CONTEXT_TYPE,
          Provider: null,
          Consumer: null,
          _currentValue: NotPendingTransition,
          _currentValue2: NotPendingTransition,
          _threadCount: 0
        }, badgeFormat = "%c%s%c", badgeStyle = "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px", resetStyle = "", pad = " ", bind = Function.prototype.bind;
        var didWarnAboutNestedUpdates = false;
        var overrideHookState = null, overrideHookStateDeletePath = null, overrideHookStateRenamePath = null, overrideProps = null, overridePropsDeletePath = null, overridePropsRenamePath = null, scheduleUpdate = null, scheduleRetry = null, setErrorHandler = null, setSuspenseHandler = null;
        overrideHookState = function(fiber, id, path, value) {
          id = findHook(fiber, id);
          null !== id && (path = copyWithSetImpl(id.memoizedState, path, 0, value), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), null !== path && scheduleUpdateOnFiber(path, fiber, 2));
        };
        overrideHookStateDeletePath = function(fiber, id, path) {
          id = findHook(fiber, id);
          null !== id && (path = copyWithDeleteImpl(id.memoizedState, path, 0), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), null !== path && scheduleUpdateOnFiber(path, fiber, 2));
        };
        overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {
          id = findHook(fiber, id);
          null !== id && (oldPath = copyWithRename(id.memoizedState, oldPath, newPath), id.memoizedState = oldPath, id.baseState = oldPath, fiber.memoizedProps = assign({}, fiber.memoizedProps), oldPath = enqueueConcurrentRenderForLane(fiber, 2), null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2));
        };
        overrideProps = function(fiber, path, value) {
          fiber.pendingProps = copyWithSetImpl(fiber.memoizedProps, path, 0, value);
          fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
          path = enqueueConcurrentRenderForLane(fiber, 2);
          null !== path && scheduleUpdateOnFiber(path, fiber, 2);
        };
        overridePropsDeletePath = function(fiber, path) {
          fiber.pendingProps = copyWithDeleteImpl(fiber.memoizedProps, path, 0);
          fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
          path = enqueueConcurrentRenderForLane(fiber, 2);
          null !== path && scheduleUpdateOnFiber(path, fiber, 2);
        };
        overridePropsRenamePath = function(fiber, oldPath, newPath) {
          fiber.pendingProps = copyWithRename(
            fiber.memoizedProps,
            oldPath,
            newPath
          );
          fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
          oldPath = enqueueConcurrentRenderForLane(fiber, 2);
          null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2);
        };
        scheduleUpdate = function(fiber) {
          var root2 = enqueueConcurrentRenderForLane(fiber, 2);
          null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2);
        };
        scheduleRetry = function(fiber) {
          var lane = claimNextRetryLane(), root2 = enqueueConcurrentRenderForLane(fiber, lane);
          null !== root2 && scheduleUpdateOnFiber(root2, fiber, lane);
        };
        setErrorHandler = function(newShouldErrorImpl) {
          shouldErrorImpl = newShouldErrorImpl;
        };
        setSuspenseHandler = function(newShouldSuspendImpl) {
          shouldSuspendImpl = newShouldSuspendImpl;
        };
        var _enabled = true, return_targetInst = null, hasScheduledReplayAttempt = false, queuedFocus = null, queuedDrag = null, queuedMouse = null, queuedPointers = /* @__PURE__ */ new Map(), queuedPointerCaptures = /* @__PURE__ */ new Map(), queuedExplicitHydrationTargets = [], discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
          " "
        ), lastScheduledReplayQueue = null;
        ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
          var root2 = this._internalRoot;
          if (null === root2) throw Error("Cannot update an unmounted root.");
          var args = arguments;
          "function" === typeof args[1] ? console.error(
            "does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."
          ) : isValidContainer(args[1]) ? console.error(
            "You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root."
          ) : "undefined" !== typeof args[1] && console.error(
            "You passed a second argument to root.render(...) but it only accepts one argument."
          );
          args = children;
          var current2 = root2.current, lane = requestUpdateLane(current2);
          updateContainerImpl(current2, lane, args, root2, null, null);
        };
        ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
          var args = arguments;
          "function" === typeof args[0] && console.error(
            "does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."
          );
          args = this._internalRoot;
          if (null !== args) {
            this._internalRoot = null;
            var container = args.containerInfo;
            (executionContext & (RenderContext | CommitContext)) !== NoContext && console.error(
              "Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."
            );
            updateContainerImpl(args.current, 2, null, args, null, null);
            flushSyncWork$1();
            container[internalContainerInstanceKey] = null;
          }
        };
        ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function(target) {
          if (target) {
            var updatePriority = resolveUpdatePriority();
            target = { blockedOn: null, target, priority: updatePriority };
            for (var i5 = 0; i5 < queuedExplicitHydrationTargets.length && 0 !== updatePriority && updatePriority < queuedExplicitHydrationTargets[i5].priority; i5++) ;
            queuedExplicitHydrationTargets.splice(i5, 0, target);
            0 === i5 && attemptExplicitHydrationTarget(target);
          }
        };
        (function() {
          var isomorphicReactPackageVersion = React2.version;
          if ("19.2.0" !== isomorphicReactPackageVersion)
            throw Error(
              'Incompatible React versions: The "react" and "react-dom" packages must have the exact same version. Instead got:\n  - react:      ' + (isomorphicReactPackageVersion + "\n  - react-dom:  19.2.0\nLearn more: https://react.dev/warnings/version-mismatch")
            );
        })();
        "function" === typeof Map && null != Map.prototype && "function" === typeof Map.prototype.forEach && "function" === typeof Set && null != Set.prototype && "function" === typeof Set.prototype.clear && "function" === typeof Set.prototype.forEach || console.error(
          "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://react.dev/link/react-polyfills"
        );
        ReactDOMSharedInternals.findDOMNode = function(componentOrElement) {
          var fiber = componentOrElement._reactInternals;
          if (void 0 === fiber) {
            if ("function" === typeof componentOrElement.render)
              throw Error("Unable to find node on an unmounted component.");
            componentOrElement = Object.keys(componentOrElement).join(",");
            throw Error(
              "Argument appears to not be a ReactComponent. Keys: " + componentOrElement
            );
          }
          componentOrElement = findCurrentFiberUsingSlowPath(fiber);
          componentOrElement = null !== componentOrElement ? findCurrentHostFiberImpl(componentOrElement) : null;
          componentOrElement = null === componentOrElement ? null : componentOrElement.stateNode;
          return componentOrElement;
        };
        if (!(function() {
          var internals = {
            bundleType: 1,
            version: "19.2.0",
            rendererPackageName: "react-dom",
            currentDispatcherRef: ReactSharedInternals,
            reconcilerVersion: "19.2.0"
          };
          internals.overrideHookState = overrideHookState;
          internals.overrideHookStateDeletePath = overrideHookStateDeletePath;
          internals.overrideHookStateRenamePath = overrideHookStateRenamePath;
          internals.overrideProps = overrideProps;
          internals.overridePropsDeletePath = overridePropsDeletePath;
          internals.overridePropsRenamePath = overridePropsRenamePath;
          internals.scheduleUpdate = scheduleUpdate;
          internals.scheduleRetry = scheduleRetry;
          internals.setErrorHandler = setErrorHandler;
          internals.setSuspenseHandler = setSuspenseHandler;
          internals.scheduleRefresh = scheduleRefresh;
          internals.scheduleRoot = scheduleRoot;
          internals.setRefreshHandler = setRefreshHandler;
          internals.getCurrentFiber = getCurrentFiberForDevTools;
          return injectInternals(internals);
        })() && canUseDOM && window.top === window.self && (-1 < navigator.userAgent.indexOf("Chrome") && -1 === navigator.userAgent.indexOf("Edge") || -1 < navigator.userAgent.indexOf("Firefox"))) {
          var protocol = window.location.protocol;
          /^(https?|file):$/.test(protocol) && console.info(
            "%cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools" + ("file:" === protocol ? "\nYou might need to use a local HTTP server (instead of file://): https://react.dev/link/react-devtools-faq" : ""),
            "font-weight:bold"
          );
        }
        exports.createRoot = function(container, options) {
          if (!isValidContainer(container))
            throw Error("Target container is not a DOM element.");
          warnIfReactDOMContainerInDEV(container);
          var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError;
          null !== options && void 0 !== options && (options.hydrate ? console.warn(
            "hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead."
          ) : "object" === typeof options && null !== options && options.$$typeof === REACT_ELEMENT_TYPE && console.error(
            "You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:\n\n  let root = createRoot(domContainer);\n  root.render(<App />);"
          ), true === options.unstable_strictMode && (isStrictMode = true), void 0 !== options.identifierPrefix && (identifierPrefix = options.identifierPrefix), void 0 !== options.onUncaughtError && (onUncaughtError = options.onUncaughtError), void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError), void 0 !== options.onRecoverableError && (onRecoverableError = options.onRecoverableError));
          options = createFiberRoot(
            container,
            1,
            false,
            null,
            null,
            isStrictMode,
            identifierPrefix,
            null,
            onUncaughtError,
            onCaughtError,
            onRecoverableError,
            defaultOnDefaultTransitionIndicator
          );
          container[internalContainerInstanceKey] = options.current;
          listenToAllSupportedEvents(container);
          return new ReactDOMRoot(options);
        };
        exports.hydrateRoot = function(container, initialChildren, options) {
          if (!isValidContainer(container))
            throw Error("Target container is not a DOM element.");
          warnIfReactDOMContainerInDEV(container);
          void 0 === initialChildren && console.error(
            "Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)"
          );
          var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, formState = null;
          null !== options && void 0 !== options && (true === options.unstable_strictMode && (isStrictMode = true), void 0 !== options.identifierPrefix && (identifierPrefix = options.identifierPrefix), void 0 !== options.onUncaughtError && (onUncaughtError = options.onUncaughtError), void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError), void 0 !== options.onRecoverableError && (onRecoverableError = options.onRecoverableError), void 0 !== options.formState && (formState = options.formState));
          initialChildren = createFiberRoot(
            container,
            1,
            true,
            initialChildren,
            null != options ? options : null,
            isStrictMode,
            identifierPrefix,
            formState,
            onUncaughtError,
            onCaughtError,
            onRecoverableError,
            defaultOnDefaultTransitionIndicator
          );
          initialChildren.context = getContextForSubtree(null);
          options = initialChildren.current;
          isStrictMode = requestUpdateLane(options);
          isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
          identifierPrefix = createUpdate(isStrictMode);
          identifierPrefix.callback = null;
          enqueueUpdate(options, identifierPrefix, isStrictMode);
          startUpdateTimerByLane(isStrictMode, "hydrateRoot()", null);
          options = isStrictMode;
          initialChildren.current.lanes = options;
          markRootUpdated$1(initialChildren, options);
          ensureRootIsScheduled(initialChildren);
          container[internalContainerInstanceKey] = initialChildren.current;
          listenToAllSupportedEvents(container);
          return new ReactDOMHydrationRoot(initialChildren);
        };
        exports.version = "19.2.0";
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
      })();
    }
  });

  // node_modules/.pnpm/react-dom@19.2.0_react@19.2.0/node_modules/react-dom/client.js
  var require_client = __commonJS({
    "node_modules/.pnpm/react-dom@19.2.0_react@19.2.0/node_modules/react-dom/client.js"(exports, module) {
      "use strict";
      if (false) {
        checkDCE();
        module.exports = null;
      } else {
        module.exports = require_react_dom_client_development();
      }
    }
  });

  // node_modules/.pnpm/react@19.2.0/node_modules/react/cjs/react-jsx-runtime.development.js
  var require_react_jsx_runtime_development = __commonJS({
    "node_modules/.pnpm/react@19.2.0/node_modules/react/cjs/react-jsx-runtime.development.js"(exports) {
      "use strict";
      (function() {
        function getComponentNameFromType(type) {
          if (null == type) return null;
          if ("function" === typeof type)
            return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
          if ("string" === typeof type) return type;
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
              return "Activity";
          }
          if ("object" === typeof type)
            switch ("number" === typeof type.tag && console.error(
              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
            ), type.$$typeof) {
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_CONTEXT_TYPE:
                return type.displayName || "Context";
              case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
              case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
              case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                  return getComponentNameFromType(type(innerType));
                } catch (x5) {
                }
            }
          return null;
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkKeyStringCoercion(value) {
          try {
            testStringCoercion(value);
            var JSCompiler_inline_result = false;
          } catch (e2) {
            JSCompiler_inline_result = true;
          }
          if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(
              JSCompiler_inline_result,
              "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
              JSCompiler_inline_result$jscomp$0
            );
            return testStringCoercion(value);
          }
        }
        function getTaskName(type) {
          if (type === REACT_FRAGMENT_TYPE) return "<>";
          if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE)
            return "<...>";
          try {
            var name = getComponentNameFromType(type);
            return name ? "<" + name + ">" : "<...>";
          } catch (x5) {
            return "<...>";
          }
        }
        function getOwner() {
          var dispatcher = ReactSharedInternals.A;
          return null === dispatcher ? null : dispatcher.getOwner();
        }
        function UnknownOwner() {
          return Error("react-stack-top-frame");
        }
        function hasValidKey(config) {
          if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) return false;
          }
          return void 0 !== config.key;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error(
              "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
              displayName
            ));
          }
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function elementRefGetterWithDeprecationWarning() {
          var componentName = getComponentNameFromType(this.type);
          didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error(
            "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
          ));
          componentName = this.props.ref;
          return void 0 !== componentName ? componentName : null;
        }
        function ReactElement(type, key, props, owner, debugStack, debugTask) {
          var refProp = props.ref;
          type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type,
            key,
            props,
            _owner: owner
          };
          null !== (void 0 !== refProp ? refProp : null) ? Object.defineProperty(type, "ref", {
            enumerable: false,
            get: elementRefGetterWithDeprecationWarning
          }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
          type._store = {};
          Object.defineProperty(type._store, "validated", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: 0
          });
          Object.defineProperty(type, "_debugInfo", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: null
          });
          Object.defineProperty(type, "_debugStack", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: debugStack
          });
          Object.defineProperty(type, "_debugTask", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: debugTask
          });
          Object.freeze && (Object.freeze(type.props), Object.freeze(type));
          return type;
        }
        function jsxDEVImpl(type, config, maybeKey, isStaticChildren, debugStack, debugTask) {
          var children = config.children;
          if (void 0 !== children)
            if (isStaticChildren)
              if (isArrayImpl(children)) {
                for (isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)
                  validateChildKeys(children[isStaticChildren]);
                Object.freeze && Object.freeze(children);
              } else
                console.error(
                  "React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead."
                );
            else validateChildKeys(children);
          if (hasOwnProperty.call(config, "key")) {
            children = getComponentNameFromType(type);
            var keys = Object.keys(config).filter(function(k5) {
              return "key" !== k5;
            });
            isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
            didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error(
              'A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />',
              isStaticChildren,
              children,
              keys,
              children
            ), didWarnAboutKeySpread[children + isStaticChildren] = true);
          }
          children = null;
          void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
          hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
          if ("key" in config) {
            maybeKey = {};
            for (var propName in config)
              "key" !== propName && (maybeKey[propName] = config[propName]);
          } else maybeKey = config;
          children && defineKeyPropWarningGetter(
            maybeKey,
            "function" === typeof type ? type.displayName || type.name || "Unknown" : type
          );
          return ReactElement(
            type,
            children,
            maybeKey,
            getOwner(),
            debugStack,
            debugTask
          );
        }
        function validateChildKeys(node) {
          isValidElement(node) ? node._store && (node._store.validated = 1) : "object" === typeof node && null !== node && node.$$typeof === REACT_LAZY_TYPE && ("fulfilled" === node._payload.status ? isValidElement(node._payload.value) && node._payload.value._store && (node._payload.value._store.validated = 1) : node._store && (node._store.validated = 1));
        }
        function isValidElement(object) {
          return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        var React2 = require_react(), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = React2.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray, createTask = console.createTask ? console.createTask : function() {
          return null;
        };
        React2 = {
          react_stack_bottom_frame: function(callStackForError) {
            return callStackForError();
          }
        };
        var specialPropKeyWarningShown;
        var didWarnAboutElementRef = {};
        var unknownOwnerDebugStack = React2.react_stack_bottom_frame.bind(
          React2,
          UnknownOwner
        )();
        var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
        var didWarnAboutKeySpread = {};
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.jsx = function(type, config, maybeKey) {
          var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
          return jsxDEVImpl(
            type,
            config,
            maybeKey,
            false,
            trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
            trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask
          );
        };
        exports.jsxs = function(type, config, maybeKey) {
          var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
          return jsxDEVImpl(
            type,
            config,
            maybeKey,
            true,
            trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
            trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask
          );
        };
      })();
    }
  });

  // node_modules/.pnpm/react@19.2.0/node_modules/react/jsx-runtime.js
  var require_jsx_runtime = __commonJS({
    "node_modules/.pnpm/react@19.2.0/node_modules/react/jsx-runtime.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_react_jsx_runtime_development();
      }
    }
  });

  // src/index.ts
  var import_reflect_metadata = __toESM(require_Reflect());

  // node_modules/.pnpm/zois-core@1.1.8/node_modules/zois-core/dist/styles.css
  var styles_default = '*{margin:0;padding:0;box-sizing:border-box}.zcButton{cursor:pointer;background:var(--tmd-element, white);color:var(--tmd-text, black);border:2px solid var(--tmd-accent, black);border-radius:4px}.zcButton:hover{background:var(--tmd-element-hover, #ebf7fe);border-color:var(--tmd-accent-hover, #7dd3fc);color:var(--tmd-accent-hover, #015a8c)}.zcButton .tooltip{position:absolute;color:#000;text-align:center;padding:4px;border-radius:4px;background:#ff8;border:2px solid #e7e787;width:max-content;min-height:100%;visibility:hidden;z-index:10}.zcButton .tooltip[position=left]{right:calc(100% + 1vw)}.zcButton .tooltip[position=right]{left:calc(100% + 1vw)}.zcButton:hover .tooltip{visibility:visible}.zcButton[data-zc-style=green]{background:#7cff7c;border-color:#52cc52;color:#000}.zcButton[data-zc-style=green]:hover{background:#5ec55e;color:#000}.zcButton[data-zc-style=inverted]{background:var(--tmd-accent, #303030);border:none;color:var(--tmd-text, white)}.zcButton[data-zc-style=inverted]:hover{background:var(--tmd-accent-hover, #474747)}.zcInput{background:var(--tmd-element, white);color:var(--tmd-text, black);padding:2vw;border:2px solid var(--tmd-accent, black);border-radius:4px}.zcInput::placeholder{color:var(--tmd-text, black)}.zcBackNextButton{display:flex;column-gap:2vw;justify-content:center;align-items:center;background:var(--tmd-element, white);color:var(--tmd-text, black);border:2px solid var(--tmd-accent, black);border-radius:4px}.zcBackNextButton-btnDisabled{background:#ffa590;pointer-events:none}.zcTabs{display:flex}.zcTabs button{cursor:pointer;width:100%;color:var(--tmd-text, black);background:none;border:none;border-bottom:2px solid var(--tmd-element, rgb(214, 214, 214));padding:.25em}.zcTabs button[data-opened=true]{font-weight:700;border-bottom:2px solid var(--tmd-accent, rgb(81, 81, 231))!important}.zcTabs button:hover{background:var(--tmd-element, rgb(235, 235, 235));border-bottom:2px solid var(--tmd-element-hover, rgb(149, 149, 149))}.zcCard{border:2px solid var(--tmd-accent, rgb(195, 195, 195));border-radius:.4em;background:var(--tmd-element, white);color:var(--tmd-text, black);padding:.4em 2.5em .4em .4em}.zcCard:hover{border:2px solid var(--tmd-accent-hover, rgb(170, 170, 170))}.zcCard_name{font-size:.5em;color:var(--tmd-text, rgb(100, 100, 100))}.zcCard_value{color:var(--tmd-text, black);margin-top:.4em;font-weight:700}.zcSelect{cursor:pointer;background:var(--tmd-element, white);color:var(--tmd-text, black);border:2px solid var(--tmd-accent, rgb(195, 195, 195));border-radius:.4em;padding:.45em;z-index:10}.zcSelect[opened=true]{border-color:var(--tmd-accent-hover, rgb(0, 96, 223))}.zcSelect[opened=false]:hover{border-color:var(--tmd-accent-hover, rgb(170, 170, 170))}.zcSelect>svg{position:absolute;right:.45em;top:50%;transform:translateY(-50%);width:1.5em;height:1.5em;color:var(--tmd-accent, rgb(0, 96, 223))}.zcSelect>div[data-zc-position=bottom]{position:absolute;top:calc(100% + .45em);left:0;width:100%;background:var(--tmd-element, #f6f6f6);border:2px solid var(--tmd-element-hover, rgb(235 235 235));border-radius:.4em}.zcSelect>div[data-zc-position=top]{position:absolute;bottom:calc(100% + .45em);left:0;width:100%;background:var(--tmd-element, #f6f6f6ed);border:2px solid var(--tmd-element-hover, rgb(235 235 235));border-radius:.4em}.zcSelect>div>div{color:var(--tmd-text, black);width:100%;padding:.45em;border-radius:.25em}.zcSelect>div>div>svg{width:1.25em;height:1.25em;color:var(--tmd-accent, rgb(0, 96, 223))}.zcSelect>div>div:hover{background:var(--tmd-element-hover, #ededed)}.zcToastsContainer{display:flex;flex-direction:column;gap:.25vw;cursor:pointer;position:fixed;z-index:30}@keyframes zcToast-progress{0%{width:0}to{width:100%}}@keyframes zcSlideInFromLeft{0%{transform:translate(-100%);opacity:0}to{transform:translate(0);opacity:1}}@keyframes zcSlideOutToLeft{0%{transform:translate(0);opacity:1}to{transform:translate(-100%);opacity:0}}.zcToast{max-width:25vw;animation:zcSlideInFromLeft .3s ease-out forwards}.zcToast.exiting{animation:zcSlideOutToLeft .3s ease-out forwards}.zcToast p{color:#fff}dialog[data-zc-dialog-type=choice_multiple] .zcDialogBtn:before{content:"";position:absolute;left:1vw;top:50%;transform:translateY(-50%);border:2px solid white;width:.5em;aspect-ratio:1/1;border-radius:50%}dialog[data-zc-dialog-type=choice_multiple] .zcDialogBtn[data-zc-picked=true]:before{background:#fff}.zcDialogBtn{cursor:pointer;background:#ffffff17;border:none;font-size:clamp(6px,2vw,24px);color:#fff;padding:.2em;border-radius:.5em}.zcDialogBtn:hover{background:#ffffff24}@keyframes zcSpin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}@keyframes zcCursorBlink{0%{border-right-color:transparent}to{border-right-color:#2a2a2a}}.zcCursor{border-right:2px solid var(--tmd-text, rgb(42, 42, 42));width:fit-content}.zcDisabled{pointer-events:none;opacity:.6}\n';

  // node_modules/.pnpm/zois-core@1.1.8/node_modules/zois-core/dist/modsApi.js
  var import_bondage_club_mod_sdk = __toESM(require_bcmodsdk());

  // node_modules/.pnpm/lucide@0.541.0/node_modules/lucide/dist/esm/defaultAttributes.js
  var defaultAttributes = {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    "stroke-width": 2,
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  };

  // node_modules/.pnpm/lucide@0.541.0/node_modules/lucide/dist/esm/createElement.js
  var createSVGElement = ([tag, attrs, children]) => {
    const element = document.createElementNS("http://www.w3.org/2000/svg", tag);
    Object.keys(attrs).forEach((name) => {
      element.setAttribute(name, String(attrs[name]));
    });
    if (children?.length) {
      children.forEach((child) => {
        const childElement = createSVGElement(child);
        element.appendChild(childElement);
      });
    }
    return element;
  };
  var createElement = (iconNode, customAttrs = {}) => {
    const tag = "svg";
    const attrs = {
      ...defaultAttributes,
      ...customAttrs
    };
    return createSVGElement([tag, attrs, iconNode]);
  };

  // node_modules/.pnpm/lucide@0.541.0/node_modules/lucide/dist/esm/icons/check.js
  var Check = [["path", { d: "M20 6 9 17l-5-5" }]];

  // node_modules/.pnpm/lucide@0.541.0/node_modules/lucide/dist/esm/icons/chevron-down.js
  var ChevronDown = [["path", { d: "m6 9 6 6 6-6" }]];

  // node_modules/.pnpm/lucide@0.541.0/node_modules/lucide/dist/esm/icons/circle-x.js
  var CircleX = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["path", { d: "m15 9-6 6" }],
    ["path", { d: "m9 9 6 6" }]
  ];

  // node_modules/.pnpm/lucide@0.541.0/node_modules/lucide/dist/esm/icons/trash-2.js
  var Trash2 = [
    ["path", { d: "M10 11v6" }],
    ["path", { d: "M14 11v6" }],
    ["path", { d: "M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6" }],
    ["path", { d: "M3 6h18" }],
    ["path", { d: "M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" }]
  ];

  // node_modules/.pnpm/zois-core@1.1.8/node_modules/zois-core/dist/modules.js
  var r = class {
    overrideProperties(e2, t3) {
      return e2;
    }
    layoutEffect(e2, t3) {
    }
    effect(e2, t3) {
    }
  };

  // node_modules/.pnpm/zois-core@1.1.8/node_modules/zois-core/dist/ui-modules/centerModule.js
  var l = class extends r {
    overrideProperties(e2) {
      return e2.element.style.cssText += "transform: translate(-50%, -50%);", e2.x = 1e3, e2.y = 500, e2;
    }
  };

  // node_modules/.pnpm/zois-core@1.1.8/node_modules/zois-core/dist/ui-modules/counterUpModule.js
  function f(n4, a5, r5, e2) {
    if (!n4) throw new Error("Element not found");
    let s5 = 0, o5, t3;
    const i5 = (m4) => {
      o5 || (o5 = m4);
      const l6 = m4 - o5;
      let u6 = Math.min(l6 / r5, 1);
      const c7 = u6 * (2 - u6), p5 = parseInt(s5 + (a5 - s5) * c7);
      n4.textContent = typeof e2 == "function" ? e2(p5) : p5.toString(), u6 < 1 && (t3 = requestAnimationFrame(i5));
    };
    t3 && cancelAnimationFrame(t3), t3 = requestAnimationFrame(i5);
  }
  var x = class extends r {
    constructor(r5) {
      super();
      this.props = r5;
    }
    effect(r5, e2) {
      f(e2, this.props.endValue, this.props.duration, this.props.formattingFunction);
    }
  };

  // node_modules/.pnpm/zois-core@1.1.8/node_modules/zois-core/dist/ui-modules/typeModule.js
  function l2(e2, o5) {
    if (!e2) throw new Error("Element not found");
    const t3 = e2.textContent;
    e2.textContent = "\xA0", e2.classList.add("zcCursor");
    let r5, n4;
    const s5 = (u6) => {
      r5 || (r5 = u6);
      const c7 = u6 - r5;
      let a5 = Math.min(c7 / o5, 1);
      const i5 = t3.slice(0, parseInt(t3.length * a5));
      i5.trim() !== "" && (e2.textContent = i5), a5 < 1 ? n4 = requestAnimationFrame(s5) : setTimeout(() => e2.classList.remove("zcCursor"), o5 / t3.length);
    };
    n4 = requestAnimationFrame(s5);
  }
  var x2 = class extends r {
    constructor(t3) {
      super();
      this.props = t3;
    }
    effect(t3, r5) {
      l2(r5, this.props.duration);
    }
  };

  // node_modules/.pnpm/zois-core@1.1.8/node_modules/zois-core/dist/ui-modules/styleModule.js
  var u = class extends r {
    constructor(o5) {
      super();
      this.style = o5;
    }
    applyStyle(o5, t3) {
      for (const e2 of Object.keys(t3)) !isNaN(e2) || typeof t3[e2] == "function" || (o5.style[e2] = t3[e2]);
    }
    layoutEffect(o5, t3) {
      this.applyStyle(t3, this.style);
    }
  };

  // node_modules/.pnpm/zois-core@1.1.8/node_modules/zois-core/dist/ui-modules/dynamicClassModule.js
  var y = class extends r {
    constructor(t3) {
      super();
      this.style = t3;
    }
    layoutEffect(t3, e2) {
      Q(e2, this.style);
    }
  };

  // node_modules/.pnpm/zois-core@1.1.8/node_modules/zois-core/dist/ui-modules/attributesModule.js
  var c = class extends r {
    constructor(e2) {
      super();
      this.attributes = e2;
    }
    layoutEffect(e2, r5) {
      for (const t3 of Object.keys(this.attributes)) r5.setAttribute(t3, this.attributes[t3]);
    }
  };

  // node_modules/.pnpm/zois-core@1.1.8/node_modules/zois-core/dist/ui-modules/clickModule.js
  var i = class extends r {
    constructor(t3) {
      super();
      this.callback = t3;
    }
    layoutEffect(t3, e2) {
      e2.addEventListener("click", () => this.callback(e2));
    }
  };

  // node_modules/.pnpm/zois-core@1.1.8/node_modules/zois-core/dist/ui.js
  function D(b3) {
    return b3 * (MainCanvas.canvas.clientHeight / 1e3);
  }
  function P(b3) {
    return b3 * (MainCanvas.canvas.clientWidth / 2e3);
  }
  function V(b3, e2 = "top") {
    const o5 = MainCanvas.canvas.clientHeight / 1e3;
    return e2 === "top" ? MainCanvas.canvas.offsetTop + b3 * o5 : window.innerHeight - (MainCanvas.canvas.offsetTop + MainCanvas.canvas.clientHeight) + b3 * o5;
  }
  function R(b3, e2 = "left") {
    const o5 = MainCanvas.canvas.clientWidth / 2e3;
    return e2 === "left" ? MainCanvas.canvas.offsetLeft + b3 * o5 : window.innerWidth - (MainCanvas.canvas.offsetLeft + MainCanvas.canvas.clientWidth) + b3 * o5;
  }
  function O(b3, e2, o5, l6 = "top-left") {
    const i5 = l6 === "top-left" || l6 === "top-right" ? "top" : "bottom", n4 = l6 === "top-left" || l6 === "bottom-left" ? "left" : "right", t3 = V(o5, i5), m4 = R(e2, n4);
    Object.assign(b3.style, { position: "fixed", [n4]: m4 + "px", [i5]: t3 + "px" });
  }
  function j(b3, e2) {
    const o5 = MainCanvas.canvas.clientWidth, l6 = MainCanvas.canvas.clientHeight, i5 = Math.min(o5, l6) / 100, n4 = e2 * i5;
    Object.assign(b3.style, { fontSize: n4 + "px" });
  }
  function L(b3, e2) {
    b3.style.fontFamily = e2 ?? "sans-serif";
  }
  function G(b3, e2) {
    const o5 = MainCanvas.canvas.clientWidth, l6 = MainCanvas.canvas.clientHeight, i5 = Math.min(o5, l6) / 100, n4 = e2 * i5;
    Object.assign(b3.style, { padding: n4 + "px" });
  }
  function X(b3) {
    const e2 = MainCanvas.canvas.clientWidth <= MainCanvas.canvas.clientHeight * 2 ? MainCanvas.canvas.clientWidth / 50 : MainCanvas.canvas.clientHeight / 25;
    Object.assign(b3.style, { fontSize: e2 + "px" });
  }
  var B = [];
  function _(b3) {
    const e2 = (o5) => o5 ? JSON.stringify(Object.keys(o5).sort().reduce((l6, i5) => (l6[i5] = o5[i5], l6), {})) : "null";
    return `base:${e2(b3.base)}|hover:${e2(b3.hover)}|active:${e2(b3.active)}|before:${e2(b3.before)}|after:${e2(b3.after)}`;
  }
  function Q(b3, e2) {
    const o5 = _(e2), l6 = B.find((h7) => h7.key === o5);
    if (l6) return b3.classList.add(l6.className);
    let i5;
    do
      i5 = "dynamic-" + Math.random().toString(36).substring(2, 10);
    while (B.find((h7) => h7.className === i5));
    B.push({ key: o5, className: i5 });
    const n4 = (h7, f6) => {
      let d6 = `${h7} {`;
      for (const [r5, c7] of Object.entries(f6)) d6 += `${r5.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, "$1-$2").toLowerCase()}: ${c7};`;
      return d6 += "}", d6;
    };
    let t3 = "";
    e2.base && (t3 += n4(`.${i5}`, e2.base)), e2.hover && (t3 += n4(`.${i5}:hover`, e2.hover)), e2.active && (t3 += n4(`.${i5}:active`, e2.active)), e2.focus && (t3 += n4(`.${i5}:focus`, e2.focus)), e2.disabled && (t3 += n4(`.${i5}:disabled`, e2.disabled)), e2.before && (t3 += n4(`.${i5}:before`, e2.before)), e2.after && (t3 += n4(`.${i5}:after`, e2.after));
    let m4 = document.getElementById(`${c2.key ?? ""}-dynamic-classes`);
    m4 ? m4.textContent += t3 : (m4 = document.createElement("style"), m4.id = `${c2.key ?? ""}-dynamic-classes`, m4.textContent = t3, document.head.appendChild(m4)), b3.classList.add(i5);
  }
  function U() {
    $(w);
  }
  function $(b3) {
    w = k, k = b3, k && k.load(), w && w.unload();
  }
  function ee() {
    return k;
  }
  var k;
  var w = null;
  var te = class {
    htmlElements = [];
    resizeEventListeners = [];
    tabHandlers = {};
    addElement(e2, { x: o5, y: l6, width: i5, height: n4, padding: t3, fontSize: m4 = "auto", anchor: h7, place: f6, modules: d6 = {}, modulesMap: r5 }) {
      L(e2, c2.fontFamily);
      const c7 = { anchor: h7, x: o5, y: l6, width: i5, height: n4, padding: t3, fontSize: m4, place: f6, element: e2 };
      Object.keys(d6)?.forEach((s5) => {
        d6[s5].forEach((p5) => {
          const u6 = p5.overrideProperties(c7, r5[s5]);
          h7 = u6.anchor, o5 = u6.x, l6 = u6.y, i5 = u6.width, n4 = u6.height, t3 = u6.padding, m4 = u6.fontSize, f6 = u6.place, e2 = u6.element;
        });
      });
      const a5 = () => {
        typeof o5 == "number" && typeof l6 == "number" && O(e2, o5, l6, h7), m4 === "auto" ? X(e2) : j(e2, m4), t3 && G(e2, t3), i5 && (e2.style.width = P(i5) + "px"), n4 && (e2.style.height = D(n4) + "px");
      };
      a5(), window.addEventListener("resize", a5), Object.keys(d6)?.forEach((s5) => {
        d6[s5].forEach((p5) => {
          p5.layoutEffect(c7, r5[s5]);
        });
      }), f6 && document.body.append(e2), this.resizeEventListeners.push(a5), this.htmlElements.push(e2), Object.keys(d6)?.forEach((s5) => {
        d6[s5].forEach((p5) => {
          p5.effect(c7, r5[s5]);
        });
      });
    }
    get currentSubscreen() {
      return k;
    }
    get previousSubscreen() {
      return w;
    }
    get name() {
      return "";
    }
    run() {
      this.tabHandlers.run?.();
    }
    load() {
      this.createButton({ x: 1815, y: 75, width: 90, height: 90, icon: "Icons/Exit.png", modules: { base: [new u({ zIndex: "10" })] } }).addEventListener("click", () => this.exit()), this.name && (this.createText({ text: this.name, x: 100, y: 60, fontSize: 8 }).style.cssText += "max-width: 85%; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; padding: 0.1em;"), M[this.constructor.name] && M[this.name].forEach((e2) => e2(this));
    }
    unload() {
      this.tabHandlers.unload?.(), this.htmlElements.forEach((e2) => {
        e2.remove();
      }), this.resizeEventListeners.forEach((e2) => {
        removeEventListener("resize", e2);
      });
    }
    click() {
    }
    exit() {
      this.tabHandlers.exit?.(), this.setSubscreen(this.previousSubscreen);
    }
    update() {
    }
    setPreviousSubscreen() {
      U();
    }
    setSubscreen(e2) {
      $(e2);
    }
    createButton({ text: e2, x: o5, y: l6, width: i5, height: n4, fontSize: t3 = "auto", anchor: m4 = "top-left", padding: h7, style: f6 = "default", place: d6 = true, icon: r5, iconAbsolutePosition: c7 = true, tooltip: a5, onClick: s5, isDisabled: p5, modules: u6 }) {
      let g6, v4;
      const y5 = document.createElement("button");
      if (y5.classList.add("zcButton"), y5.setAttribute("data-zc-style", f6), y5.style.display = "flex", y5.style.alignItems = "center", y5.style.justifyContent = "center", y5.style.columnGap = "1.25vw", L(y5, c2.fontFamily), r5 && (typeof r5 == "string" ? (g6 = document.createElement("img"), g6.src = r5) : g6 = r5, g6.style.height = "80%", g6.style.width = "auto", e2 && c7 && (g6.style.position = "absolute", g6.style.left = "1vw"), e2 && !c7 && (y5.style.justifyContent = ""), y5.append(g6)), e2 && (v4 = document.createElement("span"), v4.textContent = e2, y5.append(v4)), a5) {
        const S4 = document.createElement("span");
        S4.classList.add("tooltip"), S4.setAttribute("position", a5.position), S4.textContent = a5.text, y5.append(S4);
      }
      return typeof p5 == "function" && p5() && y5.classList.add("zcDisabled"), y5.addEventListener("click", () => {
        if (typeof p5 == "function" && p5()) return y5.classList.add("zcDisabled");
        typeof s5 == "function" && s5();
      }), this.addElement(y5, { x: o5, y: l6, width: i5, height: n4, anchor: m4, place: d6, fontSize: t3, padding: h7, modules: u6, modulesMap: { base: y5, text: v4, icon: g6 } }), y5;
    }
    createText({ text: e2, color: o5, x: l6, y: i5, width: n4, height: t3, withBackground: m4 = false, withBorder: h7 = false, fontSize: f6 = "auto", anchor: d6 = "top-left", padding: r5, place: c7 = true, modules: a5 }) {
      const s5 = document.createElement("p");
      return s5.innerHTML = e2, s5.style.color = o5 ?? "var(--tmd-text, black)", m4 && (s5.style.background = "var(--tmd-element,rgb(239, 239, 239))"), h7 && (s5.style.border = "2px solid var(--tmd-accent, rgb(236, 236, 236))"), L(s5, c2.fontFamily), this.addElement(s5, { x: l6, y: i5, width: n4, height: t3, anchor: d6, place: c7, fontSize: f6, padding: r5, modules: a5, modulesMap: { base: s5 } }), s5;
    }
    createInput({ value: e2, placeholder: o5, x: l6, y: i5, width: n4, height: t3, textArea: m4 = false, fontSize: h7 = "auto", anchor: f6 = "top-left", padding: d6, place: r5 = true, onChange: c7, onInput: a5, isDisabled: s5, modules: p5 }) {
      const u6 = document.createElement(m4 ? "textarea" : "input");
      return u6.classList.add("zcInput"), o5 && (u6.placeholder = o5), e2 && (u6.value = e2), L(u6, c2.fontFamily), typeof s5 == "function" && s5() && u6.classList.add("zcDisabled"), u6.addEventListener("change", () => {
        if (typeof s5 == "function" && s5()) return u6.classList.add("zcDisabled");
        typeof c7 == "function" && c7();
      }), u6.addEventListener("input", () => {
        if (typeof s5 == "function" && s5()) return u6.classList.add("zcDisabled");
        typeof a5 == "function" && a5();
      }), this.addElement(u6, { x: l6, y: i5, width: n4, height: t3, anchor: f6, place: r5, fontSize: h7, padding: d6, modules: p5, modulesMap: { base: u6 } }), u6;
    }
    createCheckbox({ text: e2, x: o5, y: l6, isChecked: i5, width: n4, modules: t3, anchor: m4 = "top-left", place: h7 = true, isDisabled: f6, onChange: d6 }) {
      const r5 = document.createElement("div");
      r5.style.display = "flex", r5.style.alignItems = "center", r5.style.columnGap = "1vw";
      const c7 = document.createElement("input");
      c7.type = "checkbox", c7.checked = i5, c7.style.borderRadius = "min(0.8dvh, 0.3dvw)", c7.style.aspectRatio = "1/1", c7.classList.add("zcCheckbox", "checkbox");
      const a5 = document.createElement("p");
      return a5.textContent = e2, a5.style.color = "var(--tmd-text, black)", L(a5, c2.fontFamily), typeof f6 == "function" && f6() && r5.classList.add("zcDisabled"), r5.addEventListener("change", () => {
        if (typeof f6 == "function" && f6()) return r5.classList.add("zcDisabled");
        typeof d6 == "function" && d6();
      }), r5.append(c7, a5), this.addElement(r5, { x: o5, y: l6, width: n4, anchor: m4, place: h7, modules: t3, modulesMap: { base: r5, checkbox: c7, label: a5 } }), r5;
    }
    createScrollView({ scroll: e2, x: o5, y: l6, width: i5, height: n4, anchor: t3 = "top-left", modules: m4, place: h7 = true }) {
      const f6 = document.createElement("div");
      return e2 === "all" && (f6.style.overflow = "scroll"), e2 === "x" && (f6.style.overflowX = "scroll"), e2 === "y" && (f6.style.overflowY = "scroll"), this.addElement(f6, { x: o5, y: l6, width: i5, height: n4, anchor: t3, place: h7, modules: m4, modulesMap: { base: f6 } }), f6;
    }
    createInputList({ x: e2, y: o5, width: l6, height: i5, title: n4, value: t3, modules: m4, anchor: h7 = "top-left", place: f6 = true, numbersOnly: d6 = false, isDisabled: r5, onChange: c7 }) {
      const a5 = [], s5 = document.createElement("div");
      s5.style.cssText = `
        display: flex; flex-direction: column; gap: 1vw; border: 2px solid var(--tmd-accent, black);
        border-radius: 4px; padding: 0.75vw; background: var(--tmd-element, none);
        `, L(s5, c2.fontFamily);
      const p5 = document.createElement("div");
      p5.style.cssText = "display: flex; justify-content: center; column-gap: 1vw; width: 100%;";
      const u6 = document.createElement("b");
      u6.textContent = n4 + ":", u6.style.cssText = "width: 100%; font-size: clamp(10px, 2.4vw, 24px); color: var(--tmd-text, black);";
      const g6 = document.createElement("div");
      g6.style.cssText = `display: flex; gap: 1vw; flex-wrap: wrap; align-content: flex-start;
        overflow-y: scroll;`;
      const v4 = document.createElement("input");
      v4.style.cssText = "border: none; outline: none; background: none; height: fit-content; flex-grow: 1; padding: 0.8vw; width: 6vw; font-size: clamp(8px, 2vw, 20px);";
      const y5 = (x5, E4) => {
        const A4 = this.createButton({ icon: x5, place: false, onClick: E4, style: "default", modules: { icon: [new u({ width: "70%", height: "70%" })] } });
        A4.style.width = "2em", A4.style.aspectRatio = "1/1", p5.append(A4);
      }, S4 = (x5) => {
        const E4 = document.createElement("div");
        E4.style.cssText = "cursor: pointer; background: var(--tmd-element-hover, rgb(206, 206, 206)); color: var(--tmd-text, black); height: fit-content; padding: 0.8vw; border-radius: 0.8vw; font-size: clamp(8px, 2vw, 20px);", E4.textContent = x5, g6.insertBefore(E4, v4), E4.addEventListener("click", (A4) => {
          E4.style.border === "" ? E4.style.border = "2px solid red" : E4.style.border = "", A4.stopPropagation();
        }), a5.push(x5);
      };
      return y5(createElement(CircleX), () => {
        if (typeof r5 == "function" && r5()) return s5.classList.add("zcDisabled");
        g6.innerHTML = "", a5.splice(0, a5.length), g6.append(v4), t3.forEach((x5) => S4(String(x5))), typeof c7 == "function" && c7(d6 ? a5.map((x5) => parseInt(x5)) : a5);
      }), y5(createElement(Trash2), () => {
        if (typeof r5 == "function" && r5()) return s5.classList.add("zcDisabled");
        for (const x5 of [...g6.children]) x5.getAttribute("style").includes("border: 2px solid red;") && (a5.splice(a5.indexOf(x5.textContent), 1), x5.remove());
        typeof c7 == "function" && c7(d6 ? a5.map((x5) => parseInt(x5)) : a5);
      }), typeof r5 == "function" && r5() && s5.classList.add("zcDisabled"), v4.addEventListener("keypress", (x5) => {
        if (document.activeElement === v4) switch (x5.key) {
          case "Enter":
            if (d6 && Number.isNaN(parseInt(v4.value)) || v4.value.trim() === "") return;
            if (typeof r5 == "function" && r5()) return s5.classList.add("zcDisabled");
            S4(v4.value), v4.value = "", typeof c7 == "function" && c7(d6 ? a5.map((E4) => parseInt(E4)) : a5);
            break;
        }
      }), s5.addEventListener("click", (x5) => {
        x5.currentTarget == s5 && v4.focus();
      }), g6.append(v4), s5.append(p5, u6, g6), this.addElement(s5, { x: e2, y: o5, width: l6, height: i5, anchor: h7, place: f6, modules: m4, modulesMap: { base: s5, input: v4 } }), t3.forEach((x5) => S4(String(x5))), s5;
    }
    createImage({ x: e2, y: o5, width: l6, src: i5, place: n4 = true, anchor: t3 = "top-left", modules: m4 }) {
      const h7 = document.createElement("img");
      return h7.style.height = "auto", h7.src = i5, this.addElement(h7, { x: e2, y: o5, width: l6, height: 0, anchor: t3, place: n4, modules: m4, modulesMap: { base: h7 } }), h7;
    }
    createSvg({ x: e2, y: o5, size: l6, dataurl: i5, place: n4 = true, anchor: t3 = "top-left", fill: m4 = "var(--tmd-accent, black)", stroke: h7 = "var(--tmd-accent-hover, black)", strokeWidth: f6 = "2px", modules: d6 }) {
      function r5(s5) {
        const p5 = s5.replace("data:image/svg+xml,", ""), u6 = decodeURIComponent(p5), g6 = document.createElement("div");
        return g6.innerHTML = u6, g6.firstElementChild;
      }
      function c7(s5, { fill: p5, stroke: u6 }) {
        return s5.querySelectorAll("*").forEach((v4) => {
          v4.getAttribute("fill") !== "none" && v4.setAttribute("fill", p5), v4.getAttribute("stroke") !== "none" && v4.setAttribute("stroke", u6);
        }), s5.getAttribute("fill") !== "none" && s5.setAttribute("fill", p5), s5.getAttribute("stroke") !== "none" && s5.setAttribute("stroke", u6), s5;
      }
      const a5 = r5(i5);
      return c7(a5, { fill: m4, stroke: h7 }), a5.setAttribute("stroke-width", f6), this.addElement(a5, { x: e2, y: o5, width: l6, height: l6, anchor: t3, place: n4, modules: d6, modulesMap: { base: a5 } }), a5;
    }
    createBackNextButton({ x: e2, y: o5, width: l6, height: i5, items: n4, currentIndex: t3, modules: m4, isBold: h7 = false, anchor: f6 = "top-left", place: d6 = true, onChange: r5, isDisabled: c7 }) {
      const a5 = document.createElement("div");
      a5.classList.add("zcBackNextButton"), L(a5, c2.fontFamily);
      const s5 = () => {
        t3 === 0 || typeof c7 == "function" && c7(n4[t3 - 1][1]) ? p5.classList.add("zcBackNextButton-btnDisabled") : p5.classList.remove("zcBackNextButton-btnDisabled"), t3 === n4.length - 1 || typeof c7 == "function" && c7(n4[t3 + 1][1]) ? u6.classList.add("zcBackNextButton-btnDisabled") : u6.classList.remove("zcBackNextButton-btnDisabled");
      }, p5 = document.createElement("button");
      p5.style.cssText = `
        position: absolute; left: 1vw; font-size: 3.5vw; aspect-ratio: 1/1;
        height: 140%; background-image: url("Icons/Prev.png"); background-size: 100%;
        `, p5.classList.add("zcButton"), p5.addEventListener("click", () => {
        if (t3 === 0 || typeof c7 == "function" && c7(n4[t3 - 1][1])) return p5.classList.add("zcDisabled");
        t3--, g6.textContent = n4[t3][0], typeof r5 == "function" && r5(n4[t3][1]), s5();
      });
      const u6 = document.createElement("button");
      u6.style.cssText = `
        position: absolute; right: 1vw; font-size: 3.5vw; aspect-ratio: 1/1;
        height: 140%; background-image: url("Icons/Next.png"); background-size: 100%;
        `, u6.classList.add("zcButton"), u6.addEventListener("click", () => {
        if (t3 === n4.length - 1 || typeof c7 == "function" && c7(n4[t3 + 1][1])) return u6.classList.add("zcDisabled");
        t3++, g6.textContent = n4[t3][0], typeof r5 == "function" && r5(n4[t3][1]), s5();
      }), s5();
      const g6 = document.createElement("p");
      return h7 && (g6.style.fontWeight = "bold"), g6.textContent = n4[t3][0], a5.append(p5, g6, u6), this.addElement(a5, { x: e2, y: o5, width: l6, height: i5, anchor: f6, place: d6, modules: m4, modulesMap: { base: a5, backButton: p5, nextButton: u6, text: g6 } }), a5;
    }
    createTabs({ x: e2, y: o5, width: l6, tabs: i5, anchor: n4 = "top-left", place: t3 = true, currentTabName: m4, modules: h7 }) {
      let f6 = [];
      const d6 = document.createElement("div");
      return d6.classList.add("zcTabs"), L(d6, c2.fontFamily), i5.forEach((r5) => {
        const c7 = () => {
          for (const p5 of d6.children) p5.removeAttribute("data-opened");
          for (const p5 of f6) p5 instanceof Node && document.body.removeChild(p5);
          f6 = [], a5.setAttribute("data-opened", "true");
          const s5 = document.body.append.bind(document.body);
          document.body.append = (...p5) => {
            f6.push(...p5), s5(...p5);
          }, this.tabHandlers.unload?.(), this.tabHandlers.exit?.(), r5.load(), this.tabHandlers = { run: r5.run, load: r5.load, unload: r5.unload, exit: r5.exit }, document.body.append = s5;
        }, a5 = document.createElement("button");
        a5.textContent = r5.name, r5.name === m4 && c7(), a5.addEventListener("click", c7), d6.append(a5);
      }), this.addElement(d6, { x: e2, y: o5, width: l6, anchor: n4, place: t3, modules: h7, modulesMap: { base: d6 } }), d6;
    }
    drawPolylineArrow({ points: e2, strokeColor: o5 = S()?.base?.text ?? "black", lineWidth: l6 = 2, circleRadius: i5 = 5, circleColor: n4 = S()?.base?.text ?? "black" }) {
      if (e2.length < 2) return;
      const t3 = MainCanvas.canvas.getContext("2d");
      t3.save(), t3.strokeStyle = o5, t3.lineWidth = l6, t3.fillStyle = n4, t3.beginPath(), t3.moveTo(e2[0].x, e2[0].y);
      for (let m4 = 1; m4 < e2.length; m4++) t3.lineTo(e2[m4].x, e2[m4].y);
      t3.stroke(), t3.beginPath(), t3.arc(e2[0].x, e2[0].y, i5, 0, Math.PI * 2), t3.fill(), t3.beginPath(), t3.arc(e2[e2.length - 1].x, e2[e2.length - 1].y, i5, 0, Math.PI * 2), t3.fill(), t3.restore();
    }
    createCard({ x: e2, y: o5, name: l6, value: i5, icon: n4, anchor: t3 = "top-left", place: m4 = true, modules: h7 }) {
      const f6 = document.createElement("div");
      f6.classList.add("zcCard");
      const d6 = document.createElement("p");
      d6.classList.add("zcCard_name"), d6.textContent = l6;
      const r5 = document.createElement("p");
      return r5.classList.add("zcCard_value"), r5.textContent = `${i5}`, n4 && (n4.style.cssText += "position: absolute; top: 0.4em; right: 0.4em; width: 1.2em; height: 1.2em;", f6.append(n4)), f6.append(d6, r5), this.addElement(f6, { x: e2, y: o5, anchor: t3, place: m4, modules: h7, modulesMap: { name: d6, value: r5, base: f6, icon: null } }), f6;
    }
    createSelect({ x: e2, y: o5, width: l6, options: i5, currentOption: n4, anchor: t3 = "top-left", place: m4 = true, modules: h7, onChange: f6, isDisabled: d6 }) {
      let r5 = false, c7;
      const a5 = document.createElement("div");
      a5.classList.add("zcSelect"), a5.setAttribute("opened", false), a5.addEventListener("click", () => {
        if (d6 && d6()) return a5.classList.add("zcDisabled");
        r5 ? (r5 = false, c7.remove()) : (r5 = true, c7 = document.createElement("div"), c7.setAttribute("data-zc-position", typeof o5 == "number" && o5 > 500 - a5.offsetHeight / 2 ? "top" : "bottom"), i5.forEach((g6) => {
          const v4 = document.createElement("div");
          v4.style.cssText = "display: flex; align-items: center; column-gap: 0.5em;", g6.icon && (g6.icon.style.cssText = "color: #bcbcbc;", v4.append(g6.icon)), v4.append(g6.text), g6.name === n4 && v4.append(u6), v4.addEventListener("click", () => {
            n4 = g6.name, s5.textContent = g6.text, c7.remove(), f6 && f6(g6.name);
          }), c7.append(v4);
        }), a5.append(c7));
      });
      const s5 = document.createElement("p");
      s5.textContent = i5.find((g6) => g6.name === n4).text;
      const p5 = createElement(ChevronDown), u6 = createElement(Check);
      return u6.style.cssText = "position: absolute; right: 0.25em;", a5.append(s5, p5), d6 && d6() && a5.classList.add("zcDisabled"), this.addElement(a5, { x: e2, y: o5, width: l6, anchor: t3, place: m4, modules: h7, modulesMap: { base: a5 } }), a5;
    }
    createContainer({ x: e2, y: o5, anchor: l6 = "top-left", place: i5 = true, modules: n4 }) {
      const t3 = document.createElement("div");
      return this.addElement(t3, { x: e2, y: o5, anchor: l6, place: i5, modules: n4, modulesMap: { base: t3 } }), t3;
    }
  };
  var M = {};

  // node_modules/.pnpm/zois-core@1.1.8/node_modules/zois-core/dist/modsApi.js
  var d = ((n4) => (n4[n4.OBSERVE = 0] = "OBSERVE", n4[n4.ADD_BEHAVIOR = 1] = "ADD_BEHAVIOR", n4[n4.MODIFY_BEHAVIOR = 5] = "MODIFY_BEHAVIOR", n4[n4.OVERRIDE_BEHAVIOR = 10] = "OVERRIDE_BEHAVIOR", n4[n4.TOP = 100] = "TOP", n4))(d || {});
  var o;
  function T() {
    o = import_bondage_club_mod_sdk.default.registerMod({ name: c2.name, fullName: c2.fullName, version: c2.version, repository: c2.repository }), c3("GameKeyDown", 1, (e2, t3) => {
      const r5 = ee();
      return CommonKey.IsPressed(e2[0], "Escape") && r5 ? (r5.exit(), false) : t3(e2);
    });
  }
  function c3(e2, t3, r5) {
    if (!o) throw new Error("zois-core is not registered");
    return o.hookFunction(e2, t3, r5);
  }
  function h(e2, t3) {
    if (!o) throw new Error("zois-core is not registered");
    o.patchFunction(e2, t3);
  }
  function I(e2, t3, r5) {
    if (!o) throw new Error("zois-core is not registered");
    return o.callOriginal(e2, t3);
  }
  function E(e2) {
    return !!import_bondage_club_mod_sdk.default.getModsInfo().find((t3) => t3.name === e2);
  }

  // node_modules/.pnpm/zois-core@1.1.8/node_modules/zois-core/dist/popups.js
  var import_react4 = __toESM(require_react());
  var import_client = __toESM(require_client());

  // node_modules/.pnpm/zustand@5.0.8_react@19.2.0/node_modules/zustand/esm/vanilla.mjs
  var createStoreImpl = (createState) => {
    let state;
    const listeners = /* @__PURE__ */ new Set();
    const setState = (partial, replace) => {
      const nextState = typeof partial === "function" ? partial(state) : partial;
      if (!Object.is(nextState, state)) {
        const previousState = state;
        state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
        listeners.forEach((listener) => listener(state, previousState));
      }
    };
    const getState = () => state;
    const getInitialState = () => initialState;
    const subscribe = (listener) => {
      listeners.add(listener);
      return () => listeners.delete(listener);
    };
    const api = { setState, getState, getInitialState, subscribe };
    const initialState = state = createState(setState, getState, api);
    return api;
  };
  var createStore = ((createState) => createState ? createStoreImpl(createState) : createStoreImpl);

  // node_modules/.pnpm/zustand@5.0.8_react@19.2.0/node_modules/zustand/esm/react.mjs
  var import_react = __toESM(require_react(), 1);
  var identity = (arg) => arg;
  function useStore(api, selector = identity) {
    const slice = import_react.default.useSyncExternalStore(
      api.subscribe,
      import_react.default.useCallback(() => selector(api.getState()), [api, selector]),
      import_react.default.useCallback(() => selector(api.getInitialState()), [api, selector])
    );
    import_react.default.useDebugValue(slice);
    return slice;
  }
  var createImpl = (createState) => {
    const api = createStore(createState);
    const useBoundStore = (selector) => useStore(api, selector);
    Object.assign(useBoundStore, api);
    return useBoundStore;
  };
  var create = ((createState) => createState ? createImpl(createState) : createImpl);

  // node_modules/.pnpm/lucide-react@0.542.0_react@19.2.0/node_modules/lucide-react/dist/esm/createLucideIcon.js
  var import_react3 = __toESM(require_react());

  // node_modules/.pnpm/lucide-react@0.542.0_react@19.2.0/node_modules/lucide-react/dist/esm/shared/src/utils.js
  var toKebabCase = (string) => string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
  var toCamelCase = (string) => string.replace(
    /^([A-Z])|[\s-_]+(\w)/g,
    (match, p1, p22) => p22 ? p22.toUpperCase() : p1.toLowerCase()
  );
  var toPascalCase = (string) => {
    const camelCase = toCamelCase(string);
    return camelCase.charAt(0).toUpperCase() + camelCase.slice(1);
  };
  var mergeClasses = (...classes) => classes.filter((className, index, array) => {
    return Boolean(className) && className.trim() !== "" && array.indexOf(className) === index;
  }).join(" ").trim();
  var hasA11yProp = (props) => {
    for (const prop in props) {
      if (prop.startsWith("aria-") || prop === "role" || prop === "title") {
        return true;
      }
    }
  };

  // node_modules/.pnpm/lucide-react@0.542.0_react@19.2.0/node_modules/lucide-react/dist/esm/Icon.js
  var import_react2 = __toESM(require_react());

  // node_modules/.pnpm/lucide-react@0.542.0_react@19.2.0/node_modules/lucide-react/dist/esm/defaultAttributes.js
  var defaultAttributes2 = {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
  };

  // node_modules/.pnpm/lucide-react@0.542.0_react@19.2.0/node_modules/lucide-react/dist/esm/Icon.js
  var Icon = (0, import_react2.forwardRef)(
    ({
      color = "currentColor",
      size = 24,
      strokeWidth = 2,
      absoluteStrokeWidth,
      className = "",
      children,
      iconNode,
      ...rest
    }, ref) => (0, import_react2.createElement)(
      "svg",
      {
        ref,
        ...defaultAttributes2,
        width: size,
        height: size,
        stroke: color,
        strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size) : strokeWidth,
        className: mergeClasses("lucide", className),
        ...!children && !hasA11yProp(rest) && { "aria-hidden": "true" },
        ...rest
      },
      [
        ...iconNode.map(([tag, attrs]) => (0, import_react2.createElement)(tag, attrs)),
        ...Array.isArray(children) ? children : [children]
      ]
    )
  );

  // node_modules/.pnpm/lucide-react@0.542.0_react@19.2.0/node_modules/lucide-react/dist/esm/createLucideIcon.js
  var createLucideIcon = (iconName, iconNode) => {
    const Component = (0, import_react3.forwardRef)(
      ({ className, ...props }, ref) => (0, import_react3.createElement)(Icon, {
        ref,
        iconNode,
        className: mergeClasses(
          `lucide-${toKebabCase(toPascalCase(iconName))}`,
          `lucide-${iconName}`,
          className
        ),
        ...props
      })
    );
    Component.displayName = toPascalCase(iconName);
    return Component;
  };

  // node_modules/.pnpm/lucide-react@0.542.0_react@19.2.0/node_modules/lucide-react/dist/esm/icons/circle-alert.js
  var __iconNode = [
    ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
    ["line", { x1: "12", x2: "12", y1: "8", y2: "12", key: "1pkeuh" }],
    ["line", { x1: "12", x2: "12.01", y1: "16", y2: "16", key: "4dfq90" }]
  ];
  var CircleAlert = createLucideIcon("circle-alert", __iconNode);

  // node_modules/.pnpm/lucide-react@0.542.0_react@19.2.0/node_modules/lucide-react/dist/esm/icons/circle-check.js
  var __iconNode2 = [
    ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
    ["path", { d: "m9 12 2 2 4-4", key: "dzmm74" }]
  ];
  var CircleCheck = createLucideIcon("circle-check", __iconNode2);

  // node_modules/.pnpm/lucide-react@0.542.0_react@19.2.0/node_modules/lucide-react/dist/esm/icons/circle-x.js
  var __iconNode3 = [
    ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
    ["path", { d: "m15 9-6 6", key: "1uzhvr" }],
    ["path", { d: "m9 9 6 6", key: "z0biqf" }]
  ];
  var CircleX2 = createLucideIcon("circle-x", __iconNode3);

  // node_modules/.pnpm/lucide-react@0.542.0_react@19.2.0/node_modules/lucide-react/dist/esm/icons/info.js
  var __iconNode4 = [
    ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
    ["path", { d: "M12 16v-4", key: "1dtifu" }],
    ["path", { d: "M12 8h.01", key: "e9boi3" }]
  ];
  var Info = createLucideIcon("info", __iconNode4);

  // node_modules/.pnpm/zois-core@1.1.8/node_modules/zois-core/dist/popups.js
  var import_jsx_runtime = __toESM(require_jsx_runtime());
  function I2({ children: o5 }) {
    const [e2, t3] = (0, import_react4.useState)({}), r5 = window.ZOISCORE.useToastsStore((s5) => s5.clearToasts);
    return (0, import_react4.useEffect)(() => {
      const s5 = () => {
        t3({ fontFamily: CommonGetFontName(), bottom: V(5) + "px", left: R(5) + "px" });
      };
      return window.addEventListener("resize", s5), s5(), () => {
        window.removeEventListener("resize", s5);
      };
    }, []), (0, import_jsx_runtime.jsx)("div", { className: "zcToastsContainer", style: e2, onClick: () => {
      document.querySelectorAll(".zcToast").forEach((s5) => {
        s5.classList.add("exiting");
      }), setTimeout(r5, 300);
    }, children: o5 });
  }
  var P2 = ({ type: o5, theme: e2 }) => {
    switch (o5) {
      case "info":
        return (0, import_jsx_runtime.jsx)(Info, { style: { flexShrink: 0, width: "1.65em", height: "1.65em", fill: e2 ? e2.iconFillColor : "#addbff", stroke: e2 ? e2.iconStrokeColor : "#385073" } });
      case "success":
        return (0, import_jsx_runtime.jsx)(CircleCheck, { style: { flexShrink: 0, width: "1.65em", height: "1.65em", fill: e2 ? e2.iconFillColor : "#c3ffc3", stroke: e2 ? e2.iconStrokeColor : "#028f74" } });
      case "warning":
        return (0, import_jsx_runtime.jsx)(CircleAlert, { style: { flexShrink: 0, width: "1.65em", height: "1.65em", fill: e2 ? e2.iconFillColor : "#ffdfaf", stroke: e2 ? e2.iconStrokeColor : "#9c7633" } });
      case "error":
        return (0, import_jsx_runtime.jsx)(CircleX2, { style: { flexShrink: 0, width: "1.65em", height: "1.65em", fill: e2 ? e2.iconFillColor : "#ffb2b2", stroke: e2 ? e2.iconStrokeColor : "#7f2828" } });
      case "spinner":
        return (0, import_jsx_runtime.jsx)("div", { style: { flexShrink: 0, width: "1.65em", height: "1.65em", boxSizing: "border-box", border: "2px solid", borderRadius: "100%", borderColor: `transparent ${e2 ? e2.iconFillColor : "rgb(154 154 255)"}`, animation: "zcSpin 0.65s linear infinite" } });
    }
  };
  function R2({ title: o5, message: e2, type: t3, duration: r5, id: s5, theme: i5 }) {
    const [n4, c7] = (0, import_react4.useState)({}), [l6, m4] = (0, import_react4.useState)(false);
    return (0, import_react4.useEffect)(() => {
      const u6 = () => {
        const h7 = MainCanvas.canvas.clientWidth, b3 = MainCanvas.canvas.clientHeight, v4 = Math.min(h7, b3) / 100;
        c7({ position: "relative", width: "100%", borderRadius: "0.1em", fontSize: 3 * v4 + "px", padding: 1.5 * v4 + "px", background: i5 ? i5.backgroundColor : t3 === "success" ? "#3ece7e" : t3 === "warning" ? "#debf72" : t3 === "error" ? "rgb(212, 46, 107)" : "rgb(80, 80, 223)" });
      };
      window.addEventListener("resize", u6), u6();
      const S4 = setTimeout(() => m4(true), r5);
      return () => {
        clearTimeout(S4), window.removeEventListener("resize", u6);
      };
    }, []), (0, import_jsx_runtime.jsxs)("div", { className: `zcToast ${l6 && "exiting"}`, "data-zc-toast-type": t3, style: n4, children: [(0, import_jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "center", gap: "1vw", position: "relative", zIndex: 5 }, children: [(0, import_jsx_runtime.jsx)(P2, { type: t3, theme: i5 }), (0, import_jsx_runtime.jsxs)("div", { children: [o5 && e2 && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("p", { style: { color: i5 ? i5.titleColor : "white" }, children: o5 }), (0, import_jsx_runtime.jsx)("p", { style: { color: i5 ? i5.messageColor : t3 === "info" || t3 === "spinner" ? "#b8b8ff" : t3 === "success" ? "#c7f9c7" : t3 === "error" ? "#f8bcbc" : "#ffeec5", fontSize: "70%", overflowWrap: "anywhere", marginTop: "0.25em" }, children: e2 })] }), (!o5 && e2 || o5 && !e2) && (0, import_jsx_runtime.jsx)("p", { style: { position: "relative", zIndex: 5 }, children: o5 || e2 })] })] }), t3 !== "spinner" && (0, import_jsx_runtime.jsx)("div", { className: "zcToast-ProgressBar", style: { animation: `zcToast-progress ${r5}ms linear 0s 1 alternate none`, position: "absolute", top: 0, left: 0, height: "100%", background: i5 ? i5.progressBarColor : t3 === "info" ? "rgb(103, 103, 234)" : t3 === "success" ? "#34bc71" : t3 === "warning" ? "#d0af5e" : "rgb(183, 40, 92)" } })] });
  }
  function M2({ dialog: o5 }) {
    const e2 = window.ZOISCORE.useDialogStore((n4) => n4.clearDialog), [t3, r5] = (0, import_react4.useState)({}), [s5, i5] = (0, import_react4.useState)([]);
    return (0, import_react4.useEffect)(() => {
      const n4 = () => {
        const c7 = MainCanvas.canvas.clientWidth, l6 = MainCanvas.canvas.clientHeight, m4 = Math.min(c7, l6) / 100;
        r5({ width: P(o5.width), position: "absolute", top: "50%", left: "50%", transform: "translate(-50%, -50%)", background: "rgba(36, 36, 36, 0.96)", zIndex: 20, fontFamily: CommonGetFontName(), border: "none", padding: 2 * m4 });
      };
      return window.addEventListener("resize", n4), n4(), () => {
        window.removeEventListener("resize", n4);
      };
    }, []), (0, import_jsx_runtime.jsxs)("dialog", { open: Object.keys(t3).length > 0, "data-zc-dialog-type": o5.type, style: t3, children: [o5.title && (0, import_jsx_runtime.jsx)("p", { style: { position: "absolute", top: 0, left: 0, fontWeight: "bold", color: "white", fontSize: "clamp(6px, 2vw, 24px)", padding: "0.25em", background: "#2d2d2d", width: "100%" }, children: o5.title }), (0, import_jsx_runtime.jsx)("p", { style: { padding: "1em", marginTop: "2vw", fontSize: "clamp(6px, 2vw, 24px)", color: "white" }, children: o5.body }), (0, import_jsx_runtime.jsx)("div", { style: { display: "flex", flexDirection: o5.buttons.direction, justifyContent: "center", gap: "0.5vw" }, children: o5.buttons?.list?.map((n4, c7) => (0, import_jsx_runtime.jsx)("button", { className: "zcDialogBtn", "data-zc-picked": s5.includes(c7), style: { width: "100%", position: "relative" }, onClick: () => {
      o5.type === "choice_one" ? (e2(), o5.promise.resolve(n4.value)) : s5.includes(c7) ? i5(s5.filter((l6) => l6 !== c7)) : i5([...s5, c7]);
    }, children: n4.text })) }), o5.type === "choice_multiple" && (0, import_jsx_runtime.jsx)("button", { style: { cursor: "pointer", color: "white", background: "#4d4d4d", border: "none", marginTop: "1vw", fontSize: "clamp(8px,2.5vw,28px)", padding: "0.2em", borderRadius: "4px" }, onClick: () => {
      e2(), o5.promise.resolve(o5.buttons.list.filter((n4, c7) => s5.includes(c7)).map((n4) => n4.value));
    }, children: "Confirm" })] });
  }
  var F = class {
    generateToastId() {
      return crypto.randomUUID();
    }
    process({ title: e2, message: t3, duration: r5, type: s5, id: i5, theme: n4 }) {
      const { addToast: c7, removeToast: l6 } = window.ZOISCORE.useToastsStore.getState();
      c7({ id: i5, title: e2, message: t3, duration: r5, type: s5, theme: n4 }), setTimeout(() => l6(i5), r5 + 300);
    }
    info({ title: e2, message: t3, duration: r5 }) {
      const s5 = this.generateToastId(), i5 = c2.singleToastsTheme;
      this.process({ title: e2, message: t3, duration: r5, type: "info", id: s5, theme: i5 });
    }
    success({ title: e2, message: t3, duration: r5 }) {
      const s5 = this.generateToastId(), i5 = c2.singleToastsTheme;
      this.process({ title: e2, message: t3, duration: r5, type: "success", id: s5, theme: i5 });
    }
    warn({ title: e2, message: t3, duration: r5 }) {
      const s5 = this.generateToastId(), i5 = c2.singleToastsTheme;
      this.process({ title: e2, message: t3, duration: r5, type: "warning", id: s5, theme: i5 });
    }
    error({ title: e2, message: t3, duration: r5 }) {
      const s5 = this.generateToastId(), i5 = c2.singleToastsTheme;
      this.process({ title: e2, message: t3, duration: r5, type: "error", id: s5, theme: i5 });
    }
    spinner({ title: e2, message: t3 }) {
      const r5 = this.generateToastId(), s5 = c2.singleToastsTheme;
      return this.process({ title: e2, message: t3, duration: 1e6, type: "spinner", id: r5, theme: s5 }), r5;
    }
    removeSpinner(e2) {
      const { removeToast: t3 } = window.ZOISCORE.useToastsStore.getState();
      t3(e2);
    }
  };
  var N = class {
    showDialog({ type: e2, title: t3, body: r5, buttons: s5, width: i5 }) {
      const { setDialog: n4 } = window.ZOISCORE.useDialogStore.getState();
      return new Promise((c7, l6) => {
        n4({ width: i5, type: e2, title: t3, body: r5, buttons: s5, promise: { resolve: c7, reject: l6 } });
      });
    }
  };
  function L2() {
    const o5 = window.ZOISCORE.useToastsStore((t3) => t3.toasts), e2 = window.ZOISCORE.useDialogStore((t3) => t3.dialog);
    return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)(I2, { children: o5.map(({ title: t3, message: r5, type: s5, duration: i5, id: n4, theme: c7 }) => (0, import_jsx_runtime.jsx)(R2, { id: n4, title: t3, message: r5, type: s5, duration: i5, theme: c7 }, n4)) }), e2 && (0, import_jsx_runtime.jsx)(M2, { dialog: e2 })] });
  }
  var W = class extends HTMLElement {
    disconnectedCallback() {
      ServerShowBeep("VirtualDOM was removed, chaos is coming...", 5e3, {});
    }
  };
  var q = create((o5) => ({ toasts: [], addToast: (e2) => o5((t3) => ({ toasts: [...t3.toasts, e2] })), removeToast: (e2) => o5((t3) => ({ toasts: t3.toasts.filter((r5) => r5.id !== e2) })), clearToasts: () => o5({ toasts: [] }) }));
  var Y = create((o5) => ({ dialog: null, setDialog: (e2) => o5({ dialog: e2 }), clearDialog: () => o5({ dialog: null }) }));
  function K() {
    customElements.define("zc-virtual-dom", W);
    const o5 = document.createElement("zc-virtual-dom");
    document.body.append(o5), import_client.default.createRoot(document.getElementsByTagName("zc-virtual-dom")[0]).render((0, import_jsx_runtime.jsx)(L2, {}));
  }
  var Q2 = new F();
  var ee2 = new N();

  // node_modules/.pnpm/zois-core@1.1.8/node_modules/zois-core/dist/index.js
  var c2;
  function C(e2) {
    if (!window.ZOISCORE) {
      const t3 = document.createElement("style");
      t3.innerHTML = styles_default, document.head.append(t3), window.ZOISCORE = Object.freeze({ loaded: true, useToastsStore: q, useDialogStore: Y }), K();
    }
    c2 = { ...e2 }, T();
  }
  function p(e2) {
    return new Promise((t3) => setTimeout(t3, e2));
  }
  async function h2(e2, t3 = () => false) {
    for (; !e2(); ) {
      if (t3()) return false;
      await p(10);
    }
    return true;
  }
  function y2(e2, t3) {
    return e2 = Math.ceil(e2), t3 = Math.floor(t3), Math.floor(Math.random() * (t3 - e2 + 1)) + e2;
  }
  function w3(e2, t3) {
    const r5 = e2.split("."), o5 = t3.split(".");
    for (let n4 = 0; n4 < Math.max(r5.length, o5.length); n4++) {
      const i5 = parseInt(r5[n4] || "0", 10), s5 = parseInt(o5[n4] || "0", 10);
      if (i5 > s5) return true;
      if (i5 < s5) return false;
    }
    return false;
  }
  function T2(e2) {
    return typeof e2 == "string" ? Math.round(new TextEncoder().encode(e2).byteLength / 100) / 10 : Math.round(new TextEncoder().encode(JSON.stringify(e2)).byteLength / 100) / 10;
  }
  function N2(e2) {
    if (e2) return ChatRoomCharacter.find((t3) => t3.MemberNumber == e2 || t3.Name.toLowerCase() === e2 || t3.Nickname?.toLowerCase() === e2);
  }
  function O2(e2) {
    return CharacterNickname(e2);
  }
  function S() {
    if (!E("Themed")) return null;
    const e2 = JSON.parse(LZString.decompressFromBase64(Player.ExtensionSettings.Themed ?? ""));
    return !e2?.GlobalModule?.themedEnabled || !e2?.GlobalModule?.doVanillaGuiOverhaul ? null : e2.ColorsModule;
  }
  function k2(e2) {
    const t3 = document.createElement("style");
    t3.innerHTML = e2, document.head.append(t3);
  }
  function P3(e2) {
    h2(() => typeof window.Player?.MemberNumber == "number").then(() => setTimeout(e2, y2(3e3, 6e3)));
  }
  function a2(e2) {
    return typeof e2 != "object" || e2 === null ? e2 : Array.isArray(e2) ? e2.map(a2).sort() : Object.keys(e2).sort().reduce((t3, r5) => (t3[r5] = a2(e2[r5]), t3), {});
  }

  // src/styles.css
  var styles_default2 = `@import url('https://fonts.googleapis.com/css2?family=Finger+Paint&family=Frijole&family=Rubik+Wet+Paint&family=Yusei+Magic&family=Macondo+Swash+Caps&display=swap');

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

@media (max-width: 750px) {
  .bccQAM .bccQAM_sidebar>input {
    display: none;
  }

  .bccQAM .bccQAM_sidebar {
    width: auto !important;
  }

  .bccQAM>div:first-of-type>div:first-of-type>svg:first-of-type {
    display: none;
  }

  .bccQAM .bccQAM_sidebar>div>button>div {
    display: none !important;
  }
}

.bccQAM .bccQAM_sidebar[data-minimized]>input {
  display: none;
}

.bccQAM .bccQAM_sidebar[data-minimized] {
  width: auto !important;
}

.bccQAM .bccQAM_sidebar[data-minimized]>div>button>div {
  display: none !important;
}

.bccQAM {
  display: flex;
  flex-direction: column;
  position: fixed;
  overflow: hidden;
  resize: both;
  width: 95%;
  max-width: 1250px;
  min-width: 605px;
  height: 80%;
  max-height: 600px;
  min-height: 350px;
  border-radius: 4px;
  background: rgb(255, 255, 255);
  border: 2px solid rgba(182 182 182 / 11%);
  box-shadow: 0 0px 6px 0 rgb(168 168 168);
  font-family: "Yusei Magic";
  z-index: 25;
}

.bccQAMButton {
  display: grid;
  place-items: center;
  width: 2.5em;
  aspect-ratio: 1/1;
  border-radius: 4px;
  background: rgba(255, 255, 255, 0.15);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  border: 2px solid var(--tmd-element, rgba(182 182 182 / 11%));
  box-shadow: 0 0px 4px 0 rgb(139 139 139 / 37%);
  cursor: pointer;
  position: fixed;
  top: 10px;
  left: 10px;
  z-index: 25;
}

.bccQAMButton img {
  pointer-events: none;
  width: 80%;
  aspect-ratio: 1/1;
}

.bccQAMSelect {
  cursor: pointer;
  background: white;
  border: 2px solid rgb(195, 195, 195);
  border-radius: 0.4em;
  padding: 0.45em;
  z-index: 10;
}

.bccQAMSelect[opened="true"] {
  border-color: rgb(0, 96, 223);
}

.bccQAMSelect[opened="false"]:hover {
  border-color: rgb(170, 170, 170);
}

.bccQAMSelect>svg {
  position: absolute;
  right: 0.45em;
  top: 50%;
  transform: translateY(-50%);
  width: 1.5em;
  height: 1.5em;
  color: rgb(0, 96, 223);
}

.bccQAMSelect>div {
  position: absolute;
  left: 0;
  width: 100%;
  max-height: 50vh;
  overflow-y: auto;
  scrollbar-width: thin;
  scrollbar-color: #c2c2c2 #e7e7e7;
  background: #f6f6f6;
  border: 2px solid rgb(235 235 235);
  border-radius: 0.4em;
}

.bccQAMSelect>div[data-position="top"] {
  bottom: calc(100% + 0.45em);
}

.bccQAMSelect>div[data-position="bottom"] {
  top: calc(100% + 0.45em);
}

.bccQAMSelect>div>div {
  width: 100%;
  padding: 0.45em;
  border-radius: 0.25em;
}

.bccQAMSelect>div>div>svg {
  width: 1.25em;
  height: 1.25em;
  color: rgb(0, 96, 223);
}

.bccQAMSelect>div>div:hover {
  background: #ededed;
}

.bccChangelog {
  font-family: "Yusei Magic";
  padding: 0.5em;
  font-size: 1.25em;
}

.bccChangelog ul {
  padding-left: 1em;
}

.bccChangelog ul li {
  padding: 0.5em 0;
}

/* .horror-tentacle-button {
  position: relative;
  padding: 1.25em 2.5em;
  background: linear-gradient(145deg, #0c0c0c, #1a1a1a);
  color: #8ef6e4;
  border: 0.125em solid #00adb5;
  border-radius: 0.5em;
  font-family: 'Cormorant SC', serif;
  font-size: 1rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
  overflow: hidden;
  text-shadow: 0 0 0.3125em rgba(142, 246, 228, 0.3);
  margin: 1em;
}

.horror-tentacle-button:hover {
  background: linear-gradient(145deg, #1a1a1a, #0c0c0c);
  box-shadow: 0 0 1.875em rgba(0, 173, 181, 0.5);
} */

.tentacle-horror {
  position: absolute;
  right: -0.3125em;
  top: 50%;
  transform: translateY(-50%);
  height: 80%;
  width: 1.5625em;
  display: flex;
  flex-direction: column;
  justify-content: space-around;
  align-items: flex-end;
}

.tentacle {
  position: relative;
  width: 0.75em;
  height: 0.1875em;
  background: linear-gradient(to left, var(--tmd-text, #00adb5), var(--tmd-text, #007780));
  border-radius: 0.125em;
  opacity: 0.9;
  animation: tentacleWriggle 4s ease-in-out infinite;
  transform-origin: right center;
}

.tentacle::before {
  content: '';
  position: absolute;
  left: -0.0625em;
  top: 50%;
  transform: translateY(-50%);
  width: 0.25em;
  height: 0.25em;
  background: linear-gradient(45deg, var(--tmd-text, #007780), var(--tmd-text, #00565c));
  border-radius: 50%;
  border: 0.0625em solid var(--tmd-accent, #00adb5);
  box-shadow: 0 0 0.1875em var(--tmd-text, rgba(0, 173, 181, 0.8));
}

.tentacle::after {
  content: '';
  position: absolute;
  left: -0.375em;
  top: 50%;
  transform: translateY(-50%);
  width: 0.375em;
  height: 0.375em;
  background: var(--tmd-text, #00565c);
  border-radius: 50% 50% 0 50%;
  clip-path: polygon(0 0, 100% 50%, 0 100%);
  opacity: 0.8;
}

.tentacle:nth-child(1) {
  height: 0.25em;
  animation-delay: 0s;
  transform: rotate(-5deg);
}

.tentacle:nth-child(2) {
  animation-delay: 1s;
  transform: rotate(2deg);
}

.tentacle:nth-child(3) {
  height: 0.125em;
  animation-delay: 2s;
  transform: rotate(5deg);
}

.tentacle:nth-child(4) {
  height: 0.1875em;
  animation-delay: 3s;
  transform: rotate(-3deg);
}

.tentacle-detail {
  position: absolute;
  background: var(--tmd-text, rgba(0, 173, 181, 0.3));
  border-radius: 0.0625em;
  animation: detailPulse 3s ease-in-out infinite;
}

.detail-1 {
  width: 0.1875em;
  height: 0.0625em;
  left: -0.5em;
  top: 30%;
  animation-delay: 0s;
}

.detail-2 {
  width: 0.125em;
  height: 0.0625em;
  left: -0.75em;
  top: 60%;
  animation-delay: 1s;
}

.tentacle-particle {
  position: absolute;
  width: 0.0825em;
  height: 0.0825em;
  background: var(--tmd-text, #00adb5);
  border-radius: 50%;
  animation: particleFloat 5s ease-in-out infinite;
  opacity: 0;
}

.particle-1 {
  right: 0.1875em;
  top: 20%;
  animation-delay: 0s;
}

.particle-2 {
  right: 0.5em;
  top: 50%;
  animation-delay: 2s;
}

.particle-3 {
  right: 0.3125em;
  top: 80%;
  animation-delay: 4s;
}

@keyframes tentacleWriggle {

  0%,
  100% {
    transform: rotate(0deg) scaleX(1);
    opacity: 0.9;
  }

  25% {
    transform: rotate(-8deg) scaleX(1.1);
    opacity: 1;
  }

  50% {
    transform: rotate(5deg) scaleX(0.9);
    opacity: 0.8;
  }

  75% {
    transform: rotate(3deg) scaleX(1.05);
    opacity: 0.95;
  }
}

@keyframes detailPulse {

  0%,
  100% {
    opacity: 0.2;
  }

  50% {
    opacity: 0.6;
  }
}

@keyframes particleFloat {
  0% {
    transform: translate(0, 0) scale(0);
    opacity: 0;
  }

  20% {
    transform: translate(-0.3125em, -0.1875em) scale(1);
    opacity: 0.7;
  }

  40% {
    transform: translate(-0.625em, 0.125em) scale(1.2);
    opacity: 0.4;
  }

  60% {
    transform: translate(-0.9375em, -0.0625em) scale(0.8);
    opacity: 0.2;
  }

  80% {
    transform: translate(-1.25em, 0.25em) scale(0.5);
    opacity: 0.1;
  }

  100% {
    transform: translate(-1.5625em, 0) scale(0);
    opacity: 0;
  }
}

.tentacle-slime {
  position: absolute;
  right: 0;
  bottom: 10%;
  width: 0.1875em;
  height: 0.125em;
  background: linear-gradient(to bottom, #00adb5, transparent);
  border-radius: 50%;
  animation: slimeDrip 6s ease-in-out infinite;
  opacity: 0.7;
}

@keyframes slimeDrip {

  0%,
  100% {
    height: 0.125em;
    opacity: 0.5;
  }

  50% {
    height: 0.5em;
    opacity: 0.8;
  }
}

@media (max-width: 768px) {
  .horror-tentacle-button {
    font-size: 0.9rem;
    padding: 1em 2em;
  }
}

@media (max-width: 480px) {
  .horror-tentacle-button {
    font-size: 0.8rem;
    padding: 0.8em 1.6em;
  }

  .tentacle-horror {
    width: 1.2em;
    right: -0.2em;
  }

  .tentacle {
    width: 0.6em;
  }
}

.letter {
  display: inline-block;
  opacity: 0;
  color: var(--tmd-text, black);
  transform: translateY(30px) rotateX(90deg);
  animation: letterReveal 0.45s ease-out forwards;
  font-family: 'Finger Paint';
}

@keyframes letterReveal {
  0% {
    opacity: 0;
    transform: translateY(0.75em) rotateX(90deg);
    text-shadow: 0 0 5px var(--tmd-text, #161616);
  }

  50% {
    opacity: 1;
    transform: translateY(-0.25em) rotateX(0deg);
    text-shadow: 0 0 10px var(--tmd-text, #161616);
  }

  100% {
    opacity: 1;
    transform: translateY(0) rotateX(0deg);
    text-shadow: 0.045em 0.045em 0 var(--tmd-text, black), -0.045em -0.045em 0 var(--tmd-accent, #6600da), 0.045em -0.045em 0 var(--tmd-text, black), -0.045em 0.045em 0 var(--tmd-accent, #6600da);
  }
}`;

  // package.json
  var version = "2.0.1";

  // node_modules/.pnpm/lucide@0.554.0/node_modules/lucide/dist/esm/defaultAttributes.js
  var defaultAttributes3 = {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    "stroke-width": 2,
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  };

  // node_modules/.pnpm/lucide@0.554.0/node_modules/lucide/dist/esm/createElement.js
  var createSVGElement2 = ([tag, attrs, children]) => {
    const element = document.createElementNS("http://www.w3.org/2000/svg", tag);
    Object.keys(attrs).forEach((name) => {
      element.setAttribute(name, String(attrs[name]));
    });
    if (children?.length) {
      children.forEach((child) => {
        const childElement = createSVGElement2(child);
        element.appendChild(childElement);
      });
    }
    return element;
  };
  var createElement4 = (iconNode, customAttrs = {}) => {
    const tag = "svg";
    const attrs = {
      ...defaultAttributes3,
      ...customAttrs
    };
    return createSVGElement2([tag, attrs, iconNode]);
  };

  // node_modules/.pnpm/lucide@0.554.0/node_modules/lucide/dist/esm/icons/align-vertical-space-around.js
  var AlignVerticalSpaceAround = [
    ["rect", { width: "10", height: "6", x: "7", y: "9", rx: "2" }],
    ["path", { d: "M22 20H2" }],
    ["path", { d: "M22 4H2" }]
  ];

  // node_modules/.pnpm/lucide@0.554.0/node_modules/lucide/dist/esm/icons/arrow-down.js
  var ArrowDown = [
    ["path", { d: "M12 5v14" }],
    ["path", { d: "m19 12-7 7-7-7" }]
  ];

  // node_modules/.pnpm/lucide@0.554.0/node_modules/lucide/dist/esm/icons/arrow-up.js
  var ArrowUp = [
    ["path", { d: "m5 12 7-7 7 7" }],
    ["path", { d: "M12 19V5" }]
  ];

  // node_modules/.pnpm/lucide@0.554.0/node_modules/lucide/dist/esm/icons/ban.js
  var Ban = [
    ["path", { d: "M4.929 4.929 19.07 19.071" }],
    ["circle", { cx: "12", cy: "12", r: "10" }]
  ];

  // node_modules/.pnpm/lucide@0.554.0/node_modules/lucide/dist/esm/icons/book-heart.js
  var BookHeart = [
    [
      "path",
      { d: "M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H19a1 1 0 0 1 1 1v18a1 1 0 0 1-1 1H6.5a1 1 0 0 1 0-5H20" }
    ],
    [
      "path",
      {
        d: "M8.62 9.8A2.25 2.25 0 1 1 12 6.836a2.25 2.25 0 1 1 3.38 2.966l-2.626 2.856a.998.998 0 0 1-1.507 0z"
      }
    ]
  ];

  // node_modules/.pnpm/lucide@0.554.0/node_modules/lucide/dist/esm/icons/bug.js
  var Bug = [
    ["path", { d: "M12 20v-9" }],
    ["path", { d: "M14 7a4 4 0 0 1 4 4v3a6 6 0 0 1-12 0v-3a4 4 0 0 1 4-4z" }],
    ["path", { d: "M14.12 3.88 16 2" }],
    ["path", { d: "M21 21a4 4 0 0 0-3.81-4" }],
    ["path", { d: "M21 5a4 4 0 0 1-3.55 3.97" }],
    ["path", { d: "M22 13h-4" }],
    ["path", { d: "M3 21a4 4 0 0 1 3.81-4" }],
    ["path", { d: "M3 5a4 4 0 0 0 3.55 3.97" }],
    ["path", { d: "M6 13H2" }],
    ["path", { d: "m8 2 1.88 1.88" }],
    ["path", { d: "M9 7.13V6a3 3 0 1 1 6 0v1.13" }]
  ];

  // node_modules/.pnpm/lucide@0.554.0/node_modules/lucide/dist/esm/icons/check.js
  var Check2 = [["path", { d: "M20 6 9 17l-5-5" }]];

  // node_modules/.pnpm/lucide@0.554.0/node_modules/lucide/dist/esm/icons/chevron-down.js
  var ChevronDown2 = [["path", { d: "m6 9 6 6 6-6" }]];

  // node_modules/.pnpm/lucide@0.554.0/node_modules/lucide/dist/esm/icons/clipboard-copy.js
  var ClipboardCopy = [
    ["rect", { width: "8", height: "4", x: "8", y: "2", rx: "1", ry: "1" }],
    ["path", { d: "M8 4H6a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-2" }],
    ["path", { d: "M16 4h2a2 2 0 0 1 2 2v4" }],
    ["path", { d: "M21 14H11" }],
    ["path", { d: "m15 10-4 4 4 4" }]
  ];

  // node_modules/.pnpm/lucide@0.554.0/node_modules/lucide/dist/esm/icons/clipboard-paste.js
  var ClipboardPaste = [
    ["path", { d: "M11 14h10" }],
    ["path", { d: "M16 4h2a2 2 0 0 1 2 2v1.344" }],
    ["path", { d: "m17 18 4-4-4-4" }],
    ["path", { d: "M8 4H6a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h12a2 2 0 0 0 1.793-1.113" }],
    ["rect", { x: "8", y: "2", width: "8", height: "4", rx: "1" }]
  ];

  // node_modules/.pnpm/lucide@0.554.0/node_modules/lucide/dist/esm/icons/code-xml.js
  var CodeXml = [
    ["path", { d: "m18 16 4-4-4-4" }],
    ["path", { d: "m6 8-4 4 4 4" }],
    ["path", { d: "m14.5 4-5 16" }]
  ];

  // node_modules/.pnpm/lucide@0.554.0/node_modules/lucide/dist/esm/icons/copy-plus.js
  var CopyPlus = [
    ["line", { x1: "15", x2: "15", y1: "12", y2: "18" }],
    ["line", { x1: "12", x2: "18", y1: "15", y2: "15" }],
    ["rect", { width: "14", height: "14", x: "8", y: "8", rx: "2", ry: "2" }],
    ["path", { d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2" }]
  ];

  // node_modules/.pnpm/lucide@0.554.0/node_modules/lucide/dist/esm/icons/eye.js
  var Eye = [
    [
      "path",
      {
        d: "M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0"
      }
    ],
    ["circle", { cx: "12", cy: "12", r: "3" }]
  ];

  // node_modules/.pnpm/lucide@0.554.0/node_modules/lucide/dist/esm/icons/git-commit-vertical.js
  var GitCommitVertical = [
    ["path", { d: "M12 3v6" }],
    ["circle", { cx: "12", cy: "12", r: "3" }],
    ["path", { d: "M12 15v6" }]
  ];

  // node_modules/.pnpm/lucide@0.554.0/node_modules/lucide/dist/esm/icons/git-compare-arrows.js
  var GitCompareArrows = [
    ["circle", { cx: "5", cy: "6", r: "3" }],
    ["path", { d: "M12 6h5a2 2 0 0 1 2 2v7" }],
    ["path", { d: "m15 9-3-3 3-3" }],
    ["circle", { cx: "19", cy: "18", r: "3" }],
    ["path", { d: "M12 18H7a2 2 0 0 1-2-2V9" }],
    ["path", { d: "m9 15 3 3-3 3" }]
  ];

  // node_modules/.pnpm/lucide@0.554.0/node_modules/lucide/dist/esm/icons/git-pull-request-arrow.js
  var GitPullRequestArrow = [
    ["circle", { cx: "5", cy: "6", r: "3" }],
    ["path", { d: "M5 9v12" }],
    ["circle", { cx: "19", cy: "18", r: "3" }],
    ["path", { d: "m15 9-3-3 3-3" }],
    ["path", { d: "M12 6h5a2 2 0 0 1 2 2v7" }]
  ];

  // node_modules/.pnpm/lucide@0.554.0/node_modules/lucide/dist/esm/icons/git-pull-request-closed.js
  var GitPullRequestClosed = [
    ["circle", { cx: "6", cy: "6", r: "3" }],
    ["path", { d: "M6 9v12" }],
    ["path", { d: "m21 3-6 6" }],
    ["path", { d: "m21 9-6-6" }],
    ["path", { d: "M18 11.5V15" }],
    ["circle", { cx: "18", cy: "18", r: "3" }]
  ];

  // node_modules/.pnpm/lucide@0.554.0/node_modules/lucide/dist/esm/icons/git-pull-request.js
  var GitPullRequest = [
    ["circle", { cx: "18", cy: "18", r: "3" }],
    ["circle", { cx: "6", cy: "6", r: "3" }],
    ["path", { d: "M13 6h3a2 2 0 0 1 2 2v7" }],
    ["line", { x1: "6", x2: "6", y1: "9", y2: "21" }]
  ];

  // node_modules/.pnpm/lucide@0.554.0/node_modules/lucide/dist/esm/icons/hand-coins.js
  var HandCoins = [
    ["path", { d: "M11 15h2a2 2 0 1 0 0-4h-3c-.6 0-1.1.2-1.4.6L3 17" }],
    [
      "path",
      {
        d: "m7 21 1.6-1.4c.3-.4.8-.6 1.4-.6h4c1.1 0 2.1-.4 2.8-1.2l4.6-4.4a2 2 0 0 0-2.75-2.91l-4.2 3.9"
      }
    ],
    ["path", { d: "m2 16 6 6" }],
    ["circle", { cx: "16", cy: "9", r: "2.9" }],
    ["circle", { cx: "6", cy: "5", r: "3" }]
  ];

  // node_modules/.pnpm/lucide@0.554.0/node_modules/lucide/dist/esm/icons/hat-glasses.js
  var HatGlasses = [
    ["path", { d: "M14 18a2 2 0 0 0-4 0" }],
    [
      "path",
      {
        d: "m19 11-2.11-6.657a2 2 0 0 0-2.752-1.148l-1.276.61A2 2 0 0 1 12 4H8.5a2 2 0 0 0-1.925 1.456L5 11"
      }
    ],
    ["path", { d: "M2 11h20" }],
    ["circle", { cx: "17", cy: "18", r: "3" }],
    ["circle", { cx: "7", cy: "18", r: "3" }]
  ];

  // node_modules/.pnpm/lucide@0.554.0/node_modules/lucide/dist/esm/icons/heart.js
  var Heart = [
    [
      "path",
      {
        d: "M2 9.5a5.5 5.5 0 0 1 9.591-3.676.56.56 0 0 0 .818 0A5.49 5.49 0 0 1 22 9.5c0 2.29-1.5 4-3 5.5l-5.492 5.313a2 2 0 0 1-3 .019L5 15c-1.5-1.5-3-3.2-3-5.5"
      }
    ]
  ];

  // node_modules/.pnpm/lucide@0.554.0/node_modules/lucide/dist/esm/icons/lock-open.js
  var LockOpen = [
    ["rect", { width: "18", height: "11", x: "3", y: "11", rx: "2", ry: "2" }],
    ["path", { d: "M7 11V7a5 5 0 0 1 9.9-1" }]
  ];

  // node_modules/.pnpm/lucide@0.554.0/node_modules/lucide/dist/esm/icons/lock.js
  var Lock = [
    ["rect", { width: "18", height: "11", x: "3", y: "11", rx: "2", ry: "2" }],
    ["path", { d: "M7 11V7a5 5 0 0 1 10 0v4" }]
  ];

  // node_modules/.pnpm/lucide@0.554.0/node_modules/lucide/dist/esm/icons/log-out.js
  var LogOut = [
    ["path", { d: "m16 17 5-5-5-5" }],
    ["path", { d: "M21 12H9" }],
    ["path", { d: "M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4" }]
  ];

  // node_modules/.pnpm/lucide@0.554.0/node_modules/lucide/dist/esm/icons/map-pinned.js
  var MapPinned = [
    [
      "path",
      {
        d: "M18 8c0 3.613-3.869 7.429-5.393 8.795a1 1 0 0 1-1.214 0C9.87 15.429 6 11.613 6 8a6 6 0 0 1 12 0"
      }
    ],
    ["circle", { cx: "12", cy: "8", r: "2" }],
    [
      "path",
      {
        d: "M8.714 14h-3.71a1 1 0 0 0-.948.683l-2.004 6A1 1 0 0 0 3 22h18a1 1 0 0 0 .948-1.316l-2-6a1 1 0 0 0-.949-.684h-3.712"
      }
    ]
  ];

  // node_modules/.pnpm/lucide@0.554.0/node_modules/lucide/dist/esm/icons/maximize.js
  var Maximize = [
    ["path", { d: "M8 3H5a2 2 0 0 0-2 2v3" }],
    ["path", { d: "M21 8V5a2 2 0 0 0-2-2h-3" }],
    ["path", { d: "M3 16v3a2 2 0 0 0 2 2h3" }],
    ["path", { d: "M16 21h3a2 2 0 0 0 2-2v-3" }]
  ];

  // node_modules/.pnpm/lucide@0.554.0/node_modules/lucide/dist/esm/icons/panel-left-close.js
  var PanelLeftClose = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M9 3v18" }],
    ["path", { d: "m16 15-3-3 3-3" }]
  ];

  // node_modules/.pnpm/lucide@0.554.0/node_modules/lucide/dist/esm/icons/panels-top-left.js
  var PanelsTopLeft = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M3 9h18" }],
    ["path", { d: "M9 21V9" }]
  ];

  // node_modules/.pnpm/lucide@0.554.0/node_modules/lucide/dist/esm/icons/person-standing.js
  var PersonStanding = [
    ["circle", { cx: "12", cy: "5", r: "1" }],
    ["path", { d: "m9 20 3-6 3 6" }],
    ["path", { d: "m6 8 6 2 6-2" }],
    ["path", { d: "M12 10v4" }]
  ];

  // node_modules/.pnpm/lucide@0.554.0/node_modules/lucide/dist/esm/icons/send-to-back.js
  var SendToBack = [
    ["rect", { x: "14", y: "14", width: "8", height: "8", rx: "2" }],
    ["rect", { x: "2", y: "2", width: "8", height: "8", rx: "2" }],
    ["path", { d: "M7 14v1a2 2 0 0 0 2 2h1" }],
    ["path", { d: "M14 7h1a2 2 0 0 1 2 2v1" }]
  ];

  // node_modules/.pnpm/lucide@0.554.0/node_modules/lucide/dist/esm/icons/settings.js
  var Settings = [
    [
      "path",
      {
        d: "M9.671 4.136a2.34 2.34 0 0 1 4.659 0 2.34 2.34 0 0 0 3.319 1.915 2.34 2.34 0 0 1 2.33 4.033 2.34 2.34 0 0 0 0 3.831 2.34 2.34 0 0 1-2.33 4.033 2.34 2.34 0 0 0-3.319 1.915 2.34 2.34 0 0 1-4.659 0 2.34 2.34 0 0 0-3.32-1.915 2.34 2.34 0 0 1-2.33-4.033 2.34 2.34 0 0 0 0-3.831A2.34 2.34 0 0 1 6.35 6.051a2.34 2.34 0 0 0 3.319-1.915"
      }
    ],
    ["circle", { cx: "12", cy: "12", r: "3" }]
  ];

  // node_modules/.pnpm/lucide@0.554.0/node_modules/lucide/dist/esm/icons/shell.js
  var Shell = [
    [
      "path",
      {
        d: "M14 11a2 2 0 1 1-4 0 4 4 0 0 1 8 0 6 6 0 0 1-12 0 8 8 0 0 1 16 0 10 10 0 1 1-20 0 11.93 11.93 0 0 1 2.42-7.22 2 2 0 1 1 3.16 2.44"
      }
    ]
  ];

  // node_modules/.pnpm/lucide@0.554.0/node_modules/lucide/dist/esm/icons/shield-alert.js
  var ShieldAlert = [
    [
      "path",
      {
        d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z"
      }
    ],
    ["path", { d: "M12 8v4" }],
    ["path", { d: "M12 16h.01" }]
  ];

  // node_modules/.pnpm/lucide@0.554.0/node_modules/lucide/dist/esm/icons/shield-minus.js
  var ShieldMinus = [
    [
      "path",
      {
        d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z"
      }
    ],
    ["path", { d: "M9 12h6" }]
  ];

  // node_modules/.pnpm/lucide@0.554.0/node_modules/lucide/dist/esm/icons/skull.js
  var Skull = [
    ["path", { d: "m12.5 17-.5-1-.5 1h1z" }],
    [
      "path",
      {
        d: "M15 22a1 1 0 0 0 1-1v-1a2 2 0 0 0 1.56-3.25 8 8 0 1 0-11.12 0A2 2 0 0 0 8 20v1a1 1 0 0 0 1 1z"
      }
    ],
    ["circle", { cx: "15", cy: "12", r: "1" }],
    ["circle", { cx: "9", cy: "12", r: "1" }]
  ];

  // node_modules/.pnpm/lucide@0.554.0/node_modules/lucide/dist/esm/icons/target.js
  var Target = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["circle", { cx: "12", cy: "12", r: "6" }],
    ["circle", { cx: "12", cy: "12", r: "2" }]
  ];

  // node_modules/.pnpm/lucide@0.554.0/node_modules/lucide/dist/esm/icons/trash-2.js
  var Trash22 = [
    ["path", { d: "M10 11v6" }],
    ["path", { d: "M14 11v6" }],
    ["path", { d: "M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6" }],
    ["path", { d: "M3 6h18" }],
    ["path", { d: "M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" }]
  ];

  // node_modules/.pnpm/lucide@0.554.0/node_modules/lucide/dist/esm/icons/wand.js
  var Wand = [
    ["path", { d: "M15 4V2" }],
    ["path", { d: "M15 16v-2" }],
    ["path", { d: "M8 9h2" }],
    ["path", { d: "M20 9h2" }],
    ["path", { d: "M17.8 11.8 19 13" }],
    ["path", { d: "M15 9h.01" }],
    ["path", { d: "M17.8 6.2 19 5" }],
    ["path", { d: "m3 21 9-9" }],
    ["path", { d: "M12.2 6.2 11 5" }]
  ];

  // node_modules/.pnpm/lucide@0.554.0/node_modules/lucide/dist/esm/icons/x.js
  var X2 = [
    ["path", { d: "M18 6 6 18" }],
    ["path", { d: "m6 6 12 12" }]
  ];

  // src/ui-modules/tentaclesModule.ts
  var TentaclesModule = class extends r {
    overrideProperties(context, target) {
      context.element.style.overflow = "hidden";
      context.element.innerHTML += `<div class="tentacle-horror">
    <div class="tentacle">
      <div class="tentacle-detail detail-1"></div>
      <div class="tentacle-detail detail-2"></div>
    </div>
    <div class="tentacle">
      <div class="tentacle-detail detail-1"></div>
    </div>
    <div class="tentacle">
      <div class="tentacle-detail detail-2"></div>
    </div>
    <div class="tentacle">
      <div class="tentacle-detail detail-1"></div>
      <div class="tentacle-detail detail-2"></div>
    </div>
    <div class="tentacle-particle particle-1"></div>
    <div class="tentacle-particle particle-2"></div>
    <div class="tentacle-particle particle-3"></div>
    <div class="tentacle-slime"></div>
  </div>`;
      return context;
    }
  };

  // src/ui-modules/paintTextModule.ts
  var PaintTextModule = class extends r {
    constructor(animation = true) {
      super();
      this.animation = animation;
    }
    effect(context) {
      const text = context.element.textContent;
      const container = context.element;
      container.innerHTML = "";
      text.split("").forEach((letter, index) => {
        const span = document.createElement("span");
        if (this.animation) span.className = "letter";
        else {
          span.style.fontFamily = "Finger Paint";
          span.style.textShadow = "0.045em 0.045em 0 var(--tmd-text, black), -0.045em -0.045em 0 var(--tmd-accent, #6600da), 0.045em -0.045em 0 var(--tmd-text, black), -0.045em 0.045em 0 var(--tmd-accent, #6600da)";
        }
        if (letter === " ") span.innerHTML = "&nbsp;";
        else span.textContent = letter;
        if (this.animation) {
          span.style.animationDelay = `${index * 0.05}s`;
        } else {
          span.style.animation = "";
        }
        container.appendChild(span);
      });
      const space = document.createElement("span");
      space.className = "letter";
      space.innerHTML = "&nbsp;";
      space.style.animationDelay = "0.6s";
      container.appendChild(space);
    }
  };

  // node_modules/.pnpm/class-transformer@0.5.1/node_modules/class-transformer/esm5/enums/transformation-type.enum.js
  var TransformationType;
  (function(TransformationType2) {
    TransformationType2[TransformationType2["PLAIN_TO_CLASS"] = 0] = "PLAIN_TO_CLASS";
    TransformationType2[TransformationType2["CLASS_TO_PLAIN"] = 1] = "CLASS_TO_PLAIN";
    TransformationType2[TransformationType2["CLASS_TO_CLASS"] = 2] = "CLASS_TO_CLASS";
  })(TransformationType || (TransformationType = {}));

  // node_modules/.pnpm/class-transformer@0.5.1/node_modules/class-transformer/esm5/MetadataStorage.js
  var MetadataStorage = (
    /** @class */
    (function() {
      function MetadataStorage3() {
        this._typeMetadatas = /* @__PURE__ */ new Map();
        this._transformMetadatas = /* @__PURE__ */ new Map();
        this._exposeMetadatas = /* @__PURE__ */ new Map();
        this._excludeMetadatas = /* @__PURE__ */ new Map();
        this._ancestorsMap = /* @__PURE__ */ new Map();
      }
      MetadataStorage3.prototype.addTypeMetadata = function(metadata) {
        if (!this._typeMetadatas.has(metadata.target)) {
          this._typeMetadatas.set(metadata.target, /* @__PURE__ */ new Map());
        }
        this._typeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);
      };
      MetadataStorage3.prototype.addTransformMetadata = function(metadata) {
        if (!this._transformMetadatas.has(metadata.target)) {
          this._transformMetadatas.set(metadata.target, /* @__PURE__ */ new Map());
        }
        if (!this._transformMetadatas.get(metadata.target).has(metadata.propertyName)) {
          this._transformMetadatas.get(metadata.target).set(metadata.propertyName, []);
        }
        this._transformMetadatas.get(metadata.target).get(metadata.propertyName).push(metadata);
      };
      MetadataStorage3.prototype.addExposeMetadata = function(metadata) {
        if (!this._exposeMetadatas.has(metadata.target)) {
          this._exposeMetadatas.set(metadata.target, /* @__PURE__ */ new Map());
        }
        this._exposeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);
      };
      MetadataStorage3.prototype.addExcludeMetadata = function(metadata) {
        if (!this._excludeMetadatas.has(metadata.target)) {
          this._excludeMetadatas.set(metadata.target, /* @__PURE__ */ new Map());
        }
        this._excludeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);
      };
      MetadataStorage3.prototype.findTransformMetadatas = function(target, propertyName, transformationType) {
        return this.findMetadatas(this._transformMetadatas, target, propertyName).filter(function(metadata) {
          if (!metadata.options)
            return true;
          if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true)
            return true;
          if (metadata.options.toClassOnly === true) {
            return transformationType === TransformationType.CLASS_TO_CLASS || transformationType === TransformationType.PLAIN_TO_CLASS;
          }
          if (metadata.options.toPlainOnly === true) {
            return transformationType === TransformationType.CLASS_TO_PLAIN;
          }
          return true;
        });
      };
      MetadataStorage3.prototype.findExcludeMetadata = function(target, propertyName) {
        return this.findMetadata(this._excludeMetadatas, target, propertyName);
      };
      MetadataStorage3.prototype.findExposeMetadata = function(target, propertyName) {
        return this.findMetadata(this._exposeMetadatas, target, propertyName);
      };
      MetadataStorage3.prototype.findExposeMetadataByCustomName = function(target, name) {
        return this.getExposedMetadatas(target).find(function(metadata) {
          return metadata.options && metadata.options.name === name;
        });
      };
      MetadataStorage3.prototype.findTypeMetadata = function(target, propertyName) {
        return this.findMetadata(this._typeMetadatas, target, propertyName);
      };
      MetadataStorage3.prototype.getStrategy = function(target) {
        var excludeMap = this._excludeMetadatas.get(target);
        var exclude = excludeMap && excludeMap.get(void 0);
        var exposeMap = this._exposeMetadatas.get(target);
        var expose = exposeMap && exposeMap.get(void 0);
        if (exclude && expose || !exclude && !expose)
          return "none";
        return exclude ? "excludeAll" : "exposeAll";
      };
      MetadataStorage3.prototype.getExposedMetadatas = function(target) {
        return this.getMetadata(this._exposeMetadatas, target);
      };
      MetadataStorage3.prototype.getExcludedMetadatas = function(target) {
        return this.getMetadata(this._excludeMetadatas, target);
      };
      MetadataStorage3.prototype.getExposedProperties = function(target, transformationType) {
        return this.getExposedMetadatas(target).filter(function(metadata) {
          if (!metadata.options)
            return true;
          if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true)
            return true;
          if (metadata.options.toClassOnly === true) {
            return transformationType === TransformationType.CLASS_TO_CLASS || transformationType === TransformationType.PLAIN_TO_CLASS;
          }
          if (metadata.options.toPlainOnly === true) {
            return transformationType === TransformationType.CLASS_TO_PLAIN;
          }
          return true;
        }).map(function(metadata) {
          return metadata.propertyName;
        });
      };
      MetadataStorage3.prototype.getExcludedProperties = function(target, transformationType) {
        return this.getExcludedMetadatas(target).filter(function(metadata) {
          if (!metadata.options)
            return true;
          if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true)
            return true;
          if (metadata.options.toClassOnly === true) {
            return transformationType === TransformationType.CLASS_TO_CLASS || transformationType === TransformationType.PLAIN_TO_CLASS;
          }
          if (metadata.options.toPlainOnly === true) {
            return transformationType === TransformationType.CLASS_TO_PLAIN;
          }
          return true;
        }).map(function(metadata) {
          return metadata.propertyName;
        });
      };
      MetadataStorage3.prototype.clear = function() {
        this._typeMetadatas.clear();
        this._exposeMetadatas.clear();
        this._excludeMetadatas.clear();
        this._ancestorsMap.clear();
      };
      MetadataStorage3.prototype.getMetadata = function(metadatas, target) {
        var metadataFromTargetMap = metadatas.get(target);
        var metadataFromTarget;
        if (metadataFromTargetMap) {
          metadataFromTarget = Array.from(metadataFromTargetMap.values()).filter(function(meta) {
            return meta.propertyName !== void 0;
          });
        }
        var metadataFromAncestors = [];
        for (var _i = 0, _a = this.getAncestors(target); _i < _a.length; _i++) {
          var ancestor = _a[_i];
          var ancestorMetadataMap = metadatas.get(ancestor);
          if (ancestorMetadataMap) {
            var metadataFromAncestor = Array.from(ancestorMetadataMap.values()).filter(function(meta) {
              return meta.propertyName !== void 0;
            });
            metadataFromAncestors.push.apply(metadataFromAncestors, metadataFromAncestor);
          }
        }
        return metadataFromAncestors.concat(metadataFromTarget || []);
      };
      MetadataStorage3.prototype.findMetadata = function(metadatas, target, propertyName) {
        var metadataFromTargetMap = metadatas.get(target);
        if (metadataFromTargetMap) {
          var metadataFromTarget = metadataFromTargetMap.get(propertyName);
          if (metadataFromTarget) {
            return metadataFromTarget;
          }
        }
        for (var _i = 0, _a = this.getAncestors(target); _i < _a.length; _i++) {
          var ancestor = _a[_i];
          var ancestorMetadataMap = metadatas.get(ancestor);
          if (ancestorMetadataMap) {
            var ancestorResult = ancestorMetadataMap.get(propertyName);
            if (ancestorResult) {
              return ancestorResult;
            }
          }
        }
        return void 0;
      };
      MetadataStorage3.prototype.findMetadatas = function(metadatas, target, propertyName) {
        var metadataFromTargetMap = metadatas.get(target);
        var metadataFromTarget;
        if (metadataFromTargetMap) {
          metadataFromTarget = metadataFromTargetMap.get(propertyName);
        }
        var metadataFromAncestorsTarget = [];
        for (var _i = 0, _a = this.getAncestors(target); _i < _a.length; _i++) {
          var ancestor = _a[_i];
          var ancestorMetadataMap = metadatas.get(ancestor);
          if (ancestorMetadataMap) {
            if (ancestorMetadataMap.has(propertyName)) {
              metadataFromAncestorsTarget.push.apply(metadataFromAncestorsTarget, ancestorMetadataMap.get(propertyName));
            }
          }
        }
        return metadataFromAncestorsTarget.slice().reverse().concat((metadataFromTarget || []).slice().reverse());
      };
      MetadataStorage3.prototype.getAncestors = function(target) {
        if (!target)
          return [];
        if (!this._ancestorsMap.has(target)) {
          var ancestors = [];
          for (var baseClass = Object.getPrototypeOf(target.prototype.constructor); typeof baseClass.prototype !== "undefined"; baseClass = Object.getPrototypeOf(baseClass.prototype.constructor)) {
            ancestors.push(baseClass);
          }
          this._ancestorsMap.set(target, ancestors);
        }
        return this._ancestorsMap.get(target);
      };
      return MetadataStorage3;
    })()
  );

  // node_modules/.pnpm/class-transformer@0.5.1/node_modules/class-transformer/esm5/storage.js
  var defaultMetadataStorage = new MetadataStorage();

  // node_modules/.pnpm/class-transformer@0.5.1/node_modules/class-transformer/esm5/utils/get-global.util.js
  function getGlobal() {
    if (typeof globalThis !== "undefined") {
      return globalThis;
    }
    if (typeof global !== "undefined") {
      return global;
    }
    if (typeof window !== "undefined") {
      return window;
    }
    if (typeof self !== "undefined") {
      return self;
    }
  }

  // node_modules/.pnpm/class-transformer@0.5.1/node_modules/class-transformer/esm5/utils/is-promise.util.js
  function isPromise(p5) {
    return p5 !== null && typeof p5 === "object" && typeof p5.then === "function";
  }

  // node_modules/.pnpm/class-transformer@0.5.1/node_modules/class-transformer/esm5/TransformOperationExecutor.js
  var __spreadArray = function(to, from, pack) {
    if (pack || arguments.length === 2) for (var i5 = 0, l6 = from.length, ar; i5 < l6; i5++) {
      if (ar || !(i5 in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i5);
        ar[i5] = from[i5];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  function instantiateArrayType(arrayType) {
    var array = new arrayType();
    if (!(array instanceof Set) && !("push" in array)) {
      return [];
    }
    return array;
  }
  var TransformOperationExecutor = (
    /** @class */
    (function() {
      function TransformOperationExecutor2(transformationType, options) {
        this.transformationType = transformationType;
        this.options = options;
        this.recursionStack = /* @__PURE__ */ new Set();
      }
      TransformOperationExecutor2.prototype.transform = function(source, value, targetType, arrayType, isMap, level) {
        var _this = this;
        if (level === void 0) {
          level = 0;
        }
        if (Array.isArray(value) || value instanceof Set) {
          var newValue_1 = arrayType && this.transformationType === TransformationType.PLAIN_TO_CLASS ? instantiateArrayType(arrayType) : [];
          value.forEach(function(subValue, index) {
            var subSource = source ? source[index] : void 0;
            if (!_this.options.enableCircularCheck || !_this.isCircular(subValue)) {
              var realTargetType = void 0;
              if (typeof targetType !== "function" && targetType && targetType.options && targetType.options.discriminator && targetType.options.discriminator.property && targetType.options.discriminator.subTypes) {
                if (_this.transformationType === TransformationType.PLAIN_TO_CLASS) {
                  realTargetType = targetType.options.discriminator.subTypes.find(function(subType) {
                    return subType.name === subValue[targetType.options.discriminator.property];
                  });
                  var options = { newObject: newValue_1, object: subValue, property: void 0 };
                  var newType = targetType.typeFunction(options);
                  realTargetType === void 0 ? realTargetType = newType : realTargetType = realTargetType.value;
                  if (!targetType.options.keepDiscriminatorProperty)
                    delete subValue[targetType.options.discriminator.property];
                }
                if (_this.transformationType === TransformationType.CLASS_TO_CLASS) {
                  realTargetType = subValue.constructor;
                }
                if (_this.transformationType === TransformationType.CLASS_TO_PLAIN) {
                  subValue[targetType.options.discriminator.property] = targetType.options.discriminator.subTypes.find(function(subType) {
                    return subType.value === subValue.constructor;
                  }).name;
                }
              } else {
                realTargetType = targetType;
              }
              var value_1 = _this.transform(subSource, subValue, realTargetType, void 0, subValue instanceof Map, level + 1);
              if (newValue_1 instanceof Set) {
                newValue_1.add(value_1);
              } else {
                newValue_1.push(value_1);
              }
            } else if (_this.transformationType === TransformationType.CLASS_TO_CLASS) {
              if (newValue_1 instanceof Set) {
                newValue_1.add(subValue);
              } else {
                newValue_1.push(subValue);
              }
            }
          });
          return newValue_1;
        } else if (targetType === String && !isMap) {
          if (value === null || value === void 0)
            return value;
          return String(value);
        } else if (targetType === Number && !isMap) {
          if (value === null || value === void 0)
            return value;
          return Number(value);
        } else if (targetType === Boolean && !isMap) {
          if (value === null || value === void 0)
            return value;
          return Boolean(value);
        } else if ((targetType === Date || value instanceof Date) && !isMap) {
          if (value instanceof Date) {
            return new Date(value.valueOf());
          }
          if (value === null || value === void 0)
            return value;
          return new Date(value);
        } else if (!!getGlobal().Buffer && (targetType === Buffer || value instanceof Buffer) && !isMap) {
          if (value === null || value === void 0)
            return value;
          return Buffer.from(value);
        } else if (isPromise(value) && !isMap) {
          return new Promise(function(resolve, reject) {
            value.then(function(data) {
              return resolve(_this.transform(void 0, data, targetType, void 0, void 0, level + 1));
            }, reject);
          });
        } else if (!isMap && value !== null && typeof value === "object" && typeof value.then === "function") {
          return value;
        } else if (typeof value === "object" && value !== null) {
          if (!targetType && value.constructor !== Object)
            if (!Array.isArray(value) && value.constructor === Array) {
            } else {
              targetType = value.constructor;
            }
          if (!targetType && source)
            targetType = source.constructor;
          if (this.options.enableCircularCheck) {
            this.recursionStack.add(value);
          }
          var keys = this.getKeys(targetType, value, isMap);
          var newValue = source ? source : {};
          if (!source && (this.transformationType === TransformationType.PLAIN_TO_CLASS || this.transformationType === TransformationType.CLASS_TO_CLASS)) {
            if (isMap) {
              newValue = /* @__PURE__ */ new Map();
            } else if (targetType) {
              newValue = new targetType();
            } else {
              newValue = {};
            }
          }
          var _loop_1 = function(key2) {
            if (key2 === "__proto__" || key2 === "constructor") {
              return "continue";
            }
            var valueKey = key2;
            var newValueKey = key2, propertyName = key2;
            if (!this_1.options.ignoreDecorators && targetType) {
              if (this_1.transformationType === TransformationType.PLAIN_TO_CLASS) {
                var exposeMetadata = defaultMetadataStorage.findExposeMetadataByCustomName(targetType, key2);
                if (exposeMetadata) {
                  propertyName = exposeMetadata.propertyName;
                  newValueKey = exposeMetadata.propertyName;
                }
              } else if (this_1.transformationType === TransformationType.CLASS_TO_PLAIN || this_1.transformationType === TransformationType.CLASS_TO_CLASS) {
                var exposeMetadata = defaultMetadataStorage.findExposeMetadata(targetType, key2);
                if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {
                  newValueKey = exposeMetadata.options.name;
                }
              }
            }
            var subValue = void 0;
            if (this_1.transformationType === TransformationType.PLAIN_TO_CLASS) {
              subValue = value[valueKey];
            } else {
              if (value instanceof Map) {
                subValue = value.get(valueKey);
              } else if (value[valueKey] instanceof Function) {
                subValue = value[valueKey]();
              } else {
                subValue = value[valueKey];
              }
            }
            var type = void 0, isSubValueMap = subValue instanceof Map;
            if (targetType && isMap) {
              type = targetType;
            } else if (targetType) {
              var metadata_1 = defaultMetadataStorage.findTypeMetadata(targetType, propertyName);
              if (metadata_1) {
                var options = { newObject: newValue, object: value, property: propertyName };
                var newType = metadata_1.typeFunction ? metadata_1.typeFunction(options) : metadata_1.reflectedType;
                if (metadata_1.options && metadata_1.options.discriminator && metadata_1.options.discriminator.property && metadata_1.options.discriminator.subTypes) {
                  if (!(value[valueKey] instanceof Array)) {
                    if (this_1.transformationType === TransformationType.PLAIN_TO_CLASS) {
                      type = metadata_1.options.discriminator.subTypes.find(function(subType) {
                        if (subValue && subValue instanceof Object && metadata_1.options.discriminator.property in subValue) {
                          return subType.name === subValue[metadata_1.options.discriminator.property];
                        }
                      });
                      type === void 0 ? type = newType : type = type.value;
                      if (!metadata_1.options.keepDiscriminatorProperty) {
                        if (subValue && subValue instanceof Object && metadata_1.options.discriminator.property in subValue) {
                          delete subValue[metadata_1.options.discriminator.property];
                        }
                      }
                    }
                    if (this_1.transformationType === TransformationType.CLASS_TO_CLASS) {
                      type = subValue.constructor;
                    }
                    if (this_1.transformationType === TransformationType.CLASS_TO_PLAIN) {
                      if (subValue) {
                        subValue[metadata_1.options.discriminator.property] = metadata_1.options.discriminator.subTypes.find(function(subType) {
                          return subType.value === subValue.constructor;
                        }).name;
                      }
                    }
                  } else {
                    type = metadata_1;
                  }
                } else {
                  type = newType;
                }
                isSubValueMap = isSubValueMap || metadata_1.reflectedType === Map;
              } else if (this_1.options.targetMaps) {
                this_1.options.targetMaps.filter(function(map) {
                  return map.target === targetType && !!map.properties[propertyName];
                }).forEach(function(map) {
                  return type = map.properties[propertyName];
                });
              } else if (this_1.options.enableImplicitConversion && this_1.transformationType === TransformationType.PLAIN_TO_CLASS) {
                var reflectedType = Reflect.getMetadata("design:type", targetType.prototype, propertyName);
                if (reflectedType) {
                  type = reflectedType;
                }
              }
            }
            var arrayType_1 = Array.isArray(value[valueKey]) ? this_1.getReflectedType(targetType, propertyName) : void 0;
            var subSource = source ? source[valueKey] : void 0;
            if (newValue.constructor.prototype) {
              var descriptor = Object.getOwnPropertyDescriptor(newValue.constructor.prototype, newValueKey);
              if ((this_1.transformationType === TransformationType.PLAIN_TO_CLASS || this_1.transformationType === TransformationType.CLASS_TO_CLASS) && // eslint-disable-next-line @typescript-eslint/unbound-method
              (descriptor && !descriptor.set || newValue[newValueKey] instanceof Function))
                return "continue";
            }
            if (!this_1.options.enableCircularCheck || !this_1.isCircular(subValue)) {
              var transformKey = this_1.transformationType === TransformationType.PLAIN_TO_CLASS ? newValueKey : key2;
              var finalValue = void 0;
              if (this_1.transformationType === TransformationType.CLASS_TO_PLAIN) {
                finalValue = value[transformKey];
                finalValue = this_1.applyCustomTransformations(finalValue, targetType, transformKey, value, this_1.transformationType);
                finalValue = value[transformKey] === finalValue ? subValue : finalValue;
                finalValue = this_1.transform(subSource, finalValue, type, arrayType_1, isSubValueMap, level + 1);
              } else {
                if (subValue === void 0 && this_1.options.exposeDefaultValues) {
                  finalValue = newValue[newValueKey];
                } else {
                  finalValue = this_1.transform(subSource, subValue, type, arrayType_1, isSubValueMap, level + 1);
                  finalValue = this_1.applyCustomTransformations(finalValue, targetType, transformKey, value, this_1.transformationType);
                }
              }
              if (finalValue !== void 0 || this_1.options.exposeUnsetFields) {
                if (newValue instanceof Map) {
                  newValue.set(newValueKey, finalValue);
                } else {
                  newValue[newValueKey] = finalValue;
                }
              }
            } else if (this_1.transformationType === TransformationType.CLASS_TO_CLASS) {
              var finalValue = subValue;
              finalValue = this_1.applyCustomTransformations(finalValue, targetType, key2, value, this_1.transformationType);
              if (finalValue !== void 0 || this_1.options.exposeUnsetFields) {
                if (newValue instanceof Map) {
                  newValue.set(newValueKey, finalValue);
                } else {
                  newValue[newValueKey] = finalValue;
                }
              }
            }
          };
          var this_1 = this;
          for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
            var key = keys_1[_i];
            _loop_1(key);
          }
          if (this.options.enableCircularCheck) {
            this.recursionStack.delete(value);
          }
          return newValue;
        } else {
          return value;
        }
      };
      TransformOperationExecutor2.prototype.applyCustomTransformations = function(value, target, key, obj, transformationType) {
        var _this = this;
        var metadatas = defaultMetadataStorage.findTransformMetadatas(target, key, this.transformationType);
        if (this.options.version !== void 0) {
          metadatas = metadatas.filter(function(metadata) {
            if (!metadata.options)
              return true;
            return _this.checkVersion(metadata.options.since, metadata.options.until);
          });
        }
        if (this.options.groups && this.options.groups.length) {
          metadatas = metadatas.filter(function(metadata) {
            if (!metadata.options)
              return true;
            return _this.checkGroups(metadata.options.groups);
          });
        } else {
          metadatas = metadatas.filter(function(metadata) {
            return !metadata.options || !metadata.options.groups || !metadata.options.groups.length;
          });
        }
        metadatas.forEach(function(metadata) {
          value = metadata.transformFn({ value, key, obj, type: transformationType, options: _this.options });
        });
        return value;
      };
      TransformOperationExecutor2.prototype.isCircular = function(object) {
        return this.recursionStack.has(object);
      };
      TransformOperationExecutor2.prototype.getReflectedType = function(target, propertyName) {
        if (!target)
          return void 0;
        var meta = defaultMetadataStorage.findTypeMetadata(target, propertyName);
        return meta ? meta.reflectedType : void 0;
      };
      TransformOperationExecutor2.prototype.getKeys = function(target, object, isMap) {
        var _this = this;
        var strategy = defaultMetadataStorage.getStrategy(target);
        if (strategy === "none")
          strategy = this.options.strategy || "exposeAll";
        var keys = [];
        if (strategy === "exposeAll" || isMap) {
          if (object instanceof Map) {
            keys = Array.from(object.keys());
          } else {
            keys = Object.keys(object);
          }
        }
        if (isMap) {
          return keys;
        }
        if (this.options.ignoreDecorators && this.options.excludeExtraneousValues && target) {
          var exposedProperties = defaultMetadataStorage.getExposedProperties(target, this.transformationType);
          var excludedProperties = defaultMetadataStorage.getExcludedProperties(target, this.transformationType);
          keys = __spreadArray(__spreadArray([], exposedProperties, true), excludedProperties, true);
        }
        if (!this.options.ignoreDecorators && target) {
          var exposedProperties = defaultMetadataStorage.getExposedProperties(target, this.transformationType);
          if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {
            exposedProperties = exposedProperties.map(function(key) {
              var exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);
              if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {
                return exposeMetadata.options.name;
              }
              return key;
            });
          }
          if (this.options.excludeExtraneousValues) {
            keys = exposedProperties;
          } else {
            keys = keys.concat(exposedProperties);
          }
          var excludedProperties_1 = defaultMetadataStorage.getExcludedProperties(target, this.transformationType);
          if (excludedProperties_1.length > 0) {
            keys = keys.filter(function(key) {
              return !excludedProperties_1.includes(key);
            });
          }
          if (this.options.version !== void 0) {
            keys = keys.filter(function(key) {
              var exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);
              if (!exposeMetadata || !exposeMetadata.options)
                return true;
              return _this.checkVersion(exposeMetadata.options.since, exposeMetadata.options.until);
            });
          }
          if (this.options.groups && this.options.groups.length) {
            keys = keys.filter(function(key) {
              var exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);
              if (!exposeMetadata || !exposeMetadata.options)
                return true;
              return _this.checkGroups(exposeMetadata.options.groups);
            });
          } else {
            keys = keys.filter(function(key) {
              var exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);
              return !exposeMetadata || !exposeMetadata.options || !exposeMetadata.options.groups || !exposeMetadata.options.groups.length;
            });
          }
        }
        if (this.options.excludePrefixes && this.options.excludePrefixes.length) {
          keys = keys.filter(function(key) {
            return _this.options.excludePrefixes.every(function(prefix) {
              return key.substr(0, prefix.length) !== prefix;
            });
          });
        }
        keys = keys.filter(function(key, index, self2) {
          return self2.indexOf(key) === index;
        });
        return keys;
      };
      TransformOperationExecutor2.prototype.checkVersion = function(since, until) {
        var decision = true;
        if (decision && since)
          decision = this.options.version >= since;
        if (decision && until)
          decision = this.options.version < until;
        return decision;
      };
      TransformOperationExecutor2.prototype.checkGroups = function(groups) {
        if (!groups)
          return true;
        return this.options.groups.some(function(optionGroup) {
          return groups.includes(optionGroup);
        });
      };
      return TransformOperationExecutor2;
    })()
  );

  // node_modules/.pnpm/class-transformer@0.5.1/node_modules/class-transformer/esm5/constants/default-options.constant.js
  var defaultOptions = {
    enableCircularCheck: false,
    enableImplicitConversion: false,
    excludeExtraneousValues: false,
    excludePrefixes: void 0,
    exposeDefaultValues: false,
    exposeUnsetFields: true,
    groups: void 0,
    ignoreDecorators: false,
    strategy: void 0,
    targetMaps: void 0,
    version: void 0
  };

  // node_modules/.pnpm/class-transformer@0.5.1/node_modules/class-transformer/esm5/ClassTransformer.js
  var __assign = function() {
    __assign = Object.assign || function(t3) {
      for (var s5, i5 = 1, n4 = arguments.length; i5 < n4; i5++) {
        s5 = arguments[i5];
        for (var p5 in s5) if (Object.prototype.hasOwnProperty.call(s5, p5))
          t3[p5] = s5[p5];
      }
      return t3;
    };
    return __assign.apply(this, arguments);
  };
  var ClassTransformer = (
    /** @class */
    (function() {
      function ClassTransformer2() {
      }
      ClassTransformer2.prototype.instanceToPlain = function(object, options) {
        var executor = new TransformOperationExecutor(TransformationType.CLASS_TO_PLAIN, __assign(__assign({}, defaultOptions), options));
        return executor.transform(void 0, object, void 0, void 0, void 0, void 0);
      };
      ClassTransformer2.prototype.classToPlainFromExist = function(object, plainObject, options) {
        var executor = new TransformOperationExecutor(TransformationType.CLASS_TO_PLAIN, __assign(__assign({}, defaultOptions), options));
        return executor.transform(plainObject, object, void 0, void 0, void 0, void 0);
      };
      ClassTransformer2.prototype.plainToInstance = function(cls, plain, options) {
        var executor = new TransformOperationExecutor(TransformationType.PLAIN_TO_CLASS, __assign(__assign({}, defaultOptions), options));
        return executor.transform(void 0, plain, cls, void 0, void 0, void 0);
      };
      ClassTransformer2.prototype.plainToClassFromExist = function(clsObject, plain, options) {
        var executor = new TransformOperationExecutor(TransformationType.PLAIN_TO_CLASS, __assign(__assign({}, defaultOptions), options));
        return executor.transform(clsObject, plain, void 0, void 0, void 0, void 0);
      };
      ClassTransformer2.prototype.instanceToInstance = function(object, options) {
        var executor = new TransformOperationExecutor(TransformationType.CLASS_TO_CLASS, __assign(__assign({}, defaultOptions), options));
        return executor.transform(void 0, object, void 0, void 0, void 0, void 0);
      };
      ClassTransformer2.prototype.classToClassFromExist = function(object, fromObject, options) {
        var executor = new TransformOperationExecutor(TransformationType.CLASS_TO_CLASS, __assign(__assign({}, defaultOptions), options));
        return executor.transform(fromObject, object, void 0, void 0, void 0, void 0);
      };
      ClassTransformer2.prototype.serialize = function(object, options) {
        return JSON.stringify(this.instanceToPlain(object, options));
      };
      ClassTransformer2.prototype.deserialize = function(cls, json, options) {
        var jsonObject = JSON.parse(json);
        return this.plainToInstance(cls, jsonObject, options);
      };
      ClassTransformer2.prototype.deserializeArray = function(cls, json, options) {
        var jsonObject = JSON.parse(json);
        return this.plainToInstance(cls, jsonObject, options);
      };
      return ClassTransformer2;
    })()
  );

  // node_modules/.pnpm/class-transformer@0.5.1/node_modules/class-transformer/esm5/decorators/type.decorator.js
  function Type(typeFunction, options) {
    if (options === void 0) {
      options = {};
    }
    return function(target, propertyName) {
      var reflectedType = Reflect.getMetadata("design:type", target, propertyName);
      defaultMetadataStorage.addTypeMetadata({
        target: target.constructor,
        propertyName,
        reflectedType,
        typeFunction,
        options
      });
    };
  }

  // node_modules/.pnpm/class-transformer@0.5.1/node_modules/class-transformer/esm5/index.js
  var classTransformer = new ClassTransformer();
  function plainToInstance(cls, plain, options) {
    return classTransformer.plainToInstance(cls, plain, options);
  }

  // node_modules/.pnpm/class-validator@0.14.3/node_modules/class-validator/esm5/metadata/ValidationMetadata.js
  var ValidationMetadata = (
    /** @class */
    /* @__PURE__ */ (function() {
      function ValidationMetadata2(args) {
        this.groups = [];
        this.each = false;
        this.context = void 0;
        this.type = args.type;
        this.name = args.name;
        this.target = args.target;
        this.propertyName = args.propertyName;
        this.constraints = args === null || args === void 0 ? void 0 : args.constraints;
        this.constraintCls = args.constraintCls;
        this.validationTypeOptions = args.validationTypeOptions;
        if (args.validationOptions) {
          this.message = args.validationOptions.message;
          this.groups = args.validationOptions.groups;
          this.always = args.validationOptions.always;
          this.each = args.validationOptions.each;
          this.context = args.validationOptions.context;
        }
      }
      return ValidationMetadata2;
    })()
  );

  // node_modules/.pnpm/class-validator@0.14.3/node_modules/class-validator/esm5/validation-schema/ValidationSchemaToMetadataTransformer.js
  var ValidationSchemaToMetadataTransformer = (
    /** @class */
    (function() {
      function ValidationSchemaToMetadataTransformer2() {
      }
      ValidationSchemaToMetadataTransformer2.prototype.transform = function(schema) {
        var metadatas = [];
        Object.keys(schema.properties).forEach(function(property) {
          schema.properties[property].forEach(function(validation) {
            var validationOptions = {
              message: validation.message,
              groups: validation.groups,
              always: validation.always,
              each: validation.each
            };
            var args = {
              type: validation.type,
              name: validation.name,
              target: schema.name,
              propertyName: property,
              constraints: validation.constraints,
              validationTypeOptions: validation.options,
              validationOptions
            };
            metadatas.push(new ValidationMetadata(args));
          });
        });
        return metadatas;
      };
      return ValidationSchemaToMetadataTransformer2;
    })()
  );

  // node_modules/.pnpm/class-validator@0.14.3/node_modules/class-validator/esm5/utils/convert-to-array.util.js
  function convertToArray(val) {
    if (val instanceof Map) {
      return Array.from(val.values());
    }
    return Array.isArray(val) ? val : Array.from(val);
  }

  // node_modules/.pnpm/class-validator@0.14.3/node_modules/class-validator/esm5/utils/get-global.util.js
  function getGlobal2() {
    if (typeof globalThis !== "undefined") {
      return globalThis;
    }
    if (typeof global !== "undefined") {
      return global;
    }
    if (typeof window !== "undefined") {
      return window;
    }
    if (typeof self !== "undefined") {
      return self;
    }
  }

  // node_modules/.pnpm/class-validator@0.14.3/node_modules/class-validator/esm5/utils/is-promise.util.js
  function isPromise2(p5) {
    return p5 !== null && typeof p5 === "object" && typeof p5.then === "function";
  }

  // node_modules/.pnpm/class-validator@0.14.3/node_modules/class-validator/esm5/metadata/MetadataStorage.js
  var __values = function(o5) {
    var s5 = typeof Symbol === "function" && Symbol.iterator, m4 = s5 && o5[s5], i5 = 0;
    if (m4) return m4.call(o5);
    if (o5 && typeof o5.length === "number") return {
      next: function() {
        if (o5 && i5 >= o5.length) o5 = void 0;
        return { value: o5 && o5[i5++], done: !o5 };
      }
    };
    throw new TypeError(s5 ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var __read = function(o5, n4) {
    var m4 = typeof Symbol === "function" && o5[Symbol.iterator];
    if (!m4) return o5;
    var i5 = m4.call(o5), r5, ar = [], e2;
    try {
      while ((n4 === void 0 || n4-- > 0) && !(r5 = i5.next()).done) ar.push(r5.value);
    } catch (error) {
      e2 = { error };
    } finally {
      try {
        if (r5 && !r5.done && (m4 = i5["return"])) m4.call(i5);
      } finally {
        if (e2) throw e2.error;
      }
    }
    return ar;
  };
  var __spreadArray2 = function(to, from, pack) {
    if (pack || arguments.length === 2) for (var i5 = 0, l6 = from.length, ar; i5 < l6; i5++) {
      if (ar || !(i5 in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i5);
        ar[i5] = from[i5];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  var MetadataStorage2 = (
    /** @class */
    (function() {
      function MetadataStorage3() {
        this.validationMetadatas = /* @__PURE__ */ new Map();
        this.constraintMetadatas = /* @__PURE__ */ new Map();
      }
      Object.defineProperty(MetadataStorage3.prototype, "hasValidationMetaData", {
        get: function() {
          return !!this.validationMetadatas.size;
        },
        enumerable: false,
        configurable: true
      });
      MetadataStorage3.prototype.addValidationSchema = function(schema) {
        var _this = this;
        var validationMetadatas = new ValidationSchemaToMetadataTransformer().transform(schema);
        validationMetadatas.forEach(function(validationMetadata) {
          return _this.addValidationMetadata(validationMetadata);
        });
      };
      MetadataStorage3.prototype.addValidationMetadata = function(metadata) {
        var existingMetadata = this.validationMetadatas.get(metadata.target);
        if (existingMetadata) {
          existingMetadata.push(metadata);
        } else {
          this.validationMetadatas.set(metadata.target, [metadata]);
        }
      };
      MetadataStorage3.prototype.addConstraintMetadata = function(metadata) {
        var existingMetadata = this.constraintMetadatas.get(metadata.target);
        if (existingMetadata) {
          existingMetadata.push(metadata);
        } else {
          this.constraintMetadatas.set(metadata.target, [metadata]);
        }
      };
      MetadataStorage3.prototype.groupByPropertyName = function(metadata) {
        var grouped = {};
        metadata.forEach(function(metadata2) {
          if (!grouped[metadata2.propertyName])
            grouped[metadata2.propertyName] = [];
          grouped[metadata2.propertyName].push(metadata2);
        });
        return grouped;
      };
      MetadataStorage3.prototype.getTargetValidationMetadatas = function(targetConstructor, targetSchema, always, strictGroups, groups) {
        var e_1, _a;
        var includeMetadataBecauseOfAlwaysOption = function(metadata) {
          if (typeof metadata.always !== "undefined")
            return metadata.always;
          if (metadata.groups && metadata.groups.length)
            return false;
          return always;
        };
        var excludeMetadataBecauseOfStrictGroupsOption = function(metadata) {
          if (strictGroups) {
            if (!groups || !groups.length) {
              if (metadata.groups && metadata.groups.length)
                return true;
            }
          }
          return false;
        };
        var filteredForOriginalMetadatasSearch = this.validationMetadatas.get(targetConstructor) || [];
        var originalMetadatas = filteredForOriginalMetadatasSearch.filter(function(metadata) {
          if (metadata.target !== targetConstructor && metadata.target !== targetSchema)
            return false;
          if (includeMetadataBecauseOfAlwaysOption(metadata))
            return true;
          if (excludeMetadataBecauseOfStrictGroupsOption(metadata))
            return false;
          if (groups && groups.length > 0)
            return metadata.groups && !!metadata.groups.find(function(group) {
              return groups.indexOf(group) !== -1;
            });
          return true;
        });
        var filteredForInheritedMetadatasSearch = [];
        try {
          for (var _b = __values(this.validationMetadatas.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
            var _d = __read(_c.value, 2), key = _d[0], value = _d[1];
            if (targetConstructor.prototype instanceof key) {
              filteredForInheritedMetadatasSearch.push.apply(filteredForInheritedMetadatasSearch, __spreadArray2([], __read(value), false));
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        var inheritedMetadatas = filteredForInheritedMetadatasSearch.filter(function(metadata) {
          if (typeof metadata.target === "string")
            return false;
          if (metadata.target === targetConstructor)
            return false;
          if (metadata.target instanceof Function && !(targetConstructor.prototype instanceof metadata.target))
            return false;
          if (includeMetadataBecauseOfAlwaysOption(metadata))
            return true;
          if (excludeMetadataBecauseOfStrictGroupsOption(metadata))
            return false;
          if (groups && groups.length > 0)
            return metadata.groups && !!metadata.groups.find(function(group) {
              return groups.indexOf(group) !== -1;
            });
          return true;
        });
        var uniqueInheritedMetadatas = inheritedMetadatas.filter(function(inheritedMetadata) {
          return !originalMetadatas.find(function(originalMetadata) {
            return originalMetadata.propertyName === inheritedMetadata.propertyName && originalMetadata.type === inheritedMetadata.type;
          });
        });
        return originalMetadatas.concat(uniqueInheritedMetadatas);
      };
      MetadataStorage3.prototype.getTargetValidatorConstraints = function(target) {
        return this.constraintMetadatas.get(target) || [];
      };
      return MetadataStorage3;
    })()
  );
  function getMetadataStorage() {
    var global2 = getGlobal2();
    if (!global2.classValidatorMetadataStorage) {
      global2.classValidatorMetadataStorage = new MetadataStorage2();
    }
    return global2.classValidatorMetadataStorage;
  }

  // node_modules/.pnpm/class-validator@0.14.3/node_modules/class-validator/esm5/validation/ValidationError.js
  var ValidationError = (
    /** @class */
    (function() {
      function ValidationError2() {
      }
      ValidationError2.prototype.toString = function(shouldDecorate, hasParent, parentPath, showConstraintMessages) {
        var _this = this;
        if (shouldDecorate === void 0) {
          shouldDecorate = false;
        }
        if (hasParent === void 0) {
          hasParent = false;
        }
        if (parentPath === void 0) {
          parentPath = "";
        }
        if (showConstraintMessages === void 0) {
          showConstraintMessages = false;
        }
        var boldStart = shouldDecorate ? "\x1B[1m" : "";
        var boldEnd = shouldDecorate ? "\x1B[22m" : "";
        var constraintsToString = function() {
          var _a;
          return (showConstraintMessages ? Object.values : Object.keys)((_a = _this.constraints) !== null && _a !== void 0 ? _a : {}).join(", ");
        };
        var propConstraintFailed = function(propertyName) {
          return " - property ".concat(boldStart).concat(parentPath).concat(propertyName).concat(boldEnd, " has failed the following constraints: ").concat(boldStart).concat(constraintsToString()).concat(boldEnd, " \n");
        };
        if (!hasParent) {
          return "An instance of ".concat(boldStart).concat(this.target ? this.target.constructor.name : "an object").concat(boldEnd, " has failed the validation:\n") + (this.constraints ? propConstraintFailed(this.property) : "") + (this.children ? this.children.map(function(childError) {
            return childError.toString(shouldDecorate, true, _this.property, showConstraintMessages);
          }).join("") : "");
        } else {
          var formattedProperty_1 = Number.isInteger(+this.property) ? "[".concat(this.property, "]") : "".concat(parentPath ? "." : "").concat(this.property);
          if (this.constraints) {
            return propConstraintFailed(formattedProperty_1);
          } else {
            return this.children ? this.children.map(function(childError) {
              return childError.toString(shouldDecorate, true, "".concat(parentPath).concat(formattedProperty_1), showConstraintMessages);
            }).join("") : "";
          }
        }
      };
      return ValidationError2;
    })()
  );

  // node_modules/.pnpm/class-validator@0.14.3/node_modules/class-validator/esm5/validation/ValidationTypes.js
  var ValidationTypes = (
    /** @class */
    (function() {
      function ValidationTypes2() {
      }
      ValidationTypes2.isValid = function(type) {
        var _this = this;
        return type !== "isValid" && type !== "getMessage" && Object.keys(this).map(function(key) {
          return _this[key];
        }).indexOf(type) !== -1;
      };
      ValidationTypes2.CUSTOM_VALIDATION = "customValidation";
      ValidationTypes2.NESTED_VALIDATION = "nestedValidation";
      ValidationTypes2.PROMISE_VALIDATION = "promiseValidation";
      ValidationTypes2.CONDITIONAL_VALIDATION = "conditionalValidation";
      ValidationTypes2.WHITELIST = "whitelistValidation";
      ValidationTypes2.IS_DEFINED = "isDefined";
      return ValidationTypes2;
    })()
  );

  // node_modules/.pnpm/class-validator@0.14.3/node_modules/class-validator/esm5/validation/ValidationUtils.js
  function constraintToString(constraint) {
    if (Array.isArray(constraint)) {
      return constraint.join(", ");
    }
    if (typeof constraint === "symbol") {
      constraint = constraint.description;
    }
    return "".concat(constraint);
  }
  var ValidationUtils = (
    /** @class */
    (function() {
      function ValidationUtils2() {
      }
      ValidationUtils2.replaceMessageSpecialTokens = function(message, validationArguments) {
        var messageString;
        if (message instanceof Function) {
          messageString = message(validationArguments);
        } else if (typeof message === "string") {
          messageString = message;
        }
        if (messageString && Array.isArray(validationArguments.constraints)) {
          validationArguments.constraints.forEach(function(constraint, index) {
            messageString = messageString.replace(new RegExp("\\$constraint".concat(index + 1), "g"), constraintToString(constraint));
          });
        }
        if (messageString && validationArguments.value !== void 0 && validationArguments.value !== null && ["string", "boolean", "number"].includes(typeof validationArguments.value))
          messageString = messageString.replace(/\$value/g, validationArguments.value);
        if (messageString)
          messageString = messageString.replace(/\$property/g, validationArguments.property);
        if (messageString)
          messageString = messageString.replace(/\$target/g, validationArguments.targetName);
        return messageString;
      };
      return ValidationUtils2;
    })()
  );

  // node_modules/.pnpm/class-validator@0.14.3/node_modules/class-validator/esm5/validation/ValidationExecutor.js
  var __read2 = function(o5, n4) {
    var m4 = typeof Symbol === "function" && o5[Symbol.iterator];
    if (!m4) return o5;
    var i5 = m4.call(o5), r5, ar = [], e2;
    try {
      while ((n4 === void 0 || n4-- > 0) && !(r5 = i5.next()).done) ar.push(r5.value);
    } catch (error) {
      e2 = { error };
    } finally {
      try {
        if (r5 && !r5.done && (m4 = i5["return"])) m4.call(i5);
      } finally {
        if (e2) throw e2.error;
      }
    }
    return ar;
  };
  var ValidationExecutor = (
    /** @class */
    (function() {
      function ValidationExecutor2(validator, validatorOptions) {
        this.validator = validator;
        this.validatorOptions = validatorOptions;
        this.awaitingPromises = [];
        this.ignoreAsyncValidations = false;
        this.metadataStorage = getMetadataStorage();
      }
      ValidationExecutor2.prototype.execute = function(object, targetSchema, validationErrors) {
        var _this = this;
        var _a, _b;
        if (!this.metadataStorage.hasValidationMetaData && ((_a = this.validatorOptions) === null || _a === void 0 ? void 0 : _a.enableDebugMessages) === true) {
          console.warn("No validation metadata found. No validation will be  performed. There are multiple possible reasons:\n  - There may be multiple class-validator versions installed. You will need to flatten your dependencies to fix the issue.\n  - This validation runs before any file with validation decorator was parsed by NodeJS.");
        }
        var groups = this.validatorOptions ? this.validatorOptions.groups : void 0;
        var strictGroups = this.validatorOptions && this.validatorOptions.strictGroups || false;
        var always = this.validatorOptions && this.validatorOptions.always || false;
        var forbidUnknownValues = ((_b = this.validatorOptions) === null || _b === void 0 ? void 0 : _b.forbidUnknownValues) === void 0 || this.validatorOptions.forbidUnknownValues !== false;
        var targetMetadatas = this.metadataStorage.getTargetValidationMetadatas(object.constructor, targetSchema, always, strictGroups, groups);
        var groupedMetadatas = this.metadataStorage.groupByPropertyName(targetMetadatas);
        if (forbidUnknownValues && !targetMetadatas.length) {
          var validationError = new ValidationError();
          if (!this.validatorOptions || !this.validatorOptions.validationError || this.validatorOptions.validationError.target === void 0 || this.validatorOptions.validationError.target === true)
            validationError.target = object;
          validationError.value = void 0;
          validationError.property = void 0;
          validationError.children = [];
          validationError.constraints = { unknownValue: "an unknown value was passed to the validate function" };
          validationErrors.push(validationError);
          return;
        }
        if (this.validatorOptions && this.validatorOptions.whitelist)
          this.whitelist(object, groupedMetadatas, validationErrors);
        Object.keys(groupedMetadatas).forEach(function(propertyName) {
          var value = object[propertyName];
          var definedMetadatas = groupedMetadatas[propertyName].filter(function(metadata) {
            return metadata.type === ValidationTypes.IS_DEFINED;
          });
          var metadatas = groupedMetadatas[propertyName].filter(function(metadata) {
            return metadata.type !== ValidationTypes.IS_DEFINED && metadata.type !== ValidationTypes.WHITELIST;
          });
          if (value instanceof Promise && metadatas.find(function(metadata) {
            return metadata.type === ValidationTypes.PROMISE_VALIDATION;
          })) {
            _this.awaitingPromises.push(value.then(function(resolvedValue) {
              _this.performValidations(object, resolvedValue, propertyName, definedMetadatas, metadatas, validationErrors);
            }));
          } else {
            _this.performValidations(object, value, propertyName, definedMetadatas, metadatas, validationErrors);
          }
        });
      };
      ValidationExecutor2.prototype.whitelist = function(object, groupedMetadatas, validationErrors) {
        var _this = this;
        var notAllowedProperties = [];
        Object.keys(object).forEach(function(propertyName) {
          if (!groupedMetadatas[propertyName] || groupedMetadatas[propertyName].length === 0)
            notAllowedProperties.push(propertyName);
        });
        if (notAllowedProperties.length > 0) {
          if (this.validatorOptions && this.validatorOptions.forbidNonWhitelisted) {
            notAllowedProperties.forEach(function(property) {
              var _a;
              var validationError = _this.generateValidationError(object, object[property], property);
              validationError.constraints = (_a = {}, _a[ValidationTypes.WHITELIST] = "property ".concat(property, " should not exist"), _a);
              validationError.children = void 0;
              validationErrors.push(validationError);
            });
          } else {
            notAllowedProperties.forEach(function(property) {
              return delete object[property];
            });
          }
        }
      };
      ValidationExecutor2.prototype.stripEmptyErrors = function(errors) {
        var _this = this;
        return errors.filter(function(error) {
          if (error.children) {
            error.children = _this.stripEmptyErrors(error.children);
          }
          if (Object.keys(error.constraints).length === 0) {
            if (error.children.length === 0) {
              return false;
            } else {
              delete error.constraints;
            }
          }
          return true;
        });
      };
      ValidationExecutor2.prototype.performValidations = function(object, value, propertyName, definedMetadatas, metadatas, validationErrors) {
        var customValidationMetadatas = metadatas.filter(function(metadata) {
          return metadata.type === ValidationTypes.CUSTOM_VALIDATION;
        });
        var nestedValidationMetadatas = metadatas.filter(function(metadata) {
          return metadata.type === ValidationTypes.NESTED_VALIDATION;
        });
        var conditionalValidationMetadatas = metadatas.filter(function(metadata) {
          return metadata.type === ValidationTypes.CONDITIONAL_VALIDATION;
        });
        var validationError = this.generateValidationError(object, value, propertyName);
        validationErrors.push(validationError);
        var canValidate = this.conditionalValidations(object, value, conditionalValidationMetadatas);
        if (!canValidate) {
          return;
        }
        this.customValidations(object, value, definedMetadatas, validationError);
        this.mapContexts(object, value, definedMetadatas, validationError);
        if (value === void 0 && this.validatorOptions && this.validatorOptions.skipUndefinedProperties === true) {
          return;
        }
        if (value === null && this.validatorOptions && this.validatorOptions.skipNullProperties === true) {
          return;
        }
        if ((value === null || value === void 0) && this.validatorOptions && this.validatorOptions.skipMissingProperties === true) {
          return;
        }
        this.customValidations(object, value, customValidationMetadatas, validationError);
        this.nestedValidations(value, nestedValidationMetadatas, validationError);
        this.mapContexts(object, value, metadatas, validationError);
        this.mapContexts(object, value, customValidationMetadatas, validationError);
      };
      ValidationExecutor2.prototype.generateValidationError = function(object, value, propertyName) {
        var validationError = new ValidationError();
        if (!this.validatorOptions || !this.validatorOptions.validationError || this.validatorOptions.validationError.target === void 0 || this.validatorOptions.validationError.target === true)
          validationError.target = object;
        if (!this.validatorOptions || !this.validatorOptions.validationError || this.validatorOptions.validationError.value === void 0 || this.validatorOptions.validationError.value === true)
          validationError.value = value;
        validationError.property = propertyName;
        validationError.children = [];
        validationError.constraints = {};
        return validationError;
      };
      ValidationExecutor2.prototype.conditionalValidations = function(object, value, metadatas) {
        return metadatas.map(function(metadata) {
          return metadata.constraints[0](object, value);
        }).reduce(function(resultA, resultB) {
          return resultA && resultB;
        }, true);
      };
      ValidationExecutor2.prototype.customValidations = function(object, value, metadatas, error) {
        var _this = this;
        metadatas.forEach(function(metadata) {
          _this.metadataStorage.getTargetValidatorConstraints(metadata.constraintCls).forEach(function(customConstraintMetadata) {
            if (customConstraintMetadata.async && _this.ignoreAsyncValidations)
              return;
            if (_this.validatorOptions && _this.validatorOptions.stopAtFirstError && Object.keys(error.constraints || {}).length > 0)
              return;
            var validationArguments = {
              targetName: object.constructor ? object.constructor.name : void 0,
              property: metadata.propertyName,
              object,
              value,
              constraints: metadata.constraints
            };
            if (!metadata.each || !(Array.isArray(value) || value instanceof Set || value instanceof Map)) {
              var validatedValue = customConstraintMetadata.instance.validate(value, validationArguments);
              if (isPromise2(validatedValue)) {
                var promise = validatedValue.then(function(isValid) {
                  if (!isValid) {
                    var _a2 = __read2(_this.createValidationError(object, value, metadata, customConstraintMetadata), 2), type2 = _a2[0], message2 = _a2[1];
                    error.constraints[type2] = message2;
                    if (metadata.context) {
                      if (!error.contexts) {
                        error.contexts = {};
                      }
                      error.contexts[type2] = Object.assign(error.contexts[type2] || {}, metadata.context);
                    }
                  }
                });
                _this.awaitingPromises.push(promise);
              } else {
                if (!validatedValue) {
                  var _a = __read2(_this.createValidationError(object, value, metadata, customConstraintMetadata), 2), type = _a[0], message = _a[1];
                  error.constraints[type] = message;
                }
              }
              return;
            }
            var arrayValue = convertToArray(value);
            var validatedSubValues = arrayValue.map(function(subValue) {
              return customConstraintMetadata.instance.validate(subValue, validationArguments);
            });
            var validationIsAsync = validatedSubValues.some(function(validatedSubValue) {
              return isPromise2(validatedSubValue);
            });
            if (validationIsAsync) {
              var asyncValidatedSubValues = validatedSubValues.map(function(validatedSubValue) {
                return isPromise2(validatedSubValue) ? validatedSubValue : Promise.resolve(validatedSubValue);
              });
              var asyncValidationIsFinishedPromise = Promise.all(asyncValidatedSubValues).then(function(flatValidatedValues) {
                var validationResult2 = flatValidatedValues.every(function(isValid) {
                  return isValid;
                });
                if (!validationResult2) {
                  var _a2 = __read2(_this.createValidationError(object, value, metadata, customConstraintMetadata), 2), type2 = _a2[0], message2 = _a2[1];
                  error.constraints[type2] = message2;
                  if (metadata.context) {
                    if (!error.contexts) {
                      error.contexts = {};
                    }
                    error.contexts[type2] = Object.assign(error.contexts[type2] || {}, metadata.context);
                  }
                }
              });
              _this.awaitingPromises.push(asyncValidationIsFinishedPromise);
              return;
            }
            var validationResult = validatedSubValues.every(function(isValid) {
              return isValid;
            });
            if (!validationResult) {
              var _b = __read2(_this.createValidationError(object, value, metadata, customConstraintMetadata), 2), type = _b[0], message = _b[1];
              error.constraints[type] = message;
            }
          });
        });
      };
      ValidationExecutor2.prototype.nestedValidations = function(value, metadatas, error) {
        var _this = this;
        if (value === void 0) {
          return;
        }
        metadatas.forEach(function(metadata) {
          if (metadata.type !== ValidationTypes.NESTED_VALIDATION && metadata.type !== ValidationTypes.PROMISE_VALIDATION) {
            return;
          } else if (_this.validatorOptions && _this.validatorOptions.stopAtFirstError && Object.keys(error.constraints || {}).length > 0) {
            return;
          }
          if (Array.isArray(value) || value instanceof Set || value instanceof Map) {
            var arrayLikeValue = value instanceof Set ? Array.from(value) : value;
            arrayLikeValue.forEach(function(subValue, index) {
              _this.performValidations(value, subValue, index.toString(), [], metadatas, error.children);
            });
          } else if (value instanceof Object) {
            var targetSchema = typeof metadata.target === "string" ? metadata.target : metadata.target.name;
            _this.execute(value, targetSchema, error.children);
          } else {
            var _a = __read2(_this.createValidationError(metadata.target, value, metadata), 2), type = _a[0], message = _a[1];
            error.constraints[type] = message;
          }
        });
      };
      ValidationExecutor2.prototype.mapContexts = function(object, value, metadatas, error) {
        var _this = this;
        return metadatas.forEach(function(metadata) {
          if (metadata.context) {
            var customConstraint = void 0;
            if (metadata.type === ValidationTypes.CUSTOM_VALIDATION) {
              var customConstraints = _this.metadataStorage.getTargetValidatorConstraints(metadata.constraintCls);
              customConstraint = customConstraints[0];
            }
            var type = _this.getConstraintType(metadata, customConstraint);
            if (error.constraints[type]) {
              if (!error.contexts) {
                error.contexts = {};
              }
              error.contexts[type] = Object.assign(error.contexts[type] || {}, metadata.context);
            }
          }
        });
      };
      ValidationExecutor2.prototype.createValidationError = function(object, value, metadata, customValidatorMetadata) {
        var targetName = object.constructor ? object.constructor.name : void 0;
        var type = this.getConstraintType(metadata, customValidatorMetadata);
        var validationArguments = {
          targetName,
          property: metadata.propertyName,
          object,
          value,
          constraints: metadata.constraints
        };
        var message = metadata.message || "";
        if (!metadata.message && (!this.validatorOptions || this.validatorOptions && !this.validatorOptions.dismissDefaultMessages)) {
          if (customValidatorMetadata && customValidatorMetadata.instance.defaultMessage instanceof Function) {
            message = customValidatorMetadata.instance.defaultMessage(validationArguments);
          }
        }
        var messageString = ValidationUtils.replaceMessageSpecialTokens(message, validationArguments);
        return [type, messageString];
      };
      ValidationExecutor2.prototype.getConstraintType = function(metadata, customValidatorMetadata) {
        var type = customValidatorMetadata && customValidatorMetadata.name ? customValidatorMetadata.name : metadata.type;
        return type;
      };
      return ValidationExecutor2;
    })()
  );

  // node_modules/.pnpm/class-validator@0.14.3/node_modules/class-validator/esm5/validation/Validator.js
  var __awaiter = function(thisArg, _arguments, P6, generator) {
    function adopt(value) {
      return value instanceof P6 ? value : new P6(function(resolve) {
        resolve(value);
      });
    }
    return new (P6 || (P6 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = function(thisArg, body) {
    var _4 = { label: 0, sent: function() {
      if (t3[0] & 1) throw t3[1];
      return t3[1];
    }, trys: [], ops: [] }, f6, y5, t3, g6;
    return g6 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g6[Symbol.iterator] = function() {
      return this;
    }), g6;
    function verb(n4) {
      return function(v4) {
        return step([n4, v4]);
      };
    }
    function step(op) {
      if (f6) throw new TypeError("Generator is already executing.");
      while (g6 && (g6 = 0, op[0] && (_4 = 0)), _4) try {
        if (f6 = 1, y5 && (t3 = op[0] & 2 ? y5["return"] : op[0] ? y5["throw"] || ((t3 = y5["return"]) && t3.call(y5), 0) : y5.next) && !(t3 = t3.call(y5, op[1])).done) return t3;
        if (y5 = 0, t3) op = [op[0] & 2, t3.value];
        switch (op[0]) {
          case 0:
          case 1:
            t3 = op;
            break;
          case 4:
            _4.label++;
            return { value: op[1], done: false };
          case 5:
            _4.label++;
            y5 = op[1];
            op = [0];
            continue;
          case 7:
            op = _4.ops.pop();
            _4.trys.pop();
            continue;
          default:
            if (!(t3 = _4.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _4 = 0;
              continue;
            }
            if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
              _4.label = op[1];
              break;
            }
            if (op[0] === 6 && _4.label < t3[1]) {
              _4.label = t3[1];
              t3 = op;
              break;
            }
            if (t3 && _4.label < t3[2]) {
              _4.label = t3[2];
              _4.ops.push(op);
              break;
            }
            if (t3[2]) _4.ops.pop();
            _4.trys.pop();
            continue;
        }
        op = body.call(thisArg, _4);
      } catch (e2) {
        op = [6, e2];
        y5 = 0;
      } finally {
        f6 = t3 = 0;
      }
      if (op[0] & 5) throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  };
  var Validator = (
    /** @class */
    (function() {
      function Validator2() {
      }
      Validator2.prototype.validate = function(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions) {
        return this.coreValidate(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions);
      };
      Validator2.prototype.validateOrReject = function(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions) {
        return __awaiter(this, void 0, void 0, function() {
          var errors;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.coreValidate(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions)];
              case 1:
                errors = _a.sent();
                if (errors.length)
                  return [2, Promise.reject(errors)];
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      Validator2.prototype.validateSync = function(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions) {
        var object = typeof objectOrSchemaName === "string" ? objectOrValidationOptions : objectOrSchemaName;
        var options = typeof objectOrSchemaName === "string" ? maybeValidatorOptions : objectOrValidationOptions;
        var schema = typeof objectOrSchemaName === "string" ? objectOrSchemaName : void 0;
        var executor = new ValidationExecutor(this, options);
        executor.ignoreAsyncValidations = true;
        var validationErrors = [];
        executor.execute(object, schema, validationErrors);
        return executor.stripEmptyErrors(validationErrors);
      };
      Validator2.prototype.coreValidate = function(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions) {
        var object = typeof objectOrSchemaName === "string" ? objectOrValidationOptions : objectOrSchemaName;
        var options = typeof objectOrSchemaName === "string" ? maybeValidatorOptions : objectOrValidationOptions;
        var schema = typeof objectOrSchemaName === "string" ? objectOrSchemaName : void 0;
        var executor = new ValidationExecutor(this, options);
        var validationErrors = [];
        executor.execute(object, schema, validationErrors);
        return Promise.all(executor.awaitingPromises).then(function() {
          return executor.stripEmptyErrors(validationErrors);
        });
      };
      return Validator2;
    })()
  );

  // node_modules/.pnpm/class-validator@0.14.3/node_modules/class-validator/esm5/container.js
  var defaultContainer = new /** @class */
  ((function() {
    function class_1() {
      this.instances = [];
    }
    class_1.prototype.get = function(someClass) {
      var instance = this.instances.find(function(instance2) {
        return instance2.type === someClass;
      });
      if (!instance) {
        instance = { type: someClass, object: new someClass() };
        this.instances.push(instance);
      }
      return instance.object;
    };
    return class_1;
  })())();
  var userContainer;
  var userContainerOptions;
  function getFromContainer(someClass) {
    if (userContainer) {
      try {
        var instance = userContainer.get(someClass);
        if (instance)
          return instance;
        if (!userContainerOptions || !userContainerOptions.fallback)
          return instance;
      } catch (error) {
        if (!userContainerOptions || !userContainerOptions.fallbackOnErrors)
          throw error;
      }
    }
    return defaultContainer.get(someClass);
  }

  // node_modules/.pnpm/class-validator@0.14.3/node_modules/class-validator/esm5/metadata/ConstraintMetadata.js
  var ConstraintMetadata = (
    /** @class */
    (function() {
      function ConstraintMetadata2(target, name, async) {
        if (async === void 0) {
          async = false;
        }
        this.target = target;
        this.name = name;
        this.async = async;
      }
      Object.defineProperty(ConstraintMetadata2.prototype, "instance", {
        // -------------------------------------------------------------------------
        // Accessors
        // -------------------------------------------------------------------------
        /**
         * Instance of the target custom validation class which performs validation.
         */
        get: function() {
          return getFromContainer(this.target);
        },
        enumerable: false,
        configurable: true
      });
      return ConstraintMetadata2;
    })()
  );

  // node_modules/.pnpm/class-validator@0.14.3/node_modules/class-validator/esm5/register-decorator.js
  function registerDecorator(options) {
    var constraintCls;
    if (options.validator instanceof Function) {
      constraintCls = options.validator;
      var constraintClasses = getFromContainer(MetadataStorage2).getTargetValidatorConstraints(options.validator);
      if (constraintClasses.length > 1) {
        throw "More than one implementation of ValidatorConstraintInterface found for validator on: ".concat(options.target.name, ":").concat(options.propertyName);
      }
    } else {
      var validator_1 = options.validator;
      constraintCls = /** @class */
      (function() {
        function CustomConstraint() {
        }
        CustomConstraint.prototype.validate = function(value, validationArguments) {
          return validator_1.validate(value, validationArguments);
        };
        CustomConstraint.prototype.defaultMessage = function(validationArguments) {
          if (validator_1.defaultMessage) {
            return validator_1.defaultMessage(validationArguments);
          }
          return "";
        };
        return CustomConstraint;
      })();
      getMetadataStorage().addConstraintMetadata(new ConstraintMetadata(constraintCls, options.name, options.async));
    }
    var validationMetadataArgs = {
      type: options.name && ValidationTypes.isValid(options.name) ? options.name : ValidationTypes.CUSTOM_VALIDATION,
      name: options.name,
      target: options.target,
      propertyName: options.propertyName,
      validationOptions: options.options,
      constraintCls,
      constraints: options.constraints
    };
    getMetadataStorage().addValidationMetadata(new ValidationMetadata(validationMetadataArgs));
  }

  // node_modules/.pnpm/class-validator@0.14.3/node_modules/class-validator/esm5/decorator/common/ValidateBy.js
  function buildMessage(impl, validationOptions) {
    return function(validationArguments) {
      var eachPrefix = validationOptions && validationOptions.each ? "each value in " : "";
      return impl(eachPrefix, validationArguments);
    };
  }
  function ValidateBy(options, validationOptions) {
    return function(object, propertyName) {
      registerDecorator({
        name: options.name,
        target: object.constructor,
        propertyName,
        options: validationOptions,
        constraints: options.constraints,
        validator: options.validator
      });
    };
  }

  // node_modules/.pnpm/class-validator@0.14.3/node_modules/class-validator/esm5/decorator/common/ValidateIf.js
  function ValidateIf(condition, validationOptions) {
    return function(object, propertyName) {
      var args = {
        type: ValidationTypes.CONDITIONAL_VALIDATION,
        target: object.constructor,
        propertyName,
        constraints: [condition],
        validationOptions
      };
      getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));
    };
  }

  // node_modules/.pnpm/class-validator@0.14.3/node_modules/class-validator/esm5/decorator/common/ValidateNested.js
  var __assign2 = function() {
    __assign2 = Object.assign || function(t3) {
      for (var s5, i5 = 1, n4 = arguments.length; i5 < n4; i5++) {
        s5 = arguments[i5];
        for (var p5 in s5) if (Object.prototype.hasOwnProperty.call(s5, p5))
          t3[p5] = s5[p5];
      }
      return t3;
    };
    return __assign2.apply(this, arguments);
  };
  function ValidateNested(validationOptions) {
    var opts = __assign2({}, validationOptions);
    var eachPrefix = opts.each ? "each value in " : "";
    opts.message = opts.message || eachPrefix + "nested property $property must be either object or array";
    return function(object, propertyName) {
      var args = {
        type: ValidationTypes.NESTED_VALIDATION,
        target: object.constructor,
        propertyName,
        validationOptions: opts
      };
      getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));
    };
  }

  // node_modules/.pnpm/class-validator@0.14.3/node_modules/class-validator/esm5/decorator/common/IsIn.js
  var IS_IN = "isIn";
  function isIn(value, possibleValues) {
    return Array.isArray(possibleValues) && possibleValues.some(function(possibleValue) {
      return possibleValue === value;
    });
  }
  function IsIn(values, validationOptions) {
    return ValidateBy({
      name: IS_IN,
      constraints: [values],
      validator: {
        validate: function(value, args) {
          return isIn(value, args === null || args === void 0 ? void 0 : args.constraints[0]);
        },
        defaultMessage: buildMessage(function(eachPrefix) {
          return eachPrefix + "$property must be one of the following values: $constraint1";
        }, validationOptions)
      }
    }, validationOptions);
  }

  // node_modules/.pnpm/class-validator@0.14.3/node_modules/class-validator/esm5/decorator/typechecker/IsBoolean.js
  function isBoolean(value) {
    return value instanceof Boolean || typeof value === "boolean";
  }

  // node_modules/.pnpm/class-validator@0.14.3/node_modules/class-validator/esm5/decorator/typechecker/IsNumber.js
  var IS_NUMBER = "isNumber";
  function isNumber(value, options) {
    if (options === void 0) {
      options = {};
    }
    if (typeof value !== "number") {
      return false;
    }
    if (value === Infinity || value === -Infinity) {
      return !!options.allowInfinity;
    }
    if (Number.isNaN(value)) {
      return !!options.allowNaN;
    }
    if (options.maxDecimalPlaces !== void 0) {
      var decimalPlaces = 0;
      if (value % 1 !== 0) {
        decimalPlaces = value.toString().split(".")[1].length;
      }
      if (decimalPlaces > options.maxDecimalPlaces) {
        return false;
      }
    }
    return Number.isFinite(value);
  }
  function IsNumber(options, validationOptions) {
    if (options === void 0) {
      options = {};
    }
    return ValidateBy({
      name: IS_NUMBER,
      constraints: [options],
      validator: {
        validate: function(value, args) {
          return isNumber(value, args === null || args === void 0 ? void 0 : args.constraints[0]);
        },
        defaultMessage: buildMessage(function(eachPrefix) {
          return eachPrefix + "$property must be a number conforming to the specified constraints";
        }, validationOptions)
      }
    }, validationOptions);
  }

  // node_modules/.pnpm/class-validator@0.14.3/node_modules/class-validator/esm5/decorator/typechecker/IsEnum.js
  function isEnum(value, entity) {
    var enumValues = Object.keys(entity).map(function(k5) {
      return entity[k5];
    });
    return enumValues.includes(value);
  }

  // node_modules/.pnpm/class-validator@0.14.3/node_modules/class-validator/esm5/decorator/typechecker/IsString.js
  var IS_STRING = "isString";
  function isString(value) {
    return value instanceof String || typeof value === "string";
  }
  function IsString(validationOptions) {
    return ValidateBy({
      name: IS_STRING,
      validator: {
        validate: function(value, args) {
          return isString(value);
        },
        defaultMessage: buildMessage(function(eachPrefix) {
          return eachPrefix + "$property must be a string";
        }, validationOptions)
      }
    }, validationOptions);
  }

  // node_modules/.pnpm/class-validator@0.14.3/node_modules/class-validator/esm5/decorator/typechecker/IsObject.js
  var IS_OBJECT = "isObject";
  function isObject(value) {
    return value != null && (typeof value === "object" || typeof value === "function") && !Array.isArray(value);
  }
  function IsObject(validationOptions) {
    return ValidateBy({
      name: IS_OBJECT,
      validator: {
        validate: function(value, args) {
          return isObject(value);
        },
        defaultMessage: buildMessage(function(eachPrefix) {
          return eachPrefix + "$property must be an object";
        }, validationOptions)
      }
    }, validationOptions);
  }

  // node_modules/.pnpm/class-validator@0.14.3/node_modules/class-validator/esm5/index.js
  function validate(schemaNameOrObject, objectOrValidationOptions, maybeValidatorOptions) {
    if (typeof schemaNameOrObject === "string") {
      return getFromContainer(Validator).validate(schemaNameOrObject, objectOrValidationOptions, maybeValidatorOptions);
    } else {
      return getFromContainer(Validator).validate(schemaNameOrObject, objectOrValidationOptions);
    }
  }

  // node_modules/.pnpm/zois-core@1.1.8/node_modules/zois-core/dist/validation.js
  async function c4(e2, t3) {
    try {
      const r5 = plainToInstance(t3, e2), a5 = await validate(r5);
      return a5.length > 0 ? { isValid: false, errors: a5.flatMap((s5) => Object.values(s5.constraints || {})) } : { isValid: true, validatedData: r5 };
    } catch (r5) {
      return { isValid: false, errors: ["Validation error: " + r5.message] };
    }
  }

  // node_modules/.pnpm/zois-core@1.1.8/node_modules/zois-core/dist/messaging.js
  var q2 = class {
    sendBeep(n4, e2) {
      const u6 = { IsSecret: true, BeepType: "Leash", MemberNumber: e2, Message: JSON.stringify({ ...n4 }) };
      ServerSend("AccountBeep", u6);
    }
    sendPacket(n4, e2, u6) {
      const r5 = { Content: c2.key, Dictionary: { msg: n4 }, Type: "Hidden" };
      e2 && (r5.Dictionary.data = e2), u6 && (r5.Target = u6), ServerSend("ChatRoomChat", r5);
    }
    sendAction(n4, e2 = void 0, u6 = []) {
      if (!n4 || !ServerPlayerIsInChatRoom()) return;
      const r5 = CharacterPronounDescription(Player) === "She/Her", i5 = r5 ? "Her" : "His", p5 = r5 ? "Her" : "Him", c7 = r5 ? "Herself" : "Himself", t3 = r5 ? "She" : "He";
      n4 = n4.replaceAll("<Possessive>", i5).replaceAll("<possessive>", i5.toLocaleLowerCase()).replaceAll("<Intensive>", p5).replaceAll("<intensive>", p5.toLocaleLowerCase()).replaceAll("<SelfIntensive>", c7).replaceAll("<selfIntensive>", c7.toLocaleLowerCase()).replaceAll("<Pronoun>", t3).replaceAll("<pronoun>", t3.toLocaleLowerCase()), ServerSend("ChatRoomChat", { Content: "ZC_CUSTOM_ACTION", Type: "Action", Target: e2 ?? void 0, Dictionary: [{ Tag: 'MISSING TEXT IN "Interface.csv": ZC_CUSTOM_ACTION', Text: n4 }, ...u6] });
    }
    sendRequest({ message: n4, data: e2 = {}, target: u6, type: r5 = "packet" }) {
      const i5 = crypto.randomUUID();
      return new Promise((p5) => {
        let c7;
        r5 === "packet" ? (g2.sendPacket("request", { requestId: i5, message: n4, data: e2 }, u6), c7 = c3("ChatRoomMessage", d.ADD_BEHAVIOR, (t3, o5) => {
          const a5 = t3[0], s5 = N2(a5.Sender);
          if (!s5) return o5(t3);
          if (a5.Content === c2.key && !s5.IsPlayer()) {
            const m4 = a5.Dictionary.msg, l6 = a5.Dictionary.data;
            m4 === "requestResponse" && l6.requestId === i5 && (c7(), p5({ data: l6.data, isError: false }));
          }
          return o5(t3);
        })) : (g2.sendBeep({ type: `${c2.key}_request`, requestId: i5, message: n4, data: e2 }, u6), c7 = c3("ServerAccountBeep", d.ADD_BEHAVIOR, (t3, o5) => {
          const a5 = t3[0];
          if (a5.BeepType !== "Leash") return o5(t3);
          let s5;
          try {
            s5 = JSON.parse(a5.Message);
          } catch {
            return o5(t3);
          }
          return s5.type === `${c2.key}_requestResponse` && s5.requestId === i5 && (c7(), p5({ data: s5.data, isError: false })), o5(t3);
        })), setTimeout(() => {
          c7(), p5({ isError: true });
        }, 6e3);
      });
    }
    sendLocal(n4) {
      if (!ServerPlayerIsInChatRoom()) return;
      const e2 = document.createElement("div");
      e2.setAttribute("class", "ChatMessage ChatMessageLocalMessage"), e2.setAttribute("data-time", ChatRoomCurrentTime()), e2.setAttribute("data-sender", `${Player.MemberNumber}`), L(e2, c2.fontFamily), e2.style.background = c2.chatMessageBackground ?? "#55edc095", e2.style.color = c2.chatMessageColor ?? "black", e2.style.margin = "0.15em 0", typeof n4 == "string" ? e2.innerHTML = n4 : e2.appendChild(n4), document.querySelector("#TextAreaChatLog").appendChild(e2), ElementScrollToEnd("TextAreaChatLog");
    }
    sendChat(n4) {
      ServerSend("ChatRoomChat", { Type: "Chat", Content: n4 });
    }
    onRequest(n4, e2, u6) {
      let r5, i5;
      typeof e2 == "function" && e2.prototype?.constructor == e2 ? (i5 = e2, r5 = u6) : r5 = e2;
      const p5 = c3("ChatRoomMessage", d.ADD_BEHAVIOR, async (t3, o5) => {
        const a5 = t3[0], s5 = N2(a5.Sender);
        if (!s5) return o5(t3);
        if (a5.Content === c2.key && !s5.IsPlayer()) {
          const m4 = a5.Dictionary?.msg, l6 = a5.Dictionary?.data;
          if (m4 === "request" && l6.message === n4) {
            if (typeof l6.requestId != "string" || typeof l6.message != "string") return;
            const h7 = await c4(l6.data, i5);
            if (i5 && !h7.isValid) return console.warn(`${c2.name} DTO Failure:`, h7), o5(t3);
            const k5 = r5(l6.data, s5);
            k5 !== void 0 && g2.sendPacket("requestResponse", { requestId: l6.requestId, message: l6.message, data: k5 }, s5.MemberNumber);
          }
        }
        return o5(t3);
      }), c7 = c3("ServerAccountBeep", d.ADD_BEHAVIOR, async (t3, o5) => {
        const a5 = t3[0];
        if (a5.BeepType !== "Leash") return o5(t3);
        let s5;
        try {
          s5 = JSON.parse(a5.Message);
        } catch {
          return o5(t3);
        }
        if (s5.type === `${c2.key}_request` && s5.message === n4) {
          if (typeof s5.requestId != "string") return;
          const m4 = await c4(s5.data, i5);
          if (i5 && !m4.isValid) return console.warn(`${c2.name} DTO Failure:`, m4), o5(t3);
          const l6 = r5(s5.data, a5.MemberNumber, a5.MemberName);
          l6 !== void 0 && g2.sendBeep({ type: `${c2.key}_requestResponse`, requestId: s5.requestId, message: s5.message, data: l6 }, a5.MemberNumber);
        }
        return o5(t3);
      });
      return () => {
        p5(), c7();
      };
    }
    onPacket(n4, e2, u6) {
      return c3("ChatRoomMessage", d.ADD_BEHAVIOR, async (r5, i5) => {
        let p5, c7;
        typeof e2 == "function" && e2.prototype?.constructor == e2 ? (c7 = e2, p5 = u6) : p5 = e2;
        const t3 = r5[0], o5 = N2(t3.Sender);
        if (!o5) return i5(r5);
        if (t3.Content === c2.key && t3.Dictionary.msg === n4 && !o5.IsPlayer()) {
          const a5 = await c4(t3.Dictionary.data, c7);
          if (c7 && !a5.isValid) return console.warn(`${c2.name} DTO Failure:`, a5), i5(r5);
          p5(t3.Dictionary.data, o5);
        }
        return i5(r5);
      });
    }
  };
  var g2 = new q2();

  // src/assets/game-icons/mouthWatering.svg
  var mouthWatering_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="512" height="512" viewBox="0 0 512 512"><path fill="currentColor" d="M87.75 30.72c-5.104.03-10.333.31-15.72.874c5.062 68.606 43.873 95.378 127.75 66.25c-26.35-43.13-62.692-67.418-112.03-67.125zm343.906 0c-49.338-.294-85.65 23.993-112 67.124c83.878 29.128 122.69 2.356 127.75-66.25a161 161 0 0 0-15.75-.875zM13.844 146.437c-.826 4.546-1.156 9.206-1.156 13.875c0 46.09 41.19 86.706 104.124 111.062c23.478 13.02 30.98 83.94 19.688 117.156c-2.47 7.262-12.906 26.75-12.906 35.626c0 12.032 9.75 21.97 21.78 21.97c12.033 0 21.75-9.938 21.75-21.97c0-8.93-11.05-28.19-13.093-35.625c-8.77-31.912-10.39-102.854 18.157-101.186c25.43 5.13 52.85 7.945 81.438 8h.094c19.003 1.767 24.585 30.437 15.843 56.156c-1.87 5.496-9.405 20.092-9.407 26.813c0 9.108 7.36 16.468 16.47 16.468c9.108 0 16.468-7.36 16.468-16.467c0-6.762-8.328-21.184-9.875-26.813c-5.86-26.52-4.616-39.726 12.81-41.656c19.96-2.21 28.955 77.376 17.283 111.72c-3.103 9.124-16 34-16 45.155a27.21 27.21 0 0 0 27.28 27.28a27.216 27.216 0 0 0 27.282-27.28c0-11.226-13.9-35.817-16.47-45.158c-11.062-40.25-6.928-130.344 18.533-138.093c.02-.008.04-.026.062-.033c.387-.097.77-.182 1.156-.28c.013-.01.02-.023.03-.032c2.284-.584 4.54-1.19 6.783-1.813c52.234-11.767 35.948 18 56.06 18c16.277 0 5.717-34.745 31.314-59.03c29.47-22.375 46.906-50.01 46.906-79.97c0-4.668-.36-9.328-1.188-13.875c-13.076 54.687-115.864 96.438-240.593 96.438c-124.73 0-227.55-41.75-240.626-96.438zM418 341.938c-12.01 0-21.75 9.74-21.75 21.75s9.74 21.718 21.75 21.718s21.72-9.71 21.72-21.72c0-12.008-9.71-21.748-21.72-21.748"/></svg>';

  // node_modules/.pnpm/zois-core@1.1.8/node_modules/zois-core/dist/wardrobe.js
  var m = class {
    seedsCache = /* @__PURE__ */ new Map();
    getSeed(e2) {
      const r5 = a2(ServerAppearanceBundle(e2)), o5 = JSON.stringify(r5);
      return this.seedsCache.has(o5) || this.seedsCache.set(o5, this.generateSeed(o5)), this.seedsCache.get(o5);
    }
    generateSeed(e2) {
      let r5 = 0;
      for (let o5 = 0; o5 < e2.length; o5++) {
        const a5 = e2.charCodeAt(o5);
        r5 = (r5 << 5) - r5 + a5, r5 = r5 & r5;
      }
      return r5;
    }
    compare(e2, r5) {
      return this.getSeed(e2) === this.getSeed(r5);
    }
    getDifference(e2, r5) {
      const o5 = { added: [], modified: [], removed: [] };
      if (this.compare(e2, r5)) return o5;
      const a5 = ServerBuildAppearanceDiff("Female3DCG", e2, ServerAppearanceBundle(r5));
      for (const [i5, s5] of Object.entries(a5)) {
        if (s5[0] === null && s5[1] !== null) {
          o5.added.push(s5[1].Asset.Description);
          continue;
        }
        if (s5[0] !== null && s5[1] === null) {
          o5.removed.push(s5[0].Asset.Description);
          continue;
        }
        if (s5[0].Asset.Name !== s5[1].Asset.Name) {
          o5.removed.push(s5[0].Asset.Description), o5.added.push(s5[1].Asset.Description);
          continue;
        }
        this.compare([s5[0]], [s5[1]]) || o5.modified.push(s5[0].Asset.Description);
      }
      return o5;
    }
  };
  var I3 = new m();
  function p2(t3) {
    const e2 = AssetGroup.includes(t3) ? t3 : Asset.includes(t3) ? t3.Group : t3.Asset.Group;
    if (!AssetGroup.includes(e2)) throw new Error("Failed to convert item to group");
    return e2;
  }
  function g3(t3, e2 = false) {
    const r5 = p2(t3);
    return r5.Category === "Appearance" && r5.AllowNone && r5.Clothing && (e2 || !r5.BodyCosplay);
  }
  function f3(t3) {
    const e2 = p2(t3);
    return e2.Category === "Appearance" && e2.AllowNone && e2.Clothing && e2.BodyCosplay;
  }
  function u2(t3) {
    const e2 = p2(t3);
    return e2.Category === "Appearance" && !e2.Clothing;
  }
  function A(t3, e2 = ["ItemNeck", "ItemNeckAccessories", "ItemNeckRestraints"]) {
    const r5 = p2(t3);
    return r5.Category !== "Item" || r5.BodyCosplay ? false : !e2.includes(r5.Name);
  }
  function h3(t3, e2, r5 = ["Cosplay", "Binds", "Collar", "Locks"], o5 = t3, a5 = false) {
    e2 = e2.filter((s5) => !!s5 && !u2(s5)), r5.includes("Cosplay") || (e2 = e2.filter((s5) => !f3(s5))), r5.includes("Binds") || (e2 = e2.filter((s5) => !A(s5))), r5.includes("Collar") || (e2 = e2.filter((s5) => s5.Asset.Group.Name !== "ItemNeck")), r5.includes("Locks") || (e2 = e2.map((s5) => (s5.Property?.LockedBy && delete s5.Property.LockedBy, s5)));
    const i5 = [];
    if (a5) t3.Appearance = t3.Appearance.filter((s5) => u2(s5));
    else {
      const s5 = ValidationCreateDiffParams(o5, Player.MemberNumber);
      t3.Appearance = t3.Appearance.filter((n4) => u2(n4) || !ValidationCanRemoveItem(n4, s5, !!e2.find((c7) => c7?.Asset?.Group?.Name === n4?.Asset?.Group?.Name)) || n4.Property?.LockedBy && !DialogCanUnlock(o5, n4) || n4.Asset.Name === "SlaveCollar" && o5.IsPlayer() ? (i5.push(n4.Asset.Group.Name), true) : false);
    }
    for (const s5 of e2) {
      if (!a5 && (!d3(o5, s5.Asset.Group.Name, s5.Asset) || i5.includes(s5.Asset.Group.Name))) continue;
      CharacterAppearanceSetItem(t3, s5.Asset.Group.Name, s5.Asset, s5.Color);
      const n4 = InventoryGet(t3, s5.Asset.Group.Name);
      s5.Craft && CraftingValidate(s5.Craft, s5.Asset) !== CraftingStatusType.CRITICAL_ERROR && (n4.Craft = s5.Craft), s5.Property && (ValidationSanitizeProperties(t3, s5), n4.Property = s5.Property);
    }
    CharacterRefresh(t3), t3.IsNpc() || ChatRoomCharacterUpdate(t3);
  }
  function d3(t3, e2, r5) {
    return !ValidationIsItemBlockedOrLimited(t3, Player.MemberNumber, e2, r5.Name) && ServerChatRoomGetAllowItem(Player, t3);
  }
  function v(t3, e2) {
    return e2.map((r5) => ServerBundledItemToAppearanceItem(t3, r5));
  }

  // src/qam-subscreens/baseQAMSubscreen.ts
  var BaseQAMSubscreen = class {
    name;
    description;
    isFeatureSubscreen() {
      return !!qamFeatures.find((f6) => f6.subscreen.constructor.name === this.constructor.name);
    }
    load(container) {
      const header = document.createElement("div");
      header.style.cssText = "display: flex; flex-direction: column; row-gap: 0.65em; padding: 0.65em; border-bottom: 1px solid #e5e5e5; margin-bottom: 0.5em;";
      container.append(header);
      const title = document.createElement("p");
      title.style.cssText = "font-weight: bold; font-size: 1.15em;";
      title.textContent = this.name;
      header.append(title);
      if (!this.description) return;
      const description = document.createElement("p");
      description.style.cssText = "color: #424242; font-size: 0.75em;";
      description.textContent = this.description;
      header.append(description);
    }
    buildButton(text) {
      const btn = document.createElement("button");
      Q(btn, {
        base: {
          cursor: "pointer",
          border: "none",
          padding: "0.65em",
          margin: "0.25em 1em",
          background: "#7e00ff",
          borderRadius: "4px",
          color: "white"
        },
        hover: {
          background: "rgb(143, 82, 255)"
        }
      });
      btn.textContent = text;
      return btn;
    }
    buildSelect({
      onChange,
      options,
      currentOption
    }) {
      let isOpened = false;
      let optionsContainer;
      const select = document.createElement("div");
      select.classList.add("bccQAMSelect");
      select.style.margin = "0.25em 1em";
      select.style.position = "relative";
      select.setAttribute("opened", false);
      select.addEventListener("click", () => {
        if (options.length === 0) return;
        if (isOpened) {
          isOpened = false;
          select.style.zIndex = "10";
          optionsContainer.remove();
        } else {
          isOpened = true;
          select.style.zIndex = "100";
          optionsContainer = document.createElement("div");
          optionsContainer.setAttribute(
            "data-position",
            select.offsetTop > window.innerHeight / 2 - select.offsetHeight / 2 ? "top" : "bottom"
          );
          options.forEach((option) => {
            const e2 = document.createElement("div");
            e2.style.cssText = "display: flex; align-items: center; column-gap: 0.5em;";
            if (option.icon) {
              option.icon.style.cssText = "color: #bcbcbc;";
              e2.append(option.icon);
            }
            e2.append(option.text);
            if (option.name === currentOption) {
              e2.append(checkmark);
            }
            e2.addEventListener("click", () => {
              currentOption = option.name;
              p5.textContent = option.text;
              optionsContainer.remove();
              if (onChange) onChange(option.name);
            });
            optionsContainer.append(e2);
          });
          select.append(optionsContainer);
        }
      });
      const p5 = document.createElement("p");
      p5.style.paddingRight = "2em";
      if (options.length === 0) {
        p5.textContent = "No options";
      } else {
        p5.textContent = options.find((option) => option.name === currentOption)?.text ?? "Unknown";
      }
      const arrow = createElement4(ChevronDown2);
      const checkmark = createElement4(Check2);
      checkmark.style.cssText = "position: absolute; right: 0.25em;";
      select.append(p5, arrow);
      return select;
    }
    buildCharacterSelect(onChange, currentCharacter = Player) {
      const select = this.buildSelect({
        onChange: (value) => {
          const target = N2(parseInt(value, 10));
          if (onChange && target) onChange(target);
        },
        options: (ChatRoomCharacter.length === 0 ? [Player] : ChatRoomCharacter).map((c7) => {
          return {
            name: c7.MemberNumber.toString(),
            text: c7.Name + `(${c7.MemberNumber})`,
            icon: createElement4(Target, { stroke: "red" })
          };
        }),
        currentOption: currentCharacter.MemberNumber.toString()
      });
      return select;
    }
    buildInput(placeholder) {
      const input = document.createElement("input");
      input.style.cssText = "border: none; background: #ebebeb; padding: 0.65em; margin: 0.25em 1em; border-radius: 5px;";
      input.placeholder = placeholder;
      return input;
    }
  };

  // src/qam-subscreens/welcomeQAMSubscreen.ts
  var WelcomeQAMSubscreen = class extends BaseQAMSubscreen {
    name = "Welcome to QAM";
    // public description: string = "Teleport to certain character on map";
    load(container) {
      super.load(container);
      const text = document.createElement("p");
      text.style.cssText = "margin: 0 auto; width: 95%; text-align: center; font-size: 1.45em;";
      text.textContent = "Report errors and visual bugs if you encounter them, this will help make QAM even more convenient and powerful";
      const githubPageButton = document.createElement("a");
      githubPageButton.textContent = "Github Page";
      githubPageButton.href = "https://github.com/FurryZoi/Bondage-Club-Chaos";
      githubPageButton.target = "_blank";
      Q(githubPageButton, {
        base: {
          padding: "0.45em",
          borderRadius: "6px",
          background: "rgb(227, 210, 255)",
          width: "fit-content",
          margin: "1em auto",
          textDecoration: "none"
        },
        hover: {
          background: "rgb(209 181 255)"
        }
      });
      const changelog = document.createElement("div");
      changelog.classList.add("bccChangelog");
      changelog.innerHTML = `<p>-- BCC v${version} -- Changes:</p><br><ul><li>Fixed bugs with QAM and other</li><li>Redesigned QAM</li><li>Added adaptation for mobile devices</li><li>"Disable arousal overlay" cheat</li><li>"Appearance Version Control System" QAM feature (Improved version of undo)</li></ul>`;
      container.append(text, githubPageButton, changelog);
    }
  };

  // src/qam-subscreens/mainQAMSubscreen.ts
  function getServer() {
    if (window.location.host === "www.bondageprojects.elementfx.com") return "America";
    if (window.location.host === "www.bondage-europe.com") return "Europe";
    if (window.location.host === "www.bondage-asia.com") return "Asia";
    return "Not defined";
  }
  var MainQAMSubscreen = class extends BaseQAMSubscreen {
    name = "BONDAGE CLUB CHAOS";
    load(container) {
      const header = document.createElement("div");
      header.style.cssText = "cursor: grab; user-select: none; display: flex; align-items: center; justify-content: space-between; border-bottom: 1px solid rgb(229, 229, 229); background: rgb(247 242 255 / 75%); padding: 0 0.15em;";
      const headerLeftButtonsContainer = document.createElement("div");
      const headerRightButtonsContainer = document.createElement("div");
      const _4 = "display: flex; align-items: center; column-gap: 0.2em;";
      headerLeftButtonsContainer.style.cssText = _4;
      headerRightButtonsContainer.style.cssText = _4;
      const headerButtonStyle = {
        base: {
          flexShrink: "0",
          width: "2em",
          height: "2em",
          cursor: "pointer",
          padding: "0.25em",
          color: "#8e75af",
          borderRadius: "4px"
        },
        hover: {
          background: "#94949424"
        }
      };
      const minimizeSidebarButton = createElement4(PanelLeftClose);
      Q(minimizeSidebarButton, headerButtonStyle);
      minimizeSidebarButton.addEventListener("click", () => {
        document.getElementsByClassName("bccQAM_sidebar")[0].toggleAttribute("data-minimized");
      });
      const centerQAMButton = createElement4(AlignVerticalSpaceAround);
      Q(centerQAMButton, headerButtonStyle);
      centerQAMButton.addEventListener("click", () => {
        container.style.left = (window.innerWidth - container.offsetWidth) / 2 + "px";
        container.style.top = (window.innerHeight - container.offsetHeight) / 2 + "px";
      });
      const maximizeQAMButton = createElement4(Maximize);
      Q(maximizeQAMButton, headerButtonStyle);
      maximizeQAMButton.addEventListener("click", () => {
        container.style.width = "95%";
        container.style.height = "80%";
      });
      const closeQAMButton = createElement4(X2);
      Q(closeQAMButton, headerButtonStyle);
      closeQAMButton.addEventListener("click", () => {
        document.getElementsByClassName("bccQAM")[0].style.display = "none";
      });
      headerLeftButtonsContainer.append(minimizeSidebarButton);
      headerRightButtonsContainer.append(centerQAMButton, maximizeQAMButton, closeQAMButton);
      const title = document.createElement("p");
      title.textContent = this.name;
      title.style.cssText = "font-weight: bold; padding: 0.25em 1em; text-align: center; font-size: clamp(10px, 5vw, 24px); width: 100%; letter-spacing: 0.08em;";
      title.style.textShadow = "rgb(102, 0, 218) -0.095em -0.05em 0px";
      title.style.letterSpacing = "0.05em";
      title.style.fontFamily = "Finger Paint";
      const sidebar = document.createElement("div");
      sidebar.classList.add("bccQAM_sidebar");
      sidebar.style.cssText = "display: flex; flex-direction: column; width: 40%; height: 100%;";
      const contentArea = document.createElement("div");
      contentArea.style.cssText = "width: 100%; display: flex; flex-direction: column; overflow: auto; margin: 0 auto; padding-bottom: 0.5em; border-left: 1px solid #e5e5e5;";
      const searchInput = document.createElement("input");
      searchInput.style.cssText = "border: none !important; outline: none !important; background: none; width: 100%; padding: 0.65em; margin: 0.25em 0;";
      searchInput.placeholder = "Search...";
      searchInput.addEventListener("input", () => {
        setItems(
          qamFeatures.filter((i5) => isFeatureEnabled(i5.id) && i5.subscreen.name.toLowerCase().includes(searchInput.value.toLowerCase()))
        );
      });
      const sidebarButtons = document.createElement("div");
      sidebarButtons.style.cssText = "overflow-y: auto; scrollbar-width: none;";
      let sidebarActiveButton;
      const setItems = (items2) => {
        sidebarButtons.innerHTML = "";
        items2.forEach((b3) => {
          const btn = document.createElement("button");
          Q(btn, {
            base: {
              display: "flex",
              alignItems: "center",
              columnGap: "0.45em",
              cursor: "pointer",
              fontSize: "clamp(10px, 10vw, 30px)",
              background: "none",
              border: "none",
              padding: "0.25em",
              borderTop: "1px solid #e5e5e5",
              width: "100%"
            },
            hover: {
              background: "#eeeeee"
            }
          });
          const detailsContainer = document.createElement("div");
          detailsContainer.style.cssText = "display: flex; flex-direction: column; align-items: flex-start; row-gap: 4px;";
          const name = document.createElement("span");
          name.style.fontSize = "clamp(10px, 5vw, 22px)";
          if (b3.isBeta) {
            name.innerHTML = b3.subscreen.name + "<span style='position: relative; bottom: 0.75em; margin-left: 0.45em; padding: 0 0.35em; border-radius: 6px; background: #62ffe6; font-size: 0.5em; color: #b201ff; border: 1px solid #d2d2d2;'>Beta</span>";
          } else {
            name.textContent = b3.subscreen.name;
          }
          const description = document.createElement("span");
          description.style.fontSize = "clamp(8px, 1vw, 16px)";
          description.style.color = "#878787";
          description.style.maxWidth = "calc(340px - clamp(10px, 8vw, 35px) - 0.45em)";
          description.style.whiteSpace = "nowrap";
          description.style.overflow = "clip";
          description.style.textOverflow = "ellipsis";
          description.style.padding = "2px";
          description.textContent = b3.subscreen.description;
          const icon = createElement4(b3.icon);
          icon.style.cssText = "background: rgb(228 215 255 / 65%); flex-shrink: 0; width: clamp(10px, 8vw, 35px); height: clamp(10px, 8vw, 35px); padding: 4px; stroke: #7e63b6; border-radius: 4px;";
          btn.addEventListener("click", () => {
            contentArea.innerHTML = "";
            b3.subscreen.load(contentArea);
            if (sidebarActiveButton) sidebarActiveButton.style.borderLeft = "";
            sidebarActiveButton = btn;
            sidebarActiveButton.style.borderLeft = "3px solid rgb(219 201 255)";
          });
          detailsContainer.append(name, description);
          btn.append(icon, detailsContainer);
          sidebarButtons.append(btn);
        });
      };
      const items = qamFeatures.filter((i5) => isFeatureEnabled(i5.id));
      if (items.length === 0) {
        const p5 = document.createElement("p");
        p5.innerHTML = "You don't have any features enabled.<br>Configure it in QAM settings.";
        p5.style.margin = "1.5em auto";
        p5.style.background = "#f6f1ff";
        p5.style.padding = "0.65em";
        p5.style.border = "2px solid #eee5ff";
        p5.style.borderRadius = "4px";
        container.append(p5);
      } else setItems(items);
      const footer = document.createElement("div");
      footer.style.cssText = "position: absolute; left: 0; bottom: 0; width: 100%; display: flex; align-items: center; justify-content: space-between; padding: 0.65em; background: rgb(247 242 255 / 75%); border-top: 2px solid #e8e8e8;";
      const server = document.createElement("div");
      server.style.cssText = "display: flex; align-items: center; column-gap: 0.5em; background: rgb(227, 210, 255); border-radius: 0.65em; padding: 0.65em; font-weight: bold;";
      const ping = document.createElement("div");
      ping.style.cssText = "padding: 4px; background: #cabaefe8; border-radius: 6px; font-size: 0.8em;";
      ping.textContent = serverPing + "ms";
      const settingsBtn = createElement4(Settings, { stroke: "rgb(126, 99, 182)", height: "2em", width: "2em" });
      Q(settingsBtn, {
        base: {
          cursor: "pointer",
          background: "rgb(229, 208, 255)",
          padding: "0.25em",
          borderRadius: "4px"
        },
        hover: {
          background: "rgb(223, 199, 252)"
        }
      });
      settingsBtn.addEventListener("click", async () => {
        await PreferenceOpenSubscreen("Extensions");
        await PreferenceSubscreenExtensionsOpen(c2.key, ["Online", "ChatRoom"]);
        $(new MainSubscreen(true));
      });
      header.append(headerLeftButtonsContainer, title, headerRightButtonsContainer);
      sidebar.append(searchInput, sidebarButtons);
      server.append(getServer(), ping);
      footer.append(server, settingsBtn);
      const flexContainer = document.createElement("div");
      flexContainer.style.cssText = "display: flex; width: 100%; height: calc(100% - 6.6em);";
      flexContainer.append(sidebar, contentArea);
      container.append(header, flexContainer, footer);
      new QAMWindow(container, header);
      new WelcomeQAMSubscreen().load(contentArea);
      container.style.left = (window.innerWidth - container.offsetWidth) / 2 + "px";
      container.style.top = (window.innerHeight - container.offsetHeight) / 2 + "px";
    }
  };

  // src/qam-subscreens/toggleInvisibilityQAMSubscreen.ts
  var ToggleInvisibilityQAMSubscreen = class extends BaseQAMSubscreen {
    name = "Toggle Invisibility";
    description = "Toggle target's invisibility state";
    load(container) {
      super.load(container);
      let target = Player;
      const select = this.buildCharacterSelect((C4) => {
        target = C4;
      });
      const btn = this.buildButton("Toggle Invisibility");
      btn.addEventListener("click", () => {
        if (!ServerChatRoomGetAllowItem(Player, target)) {
          return Q2.error({ message: "Interactions are not allowed", duration: 3e3 });
        }
        if (!isAllowScripts(target).hide) {
          if (target.IsPlayer()) {
            return Q2.error({
              title: "You don't allow to use scripts on yourself",
              message: `Enable "hide" option in the scripts settings`,
              duration: 7e3
            });
          } else {
            return Q2.error({
              message: `${O2(
                target
              )} doesn't allow you to modify appearance using scripts`,
              duration: 6e3
            });
          }
        }
        if (!InventoryGet(target, "ItemScript")) {
          const itemScript = InventoryWear(target, "Script", "ItemScript");
          itemScript.Property = {
            Hide: AssetGroup.filter((a5) => a5.Name !== "ItemScript").map((a5) => a5.Name)
          };
          ChatRoomCharacterUpdate(target);
          Q2.success({
            message: `You have successfully activated invisibility for ${O2(
              target
            )}!`,
            duration: 6e3
          });
        } else {
          InventoryRemove(target, "ItemScript");
          ChatRoomCharacterUpdate(target);
          Q2.success({
            message: `You have successfully deactivated invisibility for ${O2(
              target
            )}!`,
            duration: 6e3
          });
        }
      });
      container.append(select, btn);
    }
  };

  // src/qam-subscreens/posesManagerQAMSubscreen.ts
  var PosesManagerQAMSubscreen = class extends BaseQAMSubscreen {
    name = "Poses Manager";
    description = "Change target's pose, y position";
    load(container) {
      super.load(container);
      let target = Player;
      const select = this.buildCharacterSelect((C4) => {
        target = C4;
        I_DONT_KNOW_HOW_TO_NAME_THIS_VARIABLE.innerHTML = "";
        I_DONT_KNOW_HOW_TO_NAME_THIS_VARIABLE.append(
          createPosesContainer("BodyUpper"),
          createPosesContainer("BodyLower"),
          createPosesContainer("BodyFull")
        );
      });
      const createPosesContainer = (category) => {
        const container2 = document.createElement("div");
        container2.style.cssText = "display: flex; gap: calc(0.5 * min(2dvh, 1dvw)); margin: 0.25em 1em;";
        PoseFemale3DCG.filter((p5) => p5.Category === category && (p5.AllowMenu || p5.AllowMenuTransient)).forEach((p5) => {
          const btn = document.createElement("button");
          Q(btn, {
            base: {
              cursor: "pointer",
              width: "3em",
              aspectRatio: "1/1",
              background: "none",
              border: "2px solid #d2d2d2",
              borderRadius: "8px"
            },
            hover: {
              borderColor: "#ad68ff"
            }
          });
          if (target.Pose.includes(p5.Name)) {
            btn.style.borderColor = "#ad68ff";
          }
          btn.addEventListener("click", () => {
            if (!ServerChatRoomGetAllowItem(Player, target)) {
              return Q2.error({ message: "Interactions are not allowed", duration: 3e3 });
            }
            PoseSetActive(target, p5.Name);
            ChatRoomCharacterUpdate(target);
            I_DONT_KNOW_HOW_TO_NAME_THIS_VARIABLE.innerHTML = "";
            I_DONT_KNOW_HOW_TO_NAME_THIS_VARIABLE.append(
              createPosesContainer("BodyUpper"),
              createPosesContainer("BodyLower"),
              createPosesContainer("BodyFull")
            );
          });
          const image = document.createElement("img");
          image.src = `Icons/Poses/${p5.Name}.png`;
          image.style.cssText = "width: 80%; height: auto;";
          btn.append(image);
          container2.append(btn);
        });
        return container2;
      };
      const I_DONT_KNOW_HOW_TO_NAME_THIS_VARIABLE = document.createElement("div");
      I_DONT_KNOW_HOW_TO_NAME_THIS_VARIABLE.append(
        createPosesContainer("BodyUpper"),
        createPosesContainer("BodyLower"),
        createPosesContainer("BodyFull")
      );
      const suspenseBtn = this.buildButton("Suspense");
      ;
      suspenseBtn.addEventListener("click", () => {
        if (!ServerChatRoomGetAllowItem(Player, target)) {
          return Q2.error({ message: "Interactions are not allowed", duration: 3e3 });
        }
        PoseSetActive(target, "Suspension");
        ChatRoomCharacterUpdate(target);
        I_DONT_KNOW_HOW_TO_NAME_THIS_VARIABLE.innerHTML = "";
        I_DONT_KNOW_HOW_TO_NAME_THIS_VARIABLE.append(
          createPosesContainer("BodyUpper"),
          createPosesContainer("BodyLower"),
          createPosesContainer("BodyFull")
        );
      });
      const overrideHeight = (h7) => {
        const emoticon = InventoryGet(target, "Emoticon");
        if (h7 === null) {
          delete emoticon.Property?.OverrideHeight;
        } else {
          emoticon.Property ??= {};
          const height = emoticon.Property.OverrideHeight?.Height ?? 0;
          emoticon.Property.OverrideHeight = { Height: height + h7 };
        }
        ChatRoomCharacterUpdate(target);
      };
      const heightOverrideControls = document.createElement("div");
      heightOverrideControls.style.cssText = "display: flex; justify-content: center; column-gap: 0.65em; flex-shrink: 0; margin-top: 0.25em; margin-bottom: 0.65em; height: 2.5em;";
      const dynamicClass = {
        base: {
          cursor: "pointer",
          aspectRatio: "1/1",
          height: "100%",
          background: "white",
          border: "2px solid #d2d2d2",
          borderRadius: "50%"
        },
        hover: {
          borderColor: "#ad68ff"
        }
      };
      const downBtn = document.createElement("button");
      Q(downBtn, dynamicClass);
      downBtn.append(createElement4(ArrowDown));
      downBtn.addEventListener("click", () => {
        if (!ServerChatRoomGetAllowItem(Player, target)) {
          return Q2.error({ message: "Interactions are not allowed", duration: 3e3 });
        }
        overrideHeight(-10);
      });
      const resetBtn = document.createElement("button");
      Q(resetBtn, {
        base: {
          cursor: "pointer",
          padding: "0.25em 0.75em",
          height: "100%",
          border: "none",
          background: "#d3d3d3ff",
          borderRadius: "4px"
        },
        hover: {
          background: "#c3c3c3ff"
        }
      });
      resetBtn.textContent = "Reset";
      resetBtn.addEventListener("click", () => {
        if (!ServerChatRoomGetAllowItem(Player, target)) {
          return Q2.error({ message: "Interactions are not allowed", duration: 3e3 });
        }
        overrideHeight(null);
      });
      const upBtn = document.createElement("button");
      Q(upBtn, dynamicClass);
      upBtn.append(createElement4(ArrowUp));
      upBtn.addEventListener("click", () => {
        if (!ServerChatRoomGetAllowItem(Player, target)) {
          return Q2.error({ message: "Interactions are not allowed", duration: 3e3 });
        }
        overrideHeight(10);
      });
      heightOverrideControls.append(downBtn, resetBtn, upBtn);
      container.append(select, I_DONT_KNOW_HOW_TO_NAME_THIS_VARIABLE, suspenseBtn, heightOverrideControls);
    }
  };

  // src/qam-subscreens/importAppearanceQAMSubscreen.ts
  var ImportAppearanceQAMSubscreen = class extends BaseQAMSubscreen {
    name = "Import Appearance";
    description = "Import appearance on target using base64 outfit code";
    load(container) {
      super.load(container);
      let target = Player;
      const input = this.buildInput("Code");
      const select = this.buildCharacterSelect((C4) => {
        target = C4;
      });
      const btn = this.buildButton("Import Appearance");
      btn.addEventListener("click", () => {
        if (!ServerChatRoomGetAllowItem(Player, target)) {
          return Q2.error({ message: "Interactions are not allowed", duration: 3e3 });
        }
        try {
          h3(
            target,
            v(target.AssetFamily, JSON.parse(LZString.decompressFromBase64(input.value)))
          );
          Q2.success({
            message: `Appearance was successfully imported on ${O2(target)}`,
            duration: 4e3
          });
        } catch {
          Q2.error({
            title: "Oops!",
            message: "Error occurred while trying to import appearance",
            duration: 5e3
          });
        }
      });
      container.append(input, select, btn);
    }
  };

  // src/qam-subscreens/exportAppearanceQAMSubscreen.ts
  var ExportAppearanceQAMSubscreen = class extends BaseQAMSubscreen {
    name = "Export Appearance";
    description = "Copy target's appearance to clipboard in utf-16 or base64 format";
    load(container) {
      super.load(container);
      let format = "base64";
      let target = Player;
      const formatSelect = this.buildSelect({
        options: [
          {
            name: "utf-16",
            text: "UTF-16 (Not safe)"
          },
          {
            name: "btoa",
            text: "BTOA (UBC)"
          },
          {
            name: "base64",
            text: "Base64 (Most mods)"
          }
        ],
        currentOption: "base64",
        onChange: (value) => {
          format = value;
        }
      });
      const select = this.buildCharacterSelect((C4) => {
        target = C4;
      });
      const btn = this.buildButton("Copy to clipboard");
      btn.addEventListener("click", async () => {
        if (isBannedBy(target)) return Q2.error({
          title: "Denied",
          message: "You are blacklisted or ghosted by this player",
          duration: 4500
        });
        const stringifiedAppearance = JSON.stringify(ServerAppearanceBundle(target.Appearance));
        let clipboardResult;
        if (format === "base64") {
          clipboardResult = LZString.compressToBase64(stringifiedAppearance);
        } else if (format === "utf-16") {
          clipboardResult = LZString.compressToUTF16(stringifiedAppearance);
        } else {
          clipboardResult = btoa(encodeURI(stringifiedAppearance));
        }
        try {
          await navigator.clipboard.writeText(clipboardResult);
          Q2.success({
            message: "Code was copied to your clipboard",
            duration: 3e3
          });
        } catch (e2) {
          const error = e2;
          Q2.error({
            title: error.name,
            message: error.message,
            duration: 8e3
          });
        }
      });
      container.append(formatSelect, select, btn);
    }
  };

  // src/qam-subscreens/leaveRoomQAMSubscreen.ts
  var LeaveRoomQAMSubscreen = class extends BaseQAMSubscreen {
    name = "Leave Room";
    description = "Forcibly leave chat room";
    load(container) {
      super.load(container);
      const btn = this.buildButton("Leave Room");
      btn.addEventListener("click", () => {
        if (!ServerPlayerIsInChatRoom()) return;
        ChatRoomLeave();
        CommonSetScreen("Online", "ChatSearch");
      });
      container.append(btn);
    }
  };

  // src/qam-subscreens/totalReleaseQAMSubscreen.ts
  var TotalReleaseQAMSubscreen = class extends BaseQAMSubscreen {
    name = "Total Release";
    description = "Release target from all items except for clothing and slave collar";
    load(container) {
      super.load(container);
      let target = Player;
      const select = this.buildCharacterSelect((C4) => {
        target = C4;
      });
      const btn = this.buildButton("Total Release");
      btn.addEventListener("click", () => {
        if (!ServerChatRoomGetAllowItem(Player, target)) {
          return Q2.error({ message: "Interactions are not allowed", duration: 3e3 });
        }
        CharacterReleaseTotal(target, true);
        Q2.success({
          message: `${O2(target)} was completely released`,
          duration: 4e3
        });
      });
      container.append(select, btn);
    }
  };

  // src/qam-subscreens/releaseQAMSubscreen.ts
  var ReleaseQAMSubscreen = class extends BaseQAMSubscreen {
    name = "Release";
    description = "Release target from certain items";
    load(container) {
      super.load(container);
      let target = Player;
      let itemGroup = "ItemNeck";
      const select = this.buildCharacterSelect((C4) => {
        target = C4;
        itemSelectContainer.innerHTML = "";
        createItemSelect();
      });
      const itemSelectContainer = document.createElement("div");
      const createItemSelect = () => {
        const options = target.Appearance.filter((a5) => a5.Asset.Group.Name.startsWith("Item") && !!InventoryGet(target, a5.Asset.Group.Name)).map((a5) => ({ name: a5.Asset.Group.Name, text: a5.Asset.Description }));
        const select2 = this.buildSelect({
          options,
          currentOption: options[0]?.name,
          onChange: (value) => {
            itemGroup = value;
          }
        });
        itemSelectContainer.append(select2);
      };
      const btn = this.buildButton("Release");
      btn.addEventListener("click", () => {
        if (!ServerChatRoomGetAllowItem(Player, target)) {
          return Q2.error({ message: "Interactions are not allowed", duration: 3e3 });
        }
        InventoryRemove(target, itemGroup, true);
        ChatRoomCharacterUpdate(target);
        Q2.success({
          message: `Successfully released ${O2(target)}'s ${itemGroup}`,
          duration: 4e3
        });
      });
      createItemSelect();
      container.append(select, itemSelectContainer, btn);
    }
  };

  // src/qam-subscreens/mapTeleportQAMSubscreen.ts
  var MapTeleportQAMSubscreen = class extends BaseQAMSubscreen {
    name = "Map Teleport";
    description = "Teleport to certain character on map";
    load(container) {
      super.load(container);
      let target = Player;
      const select = this.buildCharacterSelect((C4) => {
        target = C4;
      });
      const btn = this.buildButton("Map Teleport");
      btn.addEventListener("click", () => {
        if (!Player.MapData) Player.MapData = {};
        const x5 = target.MapData?.Pos?.X;
        const y5 = target.MapData?.Pos?.Y;
        if (!x5 || !y5) return;
        ;
        Player.MapData.Pos = {
          X: x5,
          Y: y5
        };
        ChatRoomMapViewMovement = {
          X: x5,
          Y: y5,
          TimeStart: CommonTime(),
          TimeEnd: CommonTime(),
          Direction: "East"
        };
        g2.sendLocal(
          `You were successfully teleported to ${O2(target)}`
        );
      });
      container.append(select, btn);
    }
  };

  // src/qam-subscreens/cloneQAMSubscreen.ts
  var CloneQAMSubscreen = class extends BaseQAMSubscreen {
    name = "Clone";
    description = "Copy target's appearance, nickname, label's color and expressions. With the opportunity to return to your original appearance";
    load(container) {
      super.load(container);
      let target = Player;
      const select = this.buildCharacterSelect((C4) => {
        target = C4;
      });
      const cloneBtn = this.buildButton("Clone");
      const backupBtn = this.buildButton("Backup");
      backupBtn.addEventListener("click", () => {
        if (!modStorage.qam?.cloneBackup) return Q2.error({
          message: "You don't have backup",
          duration: 3e3
        });
        Player.Nickname = modStorage.qam.cloneBackup.nickName;
        Player.LabelColor = modStorage.qam.cloneBackup.labelColor;
        PoseSetActive(Player, modStorage.qam.cloneBackup.activePose[0]);
        CharacterSetFacialExpression(Player, "Emoticon", modStorage.qam.cloneBackup.emoticon?.expression, null, modStorage.qam.cloneBackup.emoticon?.color);
        CharacterSetFacialExpression(Player, "Blush", modStorage.qam.cloneBackup.blush?.expression);
        ServerAppearanceLoadFromBundle(
          Player,
          Player.AssetFamily,
          JSON.parse(LZString.decompressFromBase64(modStorage.qam.cloneBackup.appearance)),
          Player.MemberNumber
        );
        ServerSend("AccountUpdate", {
          Nickname: Player.Nickname,
          LabelColor: Player.LabelColor
        });
        ChatRoomCharacterUpdate(Player);
        Q2.success({
          message: `You have successfully canceled the cloning effect!`,
          duration: 4500
        });
        delete modStorage.qam.cloneBackup;
        syncStorage();
      });
      cloneBtn.addEventListener("click", () => {
        if (isBannedBy(target)) return Q2.error({
          title: "Denied",
          message: "You are blacklisted or ghosted by this player",
          duration: 4500
        });
        modStorage.qam ??= {};
        if (!modStorage.qam.cloneBackup) {
          modStorage.qam.cloneBackup = {
            nickName: O2(Player),
            labelColor: Player.LabelColor,
            emoticon: {
              expression: InventoryGet(Player, "Emoticon")?.Property?.Expression,
              // color: InventoryGet(Player, "Emoticon")?.Property?.Color
              color: ""
            },
            blush: {
              expression: InventoryGet(Player, "Blush")?.Property?.Expression
            },
            appearance: LZString.compressToBase64(JSON.stringify(ServerAppearanceBundle(Player.Appearance))),
            activePose: [...Player.ActivePose]
          };
          syncStorage();
        }
        Player.Nickname = O2(target);
        Player.LabelColor = target.LabelColor;
        PoseSetActive(Player, target.ActivePose[0]);
        CharacterSetFacialExpression(Player, "Emoticon", InventoryGet(target, "Emoticon")?.Property?.Expression, null, InventoryGet(target, "Emoticon")?.Property?.Color);
        CharacterSetFacialExpression(Player, "Blush", InventoryGet(target, "Blush")?.Property?.Expression);
        ServerAppearanceLoadFromBundle(
          Player,
          Player.AssetFamily,
          ServerAppearanceBundle(target.Appearance),
          Player.MemberNumber
        );
        ServerSend("AccountUpdate", {
          Nickname: Player.Nickname,
          LabelColor: Player.LabelColor
        });
        ChatRoomCharacterUpdate(Player);
        Q2.success({
          message: `You were successfully cloned ${O2(target)}`,
          duration: 4500
        });
      });
      container.append(select, cloneBtn, backupBtn);
    }
  };

  // src/qam-subscreens/viewCardDecksQAMSubscreen.ts
  var ViewCardDecksQAMSubscreen = class extends BaseQAMSubscreen {
    name = "View Card Decks";
    description = "View target's decks of cards";
    load(container) {
      super.load(container);
      let target = Player;
      let deckIndex = 0;
      const select = this.buildCharacterSelect((_target) => {
        target = _target;
        refreshContent();
      });
      const contentContainer = document.createElement("div");
      const createCard = (card) => {
        const cardName = card.Name;
        const requiredLevel = card.RequiredLevel ? card.RequiredLevel : 1;
        const colors = ["", "white", "#a6a4a4", "#9be09b", "#b4b4f0", "#ed8e8e"];
        const img = document.createElement("img");
        img.style.cssText = `width: 2.5em; height: 5em; background: ${colors[requiredLevel]}; padding: 4px; border: 2px solid black;`;
        img.src = card.Type === "Event" ? `https://www.bondage-europe.com/${GameVersion}/BondageClub/Screens/MiniGame/ClubCard/Event/${cardName}.png` : `https://www.bondage-europe.com/${GameVersion}/BondageClub/Screens/MiniGame/ClubCard/Member/${cardName}.png`;
        return img;
      };
      const undoBundle = (bundle) => {
        const result = [];
        for (const entrie of bundle.split("")) {
          const cardId = entrie.charCodeAt(0);
          const card = ClubCardList.find((c7) => c7.ID === cardId);
          if (!card) continue;
          result.push(card);
        }
        return result;
      };
      const refreshContent = () => {
        contentContainer.innerHTML = "";
        deckIndex = 0;
        const select2 = this.buildSelect({
          options: target.Game.ClubCard?.Deck?.map((_4, i5) => ({ name: i5.toString(), text: target?.Game?.ClubCard?.DeckName?.[i5] || `Deck #${i5}` }))?.filter((n4) => !!target?.Game?.ClubCard?.Deck?.[parseInt(n4.name, 10)]),
          currentOption: deckIndex.toString(),
          onChange: (value) => {
            deckIndex = parseInt(value, 10);
            const selectedDeck2 = undoBundle(target.Game?.ClubCard?.Deck?.[deckIndex] ?? "");
            cardsContainer.innerHTML = "";
            cardsContainer.append(...selectedDeck2.map(createCard));
          }
        });
        const cardsContainer = document.createElement("div");
        cardsContainer.style.cssText = "display: flex; flex-wrap: wrap; gap: 0.25em; overflow-y: scroll; max-height: 50vh; margin: 0.25em 1em;";
        const selectedDeck = undoBundle(target.Game?.ClubCard?.Deck?.[deckIndex] ?? "");
        cardsContainer.append(...selectedDeck.map(createCard));
        contentContainer.append(select2, cardsContainer);
      };
      refreshContent();
      container.append(select, contentContainer);
    }
  };

  // src/spell-effects/baseEffect.ts
  var BaseEffect = class {
    removeCallbacks = {};
    get isInstant() {
      return true;
    }
    get selfCastAllowed() {
      return true;
    }
    get id() {
      let charCode;
      for (const [key, value] of Object.entries(getSpellEffects())) {
        if (value.name === this.name) {
          charCode = parseInt(key, 10);
          break;
        }
      }
      return charCode;
    }
    get name() {
      return null;
    }
    get atoms() {
      return [];
    }
    get description() {
      return null;
    }
    get parameters() {
      return [];
    }
    get isActive() {
      if (this.isInstant) return false;
      const charCode = this.id;
      if (!charCode) return false;
      return modStorage.darkMagic?.state?.spells?.some((s5) => s5.effects.includes(String.fromCharCode(charCode)));
    }
    isActiveOn(C4) {
      if (this.isInstant) return false;
      if (C4.IsPlayer()) return this.isActive;
      if (!C4.BCC) return false;
      const charCode = this.id;
      if (!charCode) return false;
      return C4.BCC?.darkMagic?.state?.spells?.some((s5) => s5.effects.includes(String.fromCharCode(charCode)));
    }
    getSpellsWithEffect(C4 = Player) {
      const spells = [];
      if (!this.isActiveOn(C4)) return spells;
      const storage = C4.IsPlayer() ? modStorage : C4.BCC;
      for (const spell of (storage?.darkMagic?.state?.spells ?? []).toReversed()) {
        if (spell.effects?.includes(String.fromCharCode(this.id))) {
          spells.push(spell);
        }
      }
      return spells;
    }
    getParameter(name, C4 = Player) {
      if (!this.isActiveOn(C4)) return null;
      const spells = this.getSpellsWithEffect(C4);
      if (spells.length === 0) return null;
      const parameter = this.parameters.find((p5) => p5.name === name);
      let parameterValue = spells[0].data?.[String.fromCharCode(this.id)]?.[name];
      if (parameter) {
        if (parameter.type === "boolean") parameterValue ??= false;
        if (parameter.type === "choice") parameterValue ??= parameter.options[0].name;
      }
      return parameterValue;
    }
    setParameter(name, value, spellName) {
      if (!this.isActive) return;
      const spell = modStorage.darkMagic.state.spells.find((s5) => s5.name === spellName);
      if (!spell) return;
      spell.data ??= {};
      spell.data[String.fromCharCode(this.id)] ??= {};
      spell.data[String.fromCharCode(this.id)][name] = value;
    }
    hookFunction(event, fnName, hookPriority, fn) {
      const removeHook = c3(fnName, hookPriority, fn);
      this.removeCallbacks[event.spellName].hooks.push(removeHook);
    }
    setInterval(event, callback, ms) {
      const id = setInterval(callback, ms);
      this.removeCallbacks[event.spellName].intervals.push(() => clearInterval(id));
    }
    trigger(event) {
      this.removeCallbacks[event.spellName] = {
        hooks: [],
        intervals: []
      };
    }
    remove(event, push = true) {
      if (!this.isActive) return;
      for (const cb of this.removeCallbacks[event.targetSpellName].hooks) cb();
      for (const cb of this.removeCallbacks[event.targetSpellName].intervals) cb();
      delete this.removeCallbacks[event.targetSpellName];
      const spells = modStorage.darkMagic.state.spells;
      const spell = spells.find((s5) => s5.name === event.targetSpellName);
      spell.effects = spell.effects.replaceAll(String.fromCharCode(this.id), "");
      if (spell.effects.length === 0) {
        spells.splice(spells.findIndex((s5) => s5.name === event.targetSpellName), 1);
      }
      if (push) syncStorage();
    }
    canCast(sourceCharacter, targetCharacter) {
      if (sourceCharacter.MemberNumber === targetCharacter.MemberNumber) {
        if (!this.selfCastAllowed) return { result: false, reason: "SELF_CAST_NOT_ALLOWED" /* SELF_CAST_NOT_ALLOWED */ };
        return { result: true };
      }
      const effectsLimits = (targetCharacter.IsPlayer() ? modStorage : targetCharacter.BCC)?.darkMagic?.limits?.effects;
      const minimumRole = effectsLimits?.[String.fromCharCode(this.id)];
      switch (minimumRole) {
        case 0 /* EVERYONE */:
          return { result: true };
        case 1 /* FRIEND */:
          if (
            //@ts-expect-error
            sourceCharacter.FriendList?.includes(targetCharacter.MemberNumber) || //@ts-expect-error
            targetCharacter.FriendList?.includes(sourceCharacter.MemberNumber)
          ) {
            return { result: true };
          } else {
            return { result: false, reason: "EFFECTS_LIMITED" /* EFFECTS_LIMITED */ };
          }
        case 2 /* WHITELIST */:
          if (sourceCharacter.WhiteList?.includes(targetCharacter.MemberNumber) || targetCharacter.WhiteList?.includes(sourceCharacter.MemberNumber)) {
            return { result: true };
          } else {
            return { result: false, reason: "EFFECTS_LIMITED" /* EFFECTS_LIMITED */ };
          }
        case 3 /* LOVER */:
          if (targetCharacter.IsLoverOfCharacter(sourceCharacter)) {
            return { result: true };
          } else {
            return { result: false, reason: "EFFECTS_LIMITED" /* EFFECTS_LIMITED */ };
          }
        case 4 /* OWNER */:
          if (targetCharacter.IsOwnedByCharacter(sourceCharacter)) {
            return { result: true };
          } else {
            return { result: false, reason: "EFFECTS_LIMITED" /* EFFECTS_LIMITED */ };
          }
        default:
          if (this.atoms.includes(1e3 /* NOX */)) return { result: false, reason: "EFFECTS_LIMITED" /* EFFECTS_LIMITED */ };
          if (
            //@ts-expect-error
            sourceCharacter.FriendList?.includes(targetCharacter.MemberNumber) || //@ts-expect-error
            targetCharacter.FriendList?.includes(sourceCharacter.MemberNumber)
          ) {
            return { result: true };
          } else {
            return { result: false, reason: "EFFECTS_LIMITED" /* EFFECTS_LIMITED */ };
          }
      }
    }
  };

  // src/spell-effects/purificatioEffect.ts
  var PurificatioEffect = class extends BaseEffect {
    get name() {
      return "Purificatio";
    }
    get atoms() {
      return [1003 /* LUX */];
    }
    get description() {
      return "Removes all magic effects from the target.";
    }
    trigger(event) {
      super.trigger(event);
      const activeSpells = JSON.parse(
        JSON.stringify(modStorage.darkMagic?.state?.spells ?? [])
      );
      for (const spell of activeSpells) {
        for (const effectChar of spell.effects) {
          const effect = getSpellEffect(effectChar.charCodeAt(0));
          effect.remove({
            sourceCharacter: event.sourceCharacter,
            sourceSpellName: event.spellName,
            targetSpellName: spell.name
          }, false);
        }
      }
      syncStorage();
    }
  };

  // src/spell-effects/slumberCurseEffect.ts
  var SlumberCurseEffect = class extends BaseEffect {
    get isInstant() {
      return false;
    }
    get name() {
      return "Slumber Curse";
    }
    get atoms() {
      return [1001 /* IGNIS */, 1002 /* RATIO */];
    }
    get description() {
      return `Puts target to sleep. (Analogue of LSCG's "Slumbering" effect)`;
    }
    trigger(event) {
      super.trigger(event);
      if (CharacterCanKneel(Player)) PoseSetActive(Player, "Kneel");
      CharacterSetFacialExpression(Player, "Eyes", "Closed");
      CharacterSetFacialExpression(Player, "Emoticon", "Sleep");
      ChatRoomCharacterUpdate(Player);
      this.hookFunction(event, "ChatRoomSendChat", d.OVERRIDE_BEHAVIOR, () => {
        return g2.sendLocal("You lost control of yourself");
      });
      this.hookFunction(event, "Player.CanWalk", d.OVERRIDE_BEHAVIOR, () => false);
      this.hookFunction(event, "Player.CanChangeToPose", d.OVERRIDE_BEHAVIOR, () => false);
      this.hookFunction(event, "Player.CanChangeOwnClothes", d.OVERRIDE_BEHAVIOR, () => false);
      this.hookFunction(event, "PoseCanChangeUnaidedStatus", d.OVERRIDE_BEHAVIOR, () => PoseChangeStatus.NEVER);
      this.hookFunction(event, "ChatRoomCanAttemptStand", d.OVERRIDE_BEHAVIOR, () => false);
      this.hookFunction(event, "ChatRoomCanAttemptKneel", d.OVERRIDE_BEHAVIOR, () => false);
      this.hookFunction(event, "Player.CanInteract", d.OVERRIDE_BEHAVIOR, () => false);
      this.hookFunction(event, "InventoryGroupIsBlockedForCharacter", d.OVERRIDE_BEHAVIOR, () => true);
      this.hookFunction(event, "DialogClickExpressionMenu", d.OVERRIDE_BEHAVIOR, () => false);
      this.hookFunction(event, "ChatRoomMapViewMove", d.OVERRIDE_BEHAVIOR, () => false);
    }
    remove(event, push) {
      super.remove(event, push);
      CharacterSetFacialExpression(Player, "Eyes", null);
      CharacterSetFacialExpression(Player, "Emoticon", null);
    }
  };

  // src/spell-effects/vocisAlteratioEffect.ts
  function garbleSpeech(text, garbleWords) {
    let newText = "";
    const punctuation = ",.!?";
    for (const word of text.split(" ")) {
      const rword = word.split("").toReversed().join("");
      let wordPunctuation = "";
      if (punctuation.includes(rword[0])) {
        for (const c7 of rword.split("")) {
          if (punctuation.includes(c7)) wordPunctuation += c7;
        }
        wordPunctuation = wordPunctuation.split("").toReversed().join("");
      }
      newText += garbleWords[y2(0, garbleWords.length - 1)] + wordPunctuation + " ";
    }
    return newText.trim();
  }
  var VocisAlteratioEffect = class extends BaseEffect {
    get isInstant() {
      return false;
    }
    get name() {
      return "Vocis Alteratio";
    }
    get atoms() {
      return [1002 /* RATIO */];
    }
    get icon() {
      return null;
    }
    get description() {
      return "Changes target's speech.";
    }
    get parameters() {
      return [
        {
          name: "speechType",
          type: "choice",
          label: "Speech Type",
          options: [
            {
              name: "puppy",
              text: "Puppy"
            },
            {
              name: "kitty",
              text: "Kitty"
            },
            {
              name: "bunny",
              text: "Bunny"
            },
            {
              name: "baby",
              text: "Baby"
            },
            {
              name: "cow",
              text: "Cow"
            }
          ]
        }
      ];
    }
    trigger(event) {
      super.trigger(event);
      this.hookFunction(event, "ServerSend", d.OVERRIDE_BEHAVIOR, (args, next) => {
        const message = args[0];
        const params = args[1];
        const speechType = this.getParameter("speechType");
        if (message === "ChatRoomChat" && ["Chat", "Whisper"].includes(params.Type)) {
          if (params.Content[0] !== "(") {
            if (speechType === "puppy") {
              params.Content = garbleSpeech(params.Content, [
                "wof",
                "woof",
                "wuf",
                "wooof",
                "awo",
                "awoo",
                "woo"
              ]);
            }
            if (speechType === "kitty") {
              params.Content = garbleSpeech(params.Content, [
                "meow",
                "meoow",
                "meooow",
                "meeow",
                "meeeow",
                "mnyaa",
                "mew",
                "meew",
                "meeew"
              ]);
            }
            if (speechType === "bunny") {
              params.Content = garbleSpeech(params.Content, [
                "eep",
                "huf",
                "huff",
                "hufff",
                "thump"
              ]);
            }
            if (speechType === "baby") {
              params.Content = SpeechTransformBabyTalk(params.Content);
            }
            if (speechType === "cow") {
              params.Content = garbleSpeech(params.Content, [
                "mo",
                "moo",
                "mooo",
                "mu",
                "muu",
                "moooo"
              ]);
            }
          }
        }
        return next(args);
      });
    }
  };

  // src/assets/game-icons/atoms/lux.svg
  var lux_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="height: 512px; width: 512px;"><g class="" transform="translate(0,0)" style=""><path d="M320.063 19.72c-72.258 14.575-19.248 71.693-74.344 108.81 4.846-.49 9.746-.702 14.655-.624 16.288.26 32.785 3.72 48.594 10.72a126.431 126.431 0 0 1 14.25 7.405c12.107-47.476-37.103-96.38-3.158-126.31zM136.75 44.47c-40.76 61.357 36.984 64.33 24.406 129.405 17.407-21.255 41.17-35.9 67.156-42.313-25.006-42.138-94.4-41.924-91.562-87.093zm297.313 75.405c-32.547.872-45.475 46.314-96.594 36.22 21.35 17.42 36.034 41.25 42.467 67.31 42.306-24.92 42.053-94.466 87.282-91.624-13.43-8.92-24.06-12.15-33.158-11.905zm-177.97 26.656c-23.656.46-46.53 8.82-64.906 23.626l18.657 36.156L170 193.156a107.628 107.628 0 0 0-9.406 16.938c-8.726 19.708-11.002 40.59-7.78 60.344l44.78 2.125-34 30.312c10.798 20.622 28.414 37.852 51.406 48.03a107.842 107.842 0 0 0 9.313 3.626l24.53-38.25 9.095 43.814c27.3.075 53.737-10.387 73.593-29.188l-19.186-37.125 38.406 12.658a108.49 108.49 0 0 0 5.03-9.938c9.746-22.01 11.457-45.498 6.44-67.22l-37.626-1.75 27.687-24.718c-10.83-20.194-28.236-37.07-50.874-47.093a107.405 107.405 0 0 0-4.125-1.72l-25.874 40.313-9.906-47.75c-.5-.016-1-.023-1.5-.032-1.3-.02-2.61-.024-3.906 0zM133.407 186.5c-41.652.725-82.483 34.847-108.72 5.094 14.573 72.234 71.664 19.3 108.783 74.312-2.154-20.972.934-42.758 10.06-63.375a126.36 126.36 0 0 1 7.345-14.093c-5.822-1.47-11.642-2.038-17.47-1.937zm249.5 53.97a124.649 124.649 0 0 1-10.03 63.624l-.188.375a126.38 126.38 0 0 1-7.22 13.78c47.524 12.244 96.507-37.137 126.47-3.156-14.603-72.388-71.92-19.04-109.032-74.625zM136.53 283.405c-42.123 25.014-41.928 94.37-87.093 91.53 61.422 40.803 64.322-37.123 129.594-24.342-21.344-17.385-36.03-41.167-42.5-67.188zm219.064 48.906c-17.406 21.46-41.236 36.24-67.344 42.72 24.944 42.263 94.497 42.004 91.656 87.218 40.867-61.52-37.402-64.358-24.312-129.938zM193.406 360.72c-12.047 47.456 37.087 96.33 3.156 126.25 72.305-14.587 19.195-71.79 74.47-108.908-21.04 2.204-42.898-.9-63.594-10.062a126.43 126.43 0 0 1-14.032-7.28z" fill="%23000000" fill-opacity="1"></path></g></svg>';

  // src/assets/game-icons/atoms/motus.svg
  var motus_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="height: 512px; width: 512px;"><g class="" transform="translate(0,0)" style=""><path d="M396.082 17.326c-.166-.025-1.922.108-4.977.108-21.975 0-42.158 18.904-49.437 46.595l75.713 12.61-78.526 13.085c.564 16.248 5.55 30.99 13.062 42.367l54.39 9.603-41.277 7.29.484.607-15.91 2.47c-15.262 2.366-25.866 9.63-34.46 21.165-2.534 3.4-4.848 7.198-6.962 11.328l90.798 13.2-100.976 14.684a197.818 197.818 0 0 0-1.627 6.874c-1.662 7.613-2.953 15.622-3.982 23.854l115.275 14.107-117.81 14.418c-.525 9.083-.84 18.236-1.022 27.31l114.07 16.407-113.304 16.3h40.826l2.144 32.532 82.026 11.38-80.54 11.173 2.512 38.14 75.582 10.897-74.158 10.69 2.938 44.59h96.306l11.875-159.403h43.983c-.228-36.033-1.914-77.32-10.137-111.194-4.462-18.384-10.84-34.42-19.314-46.063-8.472-11.642-18.583-18.958-32.248-21.53l-15.59-2.933 10.124-12.213c10.435-12.587 17.49-30.688 17.49-51.127 0-37.056-22.084-66.04-47.127-69.295l-.106-.013-.108-.016zm-53.535 5.055L16.785 45.968l304.93 22.082c3.073-17.672 10.43-33.57 20.832-45.67zm-22.402 62.114L16.783 106.46l312.28 22.612c-5.686-12.618-8.96-27.047-8.96-42.422 0-.722.027-1.437.042-2.156zm-2.612 60.688L16.783 166.96l269.96 19.546c3.583-8.906 7.975-17.144 13.415-24.445 4.868-6.532 10.676-12.254 17.375-16.878zm-37.79 63.228-262.96 19.04L273.19 246.02c1.18-10.497 2.77-20.808 4.927-30.69.51-2.33 1.05-4.635 1.625-6.918zm-8.327 57.803L16.783 284.65l253.225 18.336c.18-12.057.585-24.438 1.408-36.773zm-1.562 60.605-253.07 18.325 297.22 21.52-1.072-16.267H269.86v-9.343c0-4.62-.01-9.38-.006-14.235zm45.294 57.22L16.783 405.64l301.227 21.81-2.862-43.413zm3.97 60.202L16.782 466.13l305.233 22.102-2.9-43.992z" fill="%23000000" fill-opacity="1"></path></g></svg>';

  // src/assets/game-icons/atoms/nox.svg
  var nox_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="512" height="512" viewBox="0 0 512 512"><path fill="currentColor" d="m268.725 389.28l3.74 28.7h-30.89l3.74-28.7a11.705 11.705 0 1 1 23.41 0m33.84-71.83a29.5 29.5 0 1 0 29.5 29.5a29.5 29.5 0 0 0-29.51-29.5zm-94.4 0a29.5 29.5 0 1 0 29.5 29.5a29.5 29.5 0 0 0-29.51-29.5zm245.71-62c0 98.2-48.22 182.68-117.39 220.24c-46 28.26-112.77 28.26-156.19 2.5c-71.72-36.21-122.17-122.29-122.17-222.73c0-78.16 30.54-147.63 77.89-191.67c0 0-42.08 82.86 9.1 135c-11.67-173.77 169.28-63 118-184c151.79 83.33 9.14 105 84.1 148.21c0 0 66.21 47 36.4-91.73c42.95 43.99 70.25 110.3 70.25 184.19zm-68.54 29.87c-2.45-65.49-54.88-119.59-120.26-124.07c-3.06-.21-6.15-.31-9.16-.31a129.4 129.4 0 0 0-129.43 129.35a132.15 132.15 0 0 0 24.51 76v25a35 35 0 0 0 34.74 34.69h6.26v16.61a34.66 34.66 0 0 0 34.71 34.39h61.78a34.48 34.48 0 0 0 34.51-34.39v-16.61h5.38a34.89 34.89 0 0 0 34.62-34.75v-28a129.32 129.32 0 0 0 22.33-77.9z"/></svg>';

  // src/assets/game-icons/atoms/ratio.svg
  var ratio_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="height: 512px; width: 512px;"><g class="" transform="translate(0,0)" style=""><path d="M241.063 54.406a293.615 293.615 0 0 0-12.313.282c-8.814 1.567-12.884 5.426-15.094 9.843-2.435 4.87-2.34 11.423.375 17.25 2.717 5.83 7.7 10.596 14.657 12.376 6.958 1.78 16.536.86 29.125-7.187l10.063 15.75c-15.818 10.11-31.124 12.777-43.813 9.53-12.688-3.247-22.103-12.123-26.968-22.563-4.584-9.836-5.426-21.376-1.03-31.624-42.917 6.94-81.777 23.398-111.626 46.562-9.81 10.688-10.77 23.11-6.47 31.594 4.83 9.526 16.21 16.48 38.97 9.28l5.656 17.813c-28.58 9.04-52.137-.588-61.28-18.625-2.23-4.397-3.592-9.156-4.127-14.063-4.814 5.712-9.16 11.658-13 17.844l.126.06c-8.614 19.616-8.81 33.203-5.376 42.032 3.436 8.83 10.635 14.44 21.72 17.532 22.168 6.18 58.065-1.277 83.343-20.156 10.82-8.08 21.077-27.677 21.97-42.875.445-7.6-1.165-13.604-4.345-17.438-3.18-3.834-8.272-6.703-18.813-6.594l-.187-18.686c14.487-.15 26.25 4.754 33.375 13.344 7.124 8.59 9.26 19.652 8.625 30.468-1.27 21.633-12.595 44.172-29.438 56.75-29.876 22.314-69.336 31.606-99.53 23.188-13.988-3.9-26.37-12.386-32.75-25.53-9.546 45.446 4.323 87.66 30.718 116.874 3.45 3.82 7.122 7.43 10.97 10.78-2.754-7.887-4.016-16.1-3.72-24.093.53-14.325 6.082-28.346 17.22-38.03 9.134-7.946 21.752-12.53 36.843-12.5 1.006 0 2.034.018 3.062.06 2.35.1 4.763.304 7.22.626l-2.44 18.532c-15.588-2.048-25.705 1.522-32.436 7.375-6.73 5.854-10.443 14.614-10.813 24.625-.74 20.024 12.07 43.406 39.69 50.188l-.032.188c27.192 5.19 57.536.372 88-18.22.018-.012.043-.017.062-.03 6.34-4.45 9.755-8.808 11.438-12.563 1.985-4.432 1.943-8.292.53-12.438-2.824-8.29-12.94-16.812-22.218-19.187-15.002-3.84-24.532 1.436-29 7.72-4.468 6.28-4.74 12.45 2.156 17.81l-11.47 14.75c-14.187-11.033-15.092-30.487-5.905-43.405 6.892-9.688 18.985-16.326 33.564-16.75a46.963 46.963 0 0 1 1.844-.03c4.306.03 8.79.622 13.437 1.81 15.505 3.97 29.84 15.277 35.28 31.25a36.189 36.189 0 0 1 1.876 13.314c16.71-8.538 34.332-16.12 52.282-21.814 30.156-13.78 43.23-37.938 42.72-58.28-.515-20.493-13.187-37.74-42.376-40.626l1.844-18.594c36.666 3.626 58.462 29.848 59.188 58.75.422 16.84-5.754 34.363-18.188 49.28 16.072-1.8 32.044-1.495 47.53 1.627-3.152-6.472-4.68-13.478-4.467-20.438.677-22.036 19.42-42.593 48.875-42.906a66.155 66.155 0 0 1 6.03.218l-1.5 18.625c-24.927-1.998-34.3 11.086-34.718 24.656-.412 13.42 8.545 28.442 34.22 30.436 28.3.25 48.588-15.098 58.53-37.906 13.31-30.536 6.997-76.317-34.844-118.188-.792-.793-1.578-1.593-2.375-2.375a40.42 40.42 0 0 1-2.842 10.844c-7.25 17.39-24.233 29.128-41.875 32.407-24.335 4.522-44.29-5.347-53.5-20.406-9.21-15.057-6.792-36.35 9.78-47.56l10.47 15.5c-8.913 6.028-9.28 14.19-4.313 22.31 4.967 8.122 16.17 15.156 34.156 11.814 11.306-2.102 23.896-11.33 28.03-21.25 2.07-4.96 2.47-9.862.408-15.47-1.675-4.555-5.187-9.764-11.72-15.25l-.187-.155c-27.316-20.587-56.338-35.393-85.75-45.157.018.032.045.06.063.093 6.684 12.22 7.18 26.082 3.063 38.344-8.233 24.525-34.07 43.848-66.032 42.78-6.948-.23-13.56 3.12-19.186 9.657-5.627 6.537-9.735 16.113-10.688 26.313-1.905 20.4 6.923 42.886 41.344 54L277 258.28c-41.083-13.264-56.83-45.546-54.22-73.5 1.307-13.975 6.706-26.962 15.157-36.78 8.452-9.818 20.475-16.603 33.97-16.156 24.04.802 42.323-14.084 47.687-30.063 2.682-7.988 2.335-15.937-1.75-23.405-3.968-7.252-11.83-14.423-25.906-19.656a292.57 292.57 0 0 0-50.875-4.314zM342.28 306.344c-41.915 3.41-87.366 23.4-125.28 46.562-55.98 34.198-114.89 26.733-156.688-4.28 16.444 58.844 74.712 70.788 135.5 55.905 6.083-2.285 12.06-6.538 17.157-12.03 7.057-7.607 12.17-17.47 13.78-25.625l18.344 3.625c-2.445 12.383-9.078 24.666-18.406 34.72-8.95 9.645-20.61 17.35-34.094 19.374-6.766 15.07-12.334 29.68-14.594 39.906-3.55 16.06 14.206 22.225 22.156 6.03 19.022-38.743 45.87-73.23 79.406-102.967 26.064-17.153 48.406-38.303 62.72-61.22z" fill="%23000000" fill-opacity="1"></path></g></svg>';

  // src/assets/game-icons/atoms/gemitum.svg
  var gemitum_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="height: 512px; width: 512px;"><g class="" transform="translate(0,0)" style=""><path d="M382.3 36.97c14.1 16.78 24.9 31.7 32.4 44.8C428 105.1 431.9 124 428.6 139.7c-3.2 15.8-13.4 27.1-24.1 35.9-10.5 8.7-21.9 15.7-30.3 22.9-1.8 1.8-1.9 2.8-1.3 5.3.6 2.6 2.9 6.2 6.6 9.2 7.5 6 19.6 9.3 32.4 2.9 22.8-11.4 38.3-25.3 46.6-40.3 8.4-15 10.2-31 4.8-49-8.2-27.32-34.4-58.79-81-89.63zm-252.7 0C82.99 67.83 56.8 99.29 48.62 126.6c-5.39 18-3.63 34 4.74 49 8.37 15 23.84 28.9 46.64 40.3v.1c12.8 6.3 24.8 3 32.3-3 3.7-3 6-6.6 6.6-9.2.6-2.5.5-3.5-1.3-5.3-8.3-7.2-19.7-14.2-30.3-22.9-10.67-8.8-20.8-20.1-24.05-35.8-3.25-15.8.64-34.6 13.92-58.01 7.43-13.09 18.23-28.01 32.43-44.78zm43.3 113.73c-7.6.1-15.3 1-22.9 2.7-9.8 2.2-19.3 5.8-28.2 10.7 8.7 6.8 19 13.2 28 21.1l.2.2.3.2c6.1 6.2 7.9 15.1 6.1 22.6-1.9 7.4-6.6 13.8-12.9 18.8-12.5 10-32.4 14.7-51.53 5-5.4-2.7-10.49-5.5-15.27-8.6-2.38 9.4-3.69 19.8-3.69 31.2 0 43 37.69 90 81.19 131.5 21.8 20.8 44.7 40.2 64.3 57.6 15.1 13.3 28.1 25.2 37.5 36.3 9.4-11.1 22.4-23 37.5-36.3 19.6-17.4 42.5-36.8 64.3-57.6 43.5-41.5 81.2-88.5 81.2-131.5 0-11.4-1.3-21.8-3.7-31.2-4.8 3.1-9.9 6-15.4 8.7-19.2 9.6-39.1 4.9-51.6-5.1-6.3-5-11-11.4-12.9-18.8-1.8-7.5 0-16.4 6.1-22.6l.3-.2.2-.2c9.1-7.9 19.4-14.3 28.1-21.1-8.8-4.9-18.3-8.5-28.1-10.7-40.6-9.2-83.6 5.6-97.6 40.6l-8.4 20.9-8.4-20.9c-11.3-28.5-41.9-43.6-74.7-43.3zm-17.8 102.1c20.6 28.5 49.5 50.4 84.9 67.2-52.2 33.9-104.2 4.1-84.9-67.2zm201.8 0c19.3 71.3-32.7 101.1-84.9 67.2 35.4-16.8 64.3-38.7 84.9-67.2z" fill="%23000000" fill-opacity="1"></path></g></svg>';

  // src/assets/game-icons/atoms/ignis.svg
  var ignis_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="height: 512px; width: 512px;"><g class="" transform="translate(0,0)" style=""><path d="M256 16c-52.5 252.632-210 277.845 0 454.688C466 293.845 308.5 268.63 256 16zM124.75 167.407C98.5 243.197 46 294.117 46 369.907S151 496 229.75 496c-157.5-126.317-105-202.278-105-328.593zm262.5 0c0 126.317 52.5 202.278-105 328.593C361 496 466 445.696 466 369.907c0-75.79-52.5-126.71-78.75-202.5z" fill="%23000000" fill-opacity="1"></path></g></svg>';

  // src/assets/game-icons/atoms/materia.svg
  var materia_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="height: 512px; width: 512px;"><g class="" transform="translate(0,0)" style=""><path d="M256.977 22.395c-16.8 0-32.49 7.65-45.864 20.177-13.372 12.53-24.82 29.98-34.363 51.117-2 4.428-3.91 9.03-5.736 13.777a264.528 264.528 0 0 0-14.83-1.926c-5.77-.575-11.4-.932-16.87-1.06-16.42-.39-31.427 1.275-44.58 5.262-17.536 5.317-32.006 15.083-40.406 29.63-8.4 14.55-9.62 31.964-5.457 49.81 4.165 17.845 13.552 36.484 27.087 55.318 2.84 3.95 5.874 7.912 9.076 11.873a263.816 263.816 0 0 0-9.064 11.86c-13.536 18.833-22.923 37.472-27.087 55.318-4.164 17.846-2.943 35.26 5.457 49.807 8.4 14.55 22.87 24.315 40.406 29.63 17.537 5.318 38.373 6.507 61.45 4.202 4.838-.484 9.78-1.13 14.808-1.922a263.92 263.92 0 0 0 5.746 13.802c9.543 21.14 20.99 38.587 34.363 51.116 13.373 12.528 29.065 20.18 45.864 20.18 16.798 0 32.49-7.652 45.863-20.18 13.372-12.53 24.82-29.977 34.363-51.116a263.844 263.844 0 0 0 5.746-13.8c5.022.79 9.96 1.437 14.794 1.92 23.078 2.304 43.915 1.115 61.45-4.202 17.538-5.316 32.008-15.082 40.408-29.63 8.4-14.55 9.62-31.962 5.457-49.807-4.165-17.845-13.553-36.484-27.087-55.318a265.744 265.744 0 0 0-9.065-11.86 262.57 262.57 0 0 0 9.076-11.872c13.535-18.834 22.922-37.473 27.086-55.318 4.164-17.846 2.943-35.26-5.457-49.81-8.4-14.547-22.87-24.313-40.406-29.63-13.152-3.987-28.16-5.652-44.578-5.263-5.474.128-11.105.485-16.874 1.06-4.84.484-9.787 1.133-14.817 1.925a265.385 265.385 0 0 0-5.737-13.776c-9.543-21.14-20.99-38.59-34.363-51.118-13.373-12.528-29.065-20.177-45.863-20.177zm0 18.687c11.205 0 22.192 4.923 33.086 15.13 10.893 10.205 21.297 25.653 30.107 45.167a237.315 237.315 0 0 1 4.086 9.643c-21.417 4.762-44.1 12.068-67.285 21.83-23.18-9.76-45.86-17.064-67.273-21.826 1.322-3.31 2.68-6.536 4.086-9.648 8.81-19.515 19.214-34.963 30.108-45.17 10.894-10.205 21.88-15.128 33.087-15.128zm-123.59 82.057c1.804-.018 3.637-.006 5.498.036 4.96.11 10.117.43 15.443.963 3.406.34 6.887.775 10.424 1.288-6.586 20.927-11.6 44.222-14.742 69.18-20.048 15.2-37.718 31.194-52.55 47.363a236.58 236.58 0 0 1-6.327-8.378c-12.495-17.386-20.67-34.12-24.063-48.658-3.392-14.538-2.16-26.513 3.442-36.217 5.602-9.704 15.36-16.757 29.644-21.088 9.375-2.843 20.6-4.375 33.23-4.49zm247.168 0c12.63.115 23.855 1.647 33.23 4.49 14.286 4.33 24.04 11.383 29.643 21.087 5.602 9.704 6.835 21.68 3.443 36.217-3.39 14.537-11.57 31.272-24.063 48.658a238.384 238.384 0 0 1-6.325 8.38c-14.83-16.167-32.495-32.157-52.537-47.355-3.14-24.962-8.16-48.26-14.746-69.19 3.533-.513 7.01-.95 10.413-1.288a200.322 200.322 0 0 1 15.444-.964 171.87 171.87 0 0 1 5.498-.037zm-49.92 5.64c4.97 15.438 9.085 32.472 12.156 50.7a508.006 508.006 0 0 0-30.446-19.035 508.29 508.29 0 0 0-31.69-16.843c17.32-6.455 34.127-11.407 49.98-14.82zm-147.317.003c15.85 3.414 32.655 8.366 49.97 14.82a508.802 508.802 0 0 0-31.69 16.842 509.235 509.235 0 0 0-30.434 19.024c3.07-18.223 7.184-35.253 12.154-50.687zm73.653 24.46c15.207 6.708 30.643 14.504 46.03 23.388 15.393 8.888 29.87 18.36 43.285 28.18 1.796 16.527 2.762 33.798 2.762 51.57 0 17.762-.963 35.026-2.758 51.546-13.415 9.818-27.89 19.288-43.278 28.174-15.39 8.885-30.83 16.684-46.04 23.392-15.212-6.708-30.652-14.507-46.042-23.392-15.385-8.883-29.854-18.35-43.264-28.164-1.795-16.523-2.76-33.79-2.76-51.557 0-17.775.965-35.048 2.762-51.577 13.413-9.817 27.885-19.288 43.273-28.172 15.388-8.883 30.824-16.68 46.03-23.386zm1.264 28.116-53.502 33.017 53.502 33.02 53.502-33.02-53.502-33.018zm-110.76 39.134a509.17 509.17 0 0 0-1.257 35.885c0 12.198.43 24.172 1.258 35.864-14.25-11.77-26.943-23.85-37.827-35.873 10.884-12.022 23.577-24.104 37.827-35.876zm219.005.01c14.243 11.77 26.933 23.847 37.813 35.867-10.88 12.02-23.57 24.097-37.813 35.864a508.92 508.92 0 0 0 1.256-35.855c0-12.204-.43-24.18-1.257-35.876zm-173.8 8.394v65.198l56.19 34.677v-65.195l-56.19-34.68zm131.058.034-56.177 34.67v65.164l56.178-34.67V228.93zm-226.28 41.84c14.834 16.17 32.502 32.16 52.548 47.36 3.14 24.955 8.156 48.248 14.74 69.175-3.53.51-7.006.947-10.406 1.287-21.304 2.127-39.887.84-54.172-3.49-14.286-4.33-24.04-11.386-29.643-21.09-5.602-9.705-6.835-21.68-3.443-36.217 3.392-14.537 11.568-31.272 24.063-48.658a236.048 236.048 0 0 1 6.314-8.367zm319.024.003c2.207 2.8 4.32 5.59 6.313 8.364 12.494 17.385 20.67 34.12 24.062 48.657 3.392 14.537 2.162 26.512-3.44 36.217-5.604 9.704-15.36 16.76-29.646 21.09-14.284 4.33-32.864 5.617-54.168 3.49a239.38 239.38 0 0 1-10.395-1.285c6.585-20.932 11.6-44.23 14.74-69.19 20.04-15.196 37.706-31.182 52.535-47.345zm-73.687 62.483c-3.07 18.226-7.184 35.26-12.154 50.697-15.854-3.413-32.663-8.368-49.984-14.822a509.453 509.453 0 0 0 31.7-16.848 509.238 509.238 0 0 0 30.44-19.027zm-171.635.01a508.383 508.383 0 0 0 30.424 19.017 510.02 510.02 0 0 0 31.7 16.848c-17.316 6.453-34.12 11.407-49.973 14.82-4.97-15.434-9.08-32.464-12.15-50.685zm86.37.85.68.42.677-.42h-1.356zm-.56 45.767c23.19 9.76 45.874 17.065 67.294 21.826a236.641 236.641 0 0 1-4.094 9.67c-8.81 19.513-19.214 34.96-30.108 45.167-10.893 10.206-21.88 15.13-33.085 15.13-11.206 0-22.193-4.924-33.086-15.13-10.893-10.206-21.297-25.654-30.107-45.168a239.258 239.258 0 0 1-4.095-9.67c21.416-4.762 44.098-12.066 67.283-21.825z" fill="%23000000" fill-opacity="1"></path></g></svg>';

  // src/assets/game-icons/beamsAura.svg
  var beamsAura_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="512" height="512" viewBox="0 0 512 512"><path fill="currentColor" d="M263.594 20.625c-13.394 0-25.824 7.217-35.47 20.188c-9.644 12.97-15.968 31.547-15.968 52.25s6.324 39.248 15.97 52.218c9.644 12.972 22.074 20.19 35.468 20.19c13.393 0 25.855-7.218 35.5-20.19c9.645-12.97 15.97-31.516 15.97-52.218c-.002-20.702-6.325-39.28-15.97-52.25s-22.107-20.187-35.5-20.187zM153.188 25l-16.563 8.625l60.5 116.063a72 72 0 0 1 8.72-4.032c-7.715-13.314-12.578-29.542-13.845-46.187zM374 25l-39.313 75.438c-1.316 15.668-5.802 31.003-12.843 43.78a78 78 0 0 1 9.187 3.657l59.564-114.25zM102.687 64.844l-13.874 12.53l84.124 93.19c3.88-4.996 8.217-9.51 13.063-13.44zm321.844 0l-81.467 90.22a72.5 72.5 0 0 1 11.78 10.874c.59.677 1.185 1.366 1.75 2.062l81.813-90.625l-13.875-12.53zM63.064 117.688L53 133.438l103.875 66.406c2.283-5.967 4.938-11.697 7.97-17.063L63.062 117.688zm401.093 0l-98.875 63.25c3.01 5.416 5.56 11.208 7.72 17.25l101.22-64.75l-10.064-15.75zm-153.28 42.78c-12.165 14.36-28.78 23.688-47.282 23.688c-18.056 0-34.3-8.885-46.375-22.656c-25.124 6.894-38.6 27.533-46.94 57.344c-8.19 29.287-9.914 66.253-10.155 101.562h26l-3.5-67.72l18.688-.936l4.125 80l11.218 163.78h38V362.97h18.688v132.56h40.812l9.97-164.467l4.093-79.313l18.655.938l-3.5 67.718h23.813c-.02-35.714-.425-73.276-7.844-102.812c-4.032-16.05-10.072-29.544-18.625-39.375c-7.528-8.652-16.887-14.755-29.845-17.75zM36.968 180.032l-5.314 17.907l116.28 34.532a228 228 0 0 1 4.25-18.25L36.97 180.03zm453.28 0l-112.688 33.44c1.485 5.964 2.715 12.113 3.72 18.405l114.28-33.938l-5.312-17.906zM26.22 247.688v18.688h117.218a378 378 0 0 1 2.062-18.688zm357.124 0c.645 6.16 1.106 12.402 1.47 18.688h116.155v-18.688zm-241.03 35.594l-110.66 32.844l5.313 17.938l104.593-31.032c.148-6.562.41-13.16.75-19.75zm243.217.19c.185 6.568.27 13.104.314 19.624l104.406 30.97l5.313-17.94L385.53 283.47zm-244.186 40.686L53 380.656l10.063 15.72l89.562-57.282h-11.313v-9.344c0-1.844.026-3.733.032-5.594zm244.562.03v14.908h-11.312l89.562 57.28l10.063-15.718zm-208.97 14.908L88.814 436.72l13.876 12.53l85.562-94.78l-1.063-15.376h-10.25zm165.44 0l-1.095 17.937l83.25 92.22l13.876-12.53l-88.125-97.626h-7.905zm-152.5 39.156l-53.25 102.188l16.56 8.656l39.158-75.125l-2.47-35.72zm149.843 4.594l-2.19 36.25l36.47 70l16.594-8.656l-50.875-97.594z"/></svg>';

  // src/assets/game-icons/cauldron.svg
  var cauldron_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="height: 512px; width: 512px;"><g class="" transform="translate(0,0)" style=""><path d="M259.063 25.094c-56.045 0-106.836 9.775-144.438 26.125-18.8 8.174-34.34 17.96-45.594 29.53-11.254 11.57-18.28 25.338-18.28 40.188 0 9.936 3.17 19.388 8.625 28.03-10.218 21.883-15.844 45.794-15.844 70.782 0 103.158 95.757 187.844 215.532 187.844 119.776 0 215.563-84.686 215.563-187.844 0-24.99-5.653-48.897-15.875-70.78 5.454-8.644 8.625-18.096 8.625-28.032 0-14.85-7.026-28.617-18.28-40.188-11.256-11.57-26.825-21.356-45.626-29.53-37.603-16.35-88.363-26.126-144.408-26.126zm0 18.687c53.848 0 102.554 9.6 136.968 24.564 17.208 7.482 30.775 16.306 39.658 25.437 8.882 9.133 13 18.115 13 27.157 0 9.043-4.118 18.057-13 27.188-8.883 9.13-22.45 17.956-39.657 25.438-34.413 14.963-83.12 24.562-136.967 24.562-53.85 0-102.555-9.6-136.97-24.563-17.206-7.48-30.804-16.306-39.687-25.437-8.882-9.13-12.97-18.145-12.97-27.188 0-9.042 4.088-18.024 12.97-27.156 8.883-9.13 22.48-17.954 39.688-25.436 34.414-14.964 83.12-24.563 136.97-24.563zm-7.782 17.282c-80.57 0-146 26.008-146 57.844 0 31.836 65.43 57.81 146 57.813 40.04 0 76.404-6.613 102.782-16.94-21.316 3.34-45.064 5.845-70.656 5.845-86.066 0-155.937-21.656-155.937-47.906s69.868-47.282 155.936-47.282c20.43 0 39.926.725 57.813 2.906-24.816-7.704-55.957-12.28-89.94-12.28zM87.657 360.5c-9.916 19.897-14.758 36.638-15.78 49.03-1.23 14.906 2.752 22.238 6.655 24.626 3.905 2.388 11.497 2.48 23.376-5.75 9.25-6.41 20.16-17.73 31.375-34.406-16.778-9.432-32.1-20.71-45.624-33.5zm342.75.063c-13.532 12.782-28.872 24.043-45.656 33.468 11.21 16.666 22.13 27.97 31.375 34.376 11.88 8.23 19.472 8.138 23.375 5.75 3.903-2.388 7.886-9.72 6.656-24.625-1.022-12.38-5.855-29.098-15.75-48.967zm-199.25 64.25c1.36 21.275 5.296 37.554 10.344 48.468 6.272 13.56 13.26 17.82 17.72 17.908 4.457.088 11.14-3.683 17.374-16.907 5.133-10.89 9.165-27.52 10.437-49.467a267.366 267.366 0 0 1-27.967 1.468c-9.437 0-18.75-.506-27.907-1.467z" fill="%23000000" fill-opacity="1"></path></g></svg>';

  // src/assets/game-icons/deathJuice.svg
  var deathJuice_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="height: 512px; width: 512px;"><g class="" transform="translate(0,0)" style=""><path d="M257.617 20.717c-7.083-.011-14.242.448-21.469 1.347-31.2 3.87-59.077 16.346-82.566 39.51-18.59 18.323-30.93 40.783-33.8 68.274-3.409 32.99 6.985 61.16 28.118 84.191 6.792 7.386 9.795 14.582 9.608 25.03-.297 16.428.974 32.882 1.65 50.308 21.027-12.421 41.214-24.384 61.674-36.48 12.176 21.378 24.055 42.27 36.479 63.976 12.148-21.517 23.894-42.3 35.826-63.244 19.753 11.8 39.24 23.46 59.373 35.557.514-16.94 1.733-32.799 1.246-48.6-.353-11.07 1.813-19.676 10.256-26.223 2.677-2.083 4.707-5.356 6.845-8.308 20.568-28.606 27.712-60.348 17.16-95.498-9.77-32.502-30.771-54.695-57.699-70.362-23.066-13.405-47.403-19.44-72.7-19.478zm82.799 105.207c17.942-.134 26.164 11.07 22.404 30.474-4.353 22.379-22.92 38.723-42.674 37.668-21.38-1.139-38.695-18.755-41.025-41.892-.186-1.811.435-4.598 1.6-5.547 10.658-8.605 45.704-20.593 59.695-20.703zm-165.154.03c13.717.865 29.494 7.548 45.084 14.91 2.297 1.107 4.408 2.785 6.763 3.464 5.847 1.651 6.088 6.113 5.25 11.31-3.76 22.217-23.004 39.484-42.785 38.401-22.433-1.218-39.592-19.269-41.162-43.351-1.083-16.59 6.766-24.952 26.85-24.735zm80.615 56.556c7.44 18.214 14.42 35.235 21.646 52.93h-43.187c7.144-17.588 14.152-34.637 21.54-52.93zm-16.172 141.84c-.146.319-.293.633-.42.976-2.894 7.981-6.197 15.856-9.984 23.543-8.334 16.832-17.293 33.365-25.71 50.09-6.63 13.125-10.336 26.845-7.74 41.783 5.71 32.582 36.67 54.827 69.63 49.844 39.886-6.033 59.48-41.103 48.603-74.902-4.357-13.586-11.283-26.469-17.941-39.159-8.46-16.062-16.528-32.279-23.061-49.11-2.348 4.152-4.698 8.311-7.057 12.491l-8.658 15.328-8.742-15.279a11284.8 11284.8 0 0 1-8.92-15.605zm.053 40.97c3.709.032 3.735 27.583 1.642 40.026-2.166 12.555.13 24.084 10.495 32.69 15.02 12.475 35.426 9.66 46.654-6.386.514-.68.975-1.355 1.49-2.06.404.083.756.164 1.162.219-.89 4.763-1.217 9.633-2.652 14.261-6.33 20.702-25.515 33.068-47.977 31.174-19.404-1.624-35.833-17.753-39.24-37.996-1.841-10.579 1.218-20.05 5.654-29.17 6.602-13.61 14.018-26.817 20.647-40.375.81-1.655 1.518-2.388 2.125-2.383z" fill="%23000000" fill-opacity="1"></path></g></svg>';

  // src/assets/game-icons/diceFire.svg
  var diceFire_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="height: 512px; width: 512px;"><g class="" transform="translate(0,0)" style=""><path d="M218.4 24.72c-14.2 0-30.5 3.56-49.5 11.88 77.2 8.6 65.9 91.4 14.1 106.2-65.4 18.7-131.31-23.7-98.34-99.2-39.67 18.95-42.17 80.8-12.93 111.5C141.3 227.9 56.9 279 37.25 200.7-1.929 326.2 60.34 489.5 258.7 489.5c250.7 0 282-374.7 129.2-415.04 26.5 43.04-13.1 70.94-24.9 73.14-51.3 9.9-58.1-122.89-144.6-122.88zm37.5 118.08c4.5 0 9.4 1.1 12.8 2.9l115.9 67.1c7.4 4.1 7.4 10.9 0 15.2l-115.9 66.9c-7.2 4.3-18.5 4.3-25.7 0L126.8 228c-7.3-4.3-7.3-11.1 0-15.2L243 145.7c3.4-1.8 7.9-2.9 12.9-2.9zm-89 62.6c-21.6-.4-33.1 15-18.2 24.3 9.6 4.8 23.7 4.4 32.7-.8 8.8-5.3 9.5-13.7 1.5-19.4-4.3-2.5-10-4-16-4.1zm178.6.1c-20.8.4-31.3 15.5-16.3 24.5 9.6 4.9 23.9 4.6 33-.7 8.9-5.3 9.5-13.9 1.2-19.6-4.2-2.4-9.9-4-15.9-4.2h-2zm-89 0c-6.6-.1-13 1.5-17.7 4.2-10.2 5.6-10.4 15.1-.6 20.9 9.9 5.8 25.8 5.6 35.1-.6 15-9 4.6-24.3-16.8-24.5zm-141 41c1.5.1 3.4.5 5.6 1.6l111.5 64.5c7.2 4.1 12.9 14.2 12.9 22.5v119.7c0 8.3-5.7 11.7-12.9 7.6L121.2 398c-7.4-4.3-13.2-14.2-13.2-22.6V255.7c0-6.2 3-9.2 7.5-9.2zm281.3 0c4.2 0 7.2 3 7.2 9.2v119.7c0 8.4-6 18.3-13 22.6l-111.5 64.4c-7.2 4.1-12.9.7-12.9-7.6V335.1c0-8.3 5.7-18.4 12.9-22.5L391 248.1c2.1-1.1 4.2-1.5 5.8-1.6zm-185 65.5h-1.1c-5.3.4-8.5 4.8-8.5 11.6-.6 10.4 7.2 24.1 16.9 29.8 9.8 5.6 17.6 1.1 17.2-9.9.2-14.2-13.3-31.1-24.5-31.5zm130.9 21.8c-11.2.1-24.8 17.2-24.7 31.4.1 10.4 7.7 14.4 17.2 8.9 9.4-5.5 17-18.3 17.1-28.8 0-6.7-3.3-11.1-8.5-11.5h-1.1zm-216.9 22.5c-5.4.3-8.7 4.7-8.7 11.6-.5 10.5 7.3 24.1 17 29.8 9.8 5.5 17.6 1 17.2-10.1 0-14.5-14.1-31.8-25.5-31.3z" fill="%23000000" fill-opacity="1"></path></g></svg>';

  // src/assets/game-icons/door.svg
  var door_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="height: 512px; width: 512px;"><g class="" transform="translate(0,0)" style=""><path d="M105 41v398h302V41H105zm55 174c18.1 0 33 14.9 33 33s-14.9 33-33 33-33-14.9-33-33 14.9-33 33-33zm0 18c-8.4 0-15 6.6-15 15s6.6 15 15 15 15-6.6 15-15-6.6-15-15-15zM73 457v30h366v-30H73z" fill="%23000000" fill-opacity="1"></path></g></svg>';

  // src/assets/game-icons/evilBook.svg
  var evilBook_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="512" height="512" viewBox="0 0 512 512"><path fill="currentColor" d="M93.998 27.8c-24.004-.13-42.94 15.268-54.732 32.778C27.094 78.653 20.66 98.816 24.684 115.1l.01.04l81.476 318.186c.11-9.534 2.292-19.376 6.22-28.596c4.24-9.948 10.73-19.412 19.245-27.21c7.477-7.44 17.398-13.343 29.234-16.575l.007-.002a77.5 77.5 0 0 1 13.787-2.74l.658-.07l323.2 11.25l-126.975-328.56l-275.21-12.96a56 56 0 0 0-2.34-.062zm-.107 18.69q.78.005 1.567.04l263.046 12.39l112.408 290.867l-299.46-9.77l-.653.07c-26.13 2.814-47.677 15.802-60.554 33.823l-67.42-263.29v-.003c-1.57-6.362 2.12-25.013 11.942-39.6c9.516-14.132 23.03-24.603 39.123-24.525zm17.426 17.403L93.35 69.037l73.06 255.193l17.967-5.142zm52.48 19.2c3.22 62.57 46.11 84.672 81.54 87.507l9.07-16.85l-43.873-19.943l15.91-8.95c-24.727-2.388-42.9-24.437-62.648-41.765zm180.157 2.948c-10.863 18.29-18.594 40.613-39.375 46.132l10.31 13.844l-24.808 16.07l14.943 13.84c29.995-7.382 59.367-33.122 38.93-89.885zm44.406 88.26l-33.432 59.067l-18.184-40.082l-25.455 50.627l-50.07-37.266l-8.277 35.157l-76.937-59.768l46.058 99.145l13.426-21.8l45.862 59.07l19.857-46.41l41.196 47.108l17.785-52.03l20.13 28.827l8.04-121.644zM176.214 376.866c-23.563 2.688-39.208 17.766-46.63 35.19c-6.863 16.106-5.658 33.007 1.804 42.7l315.006 10.862c-2.514-13.553-1.82-27.43 2.32-41.203l-21.546-6.818l34.252-20.055a127 127 0 0 1 7.658-10.48z"/></svg>';

  // src/assets/game-icons/handcuffs.svg
  var handcuffs_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="height: 512px; width: 512px;"><g class="" transform="translate(0,0)" style=""><path d="M147.406 20.03a30.817 30.817 0 0 0-3.156.157c-4.238.433-8.576 1.774-12.656 4.125-.008.005-.023-.004-.03 0l-29.783 17.22c-7.858 4.534-12.662 12.15-13.874 19.78-1.212 7.63.62 15.126 4.22 21.47.11.197.227.397.343.593l-11.72 40.22a36.448 36.448 0 0 0-5 4.124c-5.196 5.117-9.01 11.83-9.844 19.56-.835 7.732 1.923 16.39 8.406 22.876L98.626 194.5c6.633 6.63 15.296 9.602 23.188 9.03 4.63-.333 8.935-1.755 12.78-3.905l7.095 6.688a29.393 29.393 0 0 0-5.157 10.437l-1.624 6.03 18.063 4.845 1.624-6.063c1.06-3.953 2.712-5.37 5.125-6.437 1.205-.533 2.67-.867 4.28-.938 1.61-.07 3.366.126 5.063.594 3.393.938 6.375 2.963 7.968 5.157 1.594 2.195 2.284 4.266 1.282 8l-1.625 6.032 18.063 4.843 1.625-6.032c2.35-8.762.32-17.56-4.22-23.81-4.537-6.253-11.093-10.28-18.124-12.22a35.11 35.11 0 0 0-10.905-1.25c-1.67.075-3.34.28-5 .625l-10.344-9.75c2.06-3.75 3.42-7.944 3.75-12.438.586-7.917-2.42-16.574-9.093-23.25l-24.343-24.312c-4.677-4.68-10.516-7.357-16.313-8.156l6.157-21.095c.177.072.353.15.532.22 7.25 2.806 16.336 2.394 24.28-2.19l29.813-17.186c6.104-3.528 10.526-8.694 12.968-14.345l21.095 5.938c-.88 3.745-1.122 7.688-.5 11.687 1.194 7.683 6.06 15.35 14 19.938l29.813 17.218a31.333 31.333 0 0 0 11.78 3.97L255 140.78c-2.735 1.553-5.224 3.477-7.438 5.657-5.195 5.12-8.977 11.833-9.812 19.563-.835 7.73 1.89 16.39 8.375 22.875l4.22 4.22 13.218-13.22-4.22-4.22c-2.893-2.893-3.314-5.032-3.03-7.655.283-2.623 1.867-5.78 4.375-8.25 2.507-2.47 5.77-4.06 8.468-4.344.337-.035.68-.052 1-.062 2.252-.07 4.17.544 6.563 2.937v.032l4.217 4.188 13.188-13.188-4.188-4.218a28.68 28.68 0 0 0-16.656-8.188l-3.25-18.28c4.92-2.895 8.87-7.066 11.658-11.845 3.74-6.412 5.516-14.137 4.03-21.936-1.484-7.8-6.637-15.374-14.812-20.094l-29.78-17.188c-3.93-2.27-8.145-3.506-12.282-3.812-4.137-.306-8.206.305-11.813 1.688-4.304 1.65-8.01 4.21-11.093 7.343l-29.093-8.186a34.05 34.05 0 0 0-3.47-8.594c-3.684-6.445-9.47-11.856-16.968-14.47-2.81-.98-5.862-1.488-9-1.5zm-.187 18.564c1.063.03 2.05.252 3.03.593 2.614.912 5.225 3.153 6.906 6.094 1.682 2.942 2.312 6.365 1.78 9.126-.528 2.756-1.805 5.11-5.717 7.375-.01.006-.024-.004-.032 0l-29.782 17.19c-3.545 2.044-5.726 1.89-8.187.936a10.648 10.648 0 0 1-1.97-1.03l.094-.345-.906-.25c-1.53-1.183-2.977-2.804-4.063-4.718-1.737-3.06-2.425-6.634-2-9.312.425-2.678 1.4-4.598 4.75-6.53v-.032l29.78-17.188h.032c2.02-1.166 3.688-1.72 5.188-1.875.375-.038.74-.04 1.094-.03zM226.5 62.22c.31-.02.618-.024.938 0 1.276.09 2.637.53 4.312 1.5v.03l29.813 17.188c4.04 2.332 5.294 4.686 5.812 7.406.518 2.72-.138 6.105-1.844 9.03-1.705 2.927-4.343 5.174-7 6.095-2.654.92-5.316 1.02-9.25-1.25L219.47 85c-3.544-2.048-4.47-3.985-4.876-6.594-.406-2.608.28-6.09 2.062-9.125 1.783-3.034 4.532-5.435 7.063-6.405.948-.364 1.85-.598 2.78-.656zM98.344 136.624c2.246-.065 4.14.575 6.53 2.97l24.345 24.31c3.296 3.3 3.89 5.896 3.686 8.657-.204 2.762-1.688 5.865-4.094 8.25-2.405 2.386-5.54 3.892-8.343 4.094-2.805.203-5.415-.415-8.626-3.625L87.53 156.97c-2.89-2.895-3.313-5.065-3.03-7.69.283-2.622 1.867-5.778 4.375-8.25 2.508-2.47 5.773-4.06 8.47-4.343.336-.035.678-.053 1-.062zM320 149.875l-62.094 62.094 48.844 48.843 26.938-26.938.343.344a71.152 71.152 0 0 1 3.033-3.25c27.69-27.693 72.59-27.693 100.28 0 27.205 27.203 27.684 71.022 1.438 98.81-.004.014-.025.02-.03.033-1.03 2.514-1.372 4.965-1.28 7.343.18 4.757 2.415 9.505 5.936 13.063 3.52 3.556 8.17 5.75 12.875 5.936 3.614.144 7.41-.73 11.47-3.625 37.58-42.338 36.114-107.29-4.438-147.842-29.2-29.2-71.177-37.894-108.062-26.563l-5.375 1.656-3.97-3.968L320 149.875zm-11.75 40.688 18.313 18.312-13.22 13.22-18.312-18.314 13.22-13.218zm-186.53 48-17.876 66.78 36.78 9.844-.124.47c1.445.292 2.9.612 4.344 1 37.828 10.135 60.26 49.015 50.125 86.843-9.962 37.175-47.675 59.485-84.876 50.625-2.695.375-4.986 1.326-7 2.594-4.03 2.533-7.024 6.796-8.344 11.624-1.32 4.828-.908 9.988 1.28 14.156 1.686 3.206 4.35 6.085 8.907 8.156 55.445 11.366 110.96-22.407 125.813-77.78.003-.01-.003-.022 0-.032 10.673-39.878-2.783-80.572-31.03-106.844l-4.126-3.844 1.437-5.437 9.5-35.44-84.81-22.717zm159.655 23.28c-6.083 33.48 3.736 69.08 29.72 95.063 36.204 36.205 91.507 41.554 133.06 15.625-5.342-2.01-10.13-5.214-14.06-9.186-5.135-5.186-8.89-11.79-10.47-19.156-26.67 13.713-60.22 9.406-82.563-12.938-14.735-14.735-21.633-34.33-20.687-53.625l-3 3-6.625 6.625-6.594-6.625-18.78-18.78zm-131.656 4.094 18.06 4.844-6.686 25.033-18.063-4.844 6.69-25.033zm-59.47 17.938c-32.02 11.48-57.93 37.8-67.438 73.28-13.252 49.46 9.77 100.012 53 123.033-.936-5.626-.568-11.36.907-16.75 1.923-7.036 5.783-13.63 11.374-18.688C62.872 428.512 49.82 397.34 58 366.812c5.395-20.134 18.935-35.924 36.125-44.75L90 320.97l-9.03-2.44 2.405-9.03 6.875-25.625z" fill="%23000000" fill-opacity="1"></path></g></svg>';

  // src/assets/game-icons/hangingSpider.svg
  var hangingSpider_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="height: 512px; width: 512px;"><g class="" transform="translate(0,0)" style=""><path d="M245.625 14.656v141.53c-27.713 6.03-48.875 38.405-48.875 77.47 0 15.552 3.366 30.034 9.156 42.22a100.09 100.09 0 0 1-9.406-10.97c-33.54-45.34-33.54-121.904 0-167.25l-15-11.125c-39.288 53.12-39.292 136.387 0 189.5a119.17 119.17 0 0 0 7.97 9.69c-55.29-22.365-93.407-72.152-93.407-129.408H77.374c0 61.73 38.437 115.01 94.438 141.938-21.208 7.248-40.477 17.198-57 29.344-36.29 26.675-59.594 64.432-59.594 106.5h18.686c0-35.19 19.332-67.448 51.97-91.438 16.31-11.99 35.903-21.796 57.75-28.594a112.592 112.592 0 0 0-6.345 6.407c-42.477 46.365-42.477 120.787 0 167.155L191.063 475c-32.263-35.218-35.342-90.954-9.25-130.094 4.213 13.518 16.883 23.438 31.72 23.438 3.25 0 6.396-.49 9.374-1.375a33.232 33.232 0 0 0 1.78 5.25 37.482 37.482 0 0 0-7.28 22.25c0 14.788 8.532 27.58 20.938 33.717-.826-4.1-1.28-8.56-1.28-13.25 0-19.7 8.013-35.687 17.905-35.687 9.89 0 17.905 15.987 17.905 35.688 0 4.69-.456 9.15-1.28 13.25 12.404-6.14 20.936-18.93 20.936-33.72 0-8.215-2.657-15.814-7.124-22a33.05 33.05 0 0 0 1.875-5.406 32.767 32.767 0 0 0 9.033 1.282c14.87 0 27.566-9.965 31.75-23.53 26.16 39.143 23.102 94.94-9.188 130.186l13.78 12.625c42.48-46.368 42.48-120.79 0-167.156a112.235 112.235 0 0 0-6.342-6.408c21.845 6.798 41.438 16.604 57.75 28.594 32.637 23.99 51.968 56.25 51.968 91.438h18.69c0-42.068-23.305-79.825-59.595-106.5-16.524-12.146-35.792-22.096-57-29.344 56-26.93 94.438-80.208 94.438-141.938h-18.688c0 57.256-38.118 107.043-93.406 129.407 2.765-3.02 5.424-6.25 7.967-9.69 39.292-53.11 39.292-136.38 0-189.5l-15 11.126c33.542 45.345 33.54 121.913 0 167.25a99.622 99.622 0 0 1-9.375 10.906c5.77-12.18 9.125-26.627 9.125-42.156 0-39.065-21.162-71.44-48.875-77.47V14.657h-18.687zm9.47 281.5c8.137 0 14.53 6.398 14.53 14.53 0 8.135-6.393 14.533-14.53 14.533-8.14 0-14.5-6.398-14.5-14.533 0-8.133 6.366-14.53 14.5-14.53zm-41.564 24.438c8.14 0 14.532 6.398 14.532 14.53 0 8.134-6.393 14.532-14.53 14.532-8.14 0-14.532-6.396-14.532-14.53s6.398-14.532 14.53-14.532zm82.782 0c8.138 0 14.532 6.398 14.532 14.53 0 8.134-6.394 14.532-14.53 14.532-8.14 0-14.533-6.396-14.533-14.53s6.4-14.532 14.533-14.532zm-41.218 23.875c8.138 0 14.53 6.397 14.53 14.53s-6.392 14.53-14.53 14.53c-8.138 0-14.5-6.395-14.5-14.53 0-8.133 6.367-14.53 14.5-14.53z" fill="%23000000" fill-opacity="1"></path></g></svg>';

  // src/assets/game-icons/haunting.svg
  var haunting_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="height: 512px; width: 512px;"><g class="" transform="translate(0,0)" style=""><path d="M272.375 17.75c-3.073.063-6.2.27-9.344.594l-.467.062c-50.047 5.388-85.223 42.445-81.25 80.875 2.455 23.772 18.7 43.2 43.312 54.095l1.97.875 1.374 1.625 16.81 19.813 71.75-5.72 8.376-22.905 1-2.72 2.344-1.655c21.862-15.694 33.8-38.044 31.344-61.813-3.736-36.142-41.12-64.063-87.22-63.125zm46.5 48.656c13.252 0 24 10.717 24 23.97 0 13.25-10.748 24-24 24s-24-10.75-24-24c0-13.253 10.748-23.97 24-23.97zm-86.47 9.5c13.253 0 24 10.717 24 23.97 0 13.25-10.747 24-24 24-13.25 0-24-10.75-24-24 0-13.253 10.75-23.97 24-23.97zm41.407 35.438 23.907 38.875-41.5 3.06 17.592-41.936zm-164.468 7.22c-53.418-.164-65.813 17.017-89.844 27.342 7.457 62.138 33.86 128.37 17.5 232.438 19.145-14.237 59.438-96.563 59.438-96.563l-7.626 82.064 51.313-92 4.906 45.78 28.845-45.187c-1.093 24.925-4.462 51.423-21.25 74.782C114.293 400.553 99.5 477.06 99.5 477.06l46.72-50.5-20.44 66.844c37.762-30.703 55.564-65.578 66.907-102.187l6.5 101.03 26.594-60.156L261 491.656c-.13-24.413-3.5-47.555 5.75-70.094 8.515 29.13 55.87 51.816 80.406 42.657-40.048-39.82-69.453-161.727 9.906-204.408 2.53 22.436-3.683 44.846-18.843 67.282 26.68-11.406 44.907-27.785 54.78-50.688l-9.97 114.813c23.782-37.54 43.916-82.23 45.22-114.19 10.45 28.937 8.05 75.348 5.375 110.283 50.06-53.433 50.658-106.84 53.813-220.375-33.91-26.452-73.682-40.823-117.844-43.907-6.46 12.55-16.095 23.77-28 32.845l-9.563 26.156-.874 2.376 2.72 32.28-18.626 1.564-2.47-29.22-21.03 1.69 2.53 30.218-18.592 1.562-2.563-30.313-18.906 1.5 2.593 30.782-18.594 1.56-2.75-32.468-1.845-2.156-18.72-22.03c-20.886-9.807-37.6-25.673-46.218-45.5-24.256-3.692-43.582-5.266-59.343-5.314z" fill="%23000000" fill-opacity="1"></path></g></svg>';

  // src/assets/game-icons/hearts.svg
  var hearts_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="height: 512px; width: 512px;"><g class="" transform="translate(0,0)" style=""><path d="M480.25 156.355c0 161.24-224.25 324.43-224.25 324.43S31.75 317.595 31.75 156.355c0-91.41 70.63-125.13 107.77-125.13 77.65 0 116.48 65.72 116.48 65.72s38.83-65.73 116.48-65.73c37.14.01 107.77 33.72 107.77 125.14z" fill="%23000000" fill-opacity="1"></path></g></svg>';

  // src/assets/game-icons/iceBolt.svg
  var iceBolt_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="height: 512px; width: 512px;"><g class="" transform="translate(0,0)" style=""><path d="M18.094 18.125v43.53l76.156 9.407-29.97-52.937H18.095zm117.437 0 57 34.125-13.186-34.125H135.53zm121.22.156-19.938 7.314 60.344 61.468-19.844-52.218L256.75 18.28zM114.812 35.188l18.97 59.157 58.155 25.625.22 63.56 36.75-8.28-33.5-92.938-80.595-47.124zm94.47 7.126 48.843 138.656 3.625-61.626 29.53-3.78-82-73.25zm118.655 6.562-8.406 23.344 60.345 61.468L350.5 51.906l-22.563-3.03zm-285.5 42.75 54.657 47.5 4.094-44.875-58.75-2.625zm353.97 2.938 9.937 67.187-27.97 54.625 31.626-30 18.563-46.28-32.157-45.532zM18.093 106.78v67.5l21.843 11.97 62.657.28-84.5-79.75zm314.656 18.19-6.594 6.624-40.78 40.75 13.218 13.22 24.812-24.814v28.22l-12.625 12.624 12.626 52.97v2.217l-31.094 17.94-2-1.158-39.5-37.343-17.218 4.593-24.438-14.094 33.875-9.064-4.843-18.062L182.53 214.5l-9.03 2.438 2.406 9.03 14.938 55.657 18.03-4.844-9.093-33.874 24.44 14.125 4.624 17.22 52.125 15.53 1.842 1.064v36.062l-1.843 1.063-52.126 15.53-4.625 17.22-24.44 14.124 9.095-33.875-18.063-4.845-14.906 55.688-2.406 9 9.03 2.437 55.657 14.906 4.844-18.062-33.874-9.063 24.438-14.124 17.22 4.625 39.56-37.405 1.845-1.063 31.186 18v2.125l-12.625 52.97 12.626 12.624V457l-24.812-24.813-13.22 13.22 40.782 40.75 6.594 6.624 6.594-6.624 40.78-40.75-13.218-13.22-24.812 24.814v-28.22l12.625-12.624-12.626-52.97v-2.28l31.03-17.937 2 1.155 39.563 37.406 17.22-4.624 24.437 14.125-33.875 9.064 4.842 18.062L483 403.25l9-2.438-2.406-9-14.906-55.687-18.063 4.844 9.094 33.874-24.44-14.125-4.624-17.22-52.125-15.53-2.155-1.25v-35.69l2.156-1.25 52.126-15.53 4.625-17.22 24.44-14.124-9.095 33.875 18.063 4.845 14.906-55.656 2.406-9.032-9-2.438-55.688-14.906-4.843 18.062 33.874 9.063-24.438 14.093-17.22-4.594-39.498 37.343-2.157 1.25-30.936-17.875v-2.375l12.625-52.97-12.626-12.624v-28.22l24.812 24.813 13.22-13.22-40.782-40.75-6.594-6.624zm-203.47 1.124-17.56 35.156 46.843 33.97 14.062-53.876-43.344-15.25zm-66.874 76.25 56.657 85.844 40.562 13.218-14.72-80.5-14.624-14.625-18.31 15.814-49.564-19.75zm-23.468 28.594-7.688 27.5 35.094 18.625 1.344-27.875-28.75-18.25zm293.656 42.093 31.094 17.94v35.874l-31.094 17.97-31.094-17.97V290.97l31.094-17.94zM93.5 304.47l31.906 56.905 32.78 7.28 11.44-39.405L93.5 304.47zm-25.75 53.624 16.094 46.72 66.72-8.127-82.814-38.593zm78.375 66.97L117 453.717l95.844-20.533-66.72-8.125z" fill="%23000000" fill-opacity="1"></path></g></svg>';

  // src/assets/game-icons/loveInjection.svg
  var loveInjection_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="height: 512px; width: 512px;"><g class="" transform="translate(0,0)" style=""><path d="M110.814 19.584C86.886 19.1 66.43 42.18 74.574 72.572 33.3 61.514 1.52 106.864 33.804 137.152c27.285 25.595 75.65 12.207 105.592 13.594l35.608 35.61-20.8 20.798a45.184 45.184 0 0 0-17.956-3.72c-1.102 0-2.2.038-3.297.117-14.61 1.05-28.493 9.07-36.325 22.636-12.533 21.7-5.02 49.73 16.682 62.26l9.343-16.186c-12.953-7.48-17.322-23.778-9.84-36.73 7.204-12.477 22.578-16.98 35.274-10.622l.79.79 165.18 165.185c22 22 51.77 20.233 71.514 6.043l89.446 89.447 13.215-13.213-89.543-89.545c5.476-7.808 8.98-17.067 9.432-27.056.633-13.987-5.028-29.007-17.884-41.863l-166.363-166.37.516-.298c-7.48-12.954-3.115-29.253 9.84-36.73 12.957-7.48 29.25-3.115 36.73 9.84l16.185-9.345c-7.83-13.564-21.715-21.583-36.325-22.63a44.153 44.153 0 0 0-3.297-.118 45.184 45.184 0 0 0-22.636 6.066c-20.796 12.005-28.546 38.234-18.14 59.498l-18.528 18.53-34.986-34.986c-1.04-30.028 11.983-81.578-14.238-106.203-8.923-8.378-18.818-12.176-28.182-12.366zm107.64 149.752L375.837 326.73l-49.754 49.754-157.39-157.39 49.76-49.758zm.837 26.373-13.214 13.214L336.584 339.43l13.215-13.215L219.29 195.71z" fill="%23000000" fill-opacity="1"></path></g></svg>';

  // src/assets/game-icons/magicPortal.svg
  var magicPortal_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="512" height="512" viewBox="0 0 512 512"><path fill="currentColor" d="m88.418 17.17l-66.12 475.242h18.866l66.12-475.242H88.42zm315.7 0l66.023 475.242h18.87L422.988 17.17zm-56.26.24l-132.422.37c-59.343 41.506-78.325 97.982-61.596 168.03c-22.324-31.34-32.747-63.248-33.59-98.234l-26.684 191.78c1.05-3.64 2.25-7.31 3.653-11.012l-3.843 12.385l-4.934 35.454c.41 37.954 18.614 69.416 40.91 87.406c-18.52-6.774-35.355-15.287-49.25-27.445l-9.207 66.152c43.032 20.635 88.614 24.346 120.56 17.78c-33.542 18.813-71.344 29.428-125.382 16.886l-2.13 15.3h217.568c73.664-14.515 117.318-55.617 129.045-89.216c3.54 30.568-2.754 60.093-37.473 89.215h73.242l-41.553-299.11c-15.226-35.307-51.106-59.122-74.695-59.718c10.876-3.615 21.615-5.918 32.305-5.78c11.61.15 23.16 3.2 34.76 10.56l-4.207-30.278c-21.365-18.958-46.472-31.023-68.92-35.954c6.54-.477 13.043-.73 19.513-.685c15.23.104 30.273 1.868 45.18 6.21l-4.224-30.398C331.8 45.105 287.813 60.384 263.44 79.407c13.68-23.55 44.533-47.68 84.417-61.998zm-81.323 33.065c-68.785 37.085-71.87 82.26-36.1 122.146c-7.626-69.52 80.94-110.016 118.96-59.032c-40.867-20.17-77.79 7.84-76.21 47.723c23.234-23.997 98.678-13.267 79.795 36.19c-11.3-33.297-56.74-30.094-63.648-13.77c-14.75 34.866 64.34 14.582 98.117 66.284c-18.85-10.875-47.74.482-39.22 14.59c32.28 53.45 84.53 113.185 13.3 147.025c23.57-38.677 10.786-65.734-21.85-81.43c25.644 66.744-5.1 163.717-103.81 133.19c62.83-11.442 78.355-62.576 57.263-83.425c-23.617 60.37-122.14 97.174-181.444 38.453c58.693 22.535 99.285 7.31 120.644-26.39c-35.89 21.435-95.375 6.933-113.994-42.977c28.694 29.187 67.102 37.963 91.195 20.356c13.217-9.658 8.303-25.06-8.55-29.402c-24.53-6.32-61.988-12.852-76.563-36.588c21.722 6.003 43.444 10.698 65.166-3.375c-33.985-22.07-81.546-50.75-50.348-100.278c1.008 35.15 17.23 56.557 53.197 48.254c9.285-2.142 16.8-15.472 8.55-23.373c-61.138-58.54-47.58-160.406 65.548-174.168z"/></svg>';

  // src/assets/game-icons/magicSwirl.svg
  var magicSwirl_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="512" height="512" viewBox="0 0 512 512"><path fill="currentColor" d="M247.79 18.734C137.967 17.596 19.874 96.94 19.73 244.53l21.403-51.395c-9.485 72.28-7.75 147.236 38.79 202.502L38.2 377.355c39.24 69.774 126.333 90.976 200.855 92.51C124.11 429.9 67.87 342.277 63.912 246.492c-6.722-211.78 260.658-217.694 340.78-75.77c-3.417-19.492-8.623-38.426-15.618-56.11c77.406 89.155 59.293 214.875-21.29 253.036c-24.25 3.95-48.93 12.06-60.954 19c-58.548 33.802-6.27 126.536 53.225 92.188c9.44-5.45 23.404-17.303 36.494-31.352c64.36-59.52 98.1-118.24 93.108-188.94c-6.52 29.1-19.175 57.904-35.623 84.683c63.158-146.822 7.956-263.89-144.838-301.354c12.097 5.835 23.503 13.63 33.873 23.36c-57.415-23.752-131.123-22.62-186.884 3.505c28.066-26.2 64.776-43.73 102.2-49.642q-5.281-.307-10.597-.362zm-19.74 160.202l-19.843 100.566c-2.958 3.81-5.64 6.852-9.033 9.94l-25.688-49.096l-22.705 11.93l31.37 60.945c4.48 11.474 10.02 20.68 15.162 28.524c28.063 42.803 64.547 35.252 95.303 9.555l87.28-48.452l-12.71-22.498l-66.136 36.94c-1.517-3.154-3.266-6.552-5.056-9.51l67.818-64.96l-17.54-18.695l-66.47 63.762c-2.356-2.318-4.238-4.527-6.765-6.54l45.084-78.085l-22.733-13.127l-45.864 78.297c-3.79-1.31-7.72-2.2-11.595-2.745l15.656-81.896l-25.533-4.854z"/></svg>';

  // src/assets/game-icons/pawPrint.svg
  var pawPrint_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="height: 512px; width: 512px;"><g class="" transform="translate(0,0)" style=""><path d="m258.53 16.727-7.553 10.367s-14.79 20.28-29.64 44.75c-7.424 12.236-14.9 25.517-20.622 38.108-5.722 12.588-9.965 24.188-9.965 35.076 0 37.323 30.458 67.783 67.78 67.783 37.327 0 67.784-30.46 67.784-67.782 0-10.888-4.242-22.488-9.964-35.076-5.723-12.59-13.162-25.872-20.586-38.108-14.85-24.47-29.676-44.75-29.676-44.75l-7.557-10.367zm0 32.778c4.848 6.853 10.65 14.592 21.245 32.05 7.185 11.838 14.33 24.617 19.565 36.133 5.235 11.518 8.285 22.092 8.285 27.34 0 14.03-5.816 26.627-15.172 35.553a36.439 36.439 0 0 0 2.662-13.698c0-20.197-36.57-70.364-36.57-70.364s-36.572 50.167-36.572 70.364c0 4.86.955 9.492 2.675 13.734-9.377-8.928-15.21-21.54-15.21-35.588 0-5.248 3.087-15.822 8.322-27.34 5.234-11.516 12.38-24.295 19.564-36.133 10.594-17.457 16.36-25.195 21.207-32.05zM60.66 79.365l-3.285 12.374s-6.49 24.27-11.496 52.45c-2.503 14.09-4.652 29.19-5.44 42.998-.786 13.807-.538 26.13 3.395 36.28 13.484 34.803 52.873 52.214 87.676 38.73 34.803-13.486 52.21-52.913 38.728-87.713-3.933-10.153-12.09-19.383-21.974-29.055-9.884-9.67-21.653-19.38-32.996-28.105C92.578 99.875 71.463 86.3 71.463 86.3l-10.805-6.936zm394.725 0L444.578 86.3s-21.114 13.574-43.8 31.025c-11.344 8.726-23.114 18.434-33 28.105-9.883 9.672-18.002 18.902-21.936 29.055-13.483 34.8 3.888 74.227 38.69 87.713 34.804 13.484 74.23-3.927 87.714-38.73 3.934-10.15 4.145-22.473 3.358-36.28-.787-13.807-2.935-28.907-5.438-42.998-5.006-28.18-11.498-52.45-11.498-52.45l-3.285-12.376zm-11.826 30.55c2.042 8.137 4.64 17.446 8.213 37.56 2.42 13.636 4.46 28.142 5.18 40.772.72 12.63-.255 23.576-2.15 28.47-5.067 13.076-15.038 22.716-26.98 27.66a36.445 36.445 0 0 0 7.412-11.788c7.298-18.834-8.68-78.824-8.68-78.824s-52.227 33.564-59.523 52.395a36.434 36.434 0 0 0-2.467 13.725c-5.504-11.706-6.38-25.56-1.31-38.648 1.897-4.893 8.553-13.598 17.595-22.445 9.042-8.85 20.34-18.203 31.316-26.647 16.206-12.465 24.41-17.6 31.393-22.23zm-371.035.037c6.997 4.64 15.17 9.745 31.355 22.193 10.977 8.444 22.276 17.798 31.318 26.647 9.042 8.847 15.696 17.552 17.592 22.445 5.068 13.082 4.197 26.932-1.3 38.635.063-4.557-.722-9.2-2.47-13.71-7.295-18.832-59.523-52.396-59.523-52.396s-15.975 59.99-8.678 78.823a36.468 36.468 0 0 0 7.415 11.79c-11.945-4.942-21.92-14.583-26.988-27.663-1.896-4.894-2.872-15.84-2.152-28.47.72-12.63 2.797-27.137 5.22-40.772 3.568-20.096 6.167-29.375 8.212-37.523zm184.294 122.39c-43.658 0-79.31 28.473-87.347 66.686-22.89 8.593-43.324 19.73-57.71 34.275-15.516 15.688-25.112 34.84-25.112 55.518 0 30.856 20.97 57.578 52.124 75.997 31.154 18.418 73.17 29.38 119.322 29.38s87.99-10.95 118.994-29.38c31.004-18.43 51.832-45.18 51.832-75.996 0-20.867-9.736-40.188-25.48-55.99-14.613-14.672-35.395-25.875-58.692-34.423-8.38-37.994-44.513-66.066-87.932-66.066zm0 18.686c37.094 0 66.64 24.44 71.178 54.936l.838 5.656 5.44 1.832c23.44 7.892 42.783 19.37 55.92 32.557 13.136 13.187 20.04 27.7 20.04 42.817 0 14.93-6.83 29.376-19.52 42.178 3.65-7.606 5.618-15.66 5.618-24.004 0-25.25-31.607-64.705-89.514-79.745.172-1.57.26-3.162.26-4.774 0-25.574-22.076-46.31-49.308-46.31-27.233 0-49.31 20.736-49.31 46.31 0 1.543.085 3.065.24 4.568-58.223 14.926-89.483 54.81-89.483 79.953h-.002c0 8.25 1.937 16.215 5.533 23.743-12.622-12.743-19.41-27.096-19.41-41.916 0-14.955 6.777-29.303 19.71-42.38C137.982 333.37 157.032 321.95 180.09 314l5.402-1.868.805-5.694c4.324-30.847 33.236-55.41 70.52-55.41z" fill="%23000000" fill-opacity="1"></path></g></svg>';

  // src/assets/game-icons/plasticDuck.svg
  var plasticDuck_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="height: 512px; width: 512px;"><g class="" transform="translate(0,0)" style=""><path d="M322.8 50.96c-28.1.66-52.4 13.13-65.8 38.48-13.4 25.36-16.1 64.96 3.6 120.46v.2c3.2 9.4 2.4 19.2-2.6 26.4-5 7.3-12.9 11.6-21.9 14.5-18 5.8-42.3 6.4-69.3 4.5-48.7-3.5-105.4-15.7-142.38-27.9-2.34 56.3 13.28 113.7 45.28 157.2 34.2 46.5 86.2 77.5 156 76.2 45.3-.8 98.8-7.4 140.2-25.5 41.4-18 70-45.8 71.3-92.4v-.1c.6-19.8-18.4-47.1-36.3-74.7-8.9-13.8-17.3-27.8-21.9-42.4-4.6-14.5-5-30.3 3.2-44.5l.2-.3.2-.3c22.2-32.6 18.7-64.5 3.9-89.24-14.7-24.79-41.5-41.12-63.7-40.6zm30.5 42.05a18 18 0 0 1 18 17.99 18 18 0 0 1-18 18 18 18 0 0 1-18-18 18 18 0 0 1 18-17.99zM416 130.2c.4 14.3-2.4 29.3-9.2 44.2 19.5-1.2 38.8-3.4 53.6-8.4 9.6-3.1 17.1-7.4 21.8-12.3 2.7-2.9 4.5-6 5.6-9.7-24.7.3-51-6.3-71.8-13.8zm-72.6 142.5c6.5 13.6 6.1 28.2.7 40.9-5.4 12.7-15.3 23.8-27.7 33.9-24.7 20-59.6 35.5-93.6 44.8-34 9.3-66.4 12.8-88.7 4.8-11.2-4-20.6-12.6-22.2-24.5-1.6-12 3.6-24.8 14.4-39.8l14.6 10.6c-9.4 13-11.8 22.2-11.2 26.8.7 4.7 3.1 7.3 10.4 10 14.7 5.2 45.9 3.5 78-5.3 32-8.7 65.3-23.8 87-41.4 10.8-8.8 18.7-18.2 22.4-27 3.8-8.8 4.1-16.8-.3-26z" fill="%23000000" fill-opacity="1"></path></g></svg>';

  // src/assets/game-icons/pumpkinMask.svg
  var pumpkinMask_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="height: 512px; width: 512px;"><g class="" transform="translate(0,0)" style=""><path d="M256.156 16.875c-48.954 107.457-128.398 80.9-139.312 36.97-57.82 42.426-95.53 110.673-95.53 187.56-.002 128.577 104.928 232.94 234.217 232.94 129.29 0 234.22-104.363 234.22-232.94 0-76.278-37.273-143.847-94.313-186.343-11.27 42.068-78.266 67.493-139.28-38.187zM134.686 134.53c9.528-.102 20.15 2.023 30.5 6.5 25.48 11.024 39.598 32.274 31.5 47.47-8.095 15.196-35.33 18.585-60.81 7.563-25.48-11.023-39.567-32.304-31.47-47.5 4.808-9.023 16.358-13.88 30.28-14.032zm248.97 1.19c14.907-.366 27.44 4.532 32.5 14.03 8.097 15.196-6.02 36.446-31.5 47.47-25.48 11.02-52.684 7.632-60.78-7.564-8.098-15.196 5.988-36.446 31.468-47.47 9.555-4.132 19.368-6.25 28.312-6.467zM151.75 228.562 205 316.719l54.5-77.5 40.438 80.56 65.406-89.936 34.812 69.25 73.375-62.844c-1.208 56.223-38.25 133.637-83.78 165.344l-23.344-68.03-56.125 93.186-56.467-89.656-70.094 83.594-53.25-91.72-17.407 64.344c-46.367-40.18-69.01-99.95-66.907-158.593l54.157 68.186 51.437-74.344z" fill="%23000000" fill-opacity="1"></path></g></svg>';

  // src/assets/game-icons/rearAura.svg
  var rearAura_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="height: 512px; width: 512px;"><g class="" transform="translate(0,0)" style=""><path d="M256 23.545c-33.5 0-63.525 15.197-83.55 39.053L92.7 38.313l60.85 56.867a108.125 108.125 0 0 0-4.905 18.105L18.498 132.592 148.635 151.9a108.074 108.074 0 0 0 4.902 18.118L92.7 226.873l78.898-24.025a91.447 91.447 0 0 1 5.203-7.702 74.948 74.948 0 0 1 7.02-8.027c-11.435-15.14-18.21-34.01-18.21-54.503 0-50.03 40.357-90.39 90.39-90.39 50.03 0 90.39 40.36 90.39 90.39 0 20.494-6.774 39.36-18.208 54.5a74.47 74.47 0 0 1 7.02 8.03 90.44 90.44 0 0 1 5.204 7.703l78.895 24.023-60.837-56.857a108.173 108.173 0 0 0 4.902-18.116l130.137-19.308-130.147-19.307a107.94 107.94 0 0 0-4.906-18.103l60.85-56.87-79.75 24.286C319.52 38.743 289.5 23.545 256 23.545zm.002 45.182c-23.1 0-42.257 23.548-45.89 54.412h36.544v18.686H209.85c1.698 19.243 9.403 35.878 20.408 46.133H219.94c-11.947 2.392-20.787 8.595-28.223 18.446-7.56 10.013-13.304 23.86-17.34 39.875-7.365 29.223-8.98 65.15-9.22 97.33h39.972l10.32 149.056h81.103l10.322-149.057h39.973c-.24-32.18-1.856-68.107-9.22-97.33-4.037-16.014-9.782-29.86-17.34-39.874-7.437-9.85-16.278-16.054-28.226-18.447h-10.316c11.005-10.256 18.71-26.89 20.408-46.134h-36.81V123.14h36.547c-3.633-30.865-22.79-54.413-45.888-54.413z" fill="%23000000" fill-opacity="1"></path></g></svg>';

  // src/assets/game-icons/rollingEnergy.svg
  var rollingEnergy_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="height: 512px; width: 512px;"><g class="" transform="translate(0,0)" style=""><path d="M247.938 22.512c-5.385.044-10.847.333-16.383.88 49.65 15.005 92.127 46.742 123.267 86.678-74.16-71.848-204.8-83.864-278.77 6.287 31.555-16.907 66.822-25.68 102.405-27.865C84.727 118.84 4.497 225.975 21.87 343.362c5.088-48.045 28.862-89.52 61.384-123.923-38.258 74.284-32.22 171.41 40.635 231.185-25.41-47.422-33.08-102.405-25.536-154.338-1.3 105.1 83.482 210.304 201.582 198.656-49.652-15.006-92.126-46.743-123.266-86.68 77.723 65.68 198.16 66.868 278.77-6.288-118.67 44.753-214.692 21.26-272.243-27.8-59.206-40.744-78.126-121.06-41.584-184.353a139.021 139.021 0 0 1 23.967-30.66c2.78-3.18 5.636-6.203 8.598-9.074 2.31-1.3 4.622-2.572 6.935-3.824 24.733-17.675 54.666-26.8 84.914-26.028 22.46.573 45.09 6.594 65.88 18.598 44.02 25.415 68.904 71.378 69.593 118.842a61.63 61.63 0 0 1 .957 10.734c0 33.88-27.466 61.344-61.346 61.344-33.877 0-61.342-27.465-61.342-61.344 0-1.698.083-3.376.218-5.04 5.484 18.857 22.88 32.644 43.504 32.644 25.027 0 45.315-20.29 45.315-45.315 0-24.785-19.903-44.912-44.596-45.298a93.138 93.138 0 0 0-15.167-1.246c-51.192 0-92.69 41.5-92.69 92.69s41.5 92.687 92.69 92.687a96.7 96.7 0 0 0 3.1-.056c-.168.064-.333.132-.5.195a165.74 165.74 0 0 0 12.336-1.03c52.59-.886 123.364-25.954 154.09-71.7-18.303 8.484-35.666 14.587-52.488 16.763a181.554 181.554 0 0 0 17.482-24.133c36.147-44.718 64.673-112.748 53.784-168.2-7.195 19.63-15.35 37.046-25.623 51.583-3.217-46.517-23.284-92.15-63.62-125.244 25.406 47.422 33.076 102.404 25.532 154.337 1.24-100.173-75.723-200.44-185.2-199.535z" fill="%23000000" fill-opacity="1"></path></g></svg>';

  // src/assets/game-icons/spellBook.svg
  var spellBook_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="height: 512px; width: 512px;"><g class="" transform="translate(-12,-44)" style=""><path d="M319.61 20.654c13.145 33.114 13.144 33.115-5.46 63.5 33.114-13.145 33.116-13.146 63.5 5.457-13.145-33.114-13.146-33.113 5.457-63.498-33.114 13.146-33.113 13.145-63.498-5.459zM113.024 38.021c-11.808 21.04-11.808 21.04-35.724 24.217 21.04 11.809 21.04 11.808 24.217 35.725 11.808-21.04 11.808-21.04 35.724-24.217-21.04-11.808-21.04-11.808-24.217-35.725zm76.55 56.184c-.952 50.588-.95 50.588-41.991 80.18 50.587.95 50.588.95 80.18 41.99.95-50.588.95-50.588 41.99-80.18-50.588-.95-50.588-.95-80.18-41.99zm191.177 55.885c-.046 24.127-.048 24.125-19.377 38.564 24.127.047 24.127.046 38.566 19.375.047-24.126.046-24.125 19.375-38.564-24.126-.047-24.125-.046-38.564-19.375zm-184.086 83.88a96.38 96.38 0 0 0-3.492.134c-18.591 1.064-41.868 8.416-77.445 22.556L76.012 433.582c78.487-20.734 132.97-21.909 170.99-4.615V247.71c-18.076-8.813-31.79-13.399-46.707-13.737a91.166 91.166 0 0 0-3.629-.002zm122.686 11.42a209.3 209.3 0 0 0-8.514.098c-12.81.417-27.638 2.215-45.84 4.522v177.135c43.565-7.825 106.85-4.2 171.244 7.566l-39.78-177.197c-35.904-8.37-56.589-11.91-77.11-12.123zm2.289 16.95c18.889.204 36.852 2.768 53.707 5.02l4.437 16.523c-23.78-3.75-65.966-4.906-92.467-.98l-.636-17.805c11.959-2.154 23.625-2.88 34.959-2.758zm-250.483 4.658L60.54 313.002h24.094l10.326-46.004H71.158zm345.881 0 39.742 177.031 2.239 9.973 22.591-.152-40.855-186.852h-23.717zm-78.857 57.82c16.993.026 33.67.791 49.146 2.223l3.524 17.174c-32.645-3.08-72.58-2.889-102.995 0l-.709-17.174c16.733-1.533 34.04-2.248 51.034-2.223zm-281.793 6.18-6.924 30.004h24.394l6.735-30.004H56.389zm274.418 27.244c4.656.021 9.487.085 14.716.203l2.555 17.498c-19.97-.471-47.115.56-59.728 1.05l-.7-17.985c16.803-.493 29.189-.828 43.157-.766zm41.476.447c8.268.042 16.697.334 24.121.069l2.58 17.74c-8.653-.312-24.87-.83-32.064-.502l-2.807-17.234a257.25 257.25 0 0 1 8.17-.073zm-326.97 20.309-17.985 77.928 25.035-.17 17.455-77.758H45.313zm303.164 11.848c19.608-.01 38.66.774 56.449 2.572l2.996 20.787c-34.305-4.244-85.755-7.697-119.1-3.244l-.14-17.922c20.02-1.379 40.186-2.183 59.795-2.193zm-166.606 44.05c-30.112.09-67.916 6.25-115.408 19.76l-7.22 2.053 187.759-1.27v-6.347c-16.236-9.206-37.42-14.278-65.13-14.196zm134.41 6.174c-19.63.067-37.112 1.439-51.283 4.182v10.064l177.594-1.203c-44.322-8.634-89.137-13.17-126.31-13.043zM26 475v18h460v-18H26z" fill="%23000000" fill-opacity="1"></path></g></svg>';

  // src/assets/game-icons/wolfTrap.svg
  var wolfTrap_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="height: 512px; width: 512px;"><g class="" transform="translate(0,0)" style=""><path d="m106 113.773-32.963 74.375a99.166 99.166 0 0 0-3.12.704c-5.293 1.296-9.95 2.918-14.044 4.79l-8.266-53.435-25.037 87.277a108.288 108.288 0 0 0-3.338 11.635l-.26.905.07-.04c-3.632 16.665-3.56 35.726 3.597 55.818 3.306 14.022 15.515 30.355 40.24 48.135 29.193 20.992 75.05 42.954 138.495 63.86a39.272 39.272 0 0 1-.393-5.486c0-12.21 5.637-23.185 14.432-30.447l-4.07-42.73-31.54 37.69a620.827 620.827 0 0 1-27.896-11.3l-2.95-78.177-33.57 60.615c-9.068-4.85-17.496-9.773-25.294-14.75l-4.627-90.04-28.932 65.057c-7.485-6.607-13.957-13.243-19.45-19.86-4.244-20.016-.412-38.063 6.145-52.42l4.483-2.602c15.852-5.496 35.514-7.645 58.504-6.182 32.732 2.084 72.51 11.748 118.152 30.803.098-13.092 7.704-24.51 18.692-30.142l-5.597-52.59-30.14 42.78c-9.68-3.6-19.025-6.73-28.012-9.41l-4.26-68.73-32.567 59.774c-11.784-2.163-22.712-3.436-32.716-3.91l-3.77-71.97zm323.08 29.936-15.973 70.28c-9.928-1.244-20.884-1.876-32.837-1.777l-19.58-66.443-18.075 68.964c-9.342 1.12-19.127 2.635-29.316 4.55l-19.015-44.84-16.422 45.742c8.9 6.183 14.768 16.47 14.768 28.04 0 2.407-.257 4.758-.74 7.03 47.224-10.57 87.28-13.166 119.37-9.7 22.9 2.47 41.908 7.938 56.592 16.05l3.978 3.332c4.016 15.265 4.72 33.704-2.873 52.707-6.54 5.582-14.047 11.016-22.547 16.25l-17.43-69.034-19.89 87.94c-8.51 3.565-17.626 6.972-27.356 10.198l-19.724-61.576-19.274 72.674a622.45 622.45 0 0 1-29.326 6.37l-22.605-45.43-14.87 49.995a39.091 39.091 0 0 1 4.02 17.283 39.03 39.03 0 0 1-3.476 16.107c70.416-9.85 122.176-24.18 155.893-40.565 27.394-13.31 42.205-27.326 47.852-40.582 10.472-18.58 13.79-37.348 13.048-54.388l.063.053-.102-.942a107.887 107.887 0 0 0-1.308-12.035l-9.81-90.26-17.243 51.245c-3.714-2.54-8.03-4.93-13.023-7.11-.96-.417-1.95-.822-2.954-1.222L429.08 143.71zm-170.584 89.07c-8.642 0-15.443 6.802-15.443 15.445 0 3.53 1.15 6.74 3.084 9.318a161.247 161.247 0 0 1 23.101 1.844c2.91-2.793 4.705-6.733 4.705-11.162 0-8.64-6.806-15.446-15.447-15.446zm-12.652 43.468c-1.02-.003-2.032.005-3.033.025-12.016.244-22.59 2.134-30.23 4.98-5.094 1.9-8.82 4.23-10.85 6.22-2.03 1.99-2.375 3.155-2.375 4.37 0 2.426 3.81 8.437 14.258 13.844 10.448 5.408 25.905 9.714 42.992 10.954 17.088 1.24 32.486-.854 42.674-4.65 5.093-1.898 8.82-4.23 10.85-6.22 2.03-1.987 2.374-3.154 2.374-4.368 0-2.43-3.81-8.44-14.258-13.847-10.447-5.408-25.904-9.712-42.992-10.95a134.712 134.712 0 0 0-9.41-.357zm-5.688 57.215-2.96 29.51c1.08-.09 2.17-.15 3.273-.15 5.382 0 10.524 1.1 15.214 3.077l3.05-30.406a159.916 159.916 0 0 1-18.578-2.032zm.313 48.05c-11.6 0-20.798 9.2-20.798 20.8 0 11.595 9.2 20.796 20.797 20.796 11.594 0 20.798-9.203 20.798-20.798 0-11.595-9.202-20.798-20.8-20.798z" fill="%23000000" fill-opacity="1"></path></g></svg>';

  // src/dto/animaFurtaMessageDto.ts
  function ValidateCustom(validator, validationOptions) {
    return (object, propertyName) => {
      registerDecorator({
        name: "validateCustom",
        target: object.constructor,
        propertyName,
        options: validationOptions,
        validator: {
          validate(value, args) {
            return validator(args.object);
          },
          defaultMessage(args) {
            return "Params error";
          }
        }
      });
    };
  }
  var PosDto = class {
    x;
    y;
  };
  __decorateClass([
    IsNumber()
  ], PosDto.prototype, "x", 2);
  __decorateClass([
    IsNumber()
  ], PosDto.prototype, "y", 2);
  var AnimaFurtaMessageDto = class {
    name;
    target;
    appearance;
    params;
    message;
    pos;
  };
  __decorateClass([
    IsString(),
    IsIn(["toggleKneel", "changeAppearance", "publishAction", "sendMessage", "mapMove"])
  ], AnimaFurtaMessageDto.prototype, "name", 2);
  __decorateClass([
    IsNumber(),
    ValidateIf((o5) => o5.name === "changeAppearance")
  ], AnimaFurtaMessageDto.prototype, "target", 2);
  __decorateClass([
    ValidateIf((o5) => o5.name === "changeAppearance")
  ], AnimaFurtaMessageDto.prototype, "appearance", 2);
  __decorateClass([
    ValidateIf((o5) => o5.name === "publishAction")
  ], AnimaFurtaMessageDto.prototype, "params", 2);
  __decorateClass([
    ValidateIf((o5) => o5.name === "sendMessage"),
    IsString(),
    ValidateCustom((o5) => !o5.message.startsWith("("))
  ], AnimaFurtaMessageDto.prototype, "message", 2);
  __decorateClass([
    ValidateIf((o5) => o5.name === "mapMove"),
    ValidateNested(),
    Type(() => PosDto)
  ], AnimaFurtaMessageDto.prototype, "pos", 2);

  // src/spell-effects/animaFurtaEffect.ts
  var AnimaFurtaEffect = class extends BaseEffect {
    removePacketListener;
    get isInstant() {
      return false;
    }
    get selfCastAllowed() {
      return false;
    }
    get name() {
      return "Anima Furta";
    }
    get atoms() {
      return [1001 /* IGNIS */, 1e3 /* NOX */, 1005 /* MOTUS */, 1002 /* RATIO */];
    }
    get description() {
      return "Lets you control target. (Chat, activities, poses, wardrobe, map moving)";
    }
    getControllableCharacter() {
      return ChatRoomCharacter.find((c7) => {
        return c7.BCC && this.isActiveOn(c7) && this.getSpellsWithEffect(c7)[0].castedBy.id === Player.MemberNumber;
      });
    }
    canCast(_sourceCharacter, targetCharacter) {
      if (this.isActiveOn(targetCharacter)) return { result: false, reason: "CANT_CAST_AT_THIS_MOMENT" /* CANT_CAST_AT_THIS_MOMENT */ };
      return { result: true };
    }
    trigger(event) {
      super.trigger(event);
      if (event.init) {
        this.hookFunction(event, "ChatRoomLeave", d.OBSERVE, (args, next) => {
          this.remove({
            sourceCharacter: event.sourceCharacter,
            sourceSpellName: null,
            targetSpellName: event.spellName
          });
          return next(args);
        });
        this.hookFunction(event, "ChatRoomSyncMemberLeave", d.OBSERVE, (args, next) => {
          const data = args[0];
          if (data.SourceMemberNumber === event.sourceCharacter?.MemberNumber) {
            this.remove({
              sourceCharacter: event.sourceCharacter,
              sourceSpellName: null,
              targetSpellName: event.spellName
            });
          }
          return next(args);
        });
        this.hookFunction(event, "ChatRoomSendChat", d.OVERRIDE_BEHAVIOR, () => {
          return g2.sendLocal("You lost control of yourself");
        });
        this.hookFunction(event, "Player.CanWalk", d.OVERRIDE_BEHAVIOR, () => false);
        this.hookFunction(event, "Player.CanChangeToPose", d.OVERRIDE_BEHAVIOR, () => false);
        this.hookFunction(event, "Player.CanChangeOwnClothes", d.OVERRIDE_BEHAVIOR, () => false);
        this.hookFunction(event, "PoseCanChangeUnaidedStatus", d.OVERRIDE_BEHAVIOR, () => PoseChangeStatus.NEVER);
        this.hookFunction(event, "ChatRoomCanAttemptStand", d.OVERRIDE_BEHAVIOR, () => false);
        this.hookFunction(event, "ChatRoomCanAttemptKneel", d.OVERRIDE_BEHAVIOR, () => false);
        this.hookFunction(event, "Player.CanInteract", d.OVERRIDE_BEHAVIOR, () => false);
        this.hookFunction(event, "InventoryGroupIsBlockedForCharacter", d.OVERRIDE_BEHAVIOR, () => true);
        this.hookFunction(event, "DialogClickExpressionMenu", d.OVERRIDE_BEHAVIOR, () => false);
        this.hookFunction(event, "ChatRoomMapViewMove", d.OVERRIDE_BEHAVIOR, () => false);
        this.removePacketListener = g2.onPacket("animaFurtaCommand", AnimaFurtaMessageDto, (data, sender) => {
          if (!sender.BCC) return;
          if (!getSpellEffect(1e3 /* ANIMA_FURTA */).isActive) return;
          if (data.name === "toggleKneel") {
            const Dictionary = new DictionaryBuilder().sourceCharacter(Player).build();
            ServerSend("ChatRoomChat", { Content: Player.IsKneeling() ? "StandUp" : "KneelDown", Type: "Action", Dictionary });
            PoseSetActive(Player, Player.IsKneeling() ? "BaseLower" : "Kneel");
            ChatRoomStimulationMessage("Kneel");
            ServerSend("ChatRoomCharacterPoseUpdate", { Pose: Player.ActivePose });
          }
          if (data.name === "changeAppearance") {
            ServerAppearanceLoadFromBundle(
              N2(data.target),
              N2(data.target).AssetFamily,
              data.appearance,
              data.target
            );
            ChatRoomCharacterUpdate(N2(data.target));
          }
          if (data.name === "publishAction") {
            ServerSend("ChatRoomChat", data.params);
          }
          if (data.name === "sendMessage") {
            g2.sendChat(data.message);
          }
          if (data.name === "mapMove") {
            if (!Player.MapData) Player.MapData = {};
            Player.MapData.Pos = {
              X: data.pos.x,
              Y: data.pos.y
            };
            ChatRoomMapViewMovement = {
              X: data.pos.x,
              Y: data.pos.y,
              Direction: "East",
              TimeStart: CommonTime(),
              TimeEnd: CommonTime()
            };
          }
        });
      } else {
        this.remove({
          sourceCharacter: event.sourceCharacter,
          sourceSpellName: null,
          targetSpellName: event.spellName
        }, false);
      }
    }
    remove(event, push) {
      super.remove(event, push);
      this.removePacketListener?.();
    }
  };

  // src/spell-effects/masqueradaEffect.ts
  var MasqueradaEffect = class extends BaseEffect {
    get isInstant() {
      return false;
    }
    get name() {
      return "Masquerada";
    }
    get atoms() {
      return [1006 /* MATERIA */];
    }
    get description() {
      return "Changes target's appearance.";
    }
    get parameters() {
      return [
        {
          name: "outfit",
          type: "text",
          label: "Outfit Code"
        }
      ];
    }
    trigger(event) {
      super.trigger(event);
      if (!event.init) return;
      const lastOutfit = LZString.compressToBase64(JSON.stringify(ServerAppearanceBundle(Player.Appearance)));
      this.setParameter("lastOutfit", lastOutfit, event.spellName);
      ServerAppearanceLoadFromBundle(Player, Player.AssetFamily, JSON.parse(LZString.decompressFromBase64(event.data.outfit)), event.sourceCharacter.MemberNumber);
      ChatRoomCharacterUpdate(Player);
      this.setParameter("outfit", void 0, event.spellName);
    }
    remove(event, push = true) {
      const lastOutfit = this.getParameter("lastOutfit", Player);
      super.remove(event, push);
      ServerAppearanceLoadFromBundle(Player, Player.AssetFamily, JSON.parse(LZString.decompressFromBase64(lastOutfit)), Player.MemberNumber);
      ChatRoomCharacterUpdate(Player);
    }
  };

  // src/spell-effects/nomenFraudisEffect.ts
  var NomenFraudisEffect = class extends BaseEffect {
    get isInstant() {
      return false;
    }
    get name() {
      return "Nomen Fraudis";
    }
    get atoms() {
      return [1002 /* RATIO */];
    }
    get icon() {
      return null;
    }
    get description() {
      return "Causes the target to hallucinate with charaters names. They will be swapped.";
    }
    trigger(event) {
      super.trigger(event);
      this.hookFunction(event, "ChatRoomMessage", d.OVERRIDE_BEHAVIOR, (args, next) => {
        const message = args[0];
        const sender = N2(message.Sender);
        if (!sender) return next(args);
        if (!sender.IsPlayer() && message.Type === "Chat") {
          const randomPlayer = ChatRoomCharacter[y2(0, ChatRoomCharacter.length - 1)];
          message.Sender = randomPlayer.MemberNumber;
        }
        return next(args);
      });
    }
  };

  // src/spell-effects/spatiumTransitusEffect.ts
  var SpatiumTransitusEffect = class extends BaseEffect {
    get name() {
      return "Spatium Transitus";
    }
    get atoms() {
      return [1e3 /* NOX */, 1005 /* MOTUS */];
    }
    get icon() {
      return null;
    }
    get description() {
      return "Teleports target in the specified chat room. If the chat room does not exist then target creates it.";
    }
    get parameters() {
      return [
        {
          name: "lobby",
          type: "choice",
          label: "Lobby",
          options: [
            {
              name: "extended",
              text: "Extended (Recommened)"
            },
            {
              name: "classic",
              text: "Classic"
            }
          ]
        },
        {
          name: "isPrivate",
          type: "boolean",
          label: "Is Private"
        },
        {
          name: "roomName",
          type: "text",
          label: "Room Name"
        }
      ];
    }
    trigger(event) {
      super.trigger(event);
      const roomName = event.data.roomName.trim();
      const isPrivate = event.data.isPrivate;
      const space = event.data.lobby;
      ChatRoomLeave();
      CommonSetScreen("Online", "ChatSearch");
      ChatSearchLastQueryJoinTime = CommonTime();
      ChatSearchLastQueryJoin = roomName;
      ServerSend("ChatRoomJoin", { Name: roomName });
      ChatRoomPingLeashedPlayers();
      ServerSocket.once("ChatRoomSearchResponse", (data) => {
        if (["CannotFindRoom", "RoomFull"].includes(data)) {
          ServerAccountUpdate.QueueData({ RoomCreateLanguage: "EN" });
          const newRoom = {
            Name: roomName,
            Language: "EN",
            Description: "",
            Background: "Introduction",
            Private: isPrivate,
            Locked: false,
            Space: space === "extended" ? "X" : "",
            Game: "",
            Admin: "",
            Whitelist: "",
            Ban: "",
            Limit: 10,
            BlockCategory: ""
          };
          ServerSend("ChatRoomCreate", newRoom);
          ServerSocket.once("ChatRoomCreateResponse", (data2) => {
            if (data2 === "ChatRoomCreated") {
              ChatRoomPingLeashedPlayers();
            }
          });
        }
      });
    }
  };

  // src/spell-effects/visioInversioEffect.ts
  var VisioInversioEffect = class extends BaseEffect {
    get isInstant() {
      return false;
    }
    get name() {
      return "Visio Inversio";
    }
    get atoms() {
      return [1002 /* RATIO */, 1006 /* MATERIA */];
    }
    get description() {
      return "Flips target's screen.";
    }
    trigger(event) {
      super.trigger(event);
      document.body.setAttribute("style", document.body.getAttribute("style") + "rotate:180deg;");
    }
    remove(event) {
      super.remove(event);
      document.body.setAttribute("style", document.body.getAttribute("style").replace("rotate:180deg;", ""));
    }
  };

  // src/spell-effects/vocisPrivatioEffect.ts
  var VocisPrivatioEffect = class extends BaseEffect {
    get isInstant() {
      return false;
    }
    get name() {
      return "Vocis Privatio";
    }
    get atoms() {
      return [1002 /* RATIO */];
    }
    get description() {
      return "Takes away the target's voice. The target will lose the ability to send messages except chat commands and OOC.";
    }
    trigger(event) {
      super.trigger(event);
      this.hookFunction(event, "ServerSend", d.OVERRIDE_BEHAVIOR, (args, next) => {
        const message = args[0];
        const params = args[1];
        if (message === "ChatRoomChat" && ["Chat", "Whisper"].includes(params.Type)) {
          if (params.Content[0] !== "(") {
            return g2.sendAction(`${O2(Player)} tries to say something, but <pronoun> doesn't have a voice`);
          }
        }
        return next(args);
      });
    }
  };

  // src/spell-effects/traditioArtiumEffect.ts
  var TraditioArtiumEffect = class extends BaseEffect {
    get name() {
      return "Traditio Artium";
    }
    get atoms() {
      return [1003 /* LUX */];
    }
    get description() {
      return "Establishes connection with target, letting you share your magical arts";
    }
    async trigger(event) {
      super.trigger(event);
      const spells = event.sourceCharacter?.BCC?.darkMagic?.spells;
      if (!spells) return;
      const result = await ee2.showDialog({
        type: "choice_multiple",
        title: "Choose spells",
        body: "",
        width: 600,
        buttons: {
          direction: "column",
          list: spells.map((s5) => ({ text: s5.name, value: s5 }))
        }
      });
      modStorage.darkMagic ??= {};
      modStorage.darkMagic.spells ??= [];
      modStorage.darkMagic.spells.push(...result);
      Q2.success({
        message: `Learned spells: ${result.map((s5) => s5.name).join(", ")}`,
        duration: 5e3
      });
      syncStorage();
    }
  };

  // src/spell-effects/flammaSubmissionisEffect.ts
  var FlammaSubmissionisEffect = class extends BaseEffect {
    get name() {
      return "Flamma Submissionis";
    }
    get atoms() {
      return [1001 /* IGNIS */];
    }
    get description() {
      return "Launches a fireball at the target";
    }
    trigger(event) {
      super.trigger(event);
      DialogChangeReputation("Dominant", y2(-5, -1));
      ServerPlayerReputationSync();
    }
  };

  // src/spell-effects/acceleratioVoluptatisEffect.ts
  var AcceleratioVoluptatisEffect = class extends BaseEffect {
    get isInstant() {
      return false;
    }
    get name() {
      return "Acceleratio Voluptatis";
    }
    get atoms() {
      return [1004 /* GEMITUM */, 1003 /* LUX */];
    }
    get description() {
      return "Makes target horny";
    }
    trigger(event) {
      super.trigger(event);
      this.setInterval(event, () => {
        if (y2(1, 2) === 1) {
          if (typeof Player.ArousalSettings.Progress !== "number") Player.ArousalSettings.Progress = 0;
          if (Player.ArousalSettings.Progress >= 100) return;
          Player.ArousalSettings.Progress += y2(1, 4);
        }
      }, 2e3);
    }
  };

  // src/modules/darkMagic.ts
  var showAnimaFurtaWaitingButton = false;
  var MAGIC_ITEMS = ["RainbowWand", "Broom", "AnimeGirlWand", "Baguette"];
  var MinimumRole = /* @__PURE__ */ ((MinimumRole2) => {
    MinimumRole2[MinimumRole2["EVERYONE"] = 0] = "EVERYONE";
    MinimumRole2[MinimumRole2["FRIEND"] = 1] = "FRIEND";
    MinimumRole2[MinimumRole2["WHITELIST"] = 2] = "WHITELIST";
    MinimumRole2[MinimumRole2["LOVER"] = 3] = "LOVER";
    MinimumRole2[MinimumRole2["OWNER"] = 4] = "OWNER";
    return MinimumRole2;
  })(MinimumRole || {});
  var atoms = {
    [1e3 /* NOX */]: {
      name: "Nox",
      iconDataUrl: nox_default,
      iconColor: "black",
      description: "Used in the most powerful and dangerous spells, which is why by default all these spells are limited in settings"
    },
    [1001 /* IGNIS */]: {
      name: "Ignis",
      iconDataUrl: ignis_default,
      iconColor: "orange",
      description: "Used in spells for attack, self-defense, and so on"
    },
    [1002 /* RATIO */]: {
      name: "Ratio",
      iconDataUrl: ratio_default,
      iconColor: "#ffd1d1",
      description: "Used in spells which change the behavior of the character and encourage the performance of any actions"
    },
    [1003 /* LUX */]: {
      name: "Lux",
      iconDataUrl: lux_default,
      iconColor: "yellow",
      description: "Used in neutral safe spells, such as power-ups"
    },
    [1004 /* GEMITUM */]: {
      name: "Gemitum",
      iconDataUrl: gemitum_default,
      iconColor: "red",
      description: "Used in spells which affect emotions, feelings and control arousal"
    },
    [1005 /* MOTUS */]: {
      name: "Motus",
      iconDataUrl: motus_default,
      iconColor: "#d4d0ff",
      description: "Used in spells which move character or make it move"
    },
    [1006 /* MATERIA */]: {
      name: "Materia",
      iconDataUrl: materia_default,
      iconColor: "#8f59fbff",
      description: "Used in spells that change materia, that is, the space around you"
    }
  };
  var spellEffects = {
    [1e3 /* ANIMA_FURTA */]: new AnimaFurtaEffect(),
    [1001 /* MASQUERADA */]: new MasqueradaEffect(),
    [1002 /* NOMEN_FRAUDIS */]: new NomenFraudisEffect(),
    [1003 /* PURIFICATIO */]: new PurificatioEffect(),
    [1004 /* SLUMBER_CURSE */]: new SlumberCurseEffect(),
    [1005 /* SPATIUM_TRANSITUS */]: new SpatiumTransitusEffect(),
    [1006 /* VISIO_INVERSION */]: new VisioInversioEffect(),
    [1007 /* VOCIS_ALTERATIO */]: new VocisAlteratioEffect(),
    [1008 /* VOCIS_PRIVATIO */]: new VocisPrivatioEffect(),
    [1009 /* TRADITIO_ARTIUM */]: new TraditioArtiumEffect(),
    [1010 /* FLAMMA_SUBMISSIONIS */]: new FlammaSubmissionisEffect(),
    [1011 /* ACCELERATIO_VOLUPTATIS */]: new AcceleratioVoluptatisEffect()
  };
  var SpellIcon = /* @__PURE__ */ ((SpellIcon2) => {
    SpellIcon2["BEAMS_AURA"] = "BeamsAura";
    SpellIcon2["CAULDRON"] = "Cauldron";
    SpellIcon2["DEATH_JUICE"] = "DeathJuice";
    SpellIcon2["DICE_FIRE"] = "DiceFire";
    SpellIcon2["DOOR"] = "Door";
    SpellIcon2["EVIL_BOOK"] = "EvilBook";
    SpellIcon2["HANDCUFFS"] = "Handcuffs";
    SpellIcon2["HANGING_SPIDER"] = "HangingSpider";
    SpellIcon2["HAUNTING"] = "Haunting";
    SpellIcon2["HEARTS"] = "Hearts";
    SpellIcon2["ICE_BOLT"] = "IceBolt";
    SpellIcon2["LOVE_INJECTION"] = "LoveInjection";
    SpellIcon2["MAGIC_PORTAL"] = "MagicPortal";
    SpellIcon2["MAGIC_SWIRL"] = "MagicSwirl";
    SpellIcon2["MOUTH_WATERING"] = "MouthWatering";
    SpellIcon2["PAW_PRINT"] = "PawPrint";
    SpellIcon2["PLASTIC_DUCK"] = "PlasticDuck";
    SpellIcon2["PUMPKIN_MASK"] = "PumpkinMask";
    SpellIcon2["REAR_AURA"] = "RearAura";
    SpellIcon2["ROLLING_ENERGY"] = "RollingEnergy";
    SpellIcon2["SPELL_BOOK"] = "SpellBool";
    SpellIcon2["WOLF_TRAP"] = "WolfTrap";
    return SpellIcon2;
  })(SpellIcon || {});
  var spellIcons = [
    {
      name: "BeamsAura" /* BEAMS_AURA */,
      dataurl: beamsAura_default
    },
    {
      name: "Cauldron" /* CAULDRON */,
      dataurl: cauldron_default
    },
    {
      name: "DeathJuice" /* DEATH_JUICE */,
      dataurl: deathJuice_default
    },
    {
      name: "DiceFire" /* DICE_FIRE */,
      dataurl: diceFire_default
    },
    {
      name: "Door" /* DOOR */,
      dataurl: door_default
    },
    {
      name: "EvilBook" /* EVIL_BOOK */,
      dataurl: evilBook_default
    },
    {
      name: "Handcuffs" /* HANDCUFFS */,
      dataurl: handcuffs_default
    },
    {
      name: "HangingSpider" /* HANGING_SPIDER */,
      dataurl: hangingSpider_default
    },
    {
      name: "Haunting" /* HAUNTING */,
      dataurl: haunting_default
    },
    {
      name: "Hearts" /* HEARTS */,
      dataurl: hearts_default
    },
    {
      name: "IceBolt" /* ICE_BOLT */,
      dataurl: iceBolt_default
    },
    {
      name: "LoveInjection" /* LOVE_INJECTION */,
      dataurl: loveInjection_default
    },
    {
      name: "MagicPortal" /* MAGIC_PORTAL */,
      dataurl: magicPortal_default
    },
    {
      name: "MagicSwirl" /* MAGIC_SWIRL */,
      dataurl: magicSwirl_default
    },
    {
      name: "MouthWatering" /* MOUTH_WATERING */,
      dataurl: mouthWatering_default
    },
    {
      name: "PawPrint" /* PAW_PRINT */,
      dataurl: pawPrint_default
    },
    {
      name: "PlasticDuck" /* PLASTIC_DUCK */,
      dataurl: plasticDuck_default
    },
    {
      name: "PumpkinMask" /* PUMPKIN_MASK */,
      dataurl: pumpkinMask_default
    },
    {
      name: "RearAura" /* REAR_AURA */,
      dataurl: rearAura_default
    },
    {
      name: "RollingEnergy" /* ROLLING_ENERGY */,
      dataurl: rollingEnergy_default
    },
    {
      name: "SpellBool" /* SPELL_BOOK */,
      dataurl: spellBook_default
    },
    {
      name: "WolfTrap" /* WOLF_TRAP */,
      dataurl: wolfTrap_default
    }
  ];
  function getSpellIcon(name) {
    return spellIcons.find((s5) => s5.name === name);
  }
  function getSpellIcons() {
    return spellIcons;
  }
  function getSpellEffect(effectId) {
    return spellEffects[effectId];
  }
  function getSpellEffects() {
    return spellEffects;
  }
  function isMagicItem(item) {
    if (!item) return false;
    return MAGIC_ITEMS.includes(item?.Asset?.Name);
  }
  function allowSpellCast(sourceCharacter, targetCharacter, spell) {
    if (!ServerChatRoomGetAllowItem(sourceCharacter, targetCharacter)) {
      return {
        result: false,
        reason: "INTERACTIONS_NOT_ALLOWED" /* INTERACTIONS_NOT_ALLOWED */
      };
    }
    if (!sourceCharacter.IsPlayer() && !sourceCharacter.BCC || !targetCharacter.IsPlayer() && !targetCharacter.BCC) return { result: false, reason: "NOT_BCC_PLAYER" /* NOT_BCC_PLAYER */ };
    if (spell.effects.length === 0) return { result: false, reason: "NO_EFFECTS" /* NO_EFFECTS */ };
    const storage = targetCharacter.IsPlayer() ? modStorage : targetCharacter.BCC;
    if ((storage.darkMagic?.state?.spells ?? []).length >= 10 && !isSpellInstant(spell)) {
      return {
        result: false,
        reason: "SPELLS_COUNT_LIMIT" /* SPELLS_COUNT_LIMIT */
      };
    }
    for (const effectChar of spell.effects.split("")) {
      const effect = getSpellEffect(effectChar.charCodeAt(0));
      const canCast = effect.canCast(sourceCharacter, targetCharacter);
      if (canCast.result === false) {
        return canCast;
      }
    }
    return { result: true };
  }
  function isSpellInstant(spell) {
    return spell.effects.split("").every((c7) => spellEffects[c7.charCodeAt(0)].isInstant);
  }
  function generateSpellName(name, attempt = 1) {
    let search;
    if (attempt === 1) search = name;
    else search = `${name} (${attempt - 1})`;
    if (modStorage.darkMagic?.state?.spells.find((s5) => s5.name === search)) {
      return generateSpellName(name, attempt + 1);
    }
    return search;
  }
  function addDefaultParametersIfNeeds(spell) {
    spell.data ??= {};
    for (const effectChar of spell.effects.split("")) {
      spell.data[effectChar] ??= {};
      const effect = getSpellEffect(effectChar.charCodeAt(0));
      for (const parameter of effect.parameters) {
        if (parameter.type === "boolean") spell.data[effectChar][parameter.name] ??= false;
        if (parameter.type === "choice") spell.data[effectChar][parameter.name] ??= parameter.options[0].name;
      }
    }
  }
  function processSpell(castedBy, spell) {
    spell = JSON.parse(JSON.stringify(spell));
    spell.name = generateSpellName(spell.name.trim());
    addDefaultParametersIfNeeds(spell);
    if (!isSpellInstant(spell)) {
      modStorage.darkMagic ??= {};
      modStorage.darkMagic.state ??= {};
      modStorage.darkMagic.state.spells ??= [];
      modStorage.darkMagic.state.spells.push({
        name: spell.name,
        icon: spell.icon,
        effects: spell.effects.split("").filter((c7) => !spellEffects[c7.charCodeAt(0)].isInstant).join(""),
        data: JSON.parse(JSON.stringify(spell.data ?? {})),
        createdBy: spell.createdBy,
        castedBy: {
          name: O2(castedBy),
          id: castedBy.MemberNumber
        }
      });
    }
    for (const c7 of spell.effects) {
      const effect = spellEffects[c7.charCodeAt(0)];
      effect.trigger({
        sourceCharacter: castedBy,
        data: JSON.parse(JSON.stringify(spell.data?.[c7] ?? {})),
        spellName: spell.name,
        init: true
      });
    }
    syncStorage();
    g2.sendAction(`Effects of "${spell.name}" spell was applied to ${O2(Player)}`);
  }
  function castSpell(target, spell) {
    g2.sendAction(`${O2(Player)} casts "${spell.name}" spell on ${O2(target)}`);
    if (target.IsPlayer()) {
      processSpell(target, spell);
    } else {
      g2.sendPacket("castSpell", { spell }, target.MemberNumber);
    }
  }
  async function loadDarkMagic() {
    for (const spell of modStorage.darkMagic?.state?.spells ?? []) {
      for (const c7 of spell.effects) {
        const effect = spellEffects[c7.charCodeAt(0)];
        effect.trigger({
          sourceCharacter: void 0,
          data: spell.data?.[c7],
          spellName: spell.name,
          init: false
        });
      }
    }
    g2.onPacket("castSpell", CastSpellMessageDto, (data, sender) => {
      const allow = allowSpellCast(sender, Player, data.spell);
      if (allow.result === false) return;
      processSpell(sender, data.spell);
    });
    c3("ChatRoomToggleKneel", d.OVERRIDE_BEHAVIOR, (args, next) => {
      const controllableCharacter = getSpellEffect(1e3 /* ANIMA_FURTA */).getControllableCharacter();
      if (!controllableCharacter) return next(args);
      if (controllableCharacter.CanChangeToPose(controllableCharacter.IsKneeling() ? "BaseLower" : "Kneel")) {
        PoseSetActive(
          controllableCharacter,
          controllableCharacter.IsKneeling() ? "BaseLower" : "Kneel"
        );
        return g2.sendPacket("animaFurtaCommand", {
          name: "toggleKneel"
        }, controllableCharacter.MemberNumber);
      }
      return next(args);
    });
    c3("ChatRoomSendChat", d.OVERRIDE_BEHAVIOR, (args, next) => {
      const controllableCharacter = getSpellEffect(1e3 /* ANIMA_FURTA */).getControllableCharacter();
      if (!controllableCharacter) return next(args);
      g2.sendPacket("animaFurtaCommand", {
        name: "sendMessage",
        message: document.getElementById("InputChat").value
      }, controllableCharacter.MemberNumber);
      document.getElementById("InputChat").value = "";
    });
    c3("ChatRoomAllowItem", d.OVERRIDE_BEHAVIOR, (args, next) => {
      const controllableCharacter = getSpellEffect(1e3 /* ANIMA_FURTA */).getControllableCharacter();
      if (!controllableCharacter) return next(args);
      const data = args[0];
      if (typeof data === "object" && typeof data.MemberNumber === "number" && typeof data.AllowItem === "boolean") {
        if (CurrentCharacter != null && CurrentCharacter.MemberNumber === data.MemberNumber) {
          data.AllowItem = ServerChatRoomGetAllowItem(controllableCharacter, CurrentCharacter);
          CurrentCharacter.AllowItem = data.AllowItem;
          CharacterSetCurrent(CurrentCharacter);
        }
      }
    });
    c3("DialogCanUnlock", d.OBSERVE, (args, next) => {
      const controllableCharacter = getSpellEffect(1e3 /* ANIMA_FURTA */).getControllableCharacter();
      if (!controllableCharacter) return next(args);
      const [target, item] = args;
      const lock = InventoryGetLock(item);
      if (!controllableCharacter.CanInteract()) return false;
      if (lock.Asset.Name === "ExclusivePadlock") return controllableCharacter.MemberNumber !== target.MemberNumber;
      if (lock.Asset.ExclusiveUnlock) {
        const allowedMembers = CommonConvertStringToArray(item.Property.MemberNumberListKeys);
        if (item.Property.MemberNumberListKeys != null) return allowedMembers.includes(controllableCharacter.MemberNumber);
        if (item.Property.LockMemberNumber === controllableCharacter.MemberNumber) return true;
      }
      if (lock.Asset.OwnerOnly && target.IsOwnedByMemberNumber(controllableCharacter.MemberNumber)) return true;
      if (lock.Asset.LoverOnly && target.IsLoverOfMemberNumber(controllableCharacter.MemberNumber)) return true;
      if (lock.Asset.FamilyOnly && target.IsInFamilyOfMemberNumber(controllableCharacter.MemberNumber)) return true;
      return false;
    });
    c3("InventoryLock", d.OVERRIDE_BEHAVIOR, (args, next) => {
      const controllableCharacter = getSpellEffect(1e3 /* ANIMA_FURTA */).getControllableCharacter();
      if (!controllableCharacter) return next(args);
      args[3] = controllableCharacter.MemberNumber;
      return next(args);
    });
    c3("Player.CanChangeOwnClothes", d.OVERRIDE_BEHAVIOR, (args, next) => {
      if (getSpellEffect(1e3 /* ANIMA_FURTA */).getControllableCharacter()) return false;
      return next(args);
    });
    c3("Player.IsDeaf", d.OVERRIDE_BEHAVIOR, (args, next) => {
      const controllableCharacter = getSpellEffect(1e3 /* ANIMA_FURTA */).getControllableCharacter();
      if (controllableCharacter) {
        return controllableCharacter.IsDeaf();
      }
      return next(args);
    });
    c3("Player.IsBlind", d.OVERRIDE_BEHAVIOR, (args, next) => {
      const controllableCharacter = getSpellEffect(1e3 /* ANIMA_FURTA */).getControllableCharacter();
      if (controllableCharacter) return controllableCharacter.IsBlind();
      return next(args);
    });
    c3("Player.GetDeafLevel", d.OVERRIDE_BEHAVIOR, (args, next) => {
      const controllableCharacter = getSpellEffect(1e3 /* ANIMA_FURTA */).getControllableCharacter();
      if (controllableCharacter) return controllableCharacter.GetDeafLevel();
      return next(args);
    });
    c3("Player.GetBlindLevel", d.OVERRIDE_BEHAVIOR, (args, next) => {
      const controllableCharacter = getSpellEffect(1e3 /* ANIMA_FURTA */).getControllableCharacter();
      if (controllableCharacter) return controllableCharacter.GetBlindLevel();
      return next(args);
    });
    c3("Player.HasTints", d.OVERRIDE_BEHAVIOR, (args, next) => {
      const effect = getSpellEffect(1e3 /* ANIMA_FURTA */);
      const controllableCharacter = effect.getControllableCharacter();
      if (controllableCharacter || effect.isActive) return true;
      return next(args);
    });
    c3("Player.GetTints", d.OVERRIDE_BEHAVIOR, (args, next) => {
      const effect = getSpellEffect(1e3 /* ANIMA_FURTA */);
      const controllableCharacter = effect.getControllableCharacter();
      if (controllableCharacter || effect.isActive) return [{ r: 0, g: 0, b: 100, a: 0.5 }];
      return next(args);
    });
    window.getControllableC = () => getSpellEffect(1e3 /* ANIMA_FURTA */).getControllableCharacter();
    h(
      "DrawCharacter",
      {
        "if (!C.IsPlayer() && !OverrideDark && (Player.IsBlind() || Player.HasTints())) {": `if (((getControllableC() && C.MemberNumber !== getControllableC().MemberNumber) || (!getControllableC() && !C.IsPlayer())) && !OverrideDark && (Player.IsBlind() || Player.HasTints())) {`
      }
    );
    c3("PoseCanChangeUnaidedStatus", d.OVERRIDE_BEHAVIOR, (args, next) => {
      const controllableCharacter = getSpellEffect(1e3 /* ANIMA_FURTA */).getControllableCharacter();
      if (!controllableCharacter) return next(args);
      if (!args[0].IsPlayer()) return next(args);
      args[0] = controllableCharacter;
      return next(args);
    });
    c3("Player.CanInteract", d.OVERRIDE_BEHAVIOR, (args, next) => {
      const controllableCharacter = getSpellEffect(1e3 /* ANIMA_FURTA */).getControllableCharacter();
      if (!controllableCharacter) return next(args);
      return controllableCharacter.CanInteract();
    });
    c3("DialogInventoryAdd", d.OVERRIDE_BEHAVIOR, (args, next) => {
      const controllableCharacter = getSpellEffect(1e3 /* ANIMA_FURTA */).getControllableCharacter();
      if (!controllableCharacter) return next(args);
      const [C4, item, isWorn, sortOrder] = args;
      const asset = item.Asset;
      if (asset.FamilyOnly && !controllableCharacter.IsInFamilyOfMemberNumber(C4.MemberNumber)) return;
      if (asset.LoverOnly && !controllableCharacter.IsLoverOfCharacter(C4)) return;
      if (asset.OwnerOnly && !C4.IsOwnedByCharacter(controllableCharacter)) return;
      const inventoryItem = DialogInventoryCreateItem(C4, item, isWorn, sortOrder);
      if (item.Craft != null) {
        inventoryItem.Craft = item.Craft;
        if (inventoryItem.SortOrder.charAt(0) === DialogSortOrder.Usable.toString()) inventoryItem.SortOrder = DialogSortOrder.PlayerFavoriteUsable.toString() + item.Asset.Description;
        if (inventoryItem.SortOrder.charAt(0) === DialogSortOrder.Unusable.toString()) inventoryItem.SortOrder = DialogSortOrder.PlayerFavoriteUnusable.toString() + item.Asset.Description;
      }
      DialogInventory.push(inventoryItem);
    });
    c3("ChatRoomOpenWardrobeScreen", d.OVERRIDE_BEHAVIOR, (args, next) => {
      const controllableCharacter = getSpellEffect(1e3 /* ANIMA_FURTA */).getControllableCharacter();
      if (!controllableCharacter) return next(args);
      if (controllableCharacter?.CanInteract()) {
        const module = CurrentModule;
        const screen = CurrentScreen;
        const inChatRoom = ServerPlayerIsInChatRoom();
        if (inChatRoom) {
          ChatRoomHideElements();
          ChatRoomStatusUpdate("Wardrobe");
        }
        CharacterAppearanceLoadCharacter(controllableCharacter, (ready) => {
          CommonSetScreen(module, screen);
          if (inChatRoom) {
            ChatRoomShowElements();
            ChatRoomStatusUpdate(null);
            if (ready) {
              g2.sendPacket("animaFurtaCommand", {
                name: "changeAppearance",
                target: controllableCharacter.MemberNumber,
                appearance: ServerAppearanceBundle(controllableCharacter.Appearance)
              }, controllableCharacter.MemberNumber);
            }
          }
        });
        return;
      }
      return next(args);
    });
    c3("ChatRoomOpenInformationScreen", d.OVERRIDE_BEHAVIOR, (args, next) => {
      const controllableCharacter = getSpellEffect(1e3 /* ANIMA_FURTA */).getControllableCharacter();
      if (!controllableCharacter) return next(args);
      ChatRoomHideElements();
      ChatRoomStatusUpdate("Preference");
      InformationSheetLoadCharacter(controllableCharacter);
    });
    c3("ChatRoomPublishAction", d.OVERRIDE_BEHAVIOR, (args, next) => {
      const controllableCharacter = getSpellEffect(1e3 /* ANIMA_FURTA */).getControllableCharacter();
      if (!controllableCharacter) return next(args);
      const [C4, Action, PrevItem, NextItem] = args;
      if (CurrentScreen !== "ChatRoom") return false;
      const dictionary = new DictionaryBuilder().sourceCharacter(controllableCharacter).destinationCharacter(C4).targetCharacter(C4);
      if (PrevItem != null) {
        dictionary.asset(PrevItem.Asset, "PrevAsset", PrevItem.Craft && PrevItem.Craft.Name);
      }
      if (NextItem != null) {
        dictionary.asset(NextItem.Asset, "NextAsset", NextItem.Craft && NextItem.Craft.Name);
      }
      if (C4.FocusGroup != null) {
        dictionary.focusGroup(C4.FocusGroup.Name);
      }
      g2.sendPacket("animaFurtaCommand", {
        name: "changeAppearance",
        appearance: ServerAppearanceBundle(C4.Appearance),
        target: C4.MemberNumber
      }, controllableCharacter.MemberNumber);
      g2.sendPacket("animaFurtaCommand", {
        name: "publishAction",
        params: { Content: Action, Type: "Action", Dictionary: dictionary.build() }
      }, controllableCharacter.MemberNumber);
      return true;
    });
    c3("ChatRoomMapViewMove", d.OVERRIDE_BEHAVIOR, async (args, next) => {
      if (showAnimaFurtaWaitingButton) return;
      const controllableCharacter = getSpellEffect(1e3 /* ANIMA_FURTA */).getControllableCharacter();
      if (!controllableCharacter) return next(args);
      controllableCharacter.MapData.Pos.X += (args[0] === "West" ? -1 : 0) + (args[0] === "East" ? 1 : 0);
      controllableCharacter.MapData.Pos.Y += (args[0] === "North" ? -1 : 0) + (args[0] === "South" ? 1 : 0);
      showAnimaFurtaWaitingButton = true;
      setTimeout(() => {
        showAnimaFurtaWaitingButton = false;
      }, 1e3);
      g2.sendPacket("animaFurtaCommand", {
        name: "mapMove",
        pos: { x: controllableCharacter.MapData.Pos.X, y: controllableCharacter.MapData.Pos.Y }
      }, controllableCharacter.MemberNumber);
    });
    c3("ChatRoomViews.Map.DrawUi", d.OBSERVE, (args, next) => {
      const controllableCharacter = getSpellEffect(1e3 /* ANIMA_FURTA */).getControllableCharacter();
      if (controllableCharacter && showAnimaFurtaWaitingButton) {
        DrawButton(790, 790, 200, 60, "Waiting...", "White");
      }
      return next(args);
    });
    window.bccDrawGridCharacter = () => window.getControllableC() ?? Player;
    h("ChatRoomMapViewDrawGrid", {
      "let ScreenX = (X - Player.MapData.Pos.X) * TileWidth + ChatRoomMapViewPerceptionRange * TileWidth;": "let ScreenX = (X - bccDrawGridCharacter().MapData.Pos.X) * TileWidth + ChatRoomMapViewPerceptionRange * TileWidth;",
      "let ScreenY = (Y - Player.MapData.Pos.Y) * TileHeight + ChatRoomMapViewPerceptionRange * TileWidth;": "let ScreenY = (Y - bccDrawGridCharacter().MapData.Pos.Y) * TileHeight + ChatRoomMapViewPerceptionRange * TileWidth;",
      "let MaxRange = Math.max(Math.abs(X - Player.MapData.Pos.X), Math.abs(Y - Player.MapData.Pos.Y));": "let MaxRange = Math.max(Math.abs(X - bccDrawGridCharacter().MapData.Pos.X), Math.abs(Y - bccDrawGridCharacter().MapData.Pos.Y));"
    });
    h("ChatRoomMapViewCalculatePerceptionMasks", {
      "if (ChatRoomMapViewHasSuperPowers()) {": "if (ChatRoomMapViewHasSuperPowers() || !bccDrawGridCharacter().IsPlayer()) {"
    });
  }

  // src/dto/castSpellMessageDto.ts
  function ValidateCustom2(validator, validationOptions) {
    return (object, propertyName) => {
      registerDecorator({
        name: "validateCustom",
        target: object.constructor,
        propertyName,
        options: validationOptions,
        validator: {
          validate(value, args) {
            return validator(args.object);
          },
          defaultMessage(args) {
            return "Params error";
          }
        }
      });
    };
  }
  var SpellDto = class {
    name;
    icon;
    effects;
    data;
    createdBy;
  };
  __decorateClass([
    IsString({ message: "tytg" })
  ], SpellDto.prototype, "name", 2);
  __decorateClass([
    ValidateIf((dto) => isEnum(dto.icon, SpellIcon))
  ], SpellDto.prototype, "icon", 2);
  __decorateClass([
    IsString(),
    ValidateCustom2((dto) => dto.effects?.split("")?.every((e2) => getSpellEffect(e2.charCodeAt(0)) instanceof BaseEffect))
  ], SpellDto.prototype, "effects", 2);
  __decorateClass([
    IsObject(),
    ValidateCustom2((dto) => {
      addDefaultParametersIfNeeds(dto);
      for (const effectChar of dto.effects.split("")) {
        const effect = getSpellEffect(effectChar.charCodeAt(0));
        for (const parameter of effect.parameters) {
          const parameterValue = dto.data?.[effectChar]?.[parameter.name];
          if (parameterValue === void 0 || parameterValue === null) return false;
          switch (parameter.type) {
            case "boolean":
              if (!isBoolean(parameterValue)) return false;
              break;
            case "number":
              if (!isNumber(parameterValue)) return false;
              if (parameter.max && parameterValue > parameter.max) return false;
              if (parameter.min && parameterValue < parameter.min) return false;
              break;
            case "text":
              if (!isString(parameterValue)) return false;
              if (parameterValue.trim() === "") return false;
              if (T2(parameterValue) > 5) return false;
              break;
            case "choice":
              if (!isString(parameterValue)) return false;
              if (!parameter.options.map((o5) => o5.name).includes(parameterValue)) return false;
              break;
          }
        }
      }
      return true;
    })
  ], SpellDto.prototype, "data", 2);
  __decorateClass([
    Type(() => CreatedByDto),
    ValidateNested()
  ], SpellDto.prototype, "createdBy", 2);
  var CastSpellMessageDto = class {
    spell;
  };
  __decorateClass([
    Type(() => SpellDto),
    ValidateNested()
  ], CastSpellMessageDto.prototype, "spell", 2);
  var CreatedByDto = class {
    name;
    id;
  };
  __decorateClass([
    IsString()
  ], CreatedByDto.prototype, "name", 2);
  __decorateClass([
    IsNumber()
  ], CreatedByDto.prototype, "id", 2);

  // src/qam-subscreens/castSpellQAMSubscreen.ts
  var CastSpellQAMSubscreen = class extends BaseQAMSubscreen {
    name = "Cast Spell";
    description = "Cast dark magic spell";
    load(container) {
      super.load(container);
      if ((modStorage.darkMagic?.spells ?? []).length === 0) {
        const message = document.createElement("p");
        message.style.cssText = "margin: 1.65em auto; font-weight: bold;";
        message.textContent = "You don't have any spells to cast";
        container.append(message);
        return;
      }
      function dataURLToSVGElement(dataURL) {
        const svgEncoded = dataURL.replace("data:image/svg+xml,", "");
        const svgString = decodeURIComponent(svgEncoded);
        const div = document.createElement("div");
        div.innerHTML = svgString;
        return div.firstElementChild;
      }
      let target = Player;
      let spell = JSON.parse(JSON.stringify(modStorage.darkMagic.spells[0]));
      const select = this.buildCharacterSelect((_target) => {
        target = _target;
      });
      const _select = this.buildSelect({
        options: modStorage.darkMagic?.spells?.map((s5) => ({ name: s5.name, text: s5.name, icon: dataURLToSVGElement(getSpellIcon(s5.icon).dataurl) })),
        currentOption: modStorage.darkMagic?.spells?.[0]?.name,
        onChange: (value) => {
          spell = JSON.parse(JSON.stringify(modStorage.darkMagic.spells.find((s5) => s5.name === value)));
          addDefaultParametersIfNeeds(spell);
          this.refreshParamtersContainer(paramters, spell);
        }
      });
      const paramters = document.createElement("div");
      paramters.style.cssText = "display: flex; flex-direction: column; row-gap: 0.5em; border: 3px dashed #dcccffff; border-radius: 4px; padding: 0.5em 0; margin: 0.5em auto; width: 90%;";
      const btn = this.buildButton("Cast Spell");
      btn.addEventListener("click", async () => {
        if (!spell) return;
        if (!Player.CanInteract()) {
          return Q2.error({ message: "You can't interact", duration: 3e3 });
        }
        if (!isMagicItem(InventoryGet(Player, "ItemHandheld"))) {
          return Q2.error({
            message: "You should hold magic item in your hand to cast spells",
            duration: 5e3
          });
        }
        const allow = allowSpellCast(Player, target, spell);
        if (allow.result === false) {
          return Q2.error({
            title: "Can't cast this spell",
            message: allow.reason,
            duration: 5e3
          });
        }
        const { isValid } = await c4({
          spell
        }, CastSpellMessageDto);
        if (!isValid) {
          return Q2.error({
            title: "Spell validation failed",
            message: "Check spell's settings and make sure that everything is specified correctly",
            duration: 5e3
          });
        }
        castSpell(target, spell);
      });
      this.refreshParamtersContainer(paramters, spell);
      container.append(select, _select, paramters, btn);
    }
    refreshParamtersContainer(paramters, spell) {
      paramters.innerHTML = "";
      const title = document.createElement("p");
      title.style.cssText = "margin: 0.65em auto; width: 90%; font-weight: bold; font-size: 0.85em; color: #9977d0;";
      title.textContent = "Parameters";
      paramters.append(title);
      for (const c7 of spell.effects.split("")) {
        const effect = getSpellEffect(c7.charCodeAt(0));
        if (effect.parameters.length === 0) continue;
        const effectName = document.createElement("p");
        effectName.style.cssText = "margin: 0.6em auto 0 auto; width: 90%;";
        effectName.textContent = effect.name;
        paramters.append(effectName);
        for (const parameter of effect.parameters) {
          const value = spell.data?.[c7]?.[parameter.name];
          switch (parameter.type) {
            case "boolean": {
              const checkbox = document.createElement("label");
              checkbox.style.cssText = "margin: auto; width: 90%;";
              const input = document.createElement("input");
              input.type = "checkbox";
              if (typeof value === "boolean") input.checked = value;
              input.addEventListener("change", () => {
                spell.data[c7][parameter.name] = input.checked;
              });
              checkbox.append(input, parameter.label);
              paramters.append(checkbox);
              break;
            }
            case "choice":
              paramters.append(
                this.buildSelect({
                  options: parameter.options,
                  currentOption: parameter.options.find((o5) => o5.name === value)?.name ?? parameter.options[0].name,
                  onChange: (_value) => {
                    spell.data[c7][parameter.name] = _value;
                  }
                })
              );
              break;
            case "number": {
              const input = this.buildInput(parameter.label);
              input.type = "number";
              if (typeof value === "number") input.value = value.toString();
              if (parameter.min) input.min = parameter.min.toString();
              if (parameter.min) input.max = parameter.max.toString();
              input.addEventListener("input", () => {
                spell.data[c7][parameter.name] = parseInt(input.value, 10);
              });
              paramters.append(input);
              break;
            }
            case "text": {
              const input = this.buildInput(parameter.label);
              if (typeof value === "string") input.value = value;
              input.addEventListener("input", () => {
                spell.data[c7][parameter.name] = input.value;
              });
              paramters.append(input);
              break;
            }
          }
        }
      }
      if (paramters.children.length === 1) paramters.style.display = "none";
      else paramters.style.display = "flex";
    }
  };

  // src/qam-subscreens/putLocksQAMSubscreen.ts
  var PutLocksQAMSubscreen = class extends BaseQAMSubscreen {
    name = "Put Locks";
    description = "Put lock on target's all items";
    load(container) {
      super.load(container);
      let target = Player;
      const locks = AssetGroupGet(Player.AssetFamily, "ItemMisc").Asset.filter((item) => item.Name?.endsWith("Padlock"));
      let lock = locks[0].Name;
      const select = this.buildCharacterSelect((_target) => {
        target = _target;
      });
      const _select = this.buildSelect({
        options: locks.map((l6) => ({ name: l6.Name, text: l6.Description })),
        currentOption: locks[0].Name,
        onChange: (value) => {
          lock = value;
        }
      });
      const btn = this.buildButton("Put Locks");
      btn.addEventListener("click", () => {
        InventoryFullLock(target, lock);
        ChatRoomCharacterUpdate(target);
        Q2.success({
          message: `You have successfully locked every item on ${O2(target)}'s body`,
          duration: 4500
        });
      });
      container.append(select, _select, btn);
    }
  };

  // src/qam-subscreens/removeLocksQAMSubscreen.ts
  var RemoveLocksQAMSubscreen = class extends BaseQAMSubscreen {
    name = "Remove Locks";
    description = "Remove all locks from target's body";
    load(container) {
      super.load(container);
      let target = Player;
      const select = this.buildCharacterSelect((_target) => {
        target = _target;
      });
      const btn = this.buildButton("Remove Locks");
      btn.addEventListener("click", () => {
        for (const a5 of Player.Appearance) {
          if (InventoryGetLock(a5)) InventoryUnlock(target, a5);
        }
        ChatRoomCharacterUpdate(target);
        Q2.success({
          message: `You have successfully unlocked every item on ${O2(target)}'s body`,
          duration: 4500
        });
      });
      container.append(select, btn);
    }
  };

  // src/qam-subscreens/avcsQAMSubscreen.ts
  function formatMilliseconds(ms) {
    const seconds = Math.floor(ms / 1e3);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);
    const remainingSeconds = seconds % 60;
    const remainingMinutes = minutes % 60;
    const remainingHours = hours % 24;
    if (days > 0) {
      return `${days} ${days === 1 ? "day" : "days"} ${remainingHours} ${remainingHours === 1 ? "hour" : "hours"}`;
    } else if (hours > 0) {
      return `${hours} ${hours === 1 ? "hour" : "hours"} ${remainingMinutes} ${remainingMinutes === 1 ? "minute" : "minutes"}`;
    } else if (minutes > 0) {
      return `${minutes} ${minutes === 1 ? "minute" : "minutes"} ${remainingSeconds} ${remainingSeconds === 1 ? "second" : "seconds"}`;
    } else {
      return `${seconds} ${seconds === 1 ? "second" : "seconds"}`;
    }
  }
  var AVQS_QAMSubscreen = class extends BaseQAMSubscreen {
    name = "AVCS";
    description = "Appearance Version Control System - System that registers all the changes in appearance that occur in room and allows you to manipulate them. Don't associate this with GIT and other VCS";
    load(container) {
      super.load(container);
      this.loadCommitsList(container);
    }
    createPreviewCanvas(commit) {
      const previewCanvas = document.createElement("canvas");
      previewCanvas.style = "width: auto; height: 100%; margin: 0; background: white; position: relative; border-radius: 6px; border: 2px solid #d7d7d7;";
      previewCanvas.width = 400;
      previewCanvas.height = 400;
      const previewCharacter = CharacterCreate("Female3DCG", CharacterType.NPC, "BCC_COMMIT_PROFILE_PREVIEW");
      previewCharacter.Appearance = v("Female3DCG", commit.bundle.content);
      CharacterRefresh(previewCharacter);
      if (previewCharacter.IsKneeling()) {
        DrawCharacter(previewCharacter, 90, -60, 0.4, false, previewCanvas.getContext("2d"));
      } else {
        DrawCharacter(previewCharacter, 90, 0, 0.4, false, previewCanvas.getContext("2d"));
      }
      return previewCanvas;
    }
    loadCommitsList(container, target = Player) {
      const select = this.buildCharacterSelect((_target) => {
        target = _target;
        commitsContainer.innerHTML = "";
        createCommits();
      }, target);
      const createCommits = () => {
        for (const commit of commits.get(target.MemberNumber)) {
          const commitElement = document.createElement("div");
          commitElement.addEventListener("click", () => {
            select.remove();
            commitsContainer.remove();
            updateButton.remove();
            this.loadCommitProfile(container, commit, target);
          });
          const icon = document.createElement("div");
          Q(icon, {
            base: {
              position: "relative",
              display: "flex",
              alignItems: "center",
              columnGap: "0.2em",
              padding: "0 0.5em",
              fontSize: "0.8em",
              border: "1px solid #dedede",
              borderRadius: "8px",
              boxSizing: "content-box",
              height: "65%"
            },
            before: {
              content: '""',
              position: "absolute",
              top: "100%",
              bottom: "-50%",
              left: "1em",
              width: "0.15em",
              background: "#c6c6c6c7"
            }
          });
          const text = document.createElement("p");
          text.style.cssText = "font-size: 0.8em;";
          let timeAgo;
          const differenceContainer = document.createElement("p");
          differenceContainer.style.cssText = "display: flex; column-gap: 0.45em; color: #6d6d6d; font-size: 0.75em;";
          if (commit.type === "initial") {
            const iconImg = createElement4(GitCommitVertical);
            iconImg.style.cssText = "height: 80%; width: auto; color: rgb(72 72 123 / 70%);";
            const iconText = document.createElement("span");
            iconText.textContent = "Initial";
            icon.style.background = "rgb(193 193 255 / 45%)";
            iconText.style.color = "rgb(72 72 123 / 70%)";
            text.textContent = "Initial Commit";
            icon.append(iconImg, iconText);
          } else {
            const iconImg = createElement4(commit.type === "push" ? GitPullRequestArrow : GitPullRequestClosed);
            iconImg.style.cssText = `height: 80%; width: auto; color: ${commit.type === "push" ? "rgb(102 152 130)" : "rgb(129 36 36 / 70%)"};`;
            const iconText = document.createElement("span");
            iconText.textContent = commit.type === "push" ? "Push" : "Revert";
            icon.style.background = commit.type === "push" ? "rgb(172 255 220 / 50%)" : "rgb(255 0 0 / 30%)";
            iconText.style.color = commit.type === "push" ? "rgb(102 152 130)" : "rgb(129 36 36 / 70%)";
            text.textContent = `${commit.sourceCharacter.name} (${commit.sourceCharacter.memberNumber})`;
            icon.append(iconImg, iconText);
            timeAgo = document.createElement("p");
            timeAgo.style.cssText = "color: #526378; font-size: 0.75em;";
            timeAgo.textContent = formatMilliseconds(Date.now() - commit.timestamp) + " ago";
            const added = document.createElement("p");
            added.textContent = "+" + commit.bundle.difference.added.length.toString();
            added.style.color = "#57d157";
            const modified = document.createElement("p");
            modified.textContent = commit.bundle.difference.modified.length.toString();
            modified.style.color = "#ffa705";
            const removed = document.createElement("p");
            removed.textContent = "-" + commit.bundle.difference.removed.length.toString();
            removed.style.color = "#ff0000";
            differenceContainer.append(added, modified, removed);
          }
          Q(commitElement, {
            base: {
              display: "flex",
              alignItems: "center",
              justifyContent: "space-between",
              cursor: "pointer",
              fontSize: "0.8em",
              height: "2.5em",
              padding: "0 0.5em"
            },
            hover: {
              background: "#e7e4ef"
            }
          });
          commitElement.append(icon, text, timeAgo ? timeAgo : "", differenceContainer);
          commitsContainer.append(commitElement);
        }
      };
      const commitsContainer = document.createElement("div");
      Q(commitsContainer, {
        base: {
          display: "flex",
          flexDirection: "column",
          width: "90%",
          // height: "60vh",
          overflowY: "scroll",
          margin: "0 auto",
          padding: "0.5em 0"
        }
      });
      createCommits();
      const updateButton = this.buildButton("Update");
      updateButton.addEventListener("click", () => {
        commitsContainer.innerHTML = "";
        createCommits();
      });
      container.append(select, commitsContainer, updateButton);
    }
    loadCommitProfile(container, commit, target) {
      const exitButton = createElement4(X2);
      Q(exitButton, {
        base: {
          cursor: "pointer",
          color: "#454545",
          margin: "0.5em",
          padding: "0.15em",
          width: "2.85em",
          height: "2.85em",
          borderRadius: "6px",
          flexShrink: "0"
        },
        hover: {
          background: "#00000014"
        }
      });
      if (commit.type === "initial") {
        const previewCanvas = this.createPreviewCanvas(commit);
        previewCanvas.style.margin = "auto";
        previewCanvas.style.width = "50%";
        previewCanvas.style.height = "auto";
        exitButton.addEventListener("click", () => {
          exitButton.remove();
          previewCanvas.remove();
          text.remove();
          this.loadCommitsList(container, target);
        });
        const text = document.createElement("p");
        text.style.cssText = "margin: auto; text-align: center;";
        text.textContent = "Just initial commit, nothing interesting. What are you doing here?";
        container.append(exitButton, previewCanvas, text);
      } else {
        const unload = () => {
          flexContainer.remove();
          details.remove();
          seed.remove();
          revertCommitButton.remove();
          revertCommitDescription.remove();
          exitButton.remove();
        };
        exitButton.addEventListener("click", () => {
          unload();
          this.loadCommitsList(container, target);
        });
        const flexContainer = document.createElement("div");
        flexContainer.style.cssText = "display: flex; justify-content: space-evenly; column-gap: 0.25em; height: 15em;";
        const previewCanvas = this.createPreviewCanvas(commit);
        const diffsContainer = document.createElement("div");
        diffsContainer.style.cssText = "font-size: clamp(8px, 1.5vw, 12px); overflow-y: scroll;";
        commit.bundle.difference.added.forEach((added) => {
          const t3 = document.createElement("div");
          t3.style.color = "rgb(87, 209, 87)";
          t3.textContent = "+ " + added;
          diffsContainer.append(t3);
        });
        commit.bundle.difference.modified.forEach((modified) => {
          const t3 = document.createElement("div");
          t3.style.color = "rgb(255, 167, 5)";
          t3.textContent = modified;
          diffsContainer.append(t3);
        });
        commit.bundle.difference.removed.forEach((removed) => {
          const t3 = document.createElement("div");
          t3.style.color = "rgb(255, 0, 0)";
          t3.textContent = "- " + removed;
          diffsContainer.append(t3);
        });
        const details = document.createElement("p");
        details.style.margin = "0.25em 1em";
        details.style.marginTop = "1em";
        details.innerHTML = `Commited by <span style="color: #3b3b4eff;">${commit.sourceCharacter.name} (${commit.sourceCharacter.memberNumber})</span> at <span style="color: #3b3b4eff;">${new Date(commit.timestamp).toLocaleString()}</span>`;
        const seed = document.createElement("p");
        seed.style.margin = "0.25em 1em";
        seed.textContent = `Appearance Seed: ${commit.bundle.seed}`;
        const revertCommitButton = this.buildButton("Revert");
        revertCommitButton.style.marginTop = "1em";
        revertCommitButton.addEventListener("click", () => {
          ServerAppearanceLoadFromBundle(target, target.AssetFamily, commit.bundle.content, Player.MemberNumber);
          ChatRoomCharacterUpdate(target);
          unload();
          this.loadCommitsList(container, target);
        });
        const revertCommitDescription = document.createElement("p");
        revertCommitDescription.style.cssText = "width: 95%; margin: 0 auto; text-align: center; font-size: 0.75em; color: #484848;";
        revertCommitDescription.textContent = "Will send revert commit that will revert all commits following this commit, or send push commit if it is impossible to set exactly the same appearance due to validation";
        flexContainer.append(previewCanvas, diffsContainer);
        container.append(exitButton, flexContainer, details, seed, revertCommitButton, revertCommitDescription);
      }
    }
  };

  // src/modules/quickAccessMenu.ts
  var serverPing;
  var currentSubscreen;
  var LOCAL_STORAGE_POS_KEY = "BCC_QAMButton_Pos";
  var commitHashGenerationToken = Date.now().toString(16);
  var Draggable = class {
    constructor(draggableElement, captureElement) {
      this.draggableElement = draggableElement;
      this.captureElement = captureElement;
      this.offset = { x: 0, y: 0 };
      this.init();
    }
    isReadyForDragging = false;
    isDragging = false;
    wasDragged = false;
    offset;
    previousMousePositionX;
    previousMousePositionY;
    init() {
      this.captureElement.addEventListener("mousedown", this.onMouseDown.bind(this));
      document.addEventListener("mousemove", this.onMouseMove.bind(this));
      document.addEventListener("mouseup", this.onMouseUp.bind(this));
      this.captureElement.addEventListener("touchstart", this.onTouchStart.bind(this));
      document.addEventListener("touchmove", this.onTouchMove.bind(this));
      document.addEventListener("touchend", this.onTouchEnd.bind(this));
      this.captureElement.addEventListener("click", this.onClick.bind(this));
    }
    onMouseDown(e2) {
      if (e2.currentTarget === this.captureElement) {
        this.isReadyForDragging = true;
        this.offset = {
          x: e2.clientX - this.draggableElement.getBoundingClientRect().left,
          y: e2.clientY - this.draggableElement.getBoundingClientRect().top
        };
      }
    }
    onMouseMove(e2) {
      if (this.previousMousePositionX === e2.clientX && this.previousMousePositionY === e2.clientY) return;
      this.previousMousePositionX = e2.clientX;
      this.previousMousePositionY = e2.clientY;
      if (!this.isReadyForDragging) return;
      const x5 = e2.clientX - this.offset.x;
      const y5 = e2.clientY - this.offset.y;
      if (x5 >= 0 && x5 + this.draggableElement.offsetWidth <= window.innerWidth) this.draggableElement.style.left = x5 + "px";
      if (y5 >= 0 && y5 + this.draggableElement.offsetHeight <= window.innerHeight) this.draggableElement.style.top = y5 + "px";
      this.isDragging = true;
    }
    onMouseUp() {
      if (this.isReadyForDragging) this.isReadyForDragging = false;
      if (this.isDragging) {
        this.isDragging = false;
        this.wasDragged = true;
        setTimeout(() => {
          this.wasDragged = false;
        }, 100);
      }
    }
    onTouchStart(e2) {
      if (e2.currentTarget === this.captureElement) {
        this.isReadyForDragging = true;
        const touch = e2.touches[0];
        this.offset = {
          x: touch.clientX - this.draggableElement.getBoundingClientRect().left,
          y: touch.clientY - this.draggableElement.getBoundingClientRect().top
        };
      }
    }
    onTouchMove(e2) {
      const touch = e2.touches[0];
      if (this.previousMousePositionX === touch.clientX && this.previousMousePositionY === touch.clientY) return;
      this.previousMousePositionX = touch.clientX;
      this.previousMousePositionY = touch.clientY;
      if (!this.isReadyForDragging) return;
      const x5 = touch.clientX - this.offset.x;
      const y5 = touch.clientY - this.offset.y;
      if (x5 >= 0 && x5 + this.draggableElement.offsetWidth <= window.innerWidth) this.draggableElement.style.left = x5 + "px";
      if (y5 >= 0 && y5 + this.draggableElement.offsetHeight <= window.innerHeight) this.draggableElement.style.top = y5 + "px";
      this.isDragging = true;
    }
    onTouchEnd() {
      if (this.isReadyForDragging) this.isReadyForDragging = false;
      if (this.isDragging) {
        this.isDragging = false;
        this.wasDragged = true;
        setTimeout(() => {
          this.wasDragged = false;
        }, 100);
      }
    }
    onClick() {
    }
  };
  var QAMButton = class extends Draggable {
    onMouseUp() {
      super.onMouseUp();
      if (this.wasDragged && typeof localStorage.setItem === "function") {
        const { top, left } = this.draggableElement.getBoundingClientRect();
        localStorage.setItem(LOCAL_STORAGE_POS_KEY, `${top}:${left}`);
      }
    }
    onClick() {
      if (this.isDragging || this.wasDragged) return;
      const qam = document.querySelector(".bccQAM");
      if (qam) {
        qam.style.display = qam.style.display === "none" ? "flex" : "none";
        currentSubscreen = null;
      } else {
        const d6 = document.createElement("div");
        d6.classList.add("bccQAM");
        document.body.append(d6);
        setQAMSubscreen4(new MainQAMSubscreen());
      }
    }
  };
  var QAMWindow = class extends Draggable {
    onMouseMove(e2) {
      this.draggableElement.style.transform = "none";
      super.onMouseMove(e2);
    }
  };
  function isBannedBy(C4) {
    return C4.HasOnBlacklist(Player);
  }
  function isAllowScripts(target = Player) {
    let allowHide = ValidationHasScriptPermission(
      target,
      "Hide",
      ScriptPermissionLevel.PUBLIC
    );
    let allowBlock = ValidationHasScriptPermission(
      target,
      "Block",
      ScriptPermissionLevel.PUBLIC
    );
    if (target.IsPlayer()) {
      if (!allowHide) {
        allowHide = ValidationHasScriptPermission(
          target,
          "Hide",
          ScriptPermissionLevel.SELF
        );
      }
      if (!allowBlock) {
        allowBlock = ValidationHasScriptPermission(
          target,
          "Block",
          ScriptPermissionLevel.SELF
        );
      }
    }
    if (target.IsOwnedByPlayer()) {
      if (!allowHide) {
        allowHide = ValidationHasScriptPermission(
          target,
          "Hide",
          ScriptPermissionLevel.OWNER
        );
      }
      if (!allowBlock) {
        allowBlock = ValidationHasScriptPermission(
          target,
          "Block",
          ScriptPermissionLevel.OWNER
        );
      }
    }
    if (target.IsLoverOfPlayer()) {
      if (!allowHide) {
        allowHide = ValidationHasScriptPermission(
          target,
          "Hide",
          ScriptPermissionLevel.LOVERS
        );
      }
      if (!allowBlock) {
        allowBlock = ValidationHasScriptPermission(
          target,
          "Block",
          ScriptPermissionLevel.LOVERS
        );
      }
    }
    if (target.WhiteList.includes(Player.MemberNumber)) {
      if (!allowHide) {
        allowHide = ValidationHasScriptPermission(
          target,
          "Hide",
          ScriptPermissionLevel.WHITELIST
        );
      }
      if (!allowBlock) {
        allowBlock = ValidationHasScriptPermission(
          target,
          "Block",
          ScriptPermissionLevel.WHITELIST
        );
      }
    }
    if (Player.FriendList.includes(target.MemberNumber)) {
      if (!allowHide) {
        allowHide = ValidationHasScriptPermission(
          target,
          "Hide",
          ScriptPermissionLevel.FRIENDS
        );
      }
      if (!allowBlock) {
        allowBlock = ValidationHasScriptPermission(
          target,
          "Block",
          ScriptPermissionLevel.FRIENDS
        );
      }
    }
    return {
      hide: allowHide,
      block: allowBlock
    };
  }
  function setQAMSubscreen4(s5) {
    if (!document.querySelector(".bccQAM")) return;
    const container = document.querySelector(".bccQAM");
    container.innerHTML = "";
    s5.load(container);
    currentSubscreen = s5;
  }
  function toggleFeature(id) {
    modStorage.qam ??= {};
    modStorage.qam.enabledFeatures ??= "";
    const char = String.fromCharCode(id);
    if (modStorage.qam.enabledFeatures.includes(char)) {
      modStorage.qam.enabledFeatures = modStorage.qam.enabledFeatures.replaceAll(char, "");
    } else modStorage.qam.enabledFeatures += String.fromCharCode(id);
    setQAMSubscreen4(new MainQAMSubscreen());
  }
  function isFeatureEnabled(id) {
    const char = String.fromCharCode(id);
    return modStorage.qam?.enabledFeatures?.includes(char);
  }
  var qamFeatures = [
    {
      id: 1e3,
      subscreen: new ToggleInvisibilityQAMSubscreen(),
      icon: HatGlasses
    },
    {
      id: 1001,
      subscreen: new PosesManagerQAMSubscreen(),
      icon: PersonStanding
    },
    {
      id: 1002,
      subscreen: new ImportAppearanceQAMSubscreen(),
      icon: ClipboardPaste
    },
    {
      id: 1003,
      subscreen: new ExportAppearanceQAMSubscreen(),
      icon: ClipboardCopy
    },
    {
      id: 1004,
      subscreen: new LeaveRoomQAMSubscreen(),
      icon: LogOut
    },
    {
      id: 1005,
      subscreen: new TotalReleaseQAMSubscreen(),
      icon: ShieldAlert
    },
    {
      id: 1006,
      subscreen: new ReleaseQAMSubscreen(),
      icon: ShieldMinus
    },
    {
      id: 1007,
      subscreen: new MapTeleportQAMSubscreen(),
      icon: MapPinned
    },
    {
      id: 1008,
      subscreen: new CloneQAMSubscreen(),
      icon: CopyPlus
    },
    {
      id: 1009,
      subscreen: new ViewCardDecksQAMSubscreen(),
      icon: Eye
    },
    {
      id: 1010,
      subscreen: new CastSpellQAMSubscreen(),
      icon: Wand
    },
    {
      id: 1011,
      subscreen: new PutLocksQAMSubscreen(),
      icon: Lock
    },
    {
      id: 1012,
      subscreen: new RemoveLocksQAMSubscreen(),
      icon: LockOpen
    },
    {
      id: 1013,
      subscreen: new AVQS_QAMSubscreen(),
      icon: GitCompareArrows,
      isBeta: true
    }
  ];
  function createQAMButton() {
    const menuButton = document.createElement("button");
    menuButton.classList.add("bccQAMButton");
    const icon = document.createElement("img");
    icon.src = mouthWatering_default;
    menuButton.append(icon);
    document.body.append(menuButton);
    new QAMButton(menuButton, menuButton);
    if (typeof localStorage.getItem === "function") {
      const pos = localStorage.getItem(LOCAL_STORAGE_POS_KEY)?.split(":");
      if (pos) {
        menuButton.style.top = pos[0] + "px";
        menuButton.style.left = pos[1] + "px";
      }
    }
  }
  function removeQuickMenu() {
    document.querySelector(".bccQAMButton")?.remove();
  }
  async function pingServer() {
    const d1 = Date.now();
    const res = await fetch(window.location.href);
    if (res.status < 400) serverPing = Date.now() - d1;
  }
  var commits = /* @__PURE__ */ new Map();
  var commitsBehindCount = /* @__PURE__ */ new Map();
  function addCommit(sourceCharacter, targetCharacter) {
    const _commits = commits.get(targetCharacter.MemberNumber) ?? [];
    const prevCommit = _commits[0];
    const seed = I3.getSeed(targetCharacter.Appearance);
    if (!prevCommit) {
      _commits.unshift({
        bundle: {
          seed,
          content: ServerAppearanceBundle(targetCharacter.Appearance)
        },
        type: "initial"
      });
    } else {
      const prevSeed = prevCommit.bundle.seed;
      if (prevSeed === seed) return;
      const revertCommitsFollowingThisCommit = _commits.find((c7) => c7.bundle.seed === seed);
      _commits.unshift({
        bundle: {
          seed,
          content: ServerAppearanceBundle(targetCharacter.Appearance),
          difference: I3.getDifference(v("Female3DCG", prevCommit.bundle.content), targetCharacter.Appearance)
        },
        sourceCharacter: {
          name: CharacterNickname(sourceCharacter),
          memberNumber: sourceCharacter.MemberNumber
        },
        timestamp: Date.now(),
        type: revertCommitsFollowingThisCommit ? "revert" : "push"
      });
    }
    commits.set(targetCharacter.MemberNumber, _commits);
  }
  function loadQuickAccessMenu() {
    if (modStorage.qam?.enabled) createQAMButton();
    pingServer();
    addCommit(Player, Player);
    commitsBehindCount.set(Player.MemberNumber, 0);
    if (ServerPlayerIsInChatRoom()) {
      ChatRoomCharacter.forEach((C4) => {
        if (!C4.IsPlayer()) addCommit(null, C4);
      });
    }
    setInterval(() => {
      if (!currentSubscreen || currentSubscreen.name !== "BONDAGE CLUB CHAOS") return;
      pingServer();
    }, 1e4);
    c3("ChatRoomCharacterItemUpdate", d.OBSERVE, (args, next) => {
      next(args);
      const [target, group] = args;
      addCommit(Player, target);
    });
    c3("ChatRoomSyncItem", d.OBSERVE, (args, next) => {
      next(args);
      const [data] = args;
      const item = data?.Item;
      const target1 = N2(data?.Source);
      const target2 = N2(item?.Target);
      if (!target1 || !target2) return;
      addCommit(target1, target2);
    });
    c3("ChatRoomSyncSingle", d.OBSERVE, (args, next) => {
      next(args);
      const [data] = args;
      const target1 = N2(data?.SourceMemberNumber);
      const target2 = N2(data?.Character?.MemberNumber);
      if (!target1 || !target2) return;
      addCommit(target1, target2);
    });
    c3("ChatRoomSync", d.OBSERVE, async (args, next) => {
      await next(args);
      const [data] = args;
      const playerCommits = commits.get(Player.MemberNumber);
      commits.clear();
      commits.set(Player.MemberNumber, playerCommits);
      ChatRoomCharacter.forEach((C4) => {
        if (!C4.IsPlayer()) addCommit(null, C4);
      });
    });
    c3("ChatRoomSyncMemberJoin", d.OBSERVE, (args, next) => {
      next(args);
      const [data] = args;
      addCommit(null, N2(data.SourceMemberNumber));
    });
  }

  // src/modules/storage.ts
  var modStorage = { version };
  function loadStorage() {
    if (typeof Player.ExtensionSettings.BCC === "string") {
      modStorage = JSON.parse(LZString.decompressFromBase64(Player.ExtensionSettings.BCC)) ?? { version };
    } else modStorage = { version };
    if (!modStorage.version) modStorage.version = version;
    if (modStorage.version === "1.8.7") {
      modStorage = { version };
      const legacyData = LZString.decompressFromBase64(Player.ExtensionSettings.BCC);
      h2(() => !!document.getElementById("TextAreaChatLog")).then(() => {
        g2.sendLocal("Legacy BCC Data: " + legacyData);
        g2.sendLocal("I get a lot of legacy BCC's error reports, so I decided to release new version sooner than necessary. Most of the functions was migrated, and those that I did not manage to migrate will be added later.");
      });
    }
    if (w3(version, modStorage.version)) {
      Q2.info({
        title: "BCC was updated",
        message: "You can read the changelog in QAM",
        duration: 6e3
      });
      modStorage.version = version;
    }
    syncStorage();
    g2.onPacket("syncStorage", (data, sender) => {
      if (!sender.BCC) {
        g2.sendPacket("syncStorage", {
          storage: JSON.parse(JSON.stringify(modStorage))
        });
      }
      sender.BCC = data.storage;
    });
  }
  function syncStorage() {
    if (typeof modStorage !== "object") return;
    Player.ExtensionSettings.BCC = LZString.compressToBase64(JSON.stringify(modStorage));
    ServerPlayerExtensionSettingsSync("BCC");
    g2.sendPacket("syncStorage", {
      storage: JSON.parse(JSON.stringify(modStorage))
    });
  }
  function resetStorage() {
    removeQuickMenu();
    modStorage = {
      version
    };
    syncStorage();
  }

  // src/modules/chaosAura.ts
  var chaosAuraLastData = {
    appearance: null,
    pose: null
  };
  function updateChaosAuraLastData() {
    chaosAuraLastData.appearance = ServerAppearanceBundle(
      Player.Appearance
    );
    chaosAuraLastData.pose = [...Player.ActivePose];
  }
  async function skyShieldAction(target) {
    const appearance1 = chaosAuraLastData.appearance;
    const activePose1 = chaosAuraLastData.pose;
    const appearance2 = ServerAppearanceBundle(Player.Appearance);
    const activePose2 = Player.ActivePose;
    let newAppearance = [...appearance2];
    let newActivePose = [...activePose2];
    const targetStorage = target.IsPlayer() ? modStorage : target.BCC;
    const itemsFilter = (item) => item.Group.startsWith("Item");
    const noItemsFilter = (item) => !item.Group.startsWith("Item");
    const restraintsFilter = (item) => InventoryGet(Player, item.Group)?.Asset?.IsRestraint;
    const noRestraintsFilter = (item) => !InventoryGet(Player, item.Group)?.Asset?.IsRestraint;
    const clothesFilter = (item) => g3(ServerBundledItemToAppearanceItem(Player.AssetFamily, item));
    const noClothesFilter = (item) => u2(ServerBundledItemToAppearanceItem(Player.AssetFamily, item));
    let triggered = false;
    const triggers = modStorage.chaosAura?.triggers;
    if (!modStorage.chaosAura?.whiteList?.includes(target.MemberNumber)) {
      if (triggers?.clothesChange) {
        if (JSON.stringify(
          appearance2.filter(clothesFilter)
        ) !== JSON.stringify(
          appearance1.filter(clothesFilter)
        )) {
          newAppearance = newAppearance.filter(noClothesFilter).concat(appearance1.filter(clothesFilter));
          triggered = true;
        }
      }
      if (triggers?.itemsChange) {
        if (modStorage.chaosAura?.ignoreItemsChangeIfNotRestraint) {
          if (JSON.stringify(
            appearance2.filter(restraintsFilter)
          ) !== JSON.stringify(
            appearance1.filter(restraintsFilter)
          )) {
            newAppearance = newAppearance.filter(noRestraintsFilter).concat(appearance1.filter(restraintsFilter));
            triggered = true;
          }
        } else {
          if (JSON.stringify(
            appearance2.filter(itemsFilter)
          ) !== JSON.stringify(
            appearance1.filter(itemsFilter)
          )) {
            newAppearance = newAppearance.filter(noItemsFilter).concat(appearance1.filter(itemsFilter));
            triggered = true;
          }
        }
      }
      if (triggers?.poseChange) {
        if (JSON.stringify(
          activePose1
        ) !== JSON.stringify(
          activePose2
        )) {
          newActivePose = activePose1;
          triggered = true;
        }
      }
      if (triggered) {
        modStorage.chaosAura.triggersCount ??= 0;
        modStorage.chaosAura.triggersCount++;
        syncStorage();
        ServerSend("ChatRoomCharacterUpdate", {
          ID: Player.OnlineID,
          ActivePose: newActivePose,
          Appearance: newAppearance
        });
        setTimeout(() => ServerSend("ChatRoomCharacterPoseUpdate", { Pose: newActivePose }), 500);
        g2.sendAction(
          `${O2(target)} tried to touch ${O2(
            Player
          )}, but ${O2(Player)} was protected by some kind of dark aura`
        );
        if (modStorage.chaosAura?.retribution && (!targetStorage?.chaosAura?.enabled || !targetStorage?.chaosAura?.triggers?.itemsChange || targetStorage?.chaosAura?.whiteList?.includes(Player.MemberNumber)) && ServerChatRoomGetAllowItem(Player, target)) {
          const items1 = appearance1.filter(itemsFilter).map((item) => JSON.stringify(item));
          const items2 = appearance2.filter(itemsFilter).map((item) => JSON.stringify(item));
          let retributionItems = [];
          items2.forEach((item) => {
            if (!items1.includes(item)) retributionItems.push(JSON.parse(item));
          });
          retributionItems = retributionItems.filter(
            (item) => item.Group !== "ItemHandheld"
          );
          if (retributionItems.length > 0) {
            g2.sendAction(
              `Retribution: Used restraints are returned to ${O2(target)}`
            );
            ServerSend("ChatRoomCharacterUpdate", {
              ID: target.AccountName.replace("Online-", ""),
              ActivePose: target.ActivePose,
              Appearance: ServerAppearanceBundle(target.Appearance).concat(
                retributionItems
              )
            });
          }
        }
      }
    }
    chaosAuraLastData.appearance = newAppearance;
    chaosAuraLastData.pose = newActivePose;
    await h2(() => {
      return JSON.stringify(
        ServerAppearanceBundle(
          Player.Appearance
        )
      ) === JSON.stringify(
        newAppearance
      );
    });
    return true;
  }
  function onPlayerAppearanceChange(target) {
    if (!modStorage.chaosAura?.enabled) return;
    if (target.IsPlayer()) updateChaosAuraLastData();
    else skyShieldAction(target);
  }
  function loadChaosAura() {
    if (modStorage.chaosAura?.enabled) updateChaosAuraLastData();
    c3("ChatRoomCharacterItemUpdate", d.OBSERVE, (args, next) => {
      next(args);
      const [target] = args;
      if (target.IsPlayer()) onPlayerAppearanceChange(Player);
    });
    c3("ChatRoomSyncItem", d.OBSERVE, (args, next) => {
      next(args);
      const [data] = args;
      const item = data?.Item;
      const target1 = N2(data?.Source);
      const target2 = N2(item?.Target);
      if (!target1 || !target2) return;
      if (target2.IsPlayer()) onPlayerAppearanceChange(target1);
    });
    c3("ChatRoomSyncSingle", d.OBSERVE, (args, next) => {
      next(args);
      const [data] = args;
      const target1 = N2(data?.SourceMemberNumber);
      const target2 = N2(data?.Character?.MemberNumber);
      if (!target1 || !target2) return;
      if (target2.IsPlayer()) onPlayerAppearanceChange(target1);
    });
  }

  // src/subscreens/chaosAuraSubscreen.ts
  var ChaosAuraSubscreen = class extends te {
    get icon() {
      return createElement4(Shell);
    }
    get name() {
      return "Aura Of Chaos";
    }
    turnTrigger(triggerName) {
      if (!modStorage.chaosAura) modStorage.chaosAura = {};
      if (!modStorage.chaosAura.triggers) modStorage.chaosAura.triggers = {};
      modStorage.chaosAura.triggers[triggerName] = !modStorage.chaosAura.triggers[triggerName];
    }
    load() {
      super.load();
      let y5 = 240;
      this.createCheckbox({
        isChecked: modStorage.chaosAura?.enabled,
        x: 120,
        y: y5,
        text: "Enabled",
        onChange: () => {
          if (!modStorage.chaosAura) modStorage.chaosAura = {};
          modStorage.chaosAura.enabled = !modStorage.chaosAura.enabled;
          updateChaosAuraLastData();
        }
      });
      y5 += 90;
      this.createCheckbox({
        isChecked: modStorage.chaosAura?.retribution,
        x: 120,
        y: y5,
        text: "Retribution",
        onChange: () => {
          if (!modStorage.chaosAura) modStorage.chaosAura = {};
          modStorage.chaosAura.retribution = !modStorage.chaosAura.retribution;
        }
      });
      y5 += 120;
      this.createText({
        text: "Triggers:",
        x: 120,
        y: y5
      });
      y5 += 90;
      this.createCheckbox({
        text: "Clothes change",
        x: 140,
        y: y5,
        isChecked: modStorage.chaosAura?.triggers?.clothesChange,
        onChange: () => this.turnTrigger("clothesChange")
      });
      y5 += 90;
      this.createCheckbox({
        text: "Items change",
        x: 140,
        y: y5,
        isChecked: modStorage.chaosAura?.triggers?.itemsChange,
        onChange: () => this.turnTrigger("itemsChange")
      });
      y5 += 90;
      this.createCheckbox({
        text: "Pose change",
        x: 140,
        y: y5,
        isChecked: modStorage.chaosAura?.triggers?.poseChange,
        onChange: () => this.turnTrigger("poseChange")
      });
      y5 += 90;
      this.createCheckbox({
        text: "Magic cast (WIP)",
        x: 140,
        y: y5,
        isChecked: modStorage.chaosAura?.triggers?.magicCast,
        isDisabled: () => true,
        onChange: () => this.turnTrigger("magicCast")
      });
      y5 += 90;
      this.createCheckbox({
        text: "Ignore items change if not restraint",
        x: 750,
        y: 240,
        isChecked: modStorage.chaosAura?.ignoreItemsChangeIfNotRestraint,
        onChange: () => {
          modStorage.chaosAura ??= {};
          modStorage.chaosAura.ignoreItemsChangeIfNotRestraint = !modStorage.chaosAura.ignoreItemsChangeIfNotRestraint;
        }
      });
      this.createInputList({
        title: "Whitelist",
        x: 750,
        y: 360,
        value: modStorage.chaosAura?.whiteList ?? [],
        width: 800,
        height: 550,
        numbersOnly: true,
        onChange: (value) => {
          modStorage.chaosAura ??= {};
          modStorage.chaosAura.whiteList = value;
        }
      });
      this.createCard({
        name: "Triggers count",
        value: 0,
        anchor: "bottom-right",
        x: 80,
        y: 60,
        modules: {
          value: [
            new x({ duration: 1100, endValue: modStorage.chaosAura?.triggersCount ?? 0 })
          ]
        }
      });
    }
    exit() {
      super.exit();
      this.setSubscreen(new MainSubscreen());
    }
  };

  // src/subscreens/overlaySubscreen.ts
  var OverlaySubscreen = class extends te {
    get icon() {
      return createElement4(SendToBack);
    }
    get name() {
      return "Overlay";
    }
    load() {
      super.load();
      const options = [
        {
          name: "2",
          text: "Always"
        },
        {
          name: "1",
          text: "On Hover"
        },
        {
          name: "0",
          text: "Never"
        }
      ];
      this.createText({
        x: 200,
        y: 220,
        text: "Version Text:",
        width: 360
      });
      this.createSelect({
        x: 550,
        y: 220 - 30,
        options,
        width: 500,
        currentOption: (modStorage.overlay?.versionText ?? 2).toString(),
        onChange: (name) => {
          modStorage.overlay ??= {};
          modStorage.overlay.versionText = parseInt(name, 10);
        },
        modules: {
          base: [
            new i((target) => {
              if (target.style.zIndex === "100") target.style.zIndex = "10";
              else target.style.zIndex = "100";
            })
          ]
        }
      });
      this.createText({
        x: 200,
        y: 320,
        text: "Effects Icons:",
        width: 325
      });
      this.createSelect({
        x: 550,
        y: 320 - 30,
        options,
        width: 500,
        currentOption: (modStorage.overlay?.effectsIcons ?? 2).toString(),
        onChange: (name) => {
          modStorage.overlay ??= {};
          modStorage.overlay.effectsIcons = parseInt(name, 10);
        },
        modules: {
          base: [
            new i((target) => {
              if (target.style.zIndex === "100") target.style.zIndex = "10";
              else target.style.zIndex = "100";
            })
          ]
        }
      });
    }
    exit() {
      super.exit();
      this.setSubscreen(new MainSubscreen());
    }
  };

  // src/subscreens/dark-magic-subscreen/effectSettingsSubscreen.ts
  var EffectSettingsSubscreen = class extends te {
    constructor(effectId, spellSettings) {
      super();
      this.effectId = effectId;
      this.spellSettings = spellSettings;
      this.spellSettings = JSON.parse(JSON.stringify(this.spellSettings));
    }
    get name() {
      return `Spell Editor > ${spellEffects[this.effectId].name}'s Settings`;
    }
    setParameter(name, value) {
      this.spellSettings.data[String.fromCharCode(this.effectId)] ??= {};
      this.spellSettings.data[String.fromCharCode(this.effectId)][name] = value;
    }
    getParameterValue(name) {
      this.spellSettings.data[String.fromCharCode(this.effectId)] ??= {};
      return this.spellSettings.data[String.fromCharCode(this.effectId)][name];
    }
    load() {
      super.load();
      if (spellEffects[this.effectId].parameters.length === 0) {
        this.exit();
        return;
      }
      let y5 = 200;
      for (const param of spellEffects[this.effectId].parameters) {
        switch (param.type) {
          case "text": {
            const textInput = this.createInput({
              x: 200,
              y: y5,
              value: this.getParameterValue(param.name),
              placeholder: param.label,
              width: 800,
              padding: 2,
              onChange: () => {
                this.setParameter(param.name, textInput.value);
              }
            });
            y5 += 100;
            break;
          }
          case "number": {
            const numberInput = this.createInput({
              x: 200,
              y: y5,
              value: this.getParameterValue(param.name),
              placeholder: param.label,
              width: 800,
              padding: 2,
              modules: {
                base: [
                  new c({
                    type: "number"
                  })
                ]
              },
              onChange: () => {
                this.setParameter(param.name, numberInput.value);
              }
            });
            y5 += 100;
            break;
          }
          case "boolean":
            this.createCheckbox({
              text: param.label,
              x: 200,
              y: y5,
              isChecked: this.getParameterValue(param.name) ?? false,
              onChange: () => {
                this.setParameter(param.name, !(this.getParameterValue(param.name) ?? false));
              }
            });
            y5 += 100;
            break;
          case "choice":
            this.createSelect({
              x: 200,
              y: y5,
              options: param.options,
              currentOption: this.getParameterValue(param.name) ?? param.options[0].name,
              width: 800,
              onChange: (name) => {
                this.setParameter(param.name, name);
              }
            });
            y5 += 100;
            break;
        }
      }
    }
    exit() {
      super.exit();
      this.setSubscreen(
        new SpellEditorSubscreen(this.spellSettings, "Effects")
      );
    }
  };

  // src/subscreens/dark-magic-subscreen/spellEditorSubscreen.ts
  var SpellEditorSubscreen = class extends te {
    constructor(spellSettings, currentTab) {
      super();
      this.spellSettings = spellSettings;
      this.currentTab = currentTab;
      if (this.spellSettings) this.spellSettings = JSON.parse(JSON.stringify(this.spellSettings));
      this.spellSettings ??= {
        name: "",
        icon: getSpellIcons()[0].name,
        effects: "",
        data: {},
        createdBy: {
          name: O2(Player),
          id: Player.MemberNumber
        }
      };
      this.currentTab ??= "Main";
      this._oldName = this.spellSettings.name;
    }
    effectNameElement;
    effectDescriptionElement;
    effectTraitsContainerElement;
    effectAddElement;
    effectSettingsElement;
    effectAtomsElement;
    effectAtomsContainerElement;
    selectedEffectId;
    selectedSpellIconElement;
    _oldName;
    get icon() {
      return createElement4(Wand);
    }
    get name() {
      return "Spell Editor";
    }
    selectEffect(effectId) {
      this.selectedEffectId = effectId;
      const effect = spellEffects[effectId];
      if (this.effectNameElement) {
        this.effectNameElement.textContent = effect.name;
      } else {
        this.effectNameElement = this.createText({
          text: effect.name,
          x: 1e3,
          y: 315,
          width: 500,
          modules: {
            base: [
              new u({
                fontWeight: "bold"
              })
            ]
          }
        });
      }
      if (this.effectTraitsContainerElement) {
        this.effectTraitsContainerElement.innerHTML = "";
      } else {
        this.effectTraitsContainerElement = this.createContainer({
          x: 1600,
          y: 315,
          width: 300
        });
      }
      if (effect.isInstant) {
        this.effectTraitsContainerElement.append(
          this.createText({
            place: false,
            text: "Instant",
            color: "#3e2653",
            fontSize: 2.5,
            modules: {
              base: [
                new u({
                  background: "#d18cff",
                  borderRadius: "0.25em",
                  padding: "0.2em 0.65em"
                })
              ]
            }
          })
        );
      }
      if (this.effectDescriptionElement) {
        this.effectDescriptionElement.textContent = effect.description;
      } else {
        this.effectDescriptionElement = this.createText({
          text: effect.description,
          withBorder: true,
          padding: 3,
          x: 1e3,
          y: 400,
          width: 800,
          height: 280,
          fontSize: 3
        });
      }
      if (this.effectAtomsElement) {
      } else {
        this.effectAtomsElement = this.createText({
          text: "Atoms:",
          x: 1e3,
          y: 700
        });
      }
      if (this.effectAtomsContainerElement) {
        this.effectAtomsContainerElement.innerHTML = "";
      } else {
        this.effectAtomsContainerElement = this.createContainer({
          x: 1e3,
          y: 760,
          width: 800,
          modules: {
            base: [
              new u({
                display: "flex",
                columnGap: "0.25em"
              })
            ]
          }
        });
      }
      effect.atoms.forEach((atomId) => {
        const atom = atoms[atomId];
        if (!atom) return;
        this.effectAtomsContainerElement.append(
          this.createSvg({
            dataurl: atom.iconDataUrl,
            size: 50,
            place: false
          })
        );
      });
      if (this.effectAddElement) {
        this.effectAddElement.textContent = this.spellSettings.effects.includes(String.fromCharCode(effectId)) ? "Remove Effect" : "Add Effect";
      } else {
        this.effectAddElement = this.createButton({
          text: this.spellSettings.effects.includes(String.fromCharCode(effectId)) ? "Remove Effect" : "Add Effect",
          anchor: "bottom-left",
          x: 1e3,
          y: 75,
          padding: 2,
          width: 365,
          onClick: () => {
            const effectButtonElement = document.getElementById(`effect-${String.fromCharCode(this.selectedEffectId)}-button`);
            if (this.spellSettings.effects.includes(String.fromCharCode(this.selectedEffectId))) {
              this.spellSettings.effects = this.spellSettings.effects.replaceAll(String.fromCharCode(this.selectedEffectId), "");
              this.effectAddElement.textContent = "Add Effect";
              effectButtonElement.setAttribute("data-zc-style", "default");
            } else {
              this.spellSettings.effects += String.fromCharCode(this.selectedEffectId);
              this.effectAddElement.textContent = "Remove Effect";
              effectButtonElement.setAttribute("data-zc-style", "green");
            }
          }
        });
      }
      if (this.effectSettingsElement) {
        this.effectSettingsElement.classList.toggle("zcDisabled", spellEffects[this.selectedEffectId].parameters.length === 0);
      } else {
        this.effectSettingsElement = this.createButton({
          text: "Settings",
          anchor: "bottom-left",
          x: 1435,
          y: 75,
          padding: 2,
          width: 365,
          onClick: () => this.setSubscreen(new EffectSettingsSubscreen(this.selectedEffectId, this.spellSettings)),
          isDisabled: () => spellEffects[this.selectedEffectId].parameters.length === 0
        });
      }
    }
    load() {
      super.load();
      this.createTabs({
        x: 160,
        y: 200,
        width: 2e3 - 320,
        tabs: [
          {
            name: "Main",
            load: () => {
              const spellName = this.createInput({
                x: 200,
                y: 315,
                width: 800,
                placeholder: "Spell name",
                padding: 2,
                value: this.spellSettings.name,
                onChange: () => {
                  this.spellSettings.name = spellName.value;
                }
              });
              this.createText({
                text: "Spell Icon",
                x: 200,
                y: 450
              });
              const iconsContainer = this.createScrollView({
                x: 200,
                y: 515,
                width: 1600,
                scroll: "x",
                modules: {
                  base: [
                    new u({
                      display: "flex",
                      gap: "4px"
                    })
                  ]
                }
              });
              iconsContainer.addEventListener("wheel", (e2) => {
                if (e2.deltaY !== 0) {
                  e2.preventDefault();
                  iconsContainer.scrollLeft += e2.deltaY;
                }
              });
              getSpellIcons().forEach((icon) => {
                iconsContainer.append(
                  this.createSvg({
                    place: false,
                    dataurl: icon.dataurl,
                    size: 150,
                    modules: {
                      base: [
                        new u({
                          cursor: "pointer",
                          borderRadius: "4px",
                          flexShrink: "0",
                          background: this.spellSettings.icon === icon.name ? "var(--tmd-element, #e6e6e6)" : ""
                        }),
                        new y({
                          hover: {
                            background: "var(--tmd-element, #e6e6e6)"
                          },
                          active: {
                            padding: "4px"
                          }
                        }),
                        new i((target) => {
                          this.spellSettings.icon = icon.name;
                          this.selectedSpellIconElement.style.background = "";
                          target.style.background = "var(--tmd-element, #e6e6e6)";
                          this.selectedSpellIconElement = target;
                        })
                      ]
                    }
                  })
                );
              });
              this.selectedSpellIconElement = iconsContainer.children[getSpellIcons().findIndex((i5) => i5.name === this.spellSettings.icon)];
              if (this.spellSettings.createdBy.id !== Player.MemberNumber) {
                this.createText({
                  anchor: "bottom-right",
                  x: 300,
                  y: 115,
                  width: 565,
                  color: "red",
                  text: "Can't edit spells which were not created by you"
                });
              }
              this.createButton({
                anchor: "bottom-right",
                x: 100,
                y: 90,
                text: "Save",
                padding: 3,
                isDisabled: () => this.spellSettings.createdBy.id !== Player.MemberNumber,
                onClick: () => {
                  modStorage.darkMagic ??= {};
                  modStorage.darkMagic.spells ??= [];
                  const spell = modStorage.darkMagic.spells.find((s5) => s5.name === this._oldName);
                  if (spell) {
                    spell.name = this.spellSettings.name;
                    spell.effects = this.spellSettings.effects;
                    spell.icon = this.spellSettings.icon;
                    spell.data = this.spellSettings.data;
                  } else {
                    modStorage.darkMagic.spells.push(this.spellSettings);
                  }
                  this.exit();
                }
              });
            }
          },
          {
            name: "Effects",
            load: () => {
              const container = this.createScrollView({
                scroll: "y",
                x: 160,
                y: 315,
                width: 800,
                height: 1e3 - 75 - 315,
                modules: {
                  base: [
                    new u({
                      display: "flex",
                      flexDirection: "column",
                      rowGap: "0.3em"
                    })
                  ]
                }
              });
              Object.keys(spellEffects).forEach((effectKey) => {
                const effectId = parseInt(effectKey, 10);
                const effectItem = spellEffects[effectId];
                const btn = this.createButton({
                  text: effectItem.name,
                  place: false,
                  padding: 2,
                  fontSize: 3,
                  style: this.spellSettings.effects.includes(String.fromCharCode(effectId)) ? "green" : "default",
                  onClick: () => this.selectEffect(effectId),
                  modules: {
                    base: [
                      new u({
                        width: "100%"
                      })
                    ]
                  }
                });
                btn.id = `effect-${String.fromCharCode(effectId)}-button`;
                container.append(btn);
              });
              this.selectEffect(1e3 /* ANIMA_FURTA */);
            },
            exit: () => {
              this.effectNameElement = null;
              this.effectTraitsContainerElement = null;
              this.effectDescriptionElement = null;
              this.effectAtomsElement = null;
              this.effectAtomsContainerElement = null;
              this.effectAddElement = null;
              this.effectSettingsElement = null;
            }
          }
        ],
        currentTabName: this.currentTab
      });
    }
    exit() {
      const s5 = this.previousSubscreen instanceof MySpellsSubscreen ? new MySpellsSubscreen() : new DarkMagicSubscreen();
      super.exit();
      this.setSubscreen(s5);
    }
  };

  // src/subscreens/dark-magic-subscreen/mySpellsSubscreen.ts
  var MySpellsSubscreen = class extends te {
    deletionMode = false;
    get icon() {
      return createElement4(BookHeart);
    }
    get name() {
      return "My Spells";
    }
    load() {
      super.load();
      if ((modStorage.darkMagic?.spells ?? []).length === 0) {
        this.createText({
          text: "You don't know any spells",
          fontSize: 8,
          modules: {
            base: [
              new l(),
              new u({
                textAlign: "center"
              })
            ]
          }
        });
        return;
      }
      const container = this.createScrollView({
        scroll: "y",
        x: 160,
        y: 220,
        width: 900,
        height: 650,
        modules: {
          base: [
            new u({
              display: "flex",
              flexDirection: "column",
              rowGap: "0.25em"
            })
          ]
        }
      });
      modStorage.darkMagic?.spells?.forEach((spell) => {
        const _container = this.createContainer({
          place: false,
          modules: {
            base: [
              new u({
                display: "flex",
                columnGap: "0.25em"
              })
            ]
          }
        });
        _container.append(
          this.createButton({
            text: spell.name,
            icon: getSpellIcon(spell.icon)?.dataurl ?? void 0,
            padding: 2,
            place: false,
            modules: {
              base: [
                new u({
                  position: "relative",
                  width: "100%"
                })
              ]
            },
            onClick: () => {
              this.setSubscreen(new SpellEditorSubscreen(spell));
            }
          }),
          this.createButton({
            icon: createElement4(Trash22),
            place: false,
            isDisabled: () => !this.deletionMode,
            modules: {
              base: [
                new u({
                  height: "100%",
                  aspectRatio: "1/1"
                }),
                new c({
                  "data-bcc-delete-button": "true"
                })
              ]
            },
            onClick: () => {
              modStorage.darkMagic.spells = modStorage.darkMagic.spells.filter((s5) => s5.name !== spell.name);
              _container.remove();
              if (modStorage.darkMagic.spells.length === 0) {
                this.unload();
                this.load();
              }
            }
          })
        );
        container.append(_container);
      });
      this.createCheckbox({
        anchor: "top-right",
        x: 360,
        y: 250,
        text: "Deletion Mode",
        isChecked: this.deletionMode,
        onChange: () => {
          this.deletionMode = !this.deletionMode;
          document.querySelectorAll("*[data-bcc-delete-button]").forEach((b3) => {
            b3.classList.toggle("zcDisabled");
          });
        }
      });
    }
    exit() {
      super.exit();
      this.setSubscreen(new DarkMagicSubscreen());
    }
  };

  // src/subscreens/dark-magic-subscreen/limitsSubscreen.ts
  var minimumRoleNames = {
    [0 /* EVERYONE */]: "Everyone",
    [1 /* FRIEND */]: "Friend",
    [2 /* WHITELIST */]: "Whitelist",
    [3 /* LOVER */]: "Lover",
    [4 /* OWNER */]: "Owner"
  };
  var LimitsSubscreen = class extends te {
    get icon() {
      return createElement4(Ban);
    }
    get name() {
      return "Limits";
    }
    load() {
      super.load();
      const container = this.createScrollView({
        scroll: "y",
        x: 160,
        y: 240,
        width: 800,
        height: 1e3 - 75 - 240,
        modules: {
          base: [
            new u({
              display: "flex",
              flexDirection: "column",
              rowGap: "0.3em"
            })
          ]
        }
      });
      for (const [key, value] of Object.entries(spellEffects)) {
        const _container = this.createContainer({
          place: false,
          modules: {
            base: [
              new u({
                display: "flex",
                alignItems: "center",
                justifyContent: "space-between",
                columnGap: "0.3em"
              })
            ]
          }
        });
        _container.append(
          this.createText({
            place: false,
            text: value.name
          }),
          this.createSelect({
            place: false,
            options: Object.values(MinimumRole).slice(Object.values(MinimumRole).length / 2).map((r5) => ({ name: r5.toString(), text: minimumRoleNames[r5] })),
            currentOption: typeof modStorage.darkMagic?.limits?.effects?.[String.fromCharCode(parseInt(key, 10))] === "number" ? modStorage.darkMagic?.limits?.effects?.[String.fromCharCode(parseInt(key, 10))].toString() : value.atoms.includes(1e3 /* NOX */) ? 3 /* LOVER */.toString() : 1 /* FRIEND */.toString(),
            width: 400,
            onChange(name) {
              modStorage.darkMagic ??= {};
              modStorage.darkMagic.limits ??= {};
              modStorage.darkMagic.limits.effects ??= {};
              modStorage.darkMagic.limits.effects[String.fromCharCode(parseInt(key, 10))] = parseInt(name, 10);
            },
            modules: {
              base: [
                new u({
                  position: "relative"
                }),
                new i((target) => {
                  if (target.style.zIndex === "100") target.style.zIndex = "10";
                  else target.style.zIndex = "100";
                })
              ]
            }
          })
        );
        container.append(_container);
      }
      this.createText({
        x: 1100,
        y: 240,
        width: 650,
        text: `Here you can limit the use of certain spell effects on yourself.<br><b>Only</b> users who fit the minimum role will be able to use the spell with the effect that you limited.<br>Dangerous effects (those containing "Nox" atom) are limited <b>by default</b>`,
        withBorder: true,
        padding: 2
      });
    }
    exit() {
      super.exit();
    }
  };

  // src/ui-modules/shuffleTextModule.ts
  function shuffleString(str) {
    return str.split("").sort(() => Math.random() - Math.random()).join("");
  }
  var ShuffleTextModule = class extends r {
    effect(context, target) {
      const id = setInterval(() => {
        try {
          target.textContent = shuffleString(target.textContent);
        } catch {
          clearInterval(id);
        }
      }, 1e3);
    }
  };

  // src/subscreens/dark-magic-subscreen/tome-of-knowledge-pages/base.ts
  var BasePage = class {
    get name() {
      return null;
    }
    load(_container) {
    }
  };
  var PageMarkup = class {
    static text({ content, fontSize = "md" }) {
      const p5 = document.createElement("p");
      p5.innerHTML = content;
      Q(p5, {
        base: {
          color: "var(--tmd-text, black)",
          fontSize: fontSize === "sm" ? "0.5em" : fontSize === "md" ? "1.2em" : "1.8em",
          fontFamily: "Yusei Magic",
          marginTop: "0.25em"
        }
      });
      return p5;
    }
    static flexContainer({
      direction = "row",
      gapX = "0",
      gapY = "0",
      wrap = "nowrap"
    } = {}) {
      const container = document.createElement("div");
      Q(container, {
        base: {
          display: "flex",
          flexDirection: direction,
          columnGap: gapX,
          rowGap: gapY,
          flexWrap: wrap
        }
      });
      return container;
    }
    static image({
      source,
      width,
      height
    }) {
      const img = document.createElement("img");
      img.src = source;
      img.style.width = width;
      img.style.height = height;
      return img;
    }
  };

  // src/subscreens/dark-magic-subscreen/tome-of-knowledge-pages/basics.ts
  var BasicsPage = class extends BasePage {
    get name() {
      return "Basics";
    }
    load(container) {
      super.load(container);
      const t1 = PageMarkup.text({
        content: "True magic is not witchcraft, it is <b>science</b>. The ultimate science that governs the fundamental forces of the universe."
      });
      const t22 = PageMarkup.text({
        content: "The world around us, visible and invisible, is made up of countless <b>Magical Atoms</b> \u2014 primordial particles that are the source of all supernatural energy. A magician is not a shaman who invokes spirits, but an arcanist engineer who, by force of will and mind, gathers these atoms into complex structures \u2014 formulas that we call <b>spells</b>."
      });
      const t3 = PageMarkup.text({
        content: "There are only few <b>atoms of magic</b> known:"
      });
      const atomsContainer = PageMarkup.flexContainer({
        direction: "column",
        gapY: "0.65em"
      });
      atomsContainer.style.marginTop = "0.5em";
      for (const atom of Object.values(atoms)) {
        const atomContainer = PageMarkup.flexContainer({
          gapX: "1em"
        });
        atomContainer.style.border = "2px solid var(--tmd-element, #d4d4d4)";
        atomContainer.style.padding = "0.25em";
        const a5 = PageMarkup.flexContainer({ direction: "column" });
        a5.style.alignItems = "center";
        a5.style.justifyContent = "center";
        a5.append(
          PageMarkup.image({ source: atom.iconDataUrl, width: "2em", height: "2em" }),
          PageMarkup.text({ content: atom.name, fontSize: "sm" })
        );
        atomContainer.append(
          a5,
          PageMarkup.text({ content: atom.description })
        );
        atomsContainer.append(atomContainer);
      }
      const t4 = PageMarkup.text({
        content: "Until you learn <b>wild magic</b>, you will have to hold a <b>magic item</b> in your hands in order to cast spells."
      });
      const t5 = PageMarkup.text({
        content: "Such items are: " + MAGIC_ITEMS.map((m4) => AssetGet(Player.AssetFamily, "ItemHandheld", m4)?.Description).filter((m4) => typeof m4 === "string").join(", ") + "."
      });
      container.append(t1, t22, t3, atomsContainer, t4, t5);
    }
  };

  // src/assets/images/limits.png
  var limits_default = "data:image/png;base64,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HiwqKmIduqSkJC0t7dixY2FhYVu2bPnqq69eeeWVJ5544t57723evHmDBg28vb1r167t7u5ep04dT09Pynz66ackFCo2WLzkaVNN3m82DqUSFhzF1XETsQ7nqWeqw3lFhiqL8+E8T0wckdVkeha+WowLGRAAARAAARAAARAAARAAARAAARAAARAAgXISsFgs58+fj4qKCg0NLS0tJYWKjvwymUwHDhzo0aPHo48+umDBgpycnLIzQMnwU1Q/g4KCgoODd+3atXv37j179uzduzcsLGz//v2PPPIIaZqPPfbYf/7zHx8fH0eJUyyZNGnSunXr1q9fP2vWLJ1Od9ttt5E1Ipl7kk3ipUuXsoVErvA3XgBV6HqsDNI5AmTeSGpmSUlJenp6cnLy4cOH16xZ89FHH7322muDBg0aMGDA3XffXbt2bQ8Pj7vuumvixInHjx+/ePFiXFzc3r17//jjj48//viFF17o0KFD69atW7Zseeedd/bu3dvX13fgwIFDhw59/fXXhw8f/uKLLz722GNt2rTp2rXrqFGjdu7cqQhhoXYTsL7JvvYKHZOlRqfCqFgonkIlGnjS0CIoxRDiU5x3OmF+ljNOq6EQBEAABEAABEAABEAABEAABEAABEAABEAABBwJFBUVbdy4cciQIS+88EJaWhqH2yHf5fj4+Ndff7158+aDBg1KTk4uE0D/sqcdO3YE2lNQUBA5v5P6GRISEhoaum/fvv3798+YMUOn03355Zd0vGNMTMyRI0d27dr1559/fvPNN6L0qdPpfH19U1JSKNhRWlraihUrpk6dmpGRkZmZSdKnIHv+422dm5tLHvE3XgAljmztyFjJe500QTbnpJMFLBZLUVFRVlbWxYsXU1JSEhMT582b98QTT3h7e9eqVatt27aTJk3673//O2LEiKeeeqpVq1a33377I488Qlrnm2++uWjRoujoaGqYkpJCx2ImJiZu2bJl9erVYWFhKSkper1eI6IoT5KnzRmFoaVCxxRlR65JGfZkp64UEqfiWXaEF8sVY/EkmTD3TCPSEIpquAQBEAABEAABEAABEAABEAABEAABEAABEAABNQIlJSVBQUFdu3Zt0aJFamoq+XCT6CTLcmZm5g8//NCxY8euXbueOXNGkqQyAXSHPdHRn2rmnwcOHFizZk3t2rUPHDhw5MiRmJiYY8eOnThx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geRUbrVayeuczC1lWSYXeDc3t5o1a5L6SS7w7K5Ol3R8pyiPuru7e3p6/vnnn2QKKnq+s488ZWgs0QW+WbNmYWFhZONJvvMsD5IqSLPlChruztqrroidTU9PnzFjxn333efr6xsZGSmGMvpHAO3ZsycLoL/99lvr1q3/+usvOivUaDQuXbq0e/fuR44cEVtWxESvY5+VdQbodVzCv6QrCKD/ko3GMkEABEAABEAABEAABEAABEAABEDg30lAWwokM0xSEjliu81mW7p0KZt8cobVT0WGK3Cmdu3aPXr0WLduncFgUIRFUhiBnj59mr3syQKUAyhRTbJIFS1VebZWq1VtT7VXrdbKlXKyAL333nuff/75/fv3k70qiZllk/Hy8urdu/eGDRtyc3MlSVqxYsU999wTEBBAizQajcuWLXvmmWeio6MhgLqyDWjrlAAEUKdYUAgCIAACIAACIAACIAACIAACIAACIFA9CGhLgexLzkdtii7wCtNOPqyTJUvOkCmowke+QYMGU6dONRpLWfQUNU3SXhMTE1k2pTNARdtPR/VTtB6tUlHgyQL0rrvu6t279/79+2luJIOWWYDWqVPnueee27x5c15enizLP//881133bV161YScU0mEwugcIGvHi+8KrUKCKBVajswGRAAARAAARAAARAAARAAARAAARAAgetLQFsAJc93k8lEzuYcb/27775zVD9J5WQZVKxAhVyBXePr1Knz448/Uqgl1i5tNpssyzRWYmIiB5S/9dZbQ0NDeTJGY6nNnjgaEtl+cgWavFNc2qt22sTFwoyMjJkzZ9555509e/YULUBtNluZAOrt7T148OCwsDC9Xm+1WleuXHnnnXdu27aNhGej0fjDDz/07ds3JiaGYNFs2I7UxclVUHO4wFcQ2OveLQTQ644UHYIACIAACIAACIAACIAACIAACIAACFQdAleUAukUSj6sk/Q30QVe4fDOKidbbnKGatIl66TPPvtsVlYWObZTWCRJkkj9tNls6enp77777vvvvz9lypRZs2YlJydbrVaj0fjrr78ePXpU9Hxn/ZS0WjIOVeN8xVWrNbzm8szMzE8//fTuu+/u1q1bWFiY2E/ZZOrVqzdixIgjR44YjUar1bpixYqWLVtu27aNLUB//vnnF1988ejRo6IAKvZSBfOVKIBardasrKx0IWVmZmocCkv0MjIyBg4cSDcHP7q7u0+bNi0hIWHBggUvvvji7bffTpbMXKFJkyatWrUaNWrUqlWrMjMznW5EQUFBQEDA22+/3apVK29vb26r0+m8vb1btmz54osvzps379SpUxoHNzjtWZZlvV4vLLQsm5+f71hZkqScnBxFTbr08/MTp8R5Ly+voKAgp030er3jEI4lZrM5Li7O399/xIgRrVq1uu2227hzztx2220E8Lfffjt79uw1EHAcFyUgAAIgAAIgAAIgAAIgAAIgAAIgAAIgwARIheBLRYYVSYWz+dKlS0kFctQ0xRIWQzkjqp/UQ/PmzWNjYyVJUiitFCedYr6TTSiHYLp06dLfIdNbt24dFhZKDUn9dJytYjl8qb1qrnYdM1lZWXPmzLn33nu7dOmyd+9est2kdenc3d3r1q07dOjQ8PDwkpISWZZ//fXX++67b8eOHRzmacWKFQMGDDhy5Ag5z5Mj/HWcX0V0VVkCaEpKSps2bVhf48zfOuPRo0fVVmqxWIYOHcqVrznzxBNPnDx5kkaRJOnQoUN9+/Ytf29NmjRZvHixwWBQm6dYLknSggULnHY+ZcoUUfDV6/XPPfec05rXVlirVq1NmzaJkxHzZrM5ICDg2WefVYjF5RnL3d29X79+4eHhUEJFpMiDAAiAAAiAAAiAAAiAAAiAAAiAAAhcMwFSJNSak05H0dUlSTIajaS/kQs8235qxHwXdVL2fBdtQuvUqRMVFcXiJtt+igHoyf6UxECDwZCTk9OnT5+aNWu2adMmNjaWdB5WP3m2VcoF/tKlS/Pnz3/ggQeeeuqpkJAQdl63Wq1lAmidOnV8fX337t1bVFRksVh++eWX9u3bBwcHkz+/yWRauXLl4MGDY2JiaKsggKrdsrIsv/fee2pC29ChQ0ksd2yel5fXoUMHtYZXWz5v3ryUlBRHe9Jy9tOhQ4fU1FTHSSpKTp061ahRI6d91q5dOyIigusfOXKkTp06Tmtec2G/fv1KS0t5CMpYrda1a9c2adLkmrvlhk2aNFm7di1kUAVhXIIACIAACIAACIAACIAACIAACIAACFwtAVIb1FqRfSV5XZOXutVqtdls/v7+imM9HU07RZWTKovGofSsu7u7h4fHwYMHqVuDwRASErJ58+Y///zz/+xp/fr1mzdv3rRp04YNGzZv3rxx48ZNmzYtXLiwZcuWJKe2b/9YVFSU1Z7YjJRd49XWpb1qtVaulGdnZy9atKhNmzadO3fes2cPd1V2BqhOp2ML0OLi4vT09EWLFvXo0SMsLIxNW//888+3336bTAttNhuJwdxL1cxUigVocXFxz549WURTZLp3767mu52enn7HHXco6rty6ebm5krz++67LyUlRXtnd+zYoTFEQEAAN78xAui5c+c6d+6sMaVreKpz587nzp3jhSADAiAAAiAAAiAAAiAAAiAAAiAAAiAAAldLgBQJtVZGo5FsFSnQEAWFlySJzgB1c3OjCEViRmHyyRWoXKGK6nQ6T0/Pw4cPk3YZHh7evHnzW265pWHDho3sycfHp1GjRg3ticobNmxYr149VlR1Ot2DDz64b98+MlBVzFZtXdqrVmvlSnl2dvZ333338MMPP/7447t27eJY7rIsl1mAent7+/n5hYaGFhcXJycnL1y4cNCgQYcOHSIneaPRuG3bthkzZiQkJIi2n2xH6srMKq5tpQiger2+e/fuakLbdRFA27Vr95Y9jRgxonnz5mpjqZX7+PgMGTKEetCYqk6nGzx4sOjG7rhTAQEBaqPodDpRAL0BLvBRUVGNGzfWmI9Op6tVq1anTp1o7fTYs2dPxaGojj00btxYtGZ15IASEAABEAABEAABEAABEAABEAABEAABENAgQGqDWgWy/TQajbIs22w2dipfvHixoz87i5sK41DFAaAUHZ7M49zd3UkApTNGf/vtN0edlEpYSCV3e5JcqecaNWo89NBD0dHR4mytVquGdqS9ajUarpTn5OQsX778scce69ChQ3BwME2VBMx/XOAHDhy4Z8+eoqKi/Pz8NWvWvP3220eOHKE492azOSIi4qeffkpLS2PplLqgIwlcmVnFta1+Aujdd999/PhxkZjVav3222/pHnVU7hQlderUWbNmjcKnOzw83MfHR1GTLt3d3YODg8XhFPnyC6CyLFdoEKSYmBi1VdBa2rVrt2fPHsXaeTmZmZnz5s3TcJz38fGJjIzk+siAAAiAAAiAAAiAAAiAAAiAAAiAAAiAQPkJkDqhVp+Dv1NIIvYx9/f35wNA1SRLhcM7yaPs+c6XHh4eERERJPT9+uuvommn0x5IP6VBxTm0b9/+8OHD5BrOlqpq69JetVorV8pzc3N//vnnjh07tm/ffufOnWzHKUmSzs3Nzdvbe+jQoQcOHCgqKrLZbHv37p06dSrFuSeH94sXL8bExOj1empZxW0/iVQ1E0AbN24cFxfneBOYzeaRI0fSLaXxqCHhLVmyRK2hxqGlsixflQDqOHMuGTFihNMJ1KlT58iRI1xNLaPX63v37u20ByqcPHlyecI6Wa3W4ODge+65x2lXI0eOrMpyvxoclIMACIAACIAACIAACIAACIAACIAACFQ6AZIa1KbBnu90ACgFGpJlecmSJaJSybaf7vbk1OTTUbIkI1BPT8+oqChS+X7//XexK7YSFcdyOgRVaNu2bXJyMtl+knSrti7tVau1cqU8Ly/vl19+6dSpU7t27QIDA0U7zjIL0Hr16o0cOfLYsWMGg8FqtcbGxn7//feJiYnkAk/ysNFo5KM/ub0rc6rottVMAJ01a5Yasf3799esWdOpbMeFX331lVrzpKSkZs2acU0x06xZs6SkJLWGVUQA3bRpk8aBpyNHjtQwxnZcGoVRql+/vshBp9Npa8GO/aAEBEAABEAABEAABEAABEAABEAABEAABIgAiQxqNCRJImtKWZYpUDspbySAKmw/nWqXosGmY4UaNWp4enpGRkaS0vr7779Tn+TwrtPpatasSeIme76zkMoZlkdbtGgRFxdHXrYcVt7p0rRX7bSJi4X5+fmrVq168skn27Zt+9dff7GAWRYEiQTQN95448SJEwaDwWKx5OTkJCUlFRYWiq7yJIbSPKi9i3Oq6ObVSQDVtoXMzs5+8MEHFYKdeHn77bcnJyerAdcO3LR161a1hlVBALVYLL6+vuJixbya2azairg8NTV1wIAB3NXgwYNzc3P5WWRAAARAAARAAARAAARAAARAAARAAARAoPwESGFQq++oflosFooCL/qniyqnWM7SJEmfjpIlBUGKiIggoe/XX39l61HOsGzKGdHznYe49957N23aRK7hrNWqrUt71WqtXCkvKChYu3Ztt27dHn300R07drAAWhYEyc3NrW7duqNGjTpx4kRJSQnZe/IRn0RcHJufEgurYL46CaAPPvhgdna2GmRJkoYNG8ZqnWPG19fXYrGoNZdl+c0333RsRSX//e9/1RpWBQE0MzPz7rvvVpv8FReutjRZlq1W68aNG996662NGzeqHR6q0RxPgQAIgAAIgAAIgAAIgAAIgAAIgAAIgAARIOFCjYbFYpEkyWQyke+1yWQi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C/w/Aqibm5uPj8/06dMPHz68cOHCrl27vvvuu+np6TabLSoq6u2334YFaPm5ayuJFXcGqIsu8NrTvnkF0PJsXE5OzqefflqrVi2nAij9WrJu3TpooOWBiTogAAIgAAIgAAIgAAIgAAIgAAIgAAKOBLSlQI44xNIkhUVaunQpSZmKmO8K20/RCNSpazwFQTp06JCoXbI/u9VqTUxMZKW1adOmYWFhHB+JDvokQZaaiLMl0dZxvVSivWq1Vi6WkwDao0eP7du3k4z7jwCq0+lIAD1y5Mg333zTpUuXsWPHpqenS5J0+PDht99+u1OnTt98842Lw9/45rAAZUXvX2sBWv67LjExsU2bNkxMkaldu/a+ffvK3xtqggAIgAAIgAAIgAAIgAAIgAAIgAAIgAAT0JYCRadyDrMuy/KSJUvIMItlUArprjD5LI9xKEWB53M/SWDloPDx8fE8hOgCb7PZTCYTnxzKEeo5/BFleJmKjPaqFZWv16XFYlm5ciUJoCR9/n8BtGHDhtOnT4+Ojl6yZMmTTz75t6NwWlqaJEkREREjR47s0qXLkiVLrtc8blg//zYBVGO9EEDLc9elpKTcd999CumTLzt16lRQUFCeflAHBEAABEAABEAABEAABEAABEAABEAABEQCV5QCFS7wNpvNarWKLvBs2kmO7SSMst+6Tld2xCXJozVr1iRJlILCk/Woh4fHgQMH+NxPmpsk2Shz9uxZevy04gAAIABJREFUPjCUXODZ5FOWZavVSr7zpJ86GoeKKxXzV1y1WPl65S0Wy++///7MM89s376d4r+TU2/ZZCgK/LFjx3766acnn3zy9ddfv3jxoizLBw4cGD58eK9evX788cfrNY8b1o+GIFinTp0jR45UxEy0fckr1AVeY70uCqC+vr4Wi8URV9UMguQ4z/KXrFq1ihVPRcbNzS0wMLD8XaEmCIAACIAACIAACIAACIAACIAACIAACBABbSmQDTNJBmXDzKVLl7Bhpqhpurm58fmerHKycaiiJvXg6el5+PBhMtiMjo7+5JNPPv74408++WTmzJmffPLJu+++y1725ALv6PlOMigZgbKQarMntV3WXrVaKxfLLRbLqlWrevfuLQqgkiTp6AzQqVOnnjp16s8//+zSpcsrr7xy4cIFWZb37dv3yiuvPP/88ytXrnRx+BvfXEMQhACq2I5r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OXz4cGVlpaIou3btGj58+IIFC06cOKGqqtVqtdlsehAXMoAACIAACIAACIAACIAACIAACIAACIAACICA3xF49dVXiQ40cP599dVXddJMVQpQYgJPFKAWi0VRlNTU1BfsLjk5mVwBj0uQdNJgEAMEQAAEQAAEQAAEQAAEQAAEQAAEQAAEQMAfCaxYsaJz587kPNB6rAYNCQnp3LmzTvZ+kn6ybdu2mztAk5KSqAl8amrqsGHDnnrqqZUrV6qqKsuyP/YqyAwCIAACIAACIAACIAACIAACIAACIAACIAACIBDgBKpuZCJngA4bNuzEiRPkDFBRFIcMGTJ69OhNmzapqqooCrkcKcBhofogAAIgAAIgAAIgAAIgAAIgAAIgAAIgAAIgAAJ+R6BKARoVFfXiiy/+8ssvNptNluWUlJTx48cfPHjQarWqqooDQP2uUSEwCIAACIAACIAACIAACIAACIAACIAACIAACIAAIVB1BuhvfvObl19+OTMzkxi8p6amvvrqqydOnLBarYrdQQeK7gICIAACIAACIAACIAACIAACIAACIAACIAACIOBHBCRJqqioWL58uRAUFPSb3/zmueeeO3r06I0bN8gt8OPHj9+/f7/0H+dHFYOoIAACIAACIAACIAACIAACIAACIAACIAACIAACAUhAtjtypKckSUeOHBkwYMBjjz120wT+6aef3rdvX2lpqc1m27Nnzz//+c8jR44QfShJE4DIUGUQAAEQAAEQAAEQAAEQAAEQAAEQAAEQAAEQAAF/ISDLss1mUxRFkqSioqKNGzcmJCRMmzatSgEaHR09fPjw48ePE43n3r17J0+efPToUWL5TlWn/lJVyAkCIAACIAACIAACIAACIAACIAACIAACIAACIBCABBRFUVVVkqSvv/46MTExJiZm3rx5VQrQBg0aDBky5Oeff75+/bokSadOnVq9evUvv/wiSRI5FTQAYaHKIAACIAACIAACIAACIAACIAACIAACIAACIAACfkSA7OMkOtAvv/zyT3/6U4MGDUaNGlV1BmhERETfvn23bdtWUlIiy7LFYsnPzy8vLyexYQLvR80MUUEABEAABEAABEAABEAABEAABEAABEAABEAgAAkoiiLLMj0A9NixY++++26nTp3i4uKqFKDh4eF9+/b98ccfS0tLJUnKy8s7evRoUVERuQIeCtAA7DGoMgiAAAiAAAiAAAiAAAiAAAiAAAiAAAiAAAj4FwGizJQkyWazybJ89OjRQYMG/eEPfxDMZnNkZGT//v137txZWloqy7Ioim+++WZ6errVaiWVpFtB/avOkBYEQAAEQAAEQAAEQAAEQAAEQAAEQAAEQAAEQCBACEiSZLVaJUmSZVmSpP3793fo0KFPnz43FaBPPvmkKIoVFRWqqn799dfdunX78ccfSQK6DzRASKGaIAACIAACIAACIAACIAACIAACIAACIAACIAACfkeAKEDJXfA5OTlLly69eQu80WiMjIx85plnDh06ZLFYZFn+6quv/vd//3fTpk03btwgN8f7XW0hMAiAAAiAAAiAAAiAAAiAAAiAAAiAAAiAAAiAQOAQUBRFkiRyEqgkSZs3b3722Wf79u27YcMGQRAEcgv8Tz/9RBSgS5cubdGixffff0+1nzCBD5y+gpqCAAiAAAiAAAiAAAiAAAiAAAiAAAiAAAiAgN8RIFbsRAGqKMqiRYv69+//ww8/XLt2TTAYDJGRkYMHD963b19lZaWqqsuWLSM7QCVJUlWVXJ/kd3WGwCAAAiAAAiAAAiAAAiAAAiAAAiAAAiAAAiAAAoFDgBz9SW50z83NvXDhgsVikSRJICbwTz75ZGpqKjkDdM2aNW3atFm2bFlxcbGqqkQNGjikUFMQAAEQAAEQAAEQAAEQAAEQAAEQAAEQAAEQAAH/IkBN4MklSIqi2Gw2csVRlQl8ZGTkU089tWfPnoqKCkVRNm7c2LFjx0mTJh06dAjG7/7V0pAWBEAABEAABEAABEAABEAABEAABEAABEAABAKTALn+SJIkm81248YNYtdetQOUKECffPLJlJSU8vJyWZa3b9/eq1evv/3tbxs3boT9e2B2F9QaBEAABEAABEAABEAABEAABEAABEAABEAABPyIADn9kwpMb4RXFEUwmUwRERGPP/741q1bS0tLVVXdvXv3gAEDnnzyyfXr13MpaRbwgAAIgAAIgAAIgAAIgAAIgAAIgAAIgAAIgAAIgIB+CBCzd3ISKNnWSW5GqjoDNCIi4pFHHvl//+//FRUVqaoqiuIzzzwzYMCApUuX4hIk/TQhJAEBEAABEAABEAABEAABEAABEAABEAABEAABEKgRAVmWqxSg4eHhPXr0+PrrrwsKChRF2bdv37Bhw/76179+9NFHREtao0wRGQRAAARAAARAAARAAARAAARAAARAAARAAARAAAR0QqBKARoWFvbQQw+tXr06Pz9fUZSffvrp5Zdf7t69+5w5c8glSLgKSSetBTFAAARAAARAAARAAARAAARAAARAAARAAARAAARqREAwGAzh4eHdu3dftWpVQUGBqqppaWn/+Mc/unbt+s4776iqik2gNQKKyCAAAiAAAiAAAiAAAiAAAiAAAiAAAiAAAiAAAvohUKUAjYiI6NGjB1WAHj9+fObMmX/5y1+mTJmCS5D001SQBARAAARAAARAAARAAARAAARAAARAAARAAARAoKYEqhSgkZGRDz/88KpVq/Lz81VVvXTp0ueff96hQ4dXXnlFkiTYv9eUKeKDAAiAAAiAAAiAAAiAAAiAAAiAAAiAAAiAAAjogYCiKIIgCJGRkT179ly9ejUxgS8tLd2+fXunTp3+/ve/kwvjJUnSg7iQAQRAAARAAARAAARAAARAAARAAARAAARAAARAAATcJ1ClAKU7QNesWVNYWKiqqtVqPXHiRJcuXf72t7+R7Z9EDep+vogJAiAAAiAAAiAAAiAAAiAAAiAAAiAAAiAAAiAAAnogULUDNDw8PDExccWKFVevXiVXHmVmZnbt2vWZZ54hIsIKXg9NBRlAAARAAARAAARAAARAAARAAARAAARAAARAAARqSqBqB2hoaGiXLl2++uorogBVVbWgoKBz586DBg3CDtCaAkV8EAABEAABEAABEAABEAABEAABEAABEAABEAAB/RAQjEZjWFhYly5dli1blp+fT659Lyoqat++fb9+/YjxO3aA6qfBIAkIgAAIgAAIgAAIgAAIgAAIgAAIgAAIgAAIgICbBGRZvrkD9MEHH1yxYgW5BElRlGvXrt133319+/bF6Z9uokQ0EAABEAABEAABEAABEAABEAABEAABEAABEAABvRG4eQt8aGhot27dVq1aRRWgBQUFXbt2HTx4sCRJsixjB6jeWg7ygAAIgAAIgAAIgAAIgAAIgAAIgAAIgAAIgAAIuEOgygSeKEBXrlxZUFBA1J3Xrl3r37//yJEjFUWx2WxQgLqDEnFAAARAAARAAARAAARAAARAAARAAARAAARAAAT0RuCmApSYwF+9elWSJEVRSkpKhg8f/s9//lNVVVjB663NIA8IgAAIgAAIgAAIgAAIgAAIgAAIgAAIgAAIgIA7BKrOADWZTKGhoQ8++ODy5cvJJUhEATpx4sSZM2fC/t0djogDAiAAAiAAAiAAAiAAAiAAAiAAAiAAAiAAAiCgQwJVZ4CaTKawsDCqACVbPktLS+fMmfPxxx9LdqdD0SESCIAACIAACIAACIAACIAACIAACIAACIAACIAACLgm8F8K0GXLltEdoOXl5Z999tmKFStku3OdC34FARAAARAAARAAARAAARAAARAAARAAARAAARAAAX0SqNoBGh4e3rVr16+++urq1avE5t1isXz33XdbtmzB9Uf6bDZIBQIgAAIgAAIgAAIgAAIgAAIgAAIgAAIgAAIg4A6BqkuQwsPDu3Tp8uWXX+bl5Sl2Z7VaT506lZGRQSzioQZ1ByXigAAIgAAIgAAIgAAIgAAIgAAIgAAIgAAIgAAI6I2AYDAYQkNDO3Xq9Nlnn+Xl5RH5JEkqLy+3WCyKothsNihA9dZskAcEQAAEQAAEQAAEQAAEQAAEQAAEQAAEQAAEQMAdAjcVoB07dlyyZElubi7RdUqSJMuyqqqKohCPO3khDgiAAAiAAAiAAAiAAAiAAAiAAAiAAAiAAAiAAAjoh4AkSb/uACUKUHIGKLZ86qeRIAkIgAAIgAAIgAAIgAAIgAAIgAAIgAAIgAAIgIBnBGRZFgRBCA0N/ctf/rJw4cKcnByaEdn7SW6Bhz6UYoEHBEAABEAABEAABEAABEAABEAABEAABEAABEDAjwhUKUBDQkLuu+++jz766MqVK0R0chUS+dePKgNRQQAEQAAEQAAEQAAEQAAEQAAEQAAEQAAEQAAEQIASUBTlpgK0Q4cOCxYsyM7OpqpPGomcBMr+CT8IgAAIgAAIgAAlv/KoAAAgAElEQVQIgAAIgAAIgAAIgAAIgAAIgAAI6J9AlQKU3ALfsWPHTz/9lJrA072f1BBe/5WBhCAAAiAAAiAAAiAAAiAAAiAAAiAAAiAAAiAAAiDAEvhVAdqpU6fPPvssNzeX/IzL31lM8IMACIAACIAACIAACIAACIAACIAACIAACIAACPgpgZs7QO+//35yCRJnAq8oiiRJVqvVT6sHsUEABEAABEAABEAABEAABEAABEAABEAABEAABAKZwK+XIH344YdXrlxRFMVmd0QTarPZzp8/f+nSpUBmhLqDAAiAAAiAAAiAAAiAAAiAAAiAAAiAAAiAAAj4I4EqE3ij0RgSEtK2bdt//etf5Bb4q1evHj9+vLS01Gq12my2hQsXJicn+2P1IDMIgAAIgAAIgAAIgAAIgAAIgAAIgAAIgAAIgECAExBMJlNoaGibNm0++OADogBNT0//6KOPzpw5I0nSjRs3Pv744++//z7AMaH6IAACIAACIAACIAACIAACIAACIAACIAACIAAC/khACAoKCgkJuffee+fNm5eVlaUoSlpa2pw5c06fPi3Lss1mO378OEzg/bFpITMIgAAIgAAIgAAIgAAIgAAIgAAIgAAIgAAIBDiBKhN4rQL09OnTq1atunjxoizLkiRZ7C7ASaH6IAACIAACIAACIAACIAACIAACIAACIAACIAACfkegSgFqMplCQkLatGlDzgCtqKi4ePHiyZMnS0tLZVm2WCybNm06fPiw39UNAoMACIAACIAACIAACIAACIAACIAACIAACIAACIDAzTNA27ZtO3/+/Ozs7Nzc3MuXL5eXl0uSpCjK9evXR44cOX/+fJACARAAARAAARAAARAAARAAARAAARAAARAAARAAAb8jcPMW+D//+c/kEqSsrKxLly5dv35dtrvr168///zzc+fO9buKQWAQAAEQAAEQAAEQAAEQAAEQAAEQAAEQAAEQAAEQ+HUHKLkEqaCgICsr68aNG6qqKopSWlo6ffr0pUuXghQIgAAIgAAIgAAIgAAIgAAIgAAIgAAIgAAIgAAI6JmAJEk2m40oNlVVtdlssizfvATpz3/+85w5c7KysnJycjIzM61WqyzLRUVFBw4cmDZt2tq1a/VcMcgGAiAAAiAAAiAAAiAAAiAAAiAAAiAAAiAAAiAQyAQURZEkSZZlm80m2R3RcEqSJJjN5uDg4FatWr377rtZWVm//PLL2bNniQn8uXPnPvnkk0mTJm3cuDGQ8aHuIAACIAACIAACIAACIAACIAACIAACIAACIAACOieg2F1OTs6qVat27dpVUVFBdKBVO0CDg4P/7//+7913383MzPz555/3799fWloqSdLJkyenTJkyYcKE7777TufVg3ggAAIgAAIgAAIgAAIgAAIgAAIgAAIgAAIgAAKBTEBRFJvN9vPPP/ft23fixIl5eXlEJVp1BihRgM6ZMyczM/PHH3/87rvvioqKrFbr4cOHx9ndt99+G8jsUHcQAAEQAAEQAAEQAAEQ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EKhTAlarldx6BMv3OuWMzEGg3hPIzc0VRXHv3r0urk2rrKxMSUnZunVrSkoKdKB67hJ409Nz60A2EAABEAABHxPAtOhj4P5bHFWAzpgxIzY29sknnxRF8VcF6KRJk4gC9LXXXrty5Yosy59//nlkZOQTTzwBE3j/bXVIDgIg4C8ELly4IIriyZMn/UVgyAkCIKBbAuROpAsXLjiUkGo/t9oddKAOKekkEG96OmkIiAECIAACIKAHApgW9dAK+pdBURRVVRVFkWV55syZcXFxTzzxxK8K0N/97ncTJkw4ffo0vQVekqQvv/wyOjp6wIABP/zwg/5rCAlBAARAwK8JkO2fuPPdrxsRwoOATgiUlJSQTaAO5SF7P3fv3l1YWJiamkr2gTqMicBbTgBvere8CSAACIAACICAfghgWtRPW+hZEqIAVVVVkqQZM2bceeedffv23bVrl2CyuzvvvHPs2LEnT56cNm3aq6++euXKFUVRVq5ceeeddz722GPffPONnusG2UAABEDA3wnk5+eLopienu7vFYH8IAACOiGQnp4uimJ+fr5Wnq1bt+7evbuiokJVVYvFIooibH20lHQSgjc9nTQExAABEAABENADAUyLemgFP5KB7ACNiYl55JFHtm3bJpjNZpPJFBsbO2bMmOPHj0+dOvWVV17JzMxUVXXdunX33HNPnz591q1b50c1hKggAAIg4HcEMjIyRFEkz16/Ex4CgwAI6JBAZmamKIoZGRla2VJSUoj2k/xksVhSUlK00RCiBwJ409NDK0AGEAABEAABnRDAtKiThtC5GPQKeFmWZ82aFRMT89BDD/3www9VCtCgoKC4uLixY8eeOHFi4sSJL730EnkJ37BhQ4sWLR5//PH169frvHoQDwRAAAT8mkBaWpooirB/9+tGhPAgoCsCxAo+LS1NK5X21iNtiDYVQm4JAbzp3RLsKBQEQAAEQECfBDAt6rNd9CaVQwXopk2bhJCQEJPJdNddd7366qsnTpx47bXXXnzxRaIATU5ObtOmTb9+/aAA1VtzQh4QAIF6RmDfvn2iKLq4srme1RfVAQEQqGsCVqtVFMV9+/bVdUHIv04J4E2vTvEicxAAARAAAf8igGnRv9rrVklLzwAlJvB33HHHQw89tGXLFiE4OJgoQEeOHLl169Zhw4YNHz48KytLVdVvv/32gQce6N+/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V7oLPFkBKggCffQnuVXeZDJt3Lhx0KBBYWFhGo2G4zitVjto0KDdu3cXFRWJouhwOPLy8mJiYrp163bu3LmSkhLy8FFfVMOYIQABCDSiAK+URhwAuoYABPxPgFeK/80LM4IABCAAAQhAAAIQgABZBEr2YyfLOjMzM995552//OUvkydPvnDhgiAIO3bseO655yIjI7dt28b17Nnzf//7n9PpLCkpcTqddrud7H20e/fuqKio8PDwgIAAvV6v1Wr1Shk2bNiJEyfI/fKyLDscjvnz5992221nz54l+lgBik8hBCAAgZoK8Eqp6VmoDwEIQKASAV4plVTAWxCAAAQgAAEIQAACEPBRAbKVERk8CUAvXry4fPnyP/3pT2PHjk1LS3M6nUlJSfPmzbv//vvXr1/P9ejRY+fOnXTVqCzLly5d+vTTT7t06aLX6zUaTWBgoEaj0el0Go1Gr9c/9thjp0+fFgShpKSEPO5z/vz5rVu3/v3330keimeA+uhHB8OGAAQaUYBXSiMOAF1DAAL+J8Arxf/mhRlBAAIQgAAEIAABCECA3MVO8kwSgFoslv/+978DBw58+umnMzIyRFHMy8vbvHlzz549P/jgg9JngO7atYvsemS32w8cOPDqq6926tQpICAgNDRUr9c3a9YsNDRUq9VyHBcQEPDoo4+ePHmSPCGU/Dlnzpw2bdqkp6fj/nd8/iAAAQh4JsArxbNzcRYEIAABtwK8Uty+hRchAAEIQAACEIAABCDgBwLkDnUSgIqieOzYsT8Wbo4ePZqklLIsx8fH/+lPf3r//fe5Ll26rFixIj093Wg0btq0aeDAgcHBwSEhIcHBwddff3337t3btm0bEhJy3XXXabXaoKCgxx577OTJk+SBoaSDRYsWde7cOTk52eFwkA2U/ECwXqfgcDhOnTq19WqJjY29ePGi9z86wGq1Go1Gk8nkcDjq1cc7GyfTN1a72O1275xIo4xKEIScnByj0Zifn98oA/D+TnmleDxOe352tUu+3elxP758opMgNdXp+/Klw9g9FuCV4vHpOBECEIAABCAAAQhAAAJeK0BiNHIbOl2Ree7cubFjx44aNercuXOkwv79+++8884lS5Zwbdq0efTRR+fOnTtt2rQ77rgjODg4KCgoJCSkXbt2Wq02MDCwa9euer2+efPmgYGBer1+5MiRBoOBXWi6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BV4gEAiFQoFA0LRp00mTJoWFhcGcd50p0C7wtbC5yWQiQASIABEgAkSACDyEQE5Ozs8//0y+nw/BRKeJABEgAkSACBABIkAEahUB8PfMysry8fGRyWQlJSVarTY8PJwDAVQqldrY2Lz88ssHDhxQKpVaU0DdtFbVlIwlAkSACBABIkAEiAARIAJEgAgQASJABIgAESACRKDOEYDp7BqNJi8vTy6Xq9VqnU63efNmjuPubQQvlUodHBzGjx8fEhKiUChgIrxOp8OIVquF6fBarRYn1dc5kFRhIkAEiAARIAJEgAgQASJABIgAESACRIAIEAEiQARqHgHwADWYgk6nAw1z7dq1pQKowBSEQqFIJGrQoMGXX3556dIllUoFqdkrQUbV6/WwQmjNqyZZRASIABEgAkSACBABIkAEiAARIAJEgAgQASJABIhAXSSAMqbRaERhc9GiRZzYFDiudDt4W1tbiURSr169bt26Xbp0CfY+UqvV6enpN27cKC4uRodQvV4Py4PWRZZUZyJABIgAESACRIAIEAEiQASIABEgAkSACBABIkAEahIBUDxB+oTNjbRarU6nmzFjRun8d1gG1Nra2sHBQSqVisViGxubr7766vLly1qtVqFQXLx4cdGiRQkJCaiewlx40kBrUiuTLUSACBABIkAEiAARIAJEgAgQASJABIgAESACRKCOEgD3T1a9BBALFiy4N/9dLBZLJBKRSGRjYyORSAQCgVgs/vTTT3fv3q1UKrdv396jR4/g4GBQT8H9k9TPOtqbqNpEgAgQASJABIgAESACRIAIEAEiQASIABEgAkSg5hEADRRnrut0Oo1GM3XqVE5kCqh7wkR4Ozs7oVDIcZyrq+vixYuHDh36yiuvBAUFofSJc+FrXk3JIiJABIgAESACRIAIEAEiQASIABEgAkSACBABIkAE6hwBXPdTYwqgh06cOPHeLvAgg8I+SGKx2N7e3traWigUSqVSkUgkFApbtWq1ffv227dvQ0Z6vV6n05ETaJ3rR1RhIkAEiAARIAJEgAgQASJABIgAESACRIAIEAEiUPMIGAwGdNmEiE6ny87Onj9/fukaoLAMqEgksrKycnZ2rlevnkgk4jjOxsYGXEFtbGxcXV0/+eSTgwcPajQamAiPC4vWvPqSRUSACBABIkAEiAARIAJEgAgQASJABIgAESACRIAI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0+mA/7Vr1w4ePDhu3LiePXu2adMG/CihccVicYMGDUaMGAGLQqB2A/4v0MRDhgxZtGjRv0vz5ubmbty4cfDgwR9//HGXLl26devWo0ePT03r4Xbt2vW9997r1q1b165dP/roow6m0KlTp7dNoX379h06dOjUqVPHjh27du06bNiw77777qefftq2bVtMTAx0S3zVAXxQiHbu3PnGG2+Aqa6urrCXLu57Bu42YrEYbnN7e3uOK90hTSQSwV1va2vbvn37AwcOqFQqrVYLE/nhNoFeAQuuZWZm7t+/f/ny5UuXLl2+fPm6deu8vb03b968ZcuWjRs3rl69esWKFatXr15rCqtWrVq6dOmCBQtmzpw5derUyZMnT5w4ccKECf+7H8aMGTN69Gh3d/eRI0eOGDHiq6++AkXyiy++GDx48IABA/r379+vX7++fft+Zgr9TeGzzz7r16/fp59+2qdPn169enXv3v2jjz7q0qVLr169evfu3a1bt/fff//dd9/t0KEDIO3YseMHH3zQtWvXzz77bPjw4RMnTvzhhx9WrVq1ZcuWHTt27Nu379KlS/Hx8eBijMN99rsLeh3eHRhhbyXzx051HMGmLzNz0B/xsWMwGAoLCxMTEyMiIsLDw//55x/Qi+FPUBH3wz///HODCf/8809kZGR0dHRcXBxIz/Hx8bdv305LS8vLy1MoFPDBiboqQIB9tMq0qiIHETuwZeVakFrAfRtvdojgpyB+fcEdUZES2TRAFY/wmhXvdI1Gk5eXl56enpqaCh5q+D4GgYa9EPPECK/bQJVBDuB99uNtjlII2oYRlpharUbHZLwWOzBG4BJ4NQA6zI0i0EzwL37RAUxzOAifvco8WSWOYBeCCHYSyArLhSENPKshju2OOVSidLyEJYCdE+FgBLp0Xl7e2bNnv/3224kTJ27ZsmXPnj3Dhw9/7rnnJBIJvHccHByef/751q1bC01BcD/A2NTeFDiOg43gV6xYAX/t3rx5c9++fT08PEJCQsAwsCotLc3b23vIkCGjRo3asGHDzZs3q6TKWPcaEoHKwpAVnzNA3txC9tZm28s8JTQZ22/LpAelYzLMB49g/0ST0AY8Be9NfDhj0WxukIa90fAIyPrwpIIHPozc4F2gVCqLiorADQReRjBqLS4uTk5OvnDhwooVKyZPnhwYGIhfRwUFBYcOHerY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";

  // src/assets/images/spell-editor-main.png
  var spell_editor_main_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABvEAAAN0CAIAAAACiZPrAAAgAElEQVR4Aby9dVxXyfc/Tnd3IxZgYwcqYgsoqFgYGGCuirq2Yq7dqKtrrIGxNqigdCkISErDi+7u5rvO8/06n7svdH+feDx+54/Xa+7cuXNnzpxz5pwzZ+YK3b179x6D+/fvP3z40N3d/dGjR0+ePHn69OmzZ8+eP3/+4sWLly9fvn792oPB27dv37179/79ey8vL29v7w8fPnz8+NHHx8fX19ePgb+/fwCDwMDAIAbBHAgKCvL29r5+/fq1a9fc3NwuXLhw8uTJQ4cO7du3b+fOnS4uLhs3bty7d++tW7cePHhw69at27dvX7t27eTJk/v27Ttx4sSNGzfQyMePHz9gcP/+/Xv37v3555/37t178ODBw4cPnzx58vjxY3cGjx8/fvLkyaNHj6hr7u7u3PTTp0+fPHny/Pnzly9fPn/+/NWrV56enujjWwaenp5eXl7v3r0LDAwMDg4ODAwMCQkJCAgIDQ2NiIiI5ENERMSnT5/Cw8NDQkKCg4Ojo6MTEhLi4+NjYmKioqK+fPkSzYHY2NioqKjQ0FCgKCwszM/P78OHD35+fgEBAcHBwc+ePZs5c6a8vLyoqKi4uLiwsLCysrKSkpKQkJCoqKiIiIiMjIyqqqqCgoKUlJSoqKicnJy+vn6PHj1MTExGjRplxsDY2Lhfv35mZmajR48eOnSotra2vLy8pqamsrKyvLy8uLi4iIiIKANhYWERPgh3AxERERSgwkJCQiglxIB7F2XwCMqIiIiIi4tLSUlJ8EGSgYSEhIyMjLS0tKSkpISEhBgDUVFRJLgvRRovRTPpvdRYahJqoHqoPSIiImJiYuLi4hISEpKSklJSUtLS0rIMxP8J/Gb+VzE5OTlFRUUlJSUFBQV5eXn8ovHS0tJycnIyMjKysrIKCgqKiooqKiqampq6urp6enr41dPT0+eDgYFBjx49dHR05OXlCUuUoO6gm8LCwqKiooRqUIKEhIS2traenp66ujpGU0FBQU1NTV1dXV5eXk5OTkFBQUlJSZkRjIKCgtw/AV2WlZWVk5OjtKysLPqlqKiorKysxkCFA9RrbuUqKipqamqqqqr0LjQAL6QKqTHAIS6pbsX/LSjxAcPBfTW3x92bgefQZiUlJUVFRWCJsCEnJ0dPoXVos6qqKvCsoaGhrq6upqamoqJCVIEGcB/Ei1RUVFQZoDyQoKysjEyqU11dXUNDQ1NTU4sP2gx0dHT0GOjr6xsYGBgaGvbo0cPIyKhnz55GRkYGBga6uroaGhpKSkqysrJSUlKSkpJiYmLCwsICPALRIS0traysDPrR19c3ZGBgYKCvr6/HyFVXV1dbWxsd1GCAIaaOY+DU1NR0dHTk5OS4pCvwRhERETk5OQ0NDaBaUlJSlIGCgkK/fv3Gjh07ceJEc3PzESNG9O/fX09PT15eHnIAdYIpwaqioqLS0tIKCgri4uJiYmJgOhUVFV1dXVlZWfRXVFQUDSBRIPwjoDL/lwQq5tbQPYd7l2QXNxPd5LYWd39YFQ0oygOToqKikpKSCgoK6urqOjo6fBnz/V9PTw/jiOHDqGEgQHvEuRBf8vLyioqK8nzgCgdiBwUFBcgNPEIiFHIPTCQjI0PiXUJCQlpaWkpKCrKR6FNDQ0NBQQFiX0ZGRkpKSkZGBmSM3gEPIiIiAugiYSjMJiwxMTF1dXXQPCZEJSUlLS0tIJBEKGGVm0AZUA5ehDoJvXRJw8RtDFWFOZRqoGq5Tf3hgz8cZaqWO9zdH///LQeNBCqoSQKX3QmY2wuBp4BMUVFRjJeurq4BA1CsHpsoIeUMDQ21tbVVVVW5tXHJg5BAjeQm6C41T0hISEREREpKSklJSVtbG8yiqampqqpKYhwKlYSEhJycHCQ8GEFBQYGme9CblJQUBJSYmBipHGgAdDa+PvWff27bgBNQDiohdkZpUVFRUkKgrkhKSgrQGFWIftHrKJ8SqFxCQkJTU1NeXl5YWFhCQgJCABoFlURf1NXVtbS0VFVVJSUlDQwM1NXVZWRk0Ck0A+WhSoGDhIWFxcTEuNIb7aGaKUEdRA4NLumipLlBW0OTQHKkGUKXwy1CHe6KiYlRVYQToAglqSX0anQNCKcxJV0R+EfXiJbQnp/1kXuX2x1qMDUVr6NXYHYDYjHxSfFBWlpahg9QR1X4egUUCeg8EKcQrZKSkvQUJWRlZVENBD4pPyBvrh4O5RM5hGRiZxpH3KJLaryEhAS6Q51FgqoCwVAx2DWQDzRGwCR34DC4AlUhk4abXkGJfxkpIgN6nNgTlou4uDiEObWNasN7uUijMtQF0CpqwLvoRWge4YeqlZCQwJyIXyhOIiIiEhISCgoKGhoaOjo6qqqqMjIy0PYVFRWhIKmpqeFFoDoStmBPKSkpYWFhSUlJTU1NOTk5mD8gBjk5OUlJSXFxcW1t7fnz59++fdvT09Pb2zsuLq60tLS5ubmtra2DD52dna2trW1tbUjQb0dHR1NTU3Nzc2Zm5ocPH+7fv79p0yYTExMZGRniZegGkG+gUhAAmgr+IjyIiYmhVdxxRJrIQFxcXFpaWklJSUdHp0+fPoMHDx4zZsykSZNmzZo1d+5cR0fH3bt3X7lyxd3d/fHjx3AOPGTg7u7+119/vXz50sPD48OHDwEBAUFBQSEhIeHh4TDe09PTS0pK6uvrm5ubm5qaGhsbmxhwE80caGGAjJaWltbWVvy2MkC6ra2ttbW1ubmZbnETLS0teFdTUxPSuETN9Nvc3NzY2Mh58/fm/Y+gsbGxnkFdXV1VVVVZWVlhYWFOTk56enpycnJsbGx8fHwCg69fv37+/Bnui8jIyNDQ0KCgIB8fH28GT548efjw4bZt23R0dEg2QilVVlZWUFCQlpaWkJCAgBUXF8eIS0lJKSgoqKqqKikpycjIkPqqo6OjpKQkJiYGNiHGpEsiEsrhJiQlJdXV1ZWYQQd6JosDokxKSmrgwIEuLi7Xr19/+vSpj49PWFhYZGTk169f4ZtJSEjIz88vLS1NTEz8+PHj/fv3Dx48OHjwYMz1EKcC5EfiC0QLSQ6fBglzriiAlKMcgZmCKxAoDS0a8hm6B1oizQA5kFHE75A50tLSqASzNlgGrUJJagZ1itiKhDPNWbiFX/SCRlxAoOGSW6eYmJiMjIyysrK6urqenp6hoWGfPn0GDhw4cuTICRMmTJ48edq0acuXL9+zZ8/Jkydv3Lhx4cKFDRs2HDhw4NGjR8+ePXNnLrt79+6dPXt25syZsrKypLeIi4vr6elBYhMyheANvH///oMHD9zd3R89evSY+QH/+uuv5wxevnz56tWrN2/eeHh4eHp6vnv37v37/w+HZiCDoKCgYAYhHAgODg4JCSksLKyoqKiurq6srKyoqCgrKyspKSksLCwoKMjLyysoKKivr29qaqqtrW1gUFNTU1RUVFZWRiKGeJ6kACQFOB8CpaWlBayOWyhJxSAUqqurvby8rjC4ePHi/v37N2zY8Ntvv6WkpHCFEaqFSGpvb29paWlrayM51d7e3tbW1tDQ0NzcDHGPMs3Nze0MOjo60KT29nZU28YB5FDDWltbMzIyVq1apaysjClKTExMUVHRwMAAtAjuBU1DLowcOfLhw4eRkZGfGYSHh8PB+vnz56ioqJiYmC9fvsCb7O3t7efn5+/v//HjRy8vL09PTxrWdwzgwH379u27d+88PT1fvHhx+vTprVu3Llq0aPbs2bNmzZo6deqkSZMmTJgwZswYMzMzY2NjXV1dJSUlSUlJYhKurAHpc0kcjEHcRSyB3oEhIf6QQ1q7AKehHmixpGyhDVQnLkmqEovSLEu6FD3C5UkoHFAyyAsMvY00Nnhs4RGD+INog0YCpQFOQ/IYqqioQKuAlxkOSmoqKUDUFwhlNBVeAzgUoKoqKSnJycnBUFFUVJSSkkLvoDGjtRC+1GYqQBoVdUqgPEltKP0oT/MTvYLqgSJCFgKVpwKkx1MZqkQgQY9QAo9QXwTK//CSnqURRw4XFd1vkZlBCisq5/pruK8jLFHlhEbqJlGFnJwc31T57oKkTlECbyHPO81neAqMT1MaVFu+M+q7Z4qcvEjABEI+fO7kXSULBzXTe9EqukTDqO9k3sNlKSMjA+4TFxcH44uKiqqpqUE0ycvLS0tLi4iIGBsb79y58/Xr1/7+/sHBwV++fElISIiJiYmIiAgLCwsMDPTz8/Px8fH09Hzw4IGbm9uuXbsWLFhgbGwsKiqqqqqqoaFBzCshIQEHmby8vIqKCvquq6urr68vKytLwgfsQ5dIIJPLWT8sRhM2lefWQ9MniR3uXYE0CTGaekEk3GdFRESkpaVVVVX19fWNjIz09fW1tLTUmd9cnQENIi0YkIsQcgb58CFyCYYGEQTDpTciaaJV8DXWnwjb4A4u00FAERIghymTPAioFuIUj9P6FhoP1QT+I9AYsA1HCYaAi0xCIFCKxTlaj9HQ0BAREVFQUNDV1UUboB93H1+0HGUkJCS0tLT09fXl5eVRFYSquLg4+Vvh2MIQqKmpaWlpaWtra2lpcVcgdHR0DA0NjYyMDA0NDQwM1NTUaEIkAuD2BWmiLm6ie7H/RU73Xncnae5Lu6cFJlZuG2ggREVFpaSk5OXlDRn06NHD0NBQX1+flkaw4gVBJCsrCxsVko3mRCUlJRUVFUVFRSCcpjZMqdDgSVKBtmnQ4U9XZKCkpKTKHJQqKirKDOD3gbiDR54elJeXhz1AopuMB7QW0z35dLjuPBA8YUxISIhWbTHWZERBNMnIyEhISFB5ShDjgEdIIBBnYQhwl0tFKED1cIeG0rgL9wF8HDAyFRQU0GAVFRXIFvLwqqurS0tLa2lpocGkNUGqQCAoKiqampqOGzdu2rRp06dPHz16dK9eveAqJb2F2kAk1z3nh41Hv0iSoAzJAXqEuiZQUqAAaoOwhe5EGCZ1FJ2iUROogTCPBE3uELmgT1IggWTSCugV3DoFKqRnUUYASxCJkNjckiRg8QrIZxosKkkdRzHuL9iQ22vygqENhCiUgU4OTkH93E4JpEHVVDkluMXodd3vElPgRRh9gTp/RieEQO67UFhghYxKUgKOPzjI1NTUMBGbmpoOHjx4xIgRY8aMmTBhwowZM+bNm7dkyRJHR8cNGzbs27fv9OnTly5devr06fPnz1+/fo2AmLcM3jHw5MC7d++8vLw+fPjg7e39ng/v3r2DtUW/SHxggLAhb2/vt2/fvnnz5v37935+flFRUUePHtXV1YWzAAJTRkYGC+pAKYW/oF/CwsJYMcLyDIQbvEuQXUOHDv3jjz/Cw8NTU1MbGxvheuO7MTva29s7+dDR0REcHHz8+PHTp0+npaXxszvb2tpg7ba2tsLxl5ubGx4e7uvr++bNmxMnTlhZWRkYGEBhwzKnktL32AsNDQ0DAwMTE5Phw4dPnDhx2rRpNjY2c+fO3bhx4+XLl1++fPn+/fs3DGCuci1W+F59fX0RDPTp06fIyMjY2NjExMS0tLScnJzi4uLq6urGxkaux4Bsba67AGZ4a2sret3S0gKzvbW1FX1EPvW3s7Ozq6uLUITyXT8HlO/q6kINlKB81AZU49VctHOLcdPdX8htLbWZ2inwLLc7HR3fBxq+C5SHQ4NQB78H3CDwX7e0tGRnZ3t7ey9btkxHR0dERASr7NLS0rAEIaKh6QkJCZEeCJsaeiDCmzDpiImJSUlJKSoqwndP6/QIBjIyMurBwJCBAQN9fX2YG8rKytBdYc5A4ikrK0+cOPHSpUsfP34MCwvLyclpaGigjqC/+IXjvqurC/6cpqam0tLS8PDwjx8/PnjwYO3atRMmTOjTp4+GhoaEhARxmTADET5AsnEnJkziJGeQIAGLx7m/qIlySIzTVIUCeBEpaVSeGkATAclYmo5RmFoCvwoiRWAhamhoQCswMjIyNjYeNGjQ0KFDR40aNXbsWEtLy5kzZ1pZWc2bN8/BwcHR0XHNmjU7d+48f/78w4cPPTw83r9/D5nmyeDt27cI1/Pz8/P19Q0MDAwNDYWj/OvXr3FxcbEMcnNz8/PzKyoqGhsbKysrs7KyiouL4aNraGiAH6+iouLUqVOamppYm4EQk5OTg4Sn7gjdY/CARTg+YiAQpPnq1avXLEjTkwUwvuc7NL29vT/+KEITsYfBDEL+CaGhocioqqqC1xISpJMPYCRQGPLa29vBaR0dHZ2dncTwkAhdP4KKiopv3755eXk9evTojz/+OHXq1LZt25YvX25jYzN+/HgzM7MhQ4aMHj16HIOZM2c6OjquXbvWycnp2LFj3t7e8fHxPB6vtrb23bt3W7Zs2bFjx6dPn/De1tZWvBeNwS9aRTktLS1dXV1NTU2dnd+lfHp6+uPHj1+8eJGYmNjY2EjdgWSB05MWvjo6OlB/Tk7OoUOH+vbtKykpiWAoWuySkJDQ1dWFUgKCXr58eWxsLNZ26uvrMbW0tbU1NTW1traCP2k5CK5YWi/ieFb/k0R5XLS0tNTX11dUVOTn52dlZWUzSEtLS05OTkpKio+Pj42NjY6O/vLlC7yooaGhwXwI4kBgYOCLFy9Onjy5fv36FStWODg42NnZWVpajh8/ftSoUYMGDerVq5eGhoasrCyCrWAS8KXE92BSiADiW9J7wPBUkvK55joxOSk3XPUO65+kiVKCBIGwsDDsWzgTSZSQbkf2M3gMggMNE5BceBaNhMFPfislJSUDAwOMNSrEs6SKASfq6uowIzFnkDVFpgu32YQu4naBHJJxKECX1GzUxr2LMoRAkrP0CArQG6ENc9eRuCWpZoGEQBmBS4HC3Evq4M8eIVIBMVBHuH0XeBZ14kE8hV5TMQwNoYKGAAMNUxkr6vDuER1yW44G0LNURoAA4HXi+qdoVqOugcxAYAKuW5AlPYIGcFGBXuAt4AW8C9QuKytLxjlMKayvGBgYwA+lqalpaGiorKyMUD6oNTY2Nq9evYqLiysrK4OuDCkEwU4LP6RYNDc319XVlZSUlJaWvnv3bunSpRoaGogv0NDQAA7RL7Qca/XwScnJyeno6PTu3btnz54wzhG4SmgknONZ7iBioKnAzxICxbgkJ8Av3BpERUWxLtW7d289PT1lZWW4xhBjC2+OrKwsVrbJ/U0uSNgA8Iaj7xhuEDC1AfYJMSm5I+GaEWge6ATUS0oYyhC6sAlAQ0MDi6uDBw8eNmzYyJEjx44diyXWKVOmWFpaTp06dfbs2UuWLHFyclq/fv26detWrVq1ZMkSZ2fnQ4cO3bhx4+7du0eOHLGzs+vVqxcpu3Jyctra2pqampCc4BeBcQEOqeV0V15eXk1NTU5ODgt+cnJykIHw7aqqqkpJSRFHYJRp4JCQk5MjCsE6EKKYucvsqBOxBoRwYiKuL5jYAfEvaIacnJySkpI6802rMlDjAy7hVBL4JVepjo4OIv2h2ev9CHR+Atp80OIA4q8FXvezSy0tLQ0NDVXmJVRlIepq/Kh8+AchGeAChn8Hzl/QMLBEsogmViCNRBAGlCZTcs1AEIG8aYUJlXBvoQDe9cP87o+AlkADCCKGNgW2oqkKfivwBTcaER4ECj/hdoTIjKYVLgXKycmpqqrq6Oj07NkTG2hGjhw5btw4S0vLadOmWVtbw0hYu3ati4vLqVOn3Nzc7ty58+DBg6dPn3p6evr5+YWEhITyVWjoWVCn+TrXP/6hjGEzkIeHx44dOxQVFdEejCbQJSkpqcw2DcjLy6uysVZQUIDlKSwsbGZmduTIkYCAgLCwsODg4LCwsIiIiK9fv3779i0jIyMzMzM5OTk+Pj4yMhIFOErffyUDAgI+fvzo6en57Nmz+/fv37p16/fff7/M4NKlSxcvXjx//vzZs2fPnDlz4sSJ33777dixY4cOHXJ1dT3MhyNHjhw+fPjIkSNHjx7FXezr2rFjh4uLy5YtWzZt2rRhw4b1DNauXevo6Ghvb29tbT2TwYwZM6ZNmzZ58mSsxI8YMWLQoEG9e/fW0dHBuoi0tDTGXUCcklxFgks53JEVKEaXJP+JyCmHm8BdVAgSwl2qBwnSEEgYcishmU+N7G7T0ouoQjyFfJpS6b24CwUGXgYDA4O+ffsOGDDAzMxs6NChw4cPHzVq1JgxY8aOHWtubj5hwoQpU6bMmDHDysrK2traxsZm9uzZtra2c+fOnT9/vr29/QIGixcvXrZs2apVq9YxWL9+/caNGzdv3uzi4rJjx449e/YcPHjw6NGjp06dOnfu3MWLFy9fvnzlyhU3N7fr16///vvvN27cuH379sOHD58/f/7hwwcfHx9/f/8gFkDDZZCQkJB/8MNPLkJCQsLCwsBWoaGhYWFhnz59+vz5c0xMTFxcXDwfvn37lpKSkp6eDrLPzc0tLi4uKyurrq6mWBaEs8C2oniXtm5AATdUnuJjkNPQ0ICHuDF9VE17e3tzc3N6evrfToTevXtjuCUYiImJKTPAgEL3FhMT09bWxpoQpJaoqKiSkpKGhga0jlGjRp05cyYmJqampgaVk9sLNmxnZ2dHR0dzc7O/v7+zszPm+r1793779g2OvJaWFtiwMH47GcBDB+9ha2trTU1NYmJieHh4JB9gNuIqKirq69ev8fHxSUlJaWlpGQwKCgpqa2sJSxRXRKigBBmt0CE7OjpgBaMlMN67+IDuUB+RLXDZ2tpaUVERFhb29u1bbAm9e/fujRs3fv/9dzc3t0uXLl2+fPnSpUsXLly4evXq69evY2Ji0FTUQ7URKmDX0yUV4/oQ2tvbT58+PWrUKAsG5ubmkyZNGj9+/Lhx48YyGDdunDkfxo8fP+FHMH78eHNz83F8QDE8PnbsWG4N5ubmEydOnDRp0uTJk6dNmzZjxoxZDCA2rays7Ozsli5d+ssvv+zdu3fPnj2urq4+Pj51dXXU5paWFiC8paWFx+OFhoaePXvW1NQUUcPKysqKiopYyIQRjcBJYWFhODExq4JKJSUlsQcITkkKJQFhk/LADS6G+gH3JWomaxqV9OrVa9++fVFRUVlZWVVVVYgng4+lgwENE2iAMpEgomptbW1oaMjLy0tOTo5h+26joqIiIiJ8fX3v3r27b9++5cuXz5kzZ8aMGRYWFubm5tgp279//969exsaGsKJDw2T1JUfCmcS/pSA/gnnQL9+/UaPHj116lQ7OzsHB4eVK1cuXrx47ty5M2bMGDt2LGY0AwMD7OczMzOzt7f/O4T25s2bISEh2EYcFhYWwiA0NBRSDjkQevgNDw+PYPDly5fIyMjo6OiYmJj4+Phv376lpaUlJSUlJyen8yEzM7OIQVlZWU1NTVPTd48TAbEnEsAnXFLwm4N+YAZCkhBfCCwkkHvt/Pnz8IHAbKH5CxLvP3i7d+/e/fv3Hz586M4P0nz69Ck3SPP169dvWJDmWxa7hy3n3R2aAQwCAwNpdgH6MM2EstkCk0doaGhZWVltbS26xCWsTj7AWQ76a2lpCQ0NPX78+NKlS2fNmmVhYTFmzBjsWBwwYEC/fv1MTEyMjY378gGDamRkZGpqOmLEiKlTp86dO3fNmjWnT5/+8OFDHIPY2NiEhIT4+PiUlJTc3NyioqKCggKE2ZNpHR0dfebMmW3btn3+/Lm9vb2pqQmCCa0Ch6C9cPDDq4ic+Pj4efPmjRgxwtTUtGfPnr169erfv//06dMPHDiQnJzMHWP0FE9hDmtvb6+vrw8KCrK3t4fKRdpGDwbKyspQOrW0tDZs2BAREYHwVbBiV1dXQ0PDp0+fli9fvm7dujdv3kAMgSwg37k4B6mRnILXlUQwJdBC9JoqwfSA95LrmS65idbW1rq6uvLy8tLS0pKSEiA8Nzc3JycnKysrIyMDrtJv374lJibCWwqH6cePH69evbpt27bFixfb2NiMGzeuX79+urq6ioqKtCGLdDvSxmBpQHDARUhWOhVGAhIWGi2JEiEhIZhJeAp+T+CcHJf0OJltZPpSDirBMgiFuXGtIPAkjHwRERGoGuTDpXglKC5KDBBrLSkpqa2tPWTIEEtLS3t7+927d//xxx/g5fv37z948ODJkyceHh6+vr5hYWHR0dFfv36NiYmJjY2N4wMuYxnExMR8/fo1KioKxom3t/fjx4+vX79+6tSpffv2ubi4bNiwwcnJCf7oRYsW2dnZTZ06dfz48WPHjh05cqSZmdmAAQOMjY179eplZGSkxSKYsHQmLy8PzYm6D2Im+1NgOHApwgByioJzxcXFMe1hOVqRgZKSkr6+fq9evXoz6MMAksDExKRfv34DBw40MzMbMWIELWOMHTt2DB/GjRs3fvx4LA5Pnz59BoPp06dPmzZt6tSpUxhYWlpOmDBh5MiRAwcO7N27t76+voaGBiJtaZL+YS+4ApdkLmZ3okzug1QGmSBmkCKRBPcWl1zhDwK9oXLiBe4rKI130WX3puKNaC3oEHuXMJeIiYlh/wiUD3l5eUlJSewAkpGRQWMkJSWHDRt27dq1vLw86PENDQ1QN2lxqK2tjSQMiQua2CCKs7Ozb968OXv2bDU1NXCipKQkWg6WxPkbwIaYmBg4FI5OBHkhnBMLv7q6uj169OjZs2fv3r35M0bfPn369OzZk0LMdHR0tLW1tRiosVMdNDQ0tLS0dNg5AJhfDA0NqZ4+ffqgKuzfx7OamppwIVEMGqlcFCYDOoeiAx5HDhCIcSTPI9EDBBoJIowIyTdccr0qRCcYdOhJiBA3MjLCBhAbGxsnJ6eLFy/6+/unpKTEx8fHMKMuISEhOTk5JSUllUFaWloWW9zKycnJZZCdnV1cXEwbLMrLyysrK8vKykpLSysqKsrLy+sY1NfX19XV8Xi8mzdv9unTR1hYWFpaWlhYWFZWVl9fH/1FB4EHLn0ize0FSkKQCgkJycjIIHwSp7XA4yYjI2NgYKCjowNqQbUyMjK9evUyMDCAjYfjDoBhbiLSvIkAACAASURBVNQezHjuNihgFcEF0JiBYcqh4UA+0SGNDvUOr4OyThMEN0E0wCUPEIPArf/pJVHFfzNBDSCjgtqJjsP/CyGAOmn4CGOQ/DSXkczB4pyMjAwqgfteoBguueQBNHJ/qULwBbyikAykBtAkQk2FKYUpG9IPLZeWllZUVKRTNYABxDpRdAZ0BmVlZV1dXWNj49GjR8+aNcvBwWHbtm1nz551d3cPCQmJjIyMi4tLYEpmXFwcuCkxMTElJSUjI4OYKC8vLz8/v6CgALuU8vPzi4qKysvLa2pqoNTBKQANkyTkfz8Bh0tLS0tVVdW3b9/Wrl2L9Sr0BTQP41BMTAwTK3AyfPjw2NjYgoIC0h5JMcbbofu1tbVBY/xZC3EXyiFZNfD4YBMlJAOkRF1dHS5ramqqq6trGVRXV2NTFy5ramqqqqqQQ+ny8nLInLKysgq28auwsDCfQUFBATCcn58PhTM3Nzc7OxsWWmpqakpKyrdv3zBSsQz4KtJ//pEJdfTTp0++vr6vX79++PDhzZs33dzcTp48eYLB8ePHjx49evjwYVdX1wMHDuzbt2/37t3bt2/ftGmTs7PzqlWrVq5c6cyHtWvXruPDpk2bXFxctjFwcXHZunXrFgZbGWxmsHXr1u3bt+/atWvfvn2HDh06efLkpUuX/vjjD2h6L168CAgICAkJQfwLPETUbIFEXFwc1OzExMSEhAQQJ/RD6IGxbPNpIh++ffuGKQBOvczMTB6PB6sW6ezs7Nzc3Ly8vNzcXB6Ph4ibAgaFhYVQ9UHhIPKioqLS0lKyBbB4WV5eXlVVhQGtqampq6traGhobGxsaGgASYCSm5ubkdPU1NTW1vZ/5A6QJdFwBwfa2N7qTj7gDoiZn/c9ZgUKDBmGqIrMq4aGhtTUVG9v71u3bp07d+4Ec9kfOHBgz549IAwnJ6fly5cvWbJk1apVW7ZsWbt27fr1648dO8bj8bq6uqAmwTmId8H2RE52dvbChQtpdpOVlVVWVgYvQzwKCQmpq6srKyuLiYmpseUoISEhLEFh/p09e/anT58qKiqqqqrQEcTi4NXAQEdHR0ZGxp49e8aMGWNsbLx48WJvb+/s7Oyamhp0Fqrdy5cvQbrR0dHwbzY3N6O18GIQiuA2BSbb29u5JiQhtrOzE5YmasAlpfFGQkXXPwF+WLJ28Yqurq76+noej/fixYurV6/u3bvX2dnZ3t5+8uTJI0aMGDx48IABA0yYG6Ffv379+/fv06ePgYGBKjtWCzvqZGRkoDPIycmpqKgYGhqOHDly3rx5rq6uHz9+LCoqgheGukk0wG0dOtg9B3SYkZGxdu1aLS0tIwY6bEVTk4G6ujoao6SkpMjOCFLkgxIHlJWVVdhxWMhTYYeDaWho0MqooaGhgcH346o0NTXV2WlXOjo6BgYGvXr1MjY27t+//6BBg4YPHz5w4EALCwtra+tff/01JCQkMDDQxcVl8ODBgwYNOnDgQGFhYWdnJ5EKRhCD3tDQkJWVdfbs2WHDhkHBo6lTWlpaiANQ6rBxB7M8V80TFhaG2oBfzOYCRhBVhukYh1MJCQlJSkoOHz780KFD4eHhdXV1nZ2dWCTo6uoCMYBuMQogM9BMe3s7d2iI75DJpUk6jaG1tbWqqqq4uJh59ory8/NzcnJ4fMBefkwxELbx8fFxDP52ECUwiGeATPqlYgkJCRC/ULxzcnKgMBQWFhYXF5eXl5eUlOClmZmZGRkZeGNSUlJmZmZhYWF1dTUibYkpSI5BntDsjPwf/hKH0kCT/xHhrsTghD0qCXOPWJXLlSjc2tpaW1v76dOnP//887fffpszZ86IESOGDh06ceLETZs2+fv719bWAvOVlZVeXl52dnaIY4Ao09TUJDL4r8T9+/9jh+aHDx8QoenHwN/fPyAgIPCf3sxQBmEMPjHAtmjkHDt2zNXVdc+ePS4uLk5OTnBXTZkyBeuoAwcOxOlaOjo6iBSAk9vQ0HD79u3R0dHZDPLy8rKzs+ER4zuOvy+jZXEgOzu7oKAA62nNzc0YWiwrdXV1QQ+Da5XGg3ANwq2urkYxontwL8Wod3V1oYb29nYej3f06NGRI0cqKSlBa+TqxKKiokZGRp6enniW3gjpj/EmmdjV1XXu3DltbW1wLLnVoLhji9CCBQsCAwOha3Z2dj579mznzp2XL19OT09va2uLj4+/evXq4sWLJ0yY0LNnTxMTkxkzZuCcgrt378bHx8OhXl9fD10TveBO850MWhjQ5I0W4qU0x6MvKE/94iZwi3gGl1xuocLdK8EqX3V1dXl5eVFRUV43yM7O5vF4mZmZcIwmJib6+Pg8e/bs+vXr+/btc3R0nD9//syZM3F438CBA3v16qWlpYV4BFhi+IUhCj8IrdvD4SjFzs8iXwPsUrIz8SA5RoUZwGoiG48ewV0yIaQYKCgoKCsryzCAG4ucFIiM09HRQZyFtLT0pEmTHj16hIXikpKSmpoaLBI2MYCI6U5OhOGfJWg44FvH5oLGxsa6urra2trq6urKykpYGtXV1SUlJcXFxfBQFxcXQ1uFXot0fn5+Xl5eTk4ORgdOkBw+IJP3cyAmzs7OxkP0CHKgRuOoCijQpDcXMoAlg8yioqISBmgwGg9luqysDOp1aWlpGR9KGRQVFaGPsJeI9uDB4c5ePB6PGkx9ysrKAk3CSfTp06dXr165ubmdOHHi+PHjR44cOXDgwO7du3fu3Ll9+3YXF5fNmzdv3Lhx/fr16/4Ja/jg7Oy8bt26DRs2bGKwYcOGdevWOTk5rVq1ytHRcRmDJQwcHByWLVu2YsWKlStXrlq1avXq1ahj9erVKOzo6Lhy5UpHBitWrFi+fPmyZcuWLl3q4OCwZMmSRQyWLFnCvVywYMHy5ctnzZo1aNAgZWVlxAjDdYgFBiglYmJixsbGa9as+TvEMiMjo6GhgcvRpJg2NTV11yG6/gkgyK6uLkRufv36devWrTo6OlyHBZ0agymNYgBxrA+5YMCqwsLCAo4P7i5CaWlpKSkpCoHHs+gUmBchZnBNoiRcJFxWhcue+zpat0AQOrWTpAeJC0wWJGTQALggpaS+H0Kko6NjYmKChTp7e3tnZ+ft27f/9ttvDx8+DAsLS0tLAx2mMaCgkqysLAGazMrKysnJKSwshG0Jvq6pqWlsbIT8J40cY0eXGB+ssmJahIlCCn0HAxTD8NEvLKXU1FRzc3MQDwZLRUWFEIgdc0AIkRNGDZcoCQsNc6KKigpGB8dMizLAuQfQjPX09IyMjLS1tXv27In96RhBaNvYUS4jI4MQV/rlin2iIhoRcpzR2gy8frSsxR1TNI88sP+le/0khS4IkNBPygoRrgQSREvcxM8q+WE+JjV0EENAxeCvRDtpguPeBQ1jsAQaBnOanIn0FBKoGbiiEQcqqAC9UaBmqooe5BZAa7k5aCRCNaFhYkOGgoJCr169pk6damtru2DBgqNHj2L7DgUQgbMws5SUlFQywDyCZRsSY1x2oExuAgFQcB9w84njKPEvVRGTciUt1FSodlB9Ozo6Ghsbg4KCFi9ejLOJ5RjQIhAUGGNj48uXL9fU1DQ3N0NJRugZxDUqJO2C2gw2RyO5v9wmQXWk1qIY6ZDckiT56REkuEigeghFKEN7v9A2WEQoAxOL5h0STdwaqEc/TOCRNnbwVFNTE/dgO1zCAVdbW1vHB/hnoaRVMKhkUMUH3ELx2traGj40NDTU1dWRe7eBbcFrZADbBOMCFw/Q+MM2/zATch7jKNB9QizKkFcIfaetqVQt5ZPtilvIF8jECArQDzdToDGoimsbo1p6OzeBlqM2pLl3/yVNDovW1lZyeVAmckD5bW1t1dXVgYGBFy5cOHDgwI4dO1atWjV58uTx48cPHz7c1NTU0NBQR0dHS0sLMa0mJiampqb9+/cfyKB///59+/bt3bu3kZGRgYGBnp4eFlBVGcD0MDc39/X1RfubmpoIgTRk8Ee0tLTcv39/woQJWBPC8TVSUt+/W6Cmpqanp0ebZOGVExIS0tTUFBERUVFRcXR0/PjxI/kl4e6h2Kja2tqOjo6ampo///xzzpw5ffr0GTlypKura1hYWHV1NdCIYWppacnIyLC3t9fT03N0dCwpKSHblnito6MDBgUZJu0M0B3yrSATJevq6lAYjEY7hVtbWxEL1tbW1tjYmJyc/P79+5s3b169evXkyZO7d+92cnKaP3/+9OnTR40ahUA5bXY6vI6ODk4TlmAgKSmJrfpqamo9evQYOHCgubn5zJkz586du3TpUmdn5x07dpw+ffr9+/exsbFwMqSmpqalpaWnp2fx13Tz8vKKi4urqqrI9QzMEPkRooik6RblEMUikqmsrAw2VDFzk8GBlf8jQLHcbpDNBxhcsJVRARYYCgsL4Tnh8XjkI8NcBmMnLy+vtLQUFlNDQwMEC4/HO3z4MHaO9u/f//fff6+rqyO3JkQEPCRYdSgrK0tNTb19+7adnZ2Wlha2bkCJxdQD3QzbT6GTS0lJYT5CYe5MjTQtPWIqhzIGfRu2tpKSko2NjYeHR1VVFTaYg/YohAKsBL6G+ooxIhEH8oN0AkHSSKEk/aIS4k2MI404txhu/awemuC4NQhk/suzAiXxXpKuNCmggzRfkLwlHgS7QcRBBjKvz/efZgbEeu3t7Vh8amtrq6+vp7bhWcIkNYyaVFZWFhMTc/ny5T179qxnsfnbtm3buXPnrl27DjJwdXUNDQ0tKirKzc3NzMw8fvz4woULU1NTu7q6Ojo6iouLjx8/PmTIEDroRkJCQkdHB8oel1qEHv4PIzQ/sGh/X19fP7/vxzL+0JsJx+UnFsP/+fPncD5ERETAs2lvbz9v3ry5c+fa29s7ODisWrXK2dkZ/dyyZcv+/fvd3Nxu3bqFHYtwP6enpxcWFtbU1BDdYOQESIFQSbjmzrggwfb2diwAktJQVVUFv0YVA+ipWAkkVyZ8lzU1NWlpaX/99Zefn19RUVEZOwm0tLQ0KSnp8OHDY8aMkZKSkpaW1tfXt7a2dnFxOXTo0Jo1a3r06AHD5u+4mPfv35MXFQKdywDkP+3o6Lh69aqOjg6tqyOuAXEEampqTk5O6enp6D4E4rFjx5YtW5aXl4emYi2ltLQ0KysrPT09Ly8vNjb20aNHhw8f3rhx47x588zNzYcNGzZo0KAhQ4ZYWFjY2tquWLFi7969OBkhIiKisLAQTh5y91SwNb3q6mroYfX19VhNpYULQjt16mcJKtl9BPEImATFSHZQbXiK1CZubSAMqHq1tbXl/NChkpKS0tLSwsJCLNfnMMhmwGM+qUwOZDFHQGZmZlJSUmRkpI+Pz19//XXr1q2TJ08ePXoUa627du3auXPnr7/+unnzZnIwrV69euXKlStWrFi6dOnixYvnz58/Z84cGxubOXPm2Nra2tnZ2drazpw5c8qUKZMnTx41alSPHj2k2DZJLENhHZXMNthdBgYGYFoJCQljY2McZAOZC32Lix8uPiF5cZJsIzsZuqamppJBdXV1VVUV0hUsoqqcA3zn3vf/UgZECUBjOT8ygmgDRh3q4D7+v07jRfR4SUkJpQUS3BaWl5dXVFSgX5WVlVVVVSBXxICAXMGARDNEVD9LELFxxYvA41y0ox7K6WAAxbGxsRHGD5krfBPmP/80KFX/BPSIuoPS1QyoIPUaHUdVwAaVQSb3l/sUHsQgIlyisrKygp19XMWiY8rLy6Oionbu3AnPJg5kQNCWjo7OhAkT9u7di3M26urqMMNxp384yhGOUVlZCWMbkxbYFhhGurOzkwgbKnJ1dXVhYeG7d+9sbW21tLTwrTM4/cnxAX8TLsnlRI7CHy72khOE+A45XO8SfEPdnTukb1GsK0Q9cALVWUlJSYX/SQc1BqrshNDevXuPGDFi0qRJ1tbWS5YsWbdu3fbt20+ePPnixQscWJ6fn5/N1u1yGCCMq6CgoKioqJItMNTU1DQ0NHC1asLYv9BqFwOgl36RgMnawKC+vh4WNUKfoOnGx8e/evUKOxgcHR0Rsv3rr78GBwfX1tZiKGkWo8qR39XVlZ2dPW/ePE1NTcRCiouLYw84xgv4p1HDUALzCgoKPXr0MDIywieGcB4ibimzz5rh/EoKE8a+b8pUVVXFDlMpKSksGuFzZ7KysvRSWVnZAQMG/P7771jlzsvLy2Sr3zQ7ZDDIzMzMZoD85OTkiIiIN2/e3Lx588yZM/v379+5c+f69euXLl06f/58KyuriRMnjhgxYsiQIaampvhAnIaGhjrbkA5iEPiFfUu/RDkqDJT/Ccj891+q6n+RQJyypqamnp5eDxbg3KtXrz59+pgwQCD84MGDTU1NEeEygAMDGfTv379fv34DBgzA5YABA2hvDULp+/fvP2DAgMGDBw8cONDY2BgGfw8GRnwwZAEmBgYGoIFe/wzM78MPlDZmACfCYP45Cebm5jgEas6cOfb29kuWLFmxYoWTk9Ovv/568eJFHx+fv48vhxqdzdbPcnNzCwoKSkpKEC9J1hERM3RCMBplMpb6/kM5nQy4OSiDfO70weaHDuTgLs4Oqq+vr2LfcODOd9BnIF1ROVVLbeAmUCECUpBfXl5eWFj45cuXM2fOODk52djYjB07dsSIEfb29hcvXsRGImoMPIDoMrfN9ApqMGY0TEzk1KvnA0QKpr+mpiZ46LgH0HPNIQGE4F14EdI0WQg0g1rY0dFBFh2NiEA9cChDieWKLCpG05DAIHIrRKvol56llnALU2u5CeoXVcJ9ltJoQ/dL5OAtAmjhZnIf5FYl8HZuw6gvKM8dIGqqQHnK576O0Mi9+99Bi0B3fvYuUMsPC+ONKCDwOPUOZdBH/DY0NFRXVycmJj558mT//v3Lli2bNWvWeLYLeNq0aYsWLdq4ceOvv/564MABNze3N2/eIPKXx+IqsOCBmSKL7/+i2FUKGcaSP4VnIMQ1MzMT/qa6ujpqLVEyDTQGAv4aDw+PYcOGIYYGSgt3QQgH72ABSVpaWkdH58CBA6WlpbRRmvCDeb+2tra4uPjRo0dOTk5jxowZMmTI2rVrHz9+nJubCzUDalhzc3M1i54+dOgQzsF88eJFC/swDpS9pqamzMxMHDh28ODB/fv379mzZ+fOnZs2bXJycsLC/Jo1a7ir6WQrWVtbz5gxY8qUKePGjUPQFuaX3mxjTT8GxsbGffv27dmzp4GBgZaWVo8ePfr37z9y5EioUvb29o6OjuvWrdu8efOBAwdu374dGhqaxjySmZmZ6enpmZmZ3JAIiPoSFqVRxWyiiooKRBpxKRYjQlyAcUEmKV1ES1xyors0psQd3ROkDFNhVMUt+cMKqan0IA0uJbg8QhVS/ZRDUxtFK8OBlZ+f//z582nTpunp6ZmYmDg5OUVEROBLSnTsANXW1dWFsxFLSkpyc3M9PDxsbW379u2ryqJfcYwVND2u1g0tWpQDIgy4riuUwa+4uLi8vPywYcOuXLmSlpZWXl7O9UVQjwgn5Klsbm6ura1FRBeIllsY0gljQexGCe4oo2ZuDmFboELuJbWne6K7YMTkS5+H4Uavc83A6urqSv4eKZjtUBtgOJeUlMTGxj5//vzKlSvHjx/fu3fv1q1bsf9y2bJl0FQtLS2hCfTv39/ExKRv3759GJiYmAwcOHDs2LGTJk2aMWOGvb395s2bXV1db9++nZWV9S/9Ao+gQHt7e0NDA8Ja4T2H4x5aVhUD6ntbW1ttbW1JSQmFe2dlZa1cuVJBQQFRvZByoqKiWDoyMjLq06ePkZHR98jNMWPGDB48eNKkSXZ2dkePHn3O4OXLl69fv37z5o2Hh8fbt2/fvXvn5eXl7e0t4NAMDAwMCgr68OHDtm3b7O3tLS0tzczM3Nzc4M0MZxDxT4BPMzU1NSMjIycnB9KkgkEl3wEBLQgBw6APwhpRJJfzif6AterqaoxoSUkJHFhw6lH0iq+v79WrV8+cOXPo0KHt27evXr164cKF06dPNzc3t7KysrCwGDp06KpVq/z9/RFkBEHQ2dn56tWrpUuX9ujRQ0NDA99v6t27N/R1nCKnqqrat2/fFStWPH78uKSkpK6uLjo6+siRI7179wb2nZ2dY2JiEPNI8gWsgj5y+/vkyZNx48bBGKNoTUlJyb59+964cQNh1ZitU1JSXF1d7969m5WVBTJCeDDpo6gWq1s1NTWlpaVY58HUy+PxPnz4cPz4cRhjFDY7fvz4kSNH4sjLYcOGjRkzxtLS0srKas6cOYsWLVq5cuWWLVv27dt37NixK1euvH79Ojo6GjNHWloa1rWA88zMzCzmIsxhAJsB0XxYDoJfjLxRVcwPhS9ENTZ+P90ZMT5E8dzRh1DALa4q3F1YQMcFKlAD4ZwqIUqDmKMJDOFI+G4VvGPQ4Ovq6qoZVPE9PuVsEw2m/LKyMq6UgYjBb1VVVUlJSUVFRUxMzKRJk3DsCJQPGRkZFRUVfGxURESkZ8+eOPxYUlJywIABx44dy8/P79475LS1tbW3t5eXl/N4vNTU1OTk5PDw8Hv37l25cuW3337bvXu3s7Pz4sWLFy5caGtrO2vWrEmTJo0ePdrMzGzQoEEDBw4cMGBAfw7069fP1NQUlictOCNzALNRYY4OHDhwEIPBDIYOHTqQgRk7dGnIkCFmZmaDBw8eMmTI0KFDhw0bNpTB8OHDR3BgOAeG/QRQHDQ5atSo0QxGMsDW8kmTJk2fPt3GxsbOzs7e3n7hwoUODg5r1qzZvn37kSNHzp07d+fOndevX0dGRhYVFYENMdDE4wgKLi0thdhFuArdJfIQwD/lc9VrojQkqBLid3qKauuew72FeugX9ExiBCXpLVSMmAI5AhVSY6CLUGF4YLkCBDVDqa2trS0sLPTz89u7d+/cuXOtrKw2bdoUExNTzRzleBFXVqPy8vLyjIyMv/76y8XFxcrKasaMGa9evaqsrCTGpFcQO6O11Be0tq2traKiIjIy8sKFC7NnzzY1NcUx4coMsEUI6wQiDOBkJG8m+StxF05JOCu5t5APfYsWlnCJIFB4zTQ0NHr06IHd67169RowYMCECROwF3Xz5s1Hjx69d+/e37FRqampOTk5MHt4/BVyCgSGE7mqqgpCjyImSHmlcSFUUEIARYjPwl2iDYFRpmcxvgjgKisrS0tL8/f3//PPP0+fPn3o0CEXFxcHBwdra2tLS8vRo0cPHz4cZ00MHjzYzMwMjNa/f39paWlnZ2fMOAjsIkHNbTY1pqKiwtnZGRETWKiXkZHR1tZWVFREBK62tja2RBkZGenp6eFAInzLEoOCBX/ISRMTk3Hjxv39lbzevXvju9VQenBmE/yYqFZERERWVhZxnbSwDzefkZHRqFGjDh8+nJKSQt4NeIrRBcyqQCMGhboD2saHEeoYwGWPhSKsemIDJteCzc7+vsUk+5/A+ydkMchkkJGRkZqampSUlJCQEBsbG8MgNjb227dvST+B5ORkKFqYfPGLN2RnZ3NfhVYgBy9F23L4kMsHblx8IYMiBkhTJAguse03Pz8fl/n5+XDHAxuw6pFJj0MrKGB7sbGpCpVw400QvVLAIP+fkJOTA79/UVER6iQFg6tjVDCorq5GGBSxA2kFyGlngDRRBS65yjoYUOCXJFhnZyd3CQ3yE4Wpqg4GeB3IKS0t7dSpU1u3brW3tx87dqyZmRkm2b59+xoaGg4ePNjJySk4ODgnJweBQty3gDIhB2CUcmtG/Zj1cFo6tOXi4mKorCRzUBITAVpItQEbtNWpo6MjMTHR1dV106ZNq1evdnZ23rBhw9atW3fu3Ll37979+/cfOHDg8OHDJ0+evHDhwrVr137//ferV6/eunXL3d39zZs3AQEBX79+TUtLy87Ozs/PR0uK+VDCAe7iJQ1oOVu0xgpcU9P3I71o+NAXdJZiydGLtra2nJwcd3f3U6dOPX/+vKSkhCZfJDo7OxG33tjYiOAmKK6lpaWVbJ2vsrIS59dzVQggjd7736ETai3Ng8jpTlHIp+ZhUKjZNLICD3a/xIMk37g1cCmTHqQ3cqmaegqpiEvSqVCSyqAGCqHlCk96IyVAzAhZrWaGOnfRHeRaXV0N3NJTVCe3tQJdIBRxMUmZmMIaGxvv3r27fv36efPmzZ8/f8uWLXfv3k1KSiosLMxmax55eXklJSWYrOvr60EkeCk1BnXSJeFNIAcjTo3snqC1BGow9Q797ejoSEtLc3V1HThwIMVGYLcBThiXlZXt1avX6NGj9+3bl5KSglVkUCwYobOzs7a2Nicn59WrV1u3brW1tZ08efLq1asfPnyYnp5eV1dHjzQ2NpaUlGRlZT169GjVqlXTpk2zsrK6dOlSfn4+0Tl6mp+f/+TJk927dzs4OEyfPn3KlClTp061tLQ0NzfH15amTJkybdo0HPc0c+ZMKysrfBfI3t5+0aJFjo6OECNbt27dvHnzjh07XF1dEWoTHByckpKSxbZAZbJjEDCvgTfpWINK5kzAii+cXNwB6o7nH+agLzCpCP9UksYUt7j5VBiMRreI0rg5/5IWqBklf5hJlcDTTTIchYlUiEe49EnP/nsCVbW0tJSXl6enp9++fXvixIm9e/c2MzPbvHlzYGBgYWFhXV0dTQ30ahJrlZWVubm5hYWFUVFRZ86ccXR0tLS0NDU17cugZ8+ePXr00NLSUmGf+FNSUlJQUKDPM4KYFRQUcBfL2P369bOzs7t06RKPx2toaMD0jb6TiMM8CLSA1IuKiuLj4589e3bp0qWXL192l/xcuYpRbmVfsS8rKyOVJp+dZALPOF85ys3hQzYHeDxeFgMksEwOx0v333Q+pDHAVVxcnJeX1507d86fP3/69OkTJ064urru2rVry5YtTk5OS5Yssba2hkU/adIkKMM49X706NHDhg0zMzMbPnz40KFDhzAY0G37nAAAIABJREFUMWKEubk5TsVdsGDBsmXL1q1bt23btl27duHsey8vr9TUVLAVGoB2gt2ys7MRyVvGThOm2RYUBQIjGUUJyqcc6CSEagwTtlCTXIKyBELi8Xi2trY4gA5fo4U7G59Bx54tGQZCDg4OtGdHSEho1KhRf0d4vv6RQ/Pjx48+Pj5+DAICAgKZQ3PVqlX4zCgq0dXV9fPzCw8PJ0/mFwaRfEA+ztPE1yGIzdB0zGfwuxUXF+NYHFBDenp6ampqSkoKPlDz9evX6OjoqKio8PDwL1++REdHBwYGPnny5PTp0zTkjo6O8+bNwwe7JzPAcewIMndxcTl37pynp2dkZGR4ePizZ89WrFgxePDgRYsW+fv7NzY2QpwhAL6zs/PcuXNDhw6lz/XIy8urq6vr6OjgG3lmZmbOzs5/V8Lj8VpaWhoaGj5//rxhwwZ8p0lYWHjKlCmvX7+OjY2Nj4/PyclBRD0GFVMC/eK96enpFy5cMDQ0hAGGgPkBAwYcPXo0JSWFy7ohISEWFhZ//PEHxZbSORGEXggssChZnpTAlooqFq8KXzBChMCBWVlZUVFRN2/exGlBLi4uzs7OK1asmDt3LtbTRo8ePWbMmPHjx1tafv9ehKWlpYWFxYQJE8BUYLBx48ZZWFhMnToVxw8jRHfZsmWOjo5r1qxZv3791q1bcWDQgQMHjhw5cv78+Rs3bri7u3t5eUVGRkZFRUVGRn758iUiIuLLly98gvqeH80AiE1ISEhMTExOTk5JSUlNTcWiHI/Hy2aH/sCmqqiooLB5mploIIAxoBdSEpY/Ma2A1IZ+QIIbZEzWEZctySTm6na1tbVPnjyxtrbGWisOS5aSksKZoQjIFxISkpWVHTly5L1792gEfzYD1dbWvnjxYs2aNRMnThw/fry1tbWNjY2VlZWtre3ChQtXrFixfv36HTt2bOfDr7/+unv37n379rm6uh49evTkyZOnTp06c+bM2bNnz/Hh0qVL586do8xLly7duHHjzz//fMjAncEjBo8ZPH361MPDw9/fPyQkJJRBWFgY+BRDGc0/exjiHr+w3vHLzac09xbvR5DNVzphKsPgxaDDBIImCtYm8Qq+w+hUV1eHhYW5ubnt3bt39+7dV69e9fPzg6jBAecgs6SkJOxDgRVdUFBQXFxcX18PImnnAwYLNUM9JQOg+/CRAOQmQI1UD7/idi5fozwImJ5FSZAxZVICb8fkgTbjFpEx1U/kTc9iSR9BLgicRGA71h64hi4eaWhoyM/PT0pKunjx4syZM1evXu3GYCI7ofzgwYM8Hg/OBTAL/dIAcVtF3ezo6GhoaICwCgwMvHHjxqFDh/bs2bN27dr58+dPmzZt7Nix8J4L/Jqxz8QhLszU1LRPnz69GPThRHuZmpriJFZoA2Z8GDp06MiRIy0sLObOnbtu3bojR448evQoOjoayg05aLBcgT0adJoPugPJQLYfdY0MYxoOStCDAjTT3t5OsohuoTBGH/inaQVluLSEAo2NjQkJCdevX1+5cuWUKVPMzc1nMLC1tV21apWLiwtUgm/fvvGYNxaHppWUlISGhm7fvl1PT2/9+vVpaWlctRINI5qhlkB3uXfvnpmZGXaRYI+zpKSkioqKvr6+tra2kpISwjahuwgLC0tJSTF1RUZTU7Nfv34YFGtr63PnziUlJVVVVRUVFfF4vJ07d06cOHHUqFEDBgzAfnNtBviyuZGREYJKSM+zsLBYvHjxlStXYmNjS0pKsNMKThzy9ra0tMCaLSgoIJ5CdzBARJA0BMinSypMOf+e6D7c3BqQ7l5GoE6MMvdB0vhJpPx7VdxXUEluQuCN3S+BGeTTg1yCp0wqQygl+sEtVMVt+c/QziVvbnm8i9skmtzBeg0NDRUVFQhGzsnJgeYDnfMbg/j4+K98iIqKIs2WEtBJoJB8/fo1Li4uNTU1Ly8Pm1qKioqwDk3TAc0IXL9hR0dHaWnp7du3dXV1jYyMZs+effnyZT8/P29v72vXrq1Zs8bc3NzExARqp6Wl5bFjx/Ly8nBEEvUdwhn2BlcUAPmUA2xzqRo5RDyYIAiNNFG2MQDeIPabm5sLCgo+f/7s4eHx9OnTW7duXb58+cKFCydPnjx27NhRDuDyCIPDfDhy5MgxBr/99ttpBqRsnDt37uLFi1euXHFzc7ty5crly5fd3Nx+//3369ev37hx49atW3/++eeTJ088PT3DwsIyMjIQg0bUSEjGtAVUt7a2JiUlXbhwYfPmzX+vsdXU1IAwKioqMjIyaJgwl6Wmpl68eHHDhg3Ozs74YsbRo0fhqL127Ro+pwu9FKopCCAmJgan9iclJUERhcIARRSOfvLelrLzJSsrK2traylAjNsFUC9RLI0IUTUVphHk8i/3Lioh1kNVxE0CTwm8F3dp9Mn5WF5ejqCbgoKC7OzsTOZs4jFjPi0tLZl9UzSZQWJiYnR0NFQpKIFxcXHxDL6x5ZnU1O8r8aGhoY8fP75z586ff/55//79Bw8e3L9//48//rh169aNGzcuX77s4eGBYequn3D7Qt0ESRPeqAwRP7gSFF5dXY1FlIKCAhgLyCejgMs49AoBJFM+V8tCPTD9uNwq8CxdAuH0dkpQ+BKQUFVV9fLlyzlz5mhra8vLy8sx6Nmz5/Dhw1evXh0QEAC9l9vslpaWuro6bFnz8fE5fPjwzp07Hz9+/PnzZ6yUQElGNEllZSWPxwsICDhy5AiMiKtXr+Io7fr6eihsqJz2jFdXVyMyIC8vr4gBbHmsioFasOxUwFawioqKEEZQzqCC7QisZK5JCh8h1hCgUkIXN0H452b+MI2S3W8RtdBIQX6CeKj8zx7nciI15l8KU4X/lwQwQ9SOquillPhfvAJ9J+nR1tZWWFh47969JUuW6DKYNWvWhQsXgoKCoqOjExIS6EhHPIhfUH57e3ttbW1FRUVJSUkOW+nPZousCQkJr169On/+/NGjR/ft27dr1y4XF5eNGzeuW7duPQNnZ+fNmzdv3bp127Zt165dS05OxsISedYwZOgdNRgf+amvr4+MjPzjjz/WrVu3ePHiHTt2vH37trKykkYZzIW4pVr2uRegEbp6TU2Nl5cXFvt/ZVszEWi8jJ3ZtXjx4gULFsybNw8bMWfPnm1tbW1lZTVr1qypU6dOY59nsGQwefJkuEcsLCwmTpw4YcKEiRMnWlhYTGJgwcDS0nLy5MlTGExlMGXKFHp86tSp1tbW9vb2y5cv37Bhwy+//LJ582ZMpKdPn37w4IGvry++45eSksJjrg8ksrKyoMBjVbiIndyNJaKKigpoKTDEgDpQC8kcXOIX/iUyZoEooj08DjahEYGUwCIQHFyQFfAXYz2JXM+4Ra9ua2tLS0ubOXMmTl1HeIoYAwSmIC0pKSkvLy908OBBrk8TB10dP37cw+N7hOb79++9GXz8+NHX19ePv988KCgoODh4zJgxAs9aWFhgXofXKYoBXE74hf4XERGRkJCQl5eHT4ETCkDriYmJz58/v3z58vnz58+cOXP48OH9+/dv374d23tpk6+jo+OiRYvmz59vZ2c3d+7cBQsW/H2iB/w1+/fvP3369EUGDx8+/Pz5cybbL4YI/5ycHIjR4uLi3NzcwMDAs2fPOjg4bNy48cyZM/7+/iUlJfQpN5rqsCD222+/Ybeampoavvlz5cqVa9eu/e2WioqKqqiowGC0t7cXFRW5ublZWFggvhrohvdz1KhRK1eufPv2bXh4eHp6Oi3jQ+vCeIMUYmJiZsyYgRPrVVVV58yZ8+DBAywsENm1t7fHx8e7uLh4enpimZpkLhGZgHglHRoJTLpckhUQebiFyOHKysoKBsXM44x4TwgmHoNsPqSkpPj5+d25c+fMmTNHjx49dOgQvla5bdu2X375ZePGjWvWrFm9erWjo6ODg4O9vb2tre2cOXNsbGxmzJgxderU6dOnz5o1a+bMmTY2NiQsbG1tZ8+ebcNg+vTpEyZMwCdf8B3eSewjblOmTLGysrK2tp4zZ868efMWLFiwePFiBwcHR/aB++3bt585c+bRo0cf2CkKHz9+9PHxAXnjLIXg4ODPnz9HRETExMQkJibiwN3KykocMwF9jsuu0IrA5Bg7mt1RjMgbd7laFGaI2tpab2/vFStW6Orq4jQcHFCIQ74kJCS0tbXt7OwSExMhO7DALjBGeCm0rpqaGtq1SpE1UCBwYAINYmVlZXX1f04SqOVDXV1dfTfAzTo+NDU1YUt7E4NmDjQy4OofaDZImsise/u5VPrDu/+dTNQPzIP+8RS9VyCBIQCbw0nU1taWn5/v4+Nz5coVV1fXDRs2LF26dNGiRQ4O3w+pxEn/a9asWbt27S+//LJjx45du3bt3Llz//79d+/e/cjg/fv3IKqPHz/6MfBnEBgYGBISEhQUFMY+rwknL070j+FDbGxsXFwcXPOJiYnMmv4eigU3fUpKSlpaWkZGRiaDLP4shaXCvLw8Ho+Xn59fUVFRyzZW4EMTNPcQkQAJ6DuhHUgjdNFlW1tbXV0dPDvZTPnI4q+T5+TkwBMEHxAMDAx3e3t7WVlZXFzcixcvjhw5snHjxrt370LRaWpqamhoKCwsPHLkyJQpU3bv3v3y5cvIyMiMjAyoyKihuzFArkDiLDAXJo7KykocrQDHBMwS7sFDmMuxxJqRkZGQkBAREeHv7+/l5fWWgbe3t6+vb3Bw8JcvXxISEtLS0nJycrj+Sngt4cIuZ/FBtHulra2NG/mCLtCsjEsiTmC+ubm5vLwco4YVUViA8fHxMTExWLH7wlZxPn36hG8UBgUFBQQEgJz8/PwwKSPhyweuQPNhEBAQEBsbW1ZWRhSOBhCbNDc3V1RUIDIObnr0urS0tKrq++kNiEYBIVEveDzegwcP7OzsTE1N58+f//bt20+fPqWnp2PNBn0n5xRddnZ2Njc3BwQEDB06VFZWVkpKSklJSVZWFn5M6CsyMjJaWlo4PBRSferUqQ4ODidPnvT19eXxeHl5efgAEc2eXV1dFRUVOPQ2Li7u9evXbm5u5xlcvnz51q1bz58/j4iIyGLRkXl5eThZpbS0lGxjUC9wgqFsa2srKCg4ceLE5s2bL1++HBYWhi9sMPP8Pz8pKSnwWRAzZnOAx4FsPu+gDdlsASaHD3iIxxwBWT8CTk3/SWaxz+uBcgR+M9iB8enp6WkMKJGWliZQMi0tLYUDqRxANlwSXEHE7b5AOokPlA9XBdah4+PjIdOSkpKoQmz9Li8v50ZNgj7r6+uZhVsO8xgHGVNYBJ0hw0UsMIeDjPHSmJiYyMjIsLCwoKCgwMDAgIAAPz8/zPi+vr5gJS8vL3d390uXLiEIAtqms7MzTpJZtmzZ30c7QYtwcHBYuHDh3LlzbWxsZjOYw8CWgZ2d3bx585YsWbJ06dK1a9cePHjw3r17cXFxaWlpXl5eSUlJkGkdDMBHkAxgk66urqampsuXL1tYWIwbN+7kyZN/r4vj25XYQFBWVpafnx8aGnrmzJnx48erqamZmJhs2bIlNDQUDiYwOE21EErFxcUREREhISH4BDmbo/7rhy82fGnOQg5QFBAQEBQU9OnTp8jIyJSUFBx1R5IZhgoJN5xH1sC+61LPPguGwyuq+VDJtMfy8vIyPmB88VtSUgLvHgwtfpEyZFLJioqKSj5UsHNRsF0GDkEKGAd6QUhc0mpra4uNjb1+/fru3bujoqJgD7e0tBQVFd27d2/9+vUI1oasa2VQUlJSUFAQHR19586dEydO7N2795dfflm1atWCBQvmMkDYhLW1ta2trY2NzSymuE6bNm3GjBmzZ8+eN2/eokWLli9f7sxOxN60adPWrVt/ZWvJe/fuPXjw4LFjx06cOHHhwoU7d+7ALoiJiYnjA3FNMou8Tmdf387KykK8TG1tLcwo0naIrrp+Am0MOjo6Wlpa6uvrsW0rOzs7IyMDLBMXFweu+fz5c2hoKFjG19cXROPDQlsCAgJ8fX1fvXp169ats2fPHmHng+PrNy7sC+Y7duzA9kYc9QBNacuWLStWrMApTMDJmjVr1q1bt2nTJsQKHTx4EAENd+7ccXd3f/nyZVRUVDE7uBBEVMUCL/BZG5Af6R50Cf4CFxAvEFqQAG6oJAw37i3gk1QaEDnKc6vC21Eb5dP83sSgvLwctiePxystLcX8SIT6k1H6fooFiLC5ubmsrCw2Ntbf3z8yMrK8vBxEixFEmZaWloSEhD179tjY2FhaWq5YseLFixdZWVnl5eWwO2DSolNAVE5OzvPnz/8OuAsICMBpG/j0OekG7e3t8Hv6+/tfvHjx2LFj7u7uCQkJFNBN/YUahimepAHuwiShPtIjSPwwH66NhoYGfCr9y5cv4QwiIiKQCGdRU+Hh4Z8/f/7E4DMHqAwKcO78I4kHP336RLUJPBgWFoaADCrzhQ8RHEClkQz49//zz60Q2n4kPzoHATrQ7tAvVIk2cx/kNpra/MMEGgxF0d/f38fHJzg4OCYmBkKbME84/x8laLyILMELcXFx58+fX7hw4cSJE83NzYcPH25iYjJy5Mi5c+du3Ljx3Llz79698/f3//jxY1BQUFRUVGJiYnZ2Nnb3w/RoZ0CCupadKQyzFMwOTbuqqqqS+bir2ac1cD4DERsagx5RUzFPtbW1ffv27ebNmyNGjJg5c+b169d5PF4li7IniQEm6uzsLC0tjWdQVlZG+AFBVrKd3eDlpKSkz58/+/r6ejPw8vJ69+6dp6enh4fHmzdvXr169eLFi+fPnz979uwvBu7u7lh7+/DhA6y/EBbug1ifyMhICHxokplsTSibD1DF8QtzBl+0hgYLk6eGfVSjtrYWZ0QIyC6uDESnuHKMe5fkA3gZxaBUwAFCiEJJXML7gc2sxcXFPB4PO4q+fv0aEREB1oiJicHkkpycnJiY6Ov7Xd8ICQlJTEzEFEbx4CAwejXenpGRYWVlhQAIMTExxPnBZMCXprAb7/unqO7du6enpyfgmvz7OOHr16/DofnhwwcoN35+fgEsPDM4ODgkJGT27Nndn3J2dgbTRjP42g2iGNy8efOvv/6KiIioqKiAyEMHmpubeTze27dvb968ee3aNTc3t6tXr96+ffvWrVt37959/Pixh4eHj49PeHh4UlISTK8cPiB4pLi4GPoQ1jxra2spAogGCTZVRkbG34eA7Nmzx8nJafPmze7u7jwej86Ao8Kt/4+97w6I8kj/3/iNMZfq3cVcYsr97pJLLuclXk7TNGpOY4tdscZeYkFFRUURFcUCIkUEFAuKNJWiFGlKEUFFBQFBAZUqTViWupRdlp+8n/DcZBeIiZ7G5Hn+eHd23qmfqe9nnplpaCgvL8ce3qioqK1bt+KM27///e9r1qxJTk4ulS6uKSsrq62txfcVFsnlcnlkZKSxsXH//v27deuGg8CeffZZHIv5+uuv/+lPf/roo48WLVoUHR1dUlKCggTJSKsZJSUlLi4uc+fOHTNmzJo1a2JjY2lkwigCX/X19XK5HIrfqLIY84itoEZOpAbVbLwC/njChryg16BX1A2hTlOA+EtPeMeOvOrqauqn0DHJpbspUVJ3JSmSLs+9IwnulkEbFm3oY/vWrVs4xSwgIMDd3f3QoUNOTk67d+/G3YKYXRkbG69atcrAwGDhwoVz5szBAZf4Ghk7duzEiROnSjJ58uSxY8cOHDiwV69ePXv27C5Jjx49evXq1b9//yFDhowaNWrmzJmbNm1ydnb28vI6ceJEUFBQZGTk5cuXc3Jy8KmPrhNtD10zTbOw1C8uO9RL586goDWa5ssTsRaamJhoaGj43nvvdezY8ZlnnsGBcU8//fS77767cePGrKwsMAsouFafVGnpA4nKjsq0VY9UiGLvRi6poGEjhkluRAPioqDIQG4oMbohi690zRSCaIAz0UY0awWC4VOMl7xTvgCjSqWqqKiQy+VUM+kTOj09PSIiwtXV1cHBwcrKasuWLSYmJitXrpw7d+7kyZOhejxdkmnTpo0YMQIKy59K8lmLQLW5d+/effr0ocW6/i0LdFjco705w4cPHzly5KhRo+5R23p6ekSwTp8+febMmbNnz547d+533303f/58fX395cuXb9y40crKys7ODlv83Nzcjh075u3t7dsiJ0+e9Pf3j46OzszMJIqcEAAm6GFUKlVWVlZERMShQ4d2795tb29/6NChEydO+EuDd1hYWEFBAeobvKMPLC0tPX/+/M6dO2fNmjVnzhw7O7vExETsF4NjzLOrqqpOnz5tYGAwbty40aNHGxsbp6eno6tBA8HogPSI8w8MpdTW6iVBsVJPpWWgekiljwTjsx+HYaNtUnao8sAv6pVuOPhEpJaOQT09PT0pKenSpUtnz54NCws7deqUnyS+vr7oRo4fP75v374NGzbo6+vPnj176tSp+EIeMWLE4MGD+/fv37dv3969e3/xxRefffbZp9IZIJ9++mnPns27SHCGQ48ePXr27Pnpp59CR37QoEGjRo2aMGHC1KlTp0+fPnv27Dlz5kyfPh2q2Q4ODrgXTq1W02IsVX7CCgMKEKAiIPxFZ2gmlZWVhYWF9z51xo0bN3jw4AEDBsyYMcPV1fX06dO3b99GZUBoKDL4ampqKisrO3jw4KBBg37/+9+//PLLNDK+8cYbvXr1mjVrlomJiZeX1+XLl3Nzc6HQVFJSUlFRQYMs1U/YoDTRwHFkdoV0eTSt0NCB99RdU4UnX0geagie925SWrRo0ezZszdt2mRpaeno6Lh//353d3c3NzdHR8dt27atW7fO2Nh448aNmzdvNjMz27Jly+bNm01NTTdu3Lhhw4b169dDpWu9JCYmJusEES2NjY3XSmIkyZofEzhb2ZoYGhquaJHlkqxYsYIsDSUhf/hLT7InXX5dAxy3xND8S94NDQ1XrVq1evXqNWvWrF271lgSExMT8BSOjs37jvdL+lbOzs4uLi6enp5+fn6nT59OSkrC5zdgB5t87tw5Z2fnffv22dnZgW00kQSYr127ds2aNcBh9erViJf+Ll++fMmSJQsXLsTSKeikBQsW4BLqGZLMlPaIgFJZvnw5Er9u3brt27fb2dnt2bNn3759+/fvx9AfGhoaFxeXkpKSkZGRmZmZI0m2JFj5ILIVf7HyUVZWplKpampqioqKcIMQKptGEjQoelZVVSUnJ/fv3/+LL74ICQnJzc1VKpU49h0GLB3W1tYWFxdHRkZOnz79+eef79y5s62tLbpHBIWmgZ6qoaHh/PnzZmZmy5cvnzVr1vjxzUeyTJo0iVaR9fT00POMHDlyzJgxYJqmT5/+7bffzpgxY8mSJSYmJps2bVqyZMm6detSU1PFGTvUrolIRbzUh9B+FGSWOt6mFiF7aonU9ESDSroSRKFQ3L17F5qAt6S7QIuKiiorKzGDwliAAGk+QzEiSeBokpKSDA0Nd+/ejTUeFEdJSYmVldXcuXMPHDhQVFSE7zf4wiQN8FZVVeEzGyR7QUEBFT2WSfLy8q5fvx4REeHu7r53715bW1sLC4vNmzdv3Lhx06ZN2PyxevXqFStWGBgYLF68GIo2y5cvB8tpYmJiZmZmYWGxc+dOe+nzB00GX0AuLi4eHh7Hjx/38fEJCgo6d+7ctWvXcnNzQXKhXJB3yngL0j/4xZBXXFwcERHh7Oy8ZcsWup8dGgZTpkyZPHnyxIkTJ0yYAG2AWbNmTZcuEqQpx7x58xZI+lP6+vqGhobGxsbr16/fsGHDtm3bcCe7iySHDh1ycXEJCwu7d61zYWEhdvFntyznYJURKiaFhc0XOeIpl6hq0OK1LdcJUnFQe0E2xcoDN+jhaXpAzYFaB+FDfslxQ0NDfn5+enp6WlrazZs3r127Bv7o7NmzYHXBX/j7+588edLb2/vYsWNeLXL8+HEvLy8fH58TJ074+voeO3bM09Pz6NGjzs7OO3futLa2dnd3T0pKIt1GtFA8f1BCwh/wKdevXzc2Nh42bNj69etTUlJQ52mYRr4aGhrKysqga0JLRPSK2AeaR9XV1YEQoXVZSgl81dXVFRQUAIc7d+7cvXsX+uBIHdoaXIowoghgjwAJbbFhim1fy4zPpcLCQicnJ3Q+pqamJiYmGzZs2Lhxo6mpKQ2sJiYmRpKIww0GHWNjYxppMWqYmJjgFcbZNS1iYmKCwVoMdt26dQjTyMho2bJlCxcunDdvHpa4cFX9JEkmTpw4fvx4PT09PMeNGzd27NgxY8ZAQWfYsGFDhw4dMmTIUEm++eabYZLAcvDgwYMGDfpakgEDBtDuxi8l6f1Dge7OvXHhc0k+a0M+//zzXpL07Nnz888/nzp1qpWVVUlJCXiDphbRSNLy78d/yX2jJPiLQkctKikpyc3NvXjx4r1j8QwNDWfMmDFmzJhhw4YNGDCgR48e77333l//+lccHz9o0KDZs2dv3brVzc3NT5KAgICIiIi4uLjk5OS7d++iwlPTbrXyoNPWGvKQKjGF6Ac0Gs28efPef//9TZs2JSQkQM8D03V8pyM0ZEelUmGQxSvdGovOBJt3a2ubOZ8GaWe6oNXzXyO0N2olqampgc4ZvhcQqVbXpNteUDbUpsQ8IhzRBlnQtSE9VrwibBEdEKOogSoyTgM6dsUVFBTcuHEjISEhNjY2IiIiNDTUz8/P29vby8sLH5iurq7m5ubGxsabNm3aKcnWFrG2tj527FhOTk5aWtq+ffsWLVo0a9YsfC/7+PgUFxejsGgGTpqbsLl3eNesWbPeeOONl156qVOnTuAxn5UER0uB02ze2uXl5WVra6tLa7799ttOTk6hki5buCSR0oJttERozpkzp1VCU2Iy4xNa5OrVq4mCJCUl4U12dnZBy03z6JepeeCe5fLycoUkoJ/Ly8uhdoTKgm8YsSLqlg0VCUoRjjHHksvlERER8+fPKfZzAAAgAElEQVTP792799SpU8+fP5+fn4+lThQhhSyXywMCAnbs2DF//vxBgwZ98cUXf/nLX1544YVnnnnmX//6l7W1dV5eHpbHwY6jftPRWmVlZcXFxdeuXfP29rawsFi4cOGoUaN69+791ltvvfzyyzi/uUuXLsOHDw8ICAACjZJUV1fj8m7gn5aWBmKe5ohwRo2Q6gFyTdM76quoXyA04JICJHsiC2BDAVJrQdS6zhCpyEEgBPEppkeMkZoTgYB4YU+tmqJGd4Nz9JXSpL+6RSorKxXSek5ZWbM+aWlp6d27d4uLi4skKZQmVfmSQF0rKysrOTk5JCQEx1Vs3rx51apVOBZqliQzZ84EL4AN8vPnzweFtGrVqj179uA758KFCwkJCVDvxYkKhYWFERER/v7+AQEBp06dOn36dEREBKZE6enptbW14DGpXFCC+fn5+/btGzZs2F//+tc333yzd+/ec+bMcXZ2Dg4OPnTokJub2/Xr11FFCUnRQLWXunIRfLyl7gyvgLPoTCwLsqci0LIRYyczVU6yEWMRLR+umdIGAwKHWcxUW4lB3UPbb7UaIxD0+PX19UqlsrKyEtUMHD10xIiLz8vLu3XrVkxMjIeHx/79+/fs2WNlZYXPG3zbQJFBX19//vz5c+fOnTVr1owZM0CGEiU6bdo0VL8ZM2ZMmzbtW0mmSvLtt9/CME0SeJk5c+aMGTPwrT5nzhyiOxcsWKCvr7906VIDAwOoURgZGdna2l68eJG6PsIKtREg1NXVXb9+/dSpU15eXt7e3mFhYVevXi0qKiqXBOsoqG80cOKEeFdXVyMjIxsbm0uXLsnlcrHTpuk1jjoqKCgIDg42NDQcPXr09u3bvby8goKCsM4cJklgYODx48cPHTrkKImHh4e/v394eHhMTMzFixcTEhKuSgNNUlLSjRs3MjMzCwsLyyQFZFDSuAAkU6IhSH+ZDihMSUm5du1acnJyUlJSYmLi1atXMUhduXIlLi4OCpLR0dFRUVFYbQ4MDPSXvmd8fHyOHTvm7u5+5MiRQ4cOHTx4cP/+/XZ2dkZGRvPnz582bdq4ceNwZG3v3r1BYfft2/err74aMGDAsGHDJk+ePGvWrNmzZ0+fPn3q1KlTpkwRC3TmzJlz5syZP3/+4sWLly5dunr16nXr1pmampqZmW3dutXS0nLXrl20+xILfsHBwXFxcdevX8eRN/n5+ejisPkLNzKJ7APpemg1HLVaTUuyWg0BfQj1w3iL7QV5eXmXLl2ysbGZLd34N3v27JUrV7q7u1+9erWyshK8AMZ6PBsbG8vKyoKDg1evXg0EZsyYMX/+fHNz89jY2NLS0vLyctKgpL6LamZdXV16enpwcLCHh8e5c+doYzh4WIqCkkp1G2MHZZnaO0LG3LG8vDwrK+vKlSvBwcHHjh3btm1bREREeXl5WVlZaWkp9ukoFIrs7OzY2FhfX18PDw83NzcXFxfUARwXaG9vv7tF7OzsbCWxaREr6SiPHS1i0SLmP5QW6+bfFrc7LCXBlNG6bUFUeG9jY2Nra7urRexaZPfu3Q4ODk6C7BNk//79Bw4ccHZ2PnTo0OHDh10kOSIJzPSEpaurq5ubm4eHx9GjR49L4uPjc/LkyRMnTpw+ffrGjRvFksjl8rKyMoWiWf+3vLwc1LNSqRRnI7W1tTdu3AgICHBycrK3t9+5c6eZmRm+aTfrCKjkLVu2mJmZbZM2L1tZWaGBHDx40NXV9eTJk+fPn09LS6PLOgoKCvJbBMrXtByOulcpCeaf2DCFSTbVHHEc0bKk6orRFpUQwwcaIKoZzOgMMfokJiauXr36L3/5y73rwqokgTpJVVUVrirCoUb19fXYJ3GPcn3jjTfuHSl179R/LE2pJcFkjFprVVUVqKJbkvbubUkyMjJSUlKSkpJSJLl69eqVK1euXbt269atbIlyAla5ubmFhYWpqakmJibDhg07dOgQFLWoP0e+GiS5c+cOFnJiYmLwzRMcHBwUFBQYGBggSWBg4ClJqAs9fvw4mg960UOCODs7Hzx4cN++fbt378aJUitXrlyyZMmCBQvmz2/eJGFmZubu7n7x4kV8CVMTbvqhoHTQ3aWmptrZ2e3evfvSpUtYV1Or1QUFBaGhoWvXrrW3ty8pKaFOD1mjxSqa2MAjfWciNnqLb/K6urqqqiqs5ZdJc1FFi8ileam4on9XklJJ0EZKpKPY4VEuSZkk+BSqlO5VVyqbz5oXO1WkBPn9IQb//YcPFpVKlZmZeejQIZzTtUKStWvXmpmZ7dixw9ra2sHB4ciRIz4+PjjBEEMJjsO7I0lBixQWFpJ2rVziIiskQaWtlkTcwQCgxOZDiUPK0WqQL7QRlB19YlAjgkvYowXhOJrbt29jkztG8LPS5gbsxjhx4gSoRjc3t8OHD+/fv//gwYMgi8FOHj16FJdob9iwAdeBGhoaGhgYYOUGAzE2xq5YsWLp0qX6+vqLFi1a2CL6+vpwvHr1aqxybd26dd++fUeOHPH19U1PT8dZDVRXqS4RCKIBmcI5gLGxsYGBgVlZWTQ6Y1TFiIaGLw58YveikgSYo1sgMBEFCgUVXqw/GNwpkQAcXmgkxfRP7HPIGQwInApXyyDml8xEuxcVFeELDm0ET/qgK/opgpaFp+ivuLgYUYivcP8yKPgbN26cP3/+zJkzoaGhgYGBJ06c8PLy8vT0dHd3d3V1PXz4sLOzs5OTEw7EcHR0dHBwsJdk165dtra21tbWO3fu3LFjh7m5+bZt27ZKskUSDGWbJNm4ceP69evXrVu3tkXWtIiRIKslESy0jevWrdu6dautra2bm9vFixexeZRailbREODtG1DiNGw1SgIvGklgA0WQEkkKCwuvX78eHBxsb2+PKfHUqVNxHQ1uXvnwww//9re/4WKSjz76qG/fvqNHjzYyMjp48OCRI0fc3d09PT29vLwCAgIiIyMvXbp0VZJbt24plUqqyajklBJx5BUTZmNjs2XLltLS0sbGRupYkGZ6qiURgcIr5F00U3Rkibjw1EWS3oqdHlkifMSu6xdexIZJCYZiI80fKJ0UILmkuDA2VVRUYNkmWTpOJy4uLjo6Ojw8PCQkxM/P7/jx4+6SVukhSTCn3b9/v6Wl5bJly7CnduzYsdiaMHjwYD09PejaL1q0yMDAYO3atZaWlidOnEhLS1MoFKXSsSSoEtjtWl9fj7XJO3fuuLu7Dx061NDQ8NKlS6SaQPMWcTJfVlYWGBi4ffv2FStW4POKzi387rvv5s2bN3v2bGzdlnl7e/v6+trZ2c2ePfuTTz6RyWQffvjht99+a2FhQYRmhHS/+dmzZ89JEhsb6+Pjs379+mHDhr3++ut//vOfp0yZYm5uniDJ1RYeM0mSZEFwvH1iYiK+Cug8TRQYennKD1UXqmooGHJAXTamIFR+NBFBCyRf6JdVKtXNmzft7Ozee++9rl27jh07NiQkBFMimqMgJUlJSVu2bOnWrVuXLl1effVV3FHQqVOnLl26dOvWbcmSJRcvXiwvL8cdeVguBpuJyxzBeiglqaqqksvlBQUFqampYWFhFhYWo0ePfv3113//+9+/+OKLnTt33rRpE9bwkfjy8vLIyMht27YtWLBg2bJlu3btwkdRbGxsdXU1VVlRj6axsTEnJ+eiJBcuXIiKioqUJEIS2pwYERERFRUVKynVR0dHx8TEXLp06Yp0VOXFixfPnz8fFxcXL511mJiYmJKScvPmzaKiojJJ6bqwsBCqB5is1EhSWVmJaVaNtAqB4Q0DYW1trVKpBG2BhtfUIigUKilkpF4S9DhizwLHeLbaKbSE+v2v2LYpHC2PYm2ByjSUSRUKhVyYcdIgl5+fXyjJrVu3YmNjAwICfHx8fH19QVkGBASEh4fn5+dDBVilUmVnZ3t6ejo4OOzevRvTJlNT0/Hjx3/11Vfm5uaY2WBOgAU0pAf159KlSw4ODnv37g0LC7t27dqxY8dsbGwwMQKnKWZKzDvAF7NGUABqeCQktTBpy170S9GJjsmSDHiLlLSV2vZDoKDu34AAdaPTTQy5JAONHJRZSjx6A/Ev+aKQqVMiZ+hMsOhXXV2NxlIuLdWUS+RImfSdI1Y2TNfE2RWqX2FhoTgDa99c0CKorgUFBUVFRfiALygogCW03oqLi0tLS5VKJfV7YnaQI8xTwd7iOwoZoUZKfRG+lNCQGyRRSGo1FRUVoCrQAyBYYrhoGKutrb18+bKtre2mTZtwldPRo0ddXV1dXFwOHz7s6Oi4Y8eODRs2rFq1aol0bAVUq1auXLl27doNGzZs2rRpuyRbt261srLat28fWJjDhw9DWcZSEhsbGzvpSBNMMbdt24YzMTZKsmHDBlrJx8zSyMho1apVK1euhFqNgYHBsmXLDAwMQENja+qCBQuQjFWSrFy5cunSpYsXL16+fPmqVauMjY1NTU23bdtmY2Pj5OR05MgRT0/PEydOnDlzJjExMTs7m4oYpYPCxST77t27JSUlpRKJVtZyRgT2cuJCDNQrZYsATLSXVqsoCpqYI6rq1EvAFwZcqvbUoGg6CGfUMNGPYZGGdjKGhITgOPP9+/f7+/vHx8fjXNHKykoc7HD06NETJ06cPHkyOjoa97qgWkKvjaoipQ0tixqaUqkMDw9fsmRJz549Bw0atGTJEnyK79q1y8HB4dChQ66ursePHz8p6SOfOnUqKCgoNDT0jCSnT58+c+bMaUlOnTrl6+vr7e2NHVIJCQl3794tKCi4evVqRETEgQMH7O3t09PTwbjR9BGJwQSxtrYW+kRVVVUoFxAZVFL4wi//oSgUijKJ11PoSFv2Pwyg+Z/Wxl5dB7BBDK2+Rdok+u77h8SkNT9A56HVg5ioqamBof0nugjUSpjBCQI9+gAWi5i6EaqTmEIolUr0mWUSm0zNQS5JmSDII5oJvCgUCrClNDOhwLUqFUqT0iM6I5diCpsk0XIG7+SM+k80OmpEFIsWTQD3wcHB3bt3f/HFF+9pWONGUUyS6+vrsZzf0NCgkqS0tPTChQvz589//fXX9fX1Y2JiYE+pQheNViymCmZKD+WdWjcNhWRoaGi4ffu2hYXFkCFD9PX1t2/ffujQoaCgICzzhISEgC3CgVHr169ftmzZzJkzx48fD32lkS2HBY0cORKbjseOHTtKErwaJsk333wzfPjwMWPGTJw4Edu0DQwMVkpiKOkdQ7ERm5TXrl27fv367du3Ozk5BQUF5eTkoHbhWwAFBKhhprzk5OSEhobeuXMHH4TI9e3bt/39/RMSEnBhHSBCAVE3qFarYUMGAhyBUwUQY2w1JeRA6y3VDSoj0YYsRV8UKRWomBitiMhjVVVVWlpaTExMVFRUeHh4qKS5gnKEmXrIM2fO4NshTJLQ0NCQkJAgSbDz4MSJE35+foGBgUFBQWCrA1vEXxK88vPz8/Lyoj7/mCTEZbu4uDg7Ox84cGDfvn179+7F015aE7K1tbWxscEX0K5du6ytrW1sbGxtbaFGvV9iJJ2dnV1cXI4ePerj4+Ph4eHk5CRu2DIxMdmyZQtYWnt7e5zxunXrVmznMjIyWrNmDZQBzc3Nraysdu/ebW9vv2fPHmiYHj9+PEASnKuekZFx584dcGqYVmHwwrQrXxKsHxQXF6O/KpVuDcW2UNpmRwWH0VYsPrHUYI9GjS9KuEc/ADO6DtRGmmuhXdMXAcIBnYrZF8KEM2r7+Iu0Ye5H/QlioeaA2gj3VK/wFi2RWhxCo3DE+tlqrmGJbpM6SfIOA2JEdIQkJVsrCtEBYStaapnJDXUpGOjr6urQD+PDFkMbDXDVkmD0pPEUw6vWs1wQhSCwFiyaZwhl0mcCDPf/VCgUVVVVUHAWc9coCWXw/g0obtQB+KL6oEW/ADRECtzAkJSWlqLVQM/D3d3dxsbGxMRk6dKlixYt0tfX/+6778aNGzdgwIBevXp17979o48+6t69+8cff9yrV68hQ4ZMnDhxprSpYuvWrXFxceXl5dQfopJThaQmg5Sgu8a1jUgztR2gIfbzYqYoy2QpRkEZRCBawIqYt2MGkmJQog21DsopXIotC3P+6urqiIiI/fv329s372zes2ePo6OjjY0NVsEtLS1h2Llzp6Wl5fbt29evX79kyZJp06ZNkAQqxhiUhw37XrN44MCBEyZMWL58OR0YuHz58qVLlxoaGpqamlpaWtrZ2Tk7O/v4+Fy+fDkrK6uwsPCOdBvkXem4KmyKEvNOnRWyg/4qIyPjwIEDVlZWkZGR+EDAh6TY3oE/tl6Vl5fLJX6GPpZLfii5ubkyX1/fkydP+vn5+ft/r1MWHBwcEhKCsS08PBwsWLSknhkTE3P+/PkL0mmDcXFxoMPi4+MTJLkqsZlJSUnJycnXJEnRkSRJSktLsStcnOBSh0j5oSKEDTpZ5BBdHsyoT1SViemDe9gTuGq1WqFQXL16FTdBL1iw4JNPPjEwMDhz5gx97BUXF3t7e48bN+61115744039PT0MIVat27dhg0bLC0tXV1dr169Ch1m9GXgMRsaGqgh4agaqJfiI5920BQXF1+6dAlXqOOcTVNTU/GOdSx3eHl5rVy50s3NzdXVFYs8MTExlZWVQIPakkqlKi0tPXv27K5du1atWmVoaIizfqZMmTJp0qTJk5u3kIwdO/Yb6bRaXFY7tkXGjBmjp6c3ZcqUyZMnjx49eujQoaNGjdLT04Pe+PDhw/X09GbNmrVIOh8dRPh3331naGiI/Wj0qW9oaGhkZAR+AdsE1q5dC2W0NWvWGBsbm7RsHNiwoXk7HsREko3SbgITaVPepk2bcDXQ4cOHvb29g4KCwsPD4+Pjs7OzaakWRYmi1+qUUdZU7lR/qPRbNVCNoopEdUZrigwHdXV1SkE5lA4upBlDY2NjXV0dTkEukW4HKy0tjYuL27p16zffNO8++O6778zNzT09PaOjo2/fvk2pQrMHhZSYmOjs7IwtexcvXoRKIECgbLaafcoF9X26NhSjloEC1LInQGBPkwZyLxrIMTVb8a1obisjohvRLKZKtCdzqw5gCRDIJRkoR6g2SLM4epFHMfC2zOQdEKFAUYsQZvuVk1IlGigushTTrGVJNVYsdLihcGCguQgSRpaUXxgoR6IBZnqK2cSuKN24qKzhC85oVtrY2FhbW1suHZRDOnoKSTCMYQwrLi7Oy8tLTk6OjIwMDg4OCAigD6qQkJDAwEAohfn4+BwXxEvSMPWWBGafFoFly7/vf319fU9IdNvJkycDAgLAiAUGBgYHB4eHh0dLclZa4Tt//nxiYmJmZmaBxB1jQyKuukaCS6XvGUwxq6urMRvGXBOqKwQ+lWOrBk2LtFqUeEmvqHnCnmoCNUxd+5bgm3+p3Kku6QZIQSFSqhvgN7FKVFFRUVhYGB8fHxoaeuHChcrKyqampurq6jt37oSEhIDe9fHxuXLlCk7wICgwFcZftBeKhUZ8nFgdERFhbW1tamoKTb2FCxdOnDhxjCSjR48eK50xMm3aNFzugdmYo6PjiRMncBpAYGCgr6/v0aNH3dzcTpw4AaX7wsLCmpoa7FhXKJqXuNDr0tSZ0kkGQphwoNpOhUKIkWO8oicVAdmQoZ1X5EbLICZAyzv9hUHL48/7S0FpBU6ZBVb4S1GQL5QyDcRkT6AR1BQ+BaJloIzDpZgAstEyiNUbJYgwKS7R0M4r0RnlFJmiiS7ZU44QI3rCM2fO9OvX79lnn3333XeXLl26Z8+egICA+Pj4JEkSExPj4uKCgoJcXFzWr18/ePDggQMHmpqaZmdng8Ek0g0pQbeMiMiMzBJolGYxX6IZDurr6zMyMoi+9Jc+FsB8BQQEkOISFnrd3d0PHjzoLGlZwoAVpiNHjrhKcuTIETc3N6jh4AMkICAgKCgoLCwsMjIyNjb2ypUrOF0K/Sqt8RRLAq1AuVyukASXAgFYqmZa1QC5gBvs/KWmis4KH1SYqDc2Np4/fx5qU2bSrYk7duxo1pSWZNu2bRYWFtbW1ra2tvQB6ejYfKgCPib37t2L8wpcXFyQX1dXVzdJSIXZR9qefFISPz8/jDLYA1FaWkp1Q6z/yAKeVHxUdcUiE9/qmjUaTXl5+fXr16Ojoy9evBgXF3fhwgWcNhvZIhEREeHh4adPnw4LCyMSE8w1Uuvn54dCP3bsGPbCY9fC4cOHjxw5ckySgwcPOjg47Nu3z9vb29PTEydIODs74/Kfffv2oYbs27dvz5499vb2pMy+a9eunTt3mpub42t8uyDbWgTHj+7atWv37t2Ojo5OTk6HDh1yd3c/dqx5J7ivr6+/v39wcDDWseLi4m7cuIHj50qls1yxXlhSUoIV3yJJGfBuy432CoWiskWwHqNUKmtra9HKqI6JMyjgrFVGVCfVajWKUnd2pFWCrZYXLMUai+9f6lVA3CA6SiQM+BxGL4QvXHA6CA0eRZYTWaC4xBzBTHmhqazYpWi5R7dG4GgFS5nV9QXlaJpYih7F0HTtdcMkG4KaOgfxla5ZTBW9haXW33YCFAPR8otA2nfQVsi6vrRsUDrAB0+t8morZMqaaBDrPGGO+oa/VOsoLqAt/oUZ24BqamqgDoX2WFJSUlhYeO3atbCwMA8Pjz179tjZ2eFm2h07mjemUH/r6uoaHx9fVlZGnSS1MjFGvEWFJ9aSvKAOoxGRmQAhZ4BUdEBmqksUqThbJugQFP4inaJH2CMWeiv6FctUdEwpBOwVFRX+/v4WFhYbN24E64LTkEhjY9OmTaampvQ0kwQ2W7Zs2bFjBza17N+/H8cBYaXq3LlzmZmZRUVFhZIUFRVhIIZKIph6fMtQycJAydOClCZ46BZUkigUioSEhOvXryOo1NRUR0dHT09PKIpFR0dfvnwZ20fy8/MVCgURQUCS8ASAarVadlJSZPD3b74R6NSpUyA0w8LCzkgLdLqEJkbBS5cuXb58mdjMxMTEpBYqk2jM1Ba5LskNScB1lpaWissIVIo/yQD4KEtU5GLTpQBRfVHtcAYQtrZlZmbu2LHjyy+/7Nu3r7Ozc1ZWVmNj45UrV8aMGfPcc8917NjxzTfftLOzKywsrKysxGcqdDPrJdFaFqNqjUECpKdKpcIogvEDmrfBwcGjR49+8cUXO3bs2Ldv3xMnTlAxo9k0Nja6urrOnz//xo0b5ZJ6V3FxMc5BQ0VBdUfXr1Ao4uLigoOD/f39T0qHvHh6eh45cuTw4cOukq7TgQMH9uzZs1sSTL8wA7O3t8eEAG+xIorlUHNz861bt27bts3c3BxTOjy3b9+OAwRXrFgxb968iRMnQgl5yJAhgyQZLMnQoUNHjhwJwnTGjBlz5szBzeZr1qzZtGkTJoU7d+60srKytm5eekXUOD7V3d3dy8vr1KlT4eHhsbGx165do3V4sUCpwZBl+wbqINpypuWAECb3oo1optZFLmEQS6qhoSE7O/vMmTMHDx60t7ffu3evk5OTjY3NNmkzgrGx8dq1a21tbY8ePerh4YGDCFesWOHl5ZWVlQWmgGovVbO2ohPttVDSSrbo8n7MWqHdj5dH7+bB80gF9yCJp2QQaGR4kGDb90tRUOxtuSeXYu0VfemaRS/kC5bkmNzoGiglWo5pUgJ7dOxi9464KCLocNHSQq0kWGZQSlJdXY0FczyrJSEb/CXl2ZrWBOHgWVtbS9dhYa0en754YpymrFEjFdMMM3Ik5h19vhgC3hJ0CBZTBK1JD7mkYMkgetdoNEqlMj8/PyEhISoqKigoCCfguLu7Y8OUjY2NlZWVhYXF1q1bTU1NcQyxoaHh8uXLl/1Qli9fvmLFCpw5uGbNmnXr1q1fv37jxo0bNmyALurOnTsxNzpw4ICbm1toaOj169dLS0sBMLHYOF4QyoxVVVVal4kRVjAQsCKeVE/q6+ux2KOQNrmkp6fj0qegoCB/f38fHx9vb++TJ08GSXd2RUZGXrhwISMjA1fZirWCtBGVSiV9dlI3K+JJySC0yYYSTEVMxUclCDfwK2ZNdKlrD1/0jUoRtepSDEpMiVYu2vGrG8JP9UuBk0eqrm0ZRC/kS8uS/JK9rkHMMoDSCo0KTrSnCbFSqSwtLc3IyIiNjYWGWmhoaEBAgK+vr6en5+HDhw8c+P7mZUtLS4zdZmZmGzduNDExWbt2rZGR0cqVK9F2li9fjntRsKC7fft2HEYcHh5eXFxMnR5VBlxQ4OXlNWLEiFdeeeWPf/xj165de/bsOWLEiJEjRw4ZMmTAgAH9+vXr27fv119/PWHChJUrV548eRJfd5RrsZcgM73VhUvLRsRENIMZQTeoVCrRdtCu0a+CAkKniu6X2pfoGF7gDDwRem/0q3R2E75CKQFkoNRSjshAjUK0IfdkoLcwiH/hBr1xUlKSra3tihUrpk6dOmLEiK+++uqLL77oIcnHkvxbkh49enz88cf/kgT2//rXvz7++OMePXp88sknOOYYh40MGjRoyJAhI0aMGD16NHSO5s+fj0NFHB0dQ0JCcJRKamoqVJB0s0xZ0DJQFrTs2/lLStC0xgaD7kioVXb4S08aUrHLXqFQgBxUSIIFyLy8PIWiWWMamxBLS0txhiN9GJdLXzcKSW+9rEWgjNPyr/kUKV2BF4Xi+yMsoLeOtSiqYHWS0GcaYQLQ8BQbINWitgwoF7F0EAiFLBrolWgQHdyPWYxLdE/J1koq2YuRipb4mkBQGJjIJVm2aiPG3o4ZfgkoSr8YpmjWDYr8ImutOqZgdb0/LJtWo2g1MQ8rxocSDiWbkko2FD69Ipv2DaJ7MTQyixWMgoIvcgMDPcme3KNfoo0vGEdELVeMMti7QL60whGTSqkig+iYKj9VMwoTBtGxro0YkZZH8S8FIronS9FlW2Ytj1p+QW2Vl5djg1FOTk5mZvNh39hfC8oY3WmpJHL59yf/lJWVKSQpLy/HBBidJzvlJFEAACAASURBVH3vkAZVWwlAStp621Z2CG14BB0HBXa1Wn3r1i0PD4+9e/fu3LkT/CxUFrZt22ZlZbVz504coYtLETEtoW8utSQyf3//gICAVgnNSOEAzdjY2AsXLoDQvHz58pUrVxIkuXr1atIP2czU1NTrktjZ2d24cSNNknRJMjIy8AoX2qBqapVQO0A84CsgiKviUMVRp+/evfvtt9++//77Xl5eCoVCo9EkJyePHz/+hRdewH0+48aN8/f3x/VBmCY2NDSg4Ckc3bSB1kSktH6en58fFha2efPmb7755g9/+MMLL7wwcODAwMDA4uJiVCCEX1FRERcXt3HjxoULF+bm5hKlRdGJoKFO4wsfH+E0caTJB3oHqriYgqCDEKeksBG3zimkGQNmD2XS/keFQoFFldzc3LS0tPj4+PPnz5+TJDo6OlKSiIiIyMjIc+fOXZJOwbiHZ2pqanp6elZWFg4GRbsqb5nNIBZ0XvR5iZ1uSmXzmUHQadIF+cmygfo0QMaRFgkJCSEhIUePHnWR5PDhw1hscXBw8PDwuHz5cnl5OUofdRX5FUv/yUKAU8sI6CJAYxsZMOzBJTZG0QIpuWnfoBvL/du0H7LuWwqZ+meyEQ1owuRGzJGWM/xtbGyUy+UpKSlRUVEhISE+Pj5u0hFg0H/ZsWPHpk2b1ksHMK1evRo3zNKlQLNmzcK5lvr6+osXL543b96MGTOweWfRokWLFy9esmTJqlWrTE1NaTFp//792G0H4mbfvn1OTk7QPNqzZ8/eFnFycjognbHoImkhubk1nyPp5uZ2/PhxX19fPz+/U6dOhYWFRUVFxcfH5+Xl1dbWioiJOX24ZsBL02Jw3BgKaZb2EKccyBRVTioyFCv+qlQqLIViu2JFRQVOUsbcgDjT+8QBvuRyeXx8vLe39549e6ytrXFE15YtW0ylmxNwZsKaFjGWblXevHnzFkmwPq/13LZtm2UbslMQq4cnQqj/NVpYWGyTlveQVHpSanHz0vr167H+t7Y1MTY2xpGL4gl3CxYsmC/Idy0yf/78hQsXLlmyBMdEGBkZrVmzZvXq1YaGhtgQh23Oq1atwiF6ZmZmu3btgqLZ8ePHjx075unp6eHh4e7efKqai4sLDtXFFlon6Xi1ffv24bQ+Nzc3nAIMXTycMEsVgKquRqOpqamJjY11cXGxt7c3NTWdM2fOyJEjJ0yYsGbNGltbW3t7e2z4io2NReMCBX+fVYid3Q8COEGotLT09u3b8fHxUVFRwcHBfn5+Pj4+vr6+WCk5fvz40aNHcaaeu464uTVvrkKhH5XOlvX29vaRdDNPnDgRGBiIA9bPnTt3+fLl7OzsqqoqTN2htYBPtftJ6i/NDXpFpAq1mnQJf2lJ5fQwAowAI/ArQwC9LngksTf+5WcTqcWcOS8vLyUlJTo6+syZM2fPno2MjLy3hQWb85ycnIYNGzZmzBgHBwecnEbTJ3xbyQJa9tZpaWiC0Dx37lxMTAwIzThJLreoZ7bFZoLHTE9P79+/f4YgNyW5Icmj5zRRxlhnhr4kVKDlcrmZmZmxsbGvr295eTm+eSorK2NjYydPnvziiy8+99xznTt3vneZ7K1bt+gwlIaGBq3N5ro1BmM5jesNDQ1FRUWnTp0aM2ZM165du3Tp8s4776xevTolJQW7zpEezFCLioocHBxmzpxpbGyck5MDJps+hlH2rdZX8RXcI2G6FV2LFxM96uaFmHV6RQECTFWLQHepXhJop8JGVP+mJFFoFL6YKnC15FF0/GSZgRWypmUGOQ72trq6WqFQpKWlXb9+/e7du7h1Cp89hHar0D1ZaHBqGYFWEUAlxyv0XXSUB/V1Yv/QaiD3Yyn2daL5fvySG6jbp6amnjt3Ligo6OTJk76+vmA6PDw8XFxccLqNjY3N9u3bTU1NcSrNsmXLFi9evGjRogULFsyZMwcXBE2aNGm8JDjRZqR0/NyoUaNGjhw5cODAzz77rFu3bh988EH37t0//fTTXr169evXD1ec4+QQPT29SZMmLVq0aMeOHYekm8SwQOLq6urp6Xns2DEfHx+sWYaGhp49e/aCdHTMpUuXrl27lpmZWVxcjL2c5eXNd/Jg9UtUwGnVjNWyGkmgFFNTU0M0IjSwcH+FyPE9lOKjItAy0DROtBdjpFokOngQM9RsUVflcnlsbCzoLTdJnJ2dbW1tTUxMFi9e/O233+rp6Y0fP37mzJmzZs2aMmXK4cOHxbT9aDKwFqtSqWpra/Py8hISEqKjm491x+bQYOkmllOnTgUEBPj7+/v5+Z2UxK/lqLvgdiWkNQltkbCHLS0B/+AXkYSEhOimlFJ36tQpf2knyknpuCQ/HfH396frhj09m28cJubRQxJ3QfAWO1VPtmxXwnz49OnT586di42NPXfu3Pnz57GKn5aWVlBQgH2pqPNU89EcxKfYasgx2gUUk1F5aGRHM0GP19DQoFQqq6qqiouL09PT4+Pjk5OTCwoK0DwRCFTPxLWfH61C7OAnIYCiEddIsDQC1T/S3Ieeqe4TxQR7pSTiygpmyLW1tbh4ihJGfQIZ6NUTYdBNtq7NE5ERTiQjwAgwAk80Aj/76+Zx5ZoGC+gK4PhaOsQWVyOWl5cnJibq6+t/+OGHW7duTU1NxYQKBFrz3nMcFoZZI205FwnN8y0HaF6SLpPBfvPExMSkpKRr166lSHL9+nWiMkFj2tnZyWSymzdv3pLkdotI+prpj4XTxKYSlST4DgkPDzcwMBg/fnxgYCCmF7TvrKGh4ejRo1999dVLL7301FNP9erVKycnBxcE04ZBqN2B6NStBCIbBXru6tWry5Yte+uttzp06PD222+7u7vn5+dT4SFJcJmenj5+/PhZs2YlJSU1NDTQ5Q+0sI/o2v9IQzpFl1RjxNT+jHpPX4/wi79qSUBBIiJMCkUzeRQT0L65/Ty27/eX85bmxyhlJIyQJ0uUPrHbgI4+fvABAwx/OVnjlDACD4gA9UtU4ZVKZUJCwrFjx6ytrTds2IDbRfX19RcsWDBv3ry5c+fOnj171qxZM1tk0qRJEydOnDBhAshBvR/KOEnGjh07RpLRbQgoQhyYPW7cOD09PQoQwYpPXPw3ZMiQr7/+un///l999dV//vMfPL/++uvBgwcPGTJk6NChQ1pksCSwHCbJ6NGj9fT0pk6dunTp0h07dri4uIBewVk2RM1A/xHaPaGhoWFhYadPnz579mxcXNy9M1JoFL59+7ZCoaAN+GAY8UVdU1OD0Q3f4RgB0VFjTNTtlqlr0jKgoMmy/b4Izmi9qn3HD1iF6MAZcbjBkIQ8Uh17uDQQOme1Wl1VVZWTk5OcnJyYmJgsnSeenJwcHx8fExNz5swZnOwWGBiIU978/PyuXLkCBfz7z7gIOw60UUpX8IEfwZMIF5Q1/ooOfuFmSj+lU2SL6G07BtF9bW2t2BC0XrX6t66urkYSrMgiGWgyqE40WGsVHEoHlRxVTssBtTLiMWmChPDxFzHS7BGnPdJdaggTLjEz/HVsYdHC6vH+RUGjUKi4qfVpGVpNKpWs2O1Q2WlZ0qyP+i4tB61G8cu0FMH5ZaaQU8UIMAKMwG8KgV/4gEKDLCbnpCdHyabxFPP8xsZG3Jner1+/gwcP0qCDcGRBQUEh0o1AbRGaFy9ejIuLA6GZkJBwVboIKDk5GWxmqrTTPC0tLT09HWxmSkrKypUrZTLZf/7zn9u3b2dKkiVJdnb2TUlwnuZD3Ah2/xUU33KVlZUnTpyAskxycjLuKMD3CfaAV1VVOTg43GOCO3bs2L17d2tra2wXwvwDc2Xc6C2Wh1YygDVNcKOjo0eOHPnaa689/fTTf/vb3zIyMrDJBQVJ89oLFy7MmTNHT0/P3d1doVBA31OkNREgzZ7xF/MwPIn6RAIoVUi8uBlErCvkrFUDwKGQ4UYrfNEjuFpS0qHaKdZaCkT0SBUULsW/orMnwqxVN9rKC0pBq0BxUiosCb12AH8iAOFEMgJaCKDywxL1vLGxEafapaenYzfApUuXLkqCTQMxMTHR0dFnz56N+qFERkZGSBIuyBlJTp8+HRYWFvpjcubMGVyPAF8Ira1nVFRUdHQ0tjLExMRApevixYuXLl0SdzMQyXVNkpSUFKwFZmRkYM0vLy8P11xgQRJkCoYD8UlvqatXqVRipyECi+6a+g3xFaYFGAe1HFBH9DP6Gd2gKFKMO1pjB719Qg00rCP9BB1KhJ4oLKANEorO1/6pGaexgAxaQ6SYhrbGmlYjJcc/29BqsG1ZthqLmBddj+QFr8ScEtStVjCtatl+LBSvGBQ1JTJQGsj9jxqQDK3EIBdiexQnDER1UXS0wUgrnB+NnR08CAJU2aggqDa2XxCiM5hR1mLXoRsCotO1f5AsPEq/Wrl+lFFzXIwAI8AIMAJPFgI05ImjHo2YZBBnR9j0cPXq1QsXLty+fbuuro7mUbLt27dD++PMmTPh4eFaGpq6hGaSdHpmSkoK2MwbN24Qm3nz5k0LC4sPPvhAJsnx48ezfyg5OTm3JXn0nCY+LWhWGhsb26NHjxUrVhQUFOC7ERQSlC6zs7OXLVv26quv/vGPfxw+fLi3t3dxcTE2gEO3Qq1W41BtcHZiSVBlwulXKC18pkZGRk6cOPG9997r1KnTq6++evDgwbKyMkyysdheUVHh7e09adKk2bNnh4SEVFdXY16LMDUaTXV1NUqu1RjhjPKIkMkvakarT0ozOdayEYPScoMvCqgW4uIqra9lihEJE+slBUVu2spXW/a66fxF2VBbFVOliwDhQJ9SUNbQUuRBaGJQbGYEfgUIoHWL1RtthOo/ug6tnKLT0LJ8kL9iJyOa2woTCRY/UMml2KGJDBQ5wHBDGYc9cq218kSxwA0xHbopVKlU2O7dqkuMgEgYkkSRUryUbLy6/yd5JAOKjIZd3dTef+D36VLktpAM8ggMxbTRqwcxUFkgEJVKJS6OiiCLdZt2m/6MkxCpwhCexHO1P6yIpU84kOFBQHhYfgGRWIhimikWYE7ZJ3sYaA0ArbItZ1q+qIkBTIzCYhWi+qPl8Sf9bWxspMM0xE6D6gmWgdFwqG7gzAGqMzRxF0P4Sclgxz+KgNgfiiQ4qgRVUWo+rRp+NBZyQMv/NP2jV2xgBBgBRoARYAR+9QjQsKs1wtLMFtMwcCNAAzYqlaqqqio8PFxfX3/u3LnN7OPQoUNNTU0DAwPvh9CEjklqauqNGzfS0tKgmxkVFWVhYdG3b1+wmTKZzNHRMTs7OycnJ7dF8iTJlOTR7z3HqduYGmo0mosXL77zzjuvv/66kZFReXk5bqHBhqagoKA+ffo8//zzn3/+ubW1dWZmJgg78LBKpZIu84HCBSGuVecwn8Z0By4zMjJ27tzZrVu3p59+unPnzr179z569Ch0bdRqdVZWlpmZ2YwZMywtLRGpRqOh26Dq6+srKiqqqqpw6hmu8amUpKKiQqFQlJaW0oFobR3zhKuBcBVPuSRkVkgCS5jpKW+5Jws2ZZIopKsMKyoqkAac9ETxKluEAMf3Hm48pIvjtRAT/97n14jo5Zdp1giiVVXQdOnrC+0TnzS62W/L/peZa04VI/BTEUBDIV/UBLA4hH6SvjDJGQxCI/veqOXgp/7VDVC0wYggfoJS4xXHY91IEQjciBmkToB4nFb9ih0IBSXq3QMfwkp3LQpRU+BigGRJIItZhpncaL0iey2D6IsW+bTcPKF/KWtazKaYHRElWjr92WwU6hiFiSkN1SIqNaqBbRWumMJfuBnYamWEENA1iNkBXLRTRHwFMzVDEUNyRlGTY0SHgVhs++SFioASJr7SMlOmqFi1HIiNl6LWiheJ1PXINg+OAHXprVaPHw2/1TpAlj9a97QK+kejYweMACPACDACjMATh4DuFAhjLg2XWjnChifxg6KysvLUqVNDhw595ZVXiISUPfvss59++umiRYvc3d3pUiBxyzkd3QVCMz09/ejRowsWLPjXv/7131Akk6OjY25ursRh5t2RJL9FsiV5XHqahF1xcfH27duHDBny4YcfDhgwICgoqKmpSaFQuLm5ffnll506dercufPq1avT0tKqqqrq6urAzWFTpFwur6iowBntIENpekqTWtpjAgdgQuvr6+9toBwyZMgLL7zQoUOHp556av369XQtbFVVVW5u7s2bN8vKyhA4kadqtbqkpMTS0hI3cs6cOXPq1KmTJ0+eOHGinp7emDFjRo4cOWrUqClTpixatMjQ0HD16tVGRkYrV65csWLFqlWrjIyMDA0N9fX1Z8yYMWrUqIEDB3711Vf9+vWjM+D69ev35Zdf9urV68svv+zTp09fSfr16/ef//ynf//+ePbv37+fJP379x88ePDw4cNHjx49YcKEadOmzZs3b+nSpUZGRhs3bjQzM7O0tHR0dHRxcfHz84uPj5fL5aiaIAIIMa1qqvUXXsjy500ryftjNIgp1zKLf8UPGHz0ijojWunX8qj1lv8yAk8WAmJjpy4alRwMArKDV+1kDeGIT/IISy1GTzcoMSVaftsKVuz8dQNs30Yrup/XrsVACD1wo5SFthIp+hUdi8mmjNPoRja63sV+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IIAAArEmIH4pduu1DBkds7znz58vJpIHxpTqEZlvyoIaaIoarrjiigMHDliW5QhP/X6/iClN0xQjN8X8d9u2//GPf9x0003dunXbsmWzuFCcGdhat37pe+12VTjHS0pKnnrqqc6dO/fr1+/r9TR///vf33bbbXv27BFxg5iBHs49muza1atXx8XFOfIU8WNqauquXbsuUEssy5o9e3bgfXNycizLOnz48NChQ8WnKvAcx5Hk5OQpU6aUlpY2SlMty/roo48GDhzouIvbj8nJyQ888EBRUVG97k6mWS+uEE8uLS2dMmVKcnKy28OSx5OTk3NyciorK23bblimuXv37rS0NFmhLPTu3buwsFBt8Jw5c+S7jVK45557NIHg4cOHR48eHeKfnaysrHfffTdoDqt2QS0vXrw4aOVz5syxbds0zXfffTcrK6vOnoo/tufOnVMrp4wAAggggAACCCCAAAIIIBCbAuK3SLe+ixGaYj9xucO4bdti7rkcoanZ5Vz8JivPFD+qIzdTUlJ2794t80oxvd3v96tbrovt0cUAzKqqqtLS0gEDBiQkJPTo0ePAgQPiV3UZaMrWNqu55//4xz9++9vffvvb377mmmtq557X1NQsXrx4+PDhe/fuFfoRlGl6vd7hw4e7BRBdunQ5ceKE20cqnOOHDh1q165d4H1TUlJ+/OMfBx6v80hiYmJOTk5VVVU4rSosLBw8eHCd9wp6wsSJE0MPaMg0w3lMgdd6vd5nn302MTEx6KNxO5iWlrZx48ZnnnnG7YR169YF3su2bY/HM2jQILerZsyYIa+qqKjo37+/25kNO96uXbtDhw7JW8jCuXPnJk6c2IA6u3Xrlp+fL+vRFCorK2tX3Aj26tu377Jlyzp16hTsTddjGRkZId5a0yreQgABBBBAAAEEEEAAAQQQiHQB8XujWy/EKEgxN1pMDxejJhcsWOBYIjNwAKYaXIqT1SGc4t34+PhWrVrt3LlTVFtVVfXee++tWbPmrbfeevv8680331yzZs3q1atXrly5Zs2aVatWrV69+rnnnsvIyBBjP6+66ge7d+82z7/kYE85J92tX/peu10VzvHTp08///zzPXr06Nu3b+3cc6/X+9Zbb919990ff/yxbdti9/dQ5oeG04hGvPbEiRNdunRxSx169OhRUFDQiLcTVW3YsMHtjuEc79u37/Hj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AAIIIIAAAggggAACMSggfkt167jYqEcMwHTklXIFzMA4Uvx6LieMnzlzZuXKlX379lWnnIvFBuPi4lq1arVjx3axTKeYva7mlWpmKhsjNzeXQzgdU87lEE63ful77XZVYx03xo4d+8/QLZSRiY11y6asx+Px7Nq169VXX50wYcKIESMyMzPF6oS33377+PHjFyxYsGvXroqKigY0KcRMswE1N+IlHo/nwIEDju537dp19OjRDz/88IYNG8rKyhp8O8uyPvzww5///OdStU+fPi+88IJje3e3+s+dO/fCCy/06dNHPJHMzMyf//znIQ6SdaszOo6LD21OTs7YsWN79uwpP7ETJkx49dVXDx48GHrm2AQgH3zwwYABA0Qjxf/79OmzatWqUEZN1tm80tLSDRs2PPzww6NHj+7atWtGRob66a0zOq+zfk5AAAEEEEAAAQQQQAABBBBAoFEE9OmeGBQpNxaXaWNNTY1IG6urq9U56XJrchloipjStu2ysrLly5d/+9vfFrtNyEU2k5OTd+/eLXc510w5F1U5kk3xo9oY2VoxDz2okr7XQS9pxIPGK6+8cvz48UasMUaqiohMM0aeBd1EAAEEEEAAAQQQQAABBBBAAAEELqKAPt0TIzTl8EkxVNNtUKQcPqkZwnns2NHHHnuse/fuLVu2FEM1L7nkkj179gQukRk491zMf5eNEZeo9xKtVWevu8Hqe+12VWMdN86ePasJXBvrNtFXD5lm9D1TeoQAAggggAACCCCAAAIIIIAAAgg0QECf7slJ3DKvFDPNbduW+/A4MkQ5hFOEj+qoSRFTVldXf/rppzk5Oe3atYuLi+vVq9fx48flVj9ip3V1yrlsg1iv07Ztx5TzwMbI4aJuIPpeu13VWMcN27ZFPxurxhiph0wzRh403UQAAQQQQAABBBBAAAEEEEAAAQT0Avp0T+5mXlNTIzYWl7O8xRbeYpdzEVzati2nnIsLxW7mIoUUAxNFJCoCvTNnzixbtuyTTz6R63XKMx3Jphwuatu2jDjlCE05Jz2wMW591/fa7arGOm5E2e5AjeVSZz1kmnUScQICCCCAAAIIIIAAAggggAACCCAQCwL6dE8Mn5RTzh3DJ8VxOYRThoxicroMH8UJ6sKX8gQR7skTZA0iGxUDMx1brquNEbcQ+wsFbYzbE9T32u2qxjpuiP43VnWx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a8WKFczWLGV8qkMAAQQQQACBAgokJyeLQFOSpICAgAIexW4IIIAAAggggAACCGiaJp6TKcuyoihpaWnr16/v3r17u3btpk+fvnv37pMnT2bee06mWb5+LlOmTBGxJn8igAACCCCAAAJOLjBlypTydaJFaxFAAAEEEEAAAQTKXEBVVUVRxBLn4eHh77zzznPPPbdu3brY2Ni0tDSLxZK+RhD3npf5OBWiAQEBAR07dhTP1nTyKxmahwACCCCAAAIuKGA2mzt27MgMzUKc5nEIAggggAACCCCAgMg0VVVNTExcsGBB586d33rrrYsXL9pstjt37qSmpko2m41JmvxQEEAAAQQQQAABBBBAAAEEEEAAAQQQQMBJBMQsTEVR4uLiBg8e/Mwzz0yePDk+Pt5qtd66devOnTuZawQ5SXNpBgIIIIAAAggggAACCCCAAAIIIIAAAgi4uIBYI0hV1ZiYmOeff/7RRx8dP3781atXrVZrcnJy+jxNTdOYqunivxK6jwACCCCAAAIIIIAAAggggAACCCCAgPMIqKoqGvPbb7/17NmzVq1a7du337hx48WLF61WqyzL0qJFi/bs2XPlyhXnaTQtQQABBBBAAAEEEEAAAQQQQAABBBBAAAGXFVAyXpqmJScnBwcHd+3a1cfHp2nTpm+//fbs2bPHjx8vffnll//617/Wr1+/bt26gwcPXrt2TTyD0263ixvXXdaOjiOAAAIIIIAAAggggAACCCCAAAIIIIBA6QuoqirLss1m0zQtNTX1xx9/HD16dLNmzfz9/R9++OEWLVpIsiynpKRERUX985//7NKly4gRI/bv35+SkqLP8Cz9RlMjAggggAACCCCAAAIIIIAAAggggAACCLi4gN1uFxGl3W6Pi4sLCwv7d8YrNDQ0M9MMDQ2dN2/ep59+unbt2mPHjiUlJSmKkpaWxpLoLv7TofsIIIAAAggggAACCCCAAAIIIIAAAgiUskBaWprVarVnvESsKe4sVxRFrAwkXb58+euvv542bdrf//73hIQEu90u1hWSZVlRlFJuLtUhgAACCCCAAAIIIIAAAggggAACCCCAgIsL6Dmmfiu5oijiUZmapqmqKk2cOHHmzJl79uyxWCyqqopM0263sxi6i/906D4CCCCAAAIIIIAAAggggAACCCCAAAJlJaAHlWLapb4CkJrxkjp27Bgc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xYv511vs39rt9itXruzbt2/Lli1bt249d+5c/n1xaIBxII4cOVIstg5V8BYBBBBAAAEEEEAAAQQQQAABBBBwcYH0dc+XLVs2bNiwv/zlL1FRUcnJySdPnty+ffuZM2fEPM0bN24kJyenpaVZrVb9UZiyLMfHx69bt65nz57Vq1evV6/ekiVLYmJixKTOK1euHD9+PCws7OrVqy7u65zdL4lM0zl7SqsQQAABBBBAAAEEEEAAAQQQQAABBCqegJSWljZnzpxhw4YtXbr00qVLFy5cOHTo0M2bN1VVvXTpUkhIyIkTJy5fvizuMbfb7RaL5bffftu5c+fkyZPr1q3r7e1dvXr1F198UTxYUywitGLFiuHDhwcEBERGRt7z5uWKZ+r8PSLTdP4xooUIIIAAAggggAACCCCAAAIIIIAAAnkJSKmpqe+//36/fv1mzZq1ffv248ePx8bG3rhx4/Dhwxs3bty2bVt8fLzNZpNlWVXVixcv7tixY8yYMU8++aTJZKpUqZLZbO7UqdOaNWvi4+MVRUlLS7t8+fI777wzcOBAcSu6wyML82oHn5emAJlmaWpTFwIIIIAAAggggAACCCCAAAIIIIBA8QpIVqt1ypQpLVu2fOWVVzZs2HDx4sVLly5t37598+bNoaGhN2/eFAuXiyWb//GPfzRv3tzHx8fd3d1sNlerVq169ervvffepUuXxMM3o6OjP/nkk8WLFwcHB6elpbEcUPGOVnGVRqZZXJKUgwACCCCAAAIIIIAAAggggAACCCBQ+gLS7du3Z82a1bVr1/fff//ChQtpaWm//vrr7t27o6KirFarLeOlqur/pmF+8MEHzZs3r1Sp0kMPPVStWjWTyfTAAw906tRp7dq1169fF5nmmTNn3nzzze+++05RFLF4es7lnku/k9ToIECm6QDCWwQQQAABBBBAAAEEEEAAAQQQQACBciSQvkbQiRMnjh49GhMTc+PGjb17965fvz4qKiotLU2sEXT16tU1a9a8+uqrDzzwQJUqVXx8fKpXry6269Wrt3Tp0oSEhOvXr//444/h4eGJiYnHjx9PSEgQi57zME3n/Cns2rVLuvt64403eD6Acw4TrUIAAQQQQAABBBBAAAEEEEAAAQQQyFVA0jRN3CR+5cqV9evX79ix4+LFi6mpqYqiXLhwYeXKla+//nq9evVMJpO439xs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gAACCCBQaAGpSZMmPj4+kpR5E7okSU888cQnn3wSFRWlqurly5enTZvWqVOn999//8aNG+LpmTabrdD1cWCxCCQnJztBjkcTchFITk4uliGmEAQQQAABBBBAAAEEEEAAAQQQQACBvASkKlWqmEwmsfq5yWR6+OGHJ0yYEBUVJcuyxWKJiIho27atr6/vG2+8kZCQwDzNvBxL8/PU1NRcsjQ+choBZmuW5l8H6kIAAQQQQAABBBBAAAEEEEAAARcUkDzuvjw9PX19ffv27btjx45r164pirJv37633367V69e9evXr1u37qFDh1JSUuwZLxeUcp4uX79+3WniOxqSi8D169ed59dCSxBAAAEEEEAAzQvNqwAAIABJREFUAQQQKE2B3dlfp0+fLs3aqQsBBBBAwHUEJJPJVLt2bZPJZDabf/e733399dc2m81qtUZHR3/66aedOnVavXr19OnTGzVq1LVr1++++05VVbvd7jpATthTnqGZS47oTB/Fx8c74c+GJiGAAAIIIIAAAqUgYLfbU1JSSqEiqnBOgdOnT/v7+6cv2nD3NWjQIOdsKq1yELh69erp06eDgoI2b948e/bsBQsWzJkzZ8mSJWvXrt21a1doaGhMTAxRgAMab0tTIDk5eevWrdvv9QoMDCx0qxYtWpSz+EKXxoGlIJD+T03VqlXNZrO/v//UqVNPnTqlaVp8fPzMmTO7d+8+ceLETz/9dMaMGW+88UbNmjX//Oc/i5XQjS1j1SCjRilsO1N8V9S2HD58eN26dR988MHbb789fPjwadOmrVmzZt++fUUtt6yPL4WfAVUgkFNAPAT55MmTn3322fr165csWTJt2rQpU6ZMnDixV69ekyZNmj59+vz587/66qugoKCDBw9euHDhzp07OcvhEwQQQAABBO5LIDY29ssvv3zjjTeGDRvWpUuXl19++ZNPPjl27Nh9FcLOFUPg9OnTjRs3vptnpv933LhxFaNrFbIXly9fDg4Onjt37oABA7p06dK0aVNvb2/j8OnbDzzwwLPPPtu5c+d3331327Ztly5dqpAgdMqZBdatW6f/IPPZqFGjxp49ewrRkcjIyNdee+2BBx5wKLwQRXFIqQmkLw3k4eFRo0aN/v37h4WFqaqalJS0Z8+ePn36jB8//vjx45MmTfrwww9/+OGHN998c9SoUf/617+Sk5NFjqmqqpLxUjNepdZoF6+orPK66OjolStX7t27t1gasHfv3qlTp7Zq1crh/y8kSWrWrNnbb7/9r3/9q1gqioiIWLp0aXh4eLGUVsBCyvVP1GKxXL16NTIy8vTp00ePHv3555/37Nmzffv29evXr1q1asmSJZ988smsWbM++uijBQsWLF++fM2aNZs3b961a1dwcPCBAwf++9//RkRExMTE3LhxQ5blck1RLhpvs9lOnz69adOmSZMmdenSpVWrVvXq1cv51yrnJw0aNGjbtu3LL7/8zjvvrFu37uTJk1artVx0uTw2UlGU6OjoQ4cObd++fd26dX/961+nTp364Ycfrly5csuWLT/++OPp06dv3bpVHrtGmxFAwMUFEhMT16xZ065du5z/0LRp02b27NmRkZEuTuRq3SfTLBcjfufOnX379s2aNatXr15NmzbN+fc3/0+qV6/etm3bCRMmHDp0qFz0l0ZWDIFNmzbl/8vUv+3atWuhF+89cOBAz549q1evrpdWMfQqWC9ECKkoSubzNF9++eVdu3bdvHlTVdUjR468/fbbY8aM+eGHH6Kjo996662PPvro+vXrhw4dGj9+/KBBg6KiovQF0GVZFskmszVL7SdSwFitGHe7dOlSQEDAc8895+np+dprrxWx5MuXL3/55ZcvvPCC/v8RuW60bt36o48+On36dBGrmz9/voeHx1NPPbVkyZIzZ84UsbQCHl5qP4YiViRuMPnpp5++/fbbuXPnjhgx4uWXX27ZsuUTTzwhnqL74IMPVqtWzdPTM9cxMn7o5ubm7e3t6+v70EMP+fv7N2jQ4Mknn2zTpk2vXr3Gjh27ePHibdu2HTx48Ny5czdv3ixiszlcCISFhS1YsKBTp06NGjUym83G4SjEdqNGjTp06DBnzpwTJ04gXFwCcXFxe/fu/eijj9q3b9+6deunnnqqbt26Hh4exgGqXr26wO/fv//s2bP37Nlz48aN4moA5SDgJAI3b948cuTIxo0bZ86cOWTIkA4dOnTr1q13796DBg0aNWrUe++9N2vWrIULF3711VebNm364YcfDh06FBYWdvr06fPnz8fExCQkJCQlJd25c4d7Hp1kQPVm7Nmzp3PnzlWrVjX+35rD9ssvv8y/LLqYK2yQaTr5KKekpAQFBfXv3//FF1/M/y+vw9/lXN82bty4f//+JJtOPugVpnkFzzSrVKmybt26Qnc8NTU1ICCgXbt24ry90OVwYIkKiChScnNza9q06aJFi2RZttls0dHRf/vb33r16rVx48YbN24cOHDg3XffXbVqlcViURTliy++6Nev34YNGyIjIxVFkWVZhJtWq1VRlBJtLoXrAgWM1Yprt++++6579+6+vr7inzE/P78ffvih0IWfP39++vTpDjek5PoPpCRJderUGT58+OHDhwtd3alTp5566ilRvpeXV6tWrb788ssLFy4UusACHqgPllNtqKoaExNz4MCB1atXjx49+qWXXmrXrt3TTz9dp06dvIagGD83m8316tVr3rx5+/bte/bsOXny5MDAwNDQ0ISEBKdScv7GJCYm7tix47XXXmvTpk1B4ub7HcQGDRq88MILmzZtYtpgoX8MN2/e3Ldv30cffdS9e/dGjRrd1xA88cQTr7766qZNm65du1boBnAgAs4jcO7cuc8++6xDhw7169f38vIq4F8Hd3d3Hx+fGjVq+Pn51atX77HHHmvSpMnTTz/dvHnz1q1bv/DCCz169BgwYMBbb701bty4999/f86cOcuWLfv666+3bt26d+/ekJCQ0NDQ8PDws2fPRkdHx8XF3bhxIyUlxWazOY9MeW9JWFjYkCFDHnrooYKMae/evWNiYsp7l2l/AQXINAsIVSa7/fzzz8OGDevYsWNB/uYWfJ/WrVvPmjUrNja2TDrlVJXGxcWFhISsXbt2xowZQ4cO7dat2wsvvNCrV68333xzypQpixYt2rRpU3BwcERERKFnEZZEf2/fvv3rr7/u3bt306ZNS5cunTZt2vDhw/v06dO5c+eXXnpp8ODB4hlxBw4cKNtRLnimKUlS27ZtL168WBSuyMjIv/zlL40bNy5KIRxbEgJikmZmplm5cuUlS5ZcuHBBURTxyNVp06b94x//iI6OPnLkyIcffrh8+fIjR47YbDZFUX755ZcVK1YMGTIkMDBQZJpWq1WshE6mWRJDlWuZBYzVimW38+fPt27d2uHfs0JP1YyJifnzn/9cu3ZthwLzeevt7T1o0KDQ0NDCdWfOnDkOhderV+/nn38uXGkFPyrXgSuTD2VZPnPmzK5du2bNmtW9e/c2bdrUrVvXwaQM3zZq1Kh9+/YDBw5cvHjxvn37uODJ/0eSmJi4fv369u3bF/Du8qKMbO3atTt27Lhp0ybm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9M6dO3slUnzjjTfCw8Ovv/76jRs3XkT569lHYmJibrrpJkmSRowYUaP06tdff23btm337t2dTmd1TMScYw888EB1DuYYBBBAwIsCYo0g19hzVVVLS0unT5/erl27Sk8bxkJCXiwolz5X4KKDtkv54L59+2bOnNmqVatp06bV6Dzfffed8Wde8wOusV8p03z55ZeNt863s2DBguqXYeXKla1atRo7duy2bduq/6lLPPLcVqsfr+Tm5k6ePNlYfKlZs2affvopE4FbqnGPHz/+2Wef9ejRo127dlX+BPn7+7dv3/4vf/nLSy+9tHXrVg+vZGopKw8XRpbltLS0mJiY77777oMPPnjllVd69+7dpUuXTp063XbbbTfffPP111/fsmXLZs2aXXHFFQ0aNLDZbKGhoeHhjGU8OwAAIABJREFU4a1atbrllltuv/32u+++u0ePHo888siIESPmzp37v//9b8eOHceOHfNwRbx+ucTExOeeey6SrRoCzz33nFfCCK/fJBTAHQJ79+49d6LDKn/RiBevv/76Hj16vP/++wzmcEdzeOCcx48ff/bZZ73417J3332Xv8qIhl6wYIEkSZMnT87JyalR0xcUFLRs2XLRokXV/9SoUaM6depU/eM5EgEEEPCKgLECUHmm+dZbb7Vu3drorUOa6ZVWqeZFLzFuu5SP7969e9++fTU6ww8//PDHP/7xwo+8e/fuNc45bNiwCxwsSZKfn9/ixYuN46uzs2nTpuocVovHVLMp6+Jhubm5K1asePXVV4cMGbJ69eoqZ/ypi/WqZ2V2Op179+5dtGjRqFGj+vbtGxER0bt376eeeioyMnL58uUxMTE1fSauZz6Wqk5hYeHJkydTU1MPHTr0yy+/xMbG7ty5c/v27dvKtp07d8bGxu7bty8xMTE9PT0/P99ShacwCCDgUwJpaWmzZs165JFHOnfu3LZt2zZt2rRr16592da2bdubbrrpz3/+89133/3yyy8vWbJk7969/NXTp24PKus+gQ4dOsyYMUOW5Zpe4v+WAr711ltrNLn2vn377r///ppeiOMRQAABTwqIseeKohQXF7vWPS8pKZk+fXrbtm2NuZ/JND3ZHjW9VkZGRi2mb+4+1Y4dO+66664u59/uvfdec6Y5ceLEm2+++fyHd7n++utXrFjh7mJfyvlrNCSkpq3P8QgggAAC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wDMCYubMhIQESZblgoKCOXPmdOnSZefOnaqqOp1OWZZFD820tLTnn39+1qxZJSUlDodDURTPlI+rIIAAAggggAACCCCAAAIIIIAAAggggAACZgFN0xRFOXz4sCvT/OSTT55++ulXX3310KFDuq4rimLMm5mYmNilS5eXXnqpoKBAjFcXM2yaz8U+AggggAACCCCAAAIIIIAAAggggAACCCBQWwLmYeLG8uZi9XJN05KTk6XDhw/ffvvt/fr1O3jwYGlpqZhMUwSXmqYlJSV16tTpueeeKywsNLLO2ioc50EAAQQQQAABBBBAAAEEEEAAAQQQQAABBM4noJo2Y27MEydOSI8//nj37t0//vhjMd5cjC7XNE2WZUVRkpKS7rrrrsGDB586dUr07RSB6Pkuw+sIIIAAAggggAACCCCAAAIIIIAAAggggMAlCoipM82dNI0T5uTkSJ07d/76669//fVXkXQaPTTFxxITEx944IG+ffvu2LGjuLjY3O3TOAs7CCCAAAIIIIAAAggggAACCCCAAAIIIIBAbQmIZFJEkWI+TGNWTFVVHQ6HtHnzZjFXptPpFIGmOdZMT0//+9//3qtXr6ioKNFVU7xbW+XjPAgggAACCCCAAAIIIIAAAggggAACCCCAwLkCRrJpxJVi2kxN0yRd14uLi3VdNwany7KsqqoYe37y5MkJEybcd999I0aMOHnypDisyj6f516VVxBAAAEEEEAAAQQQQAABBBBAAAEEEEAAgYsTEDNhiijSmCpTzJzpyjSNyNPpdB4/fnzdunVLly5dt27d8ePHf/3113feeadHjx79+/c/fvy4OAUj0C+uGfgUAggggAACCCCAAAIIIIAAAggggAACCPymgBE/GsPPi4qKMjMzjx49mpWVpSjK2UyzuLh4+/btEyZM6NKlS/v27R9++OGVK1dmZmbOnz//gQce6NevX3p6uhGL/uaFOQABBBBAAAEEEEAAAQQQQAABBBBAAAEEELgIAWP2TNErU1XVjIyMr776at68eWvXri0oKHBlmqqqZmZmfvzxxw888EDTpk0DAgKuvPLK559/fteuXXl5eT/88MOQIUPuv//+Y8eOiWTUCEovokB8BAEEEEAAAQQQQAABBBBAAAEEEEAAAQQQuICAGFYukk1d1xVFSUpKev3115988smoqKisrCxJUZQdO3aMGjWqWbNmoaGhgYGBTZs27d+//48//lhYWCjLcnZ29ujRozt06HDs2DFxJebTvIA4byGAAAIIIIAAAggggAACCCCAAAIIIIDAJQoY48VFvpmcnDxp0qTevXu/9dZbGRkZ0pdfftmtW7ewsDA/Pz9Jkmw2W7du3datW1dYWKiqqtPpPHXq1PDhw1u2bJmUlORwOMTcnJdYJj6OAAIIIIAAAggggAACCCCAAAIIIIAAAgicT8BY10dRFE3T0tLSpk2bdvfdd7/yyivHjh2TwsPD/f397Xa7zWazl209evT45ZdfxOrnuq47nc4pU6a0adMmMTFRXIN+muez5nUEEEAAAQQQQAABBBBAAAEEEEAAAQQQuEQBtWwTJxGZ5okTJ959991bb7114MCBycnJkp+fX2BgoJ+fX0BAgJ+fn91u79Onz4EDBxRFcTgcYurMKVOmNGnS5NChQyLiZD7NS2wVPo4AAggggAACCCCAAAIIIIAAAggggAAC5xNQVdU8maamaXl5eStWrOjatevjjz+empoq2e32Bg0ahIaG2mw2SZL8/f179+69b98+8THxddKkSVdddVVKSgoDz88HzesIIIAAAggggAACCCCAAAIIIIAAAgggUIsCYhy56KepquqePXv+ry9mv379UlJSpLZt2/7hD38ICQlp2LChzWYLCgrq06fPvn37FEVRVVV85u23327RokVCQoLT6dQ0TZblWiwcp0IAAQQQQAABBBBAAAEEEEAAAQQQQAABBAwBYzJNXdeNTpZJSUkDBw589NFHk5KSpMDAwOuuu85ut1922WWBgYF2u71v377x8fHmHp7Tp09v165dSkqKGHXOfJqGLzsIIIAAAggggAACCCCAAAIIIIAAAggg4AGB5OTkgQMHRkREbN26VZIk6frrr7fZbIGBgWKZoEcffTQhIUHXdRFr6rr+z3/+88Ybb0xNTSXT9EDzcAkEEEAAAQQQQAABBBBAAAEEEEAAAQQQqCSQmpo6aNCgP/3pT++9955rjaC2bdsGBAQ0aNBArHsu+mmKjp3i66xZszp27JiammrMzVnpjHyLAAIIIIAAAggggAACCCCAAAIIIIAAAgi4TyAtLW3EiBE33HDDyJEjJZvN1qZNG5vNFhoaarfbg4OD+/Xrd+DAAWONIFVV58yZc+eddyYlJZFpuq9VODMCCCCAAAIIIIAAAggg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";

  // src/assets/images/spell-editor-effects.png
  var spell_editor_effects_default = "data:image/png;base64,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evToIUlSfHy8j+mRDARAAARAAARAAASqTiA+Pl6SpB49ehiLggxqZIIzIAACIAACIAACIAACtxUB6a677urVq1dqaqrT6SShMzk5+dlnn01LS7Pf+nO5XLR1EvuE3laAAmvs6tWraUlafHw8fEIDY4hcIAACIAACIAACvhMoLS0lDVSSpNWrVxszQgY1MsEZEAABEAABEAABEACB24qAdM8997z++usHDhyQZZn2gl+4cGHTpk3T0tJIGKXl8PAD9XdYTJkyhZRQ/AcBEAABEAABEACBWiMwZcoUj5MWyKAeseAkCIAACIAACIAACIDA7UNA+vnPfz569Oi0tDRFUWRZVlU1Pj7+zjvvPHDgAMKAVnEcrF69ukePHhQntNZeflARCIAACIAACIDAbUigcePGPXr08OgHSvMZyKBVnNchOwiAAAiAAAiAAAiAQDAQoNCdbrdb0zSXy0VOnGQYR/Wkpe10UvTslO6///7IyMgjR46QBmq32xMTEx9//PGMjAwqMRhaCBtAAARAAARAAARAAASqQgAyaFXoIS8IgAAIgAAIgAAIgEAwEGCt0uVyybLMH1VVFc+QZycJoG6323XrT9M0qU2bNm+//fbx48dpUfz+/ftjYmJef/31M2fOBEPzYAMIgAAIgAAIgAAIgEDVCUAGrTpDlAACIAACIAACIAACIFDnBEjuJDNI4rTZbC6Xi/c0ovCedrudRVLe9Ej6xS9+8d5772VmZiqKYrfb4+PjJ02atGTJkuvXr9d5w2AACIAACIAACIAACIBAtRCADFotGFEICIAACIAACIAACIBAHRJgQZPcP2mXIxJAFUUhMVRRFPID1UX7VFVVeuihh2bMmHH27FlZlsvKymbMmPGXv/zlypUryq2/OmwYqgYBEAABEAABEAABEKguApBBq4skygEBEAABEAABEAABEKgrAqxv0op4VVWdTif5hJLvJ4UHpfMklSqKQtbelEE7d+68ZMmSa9euKYpSUlIyadKk6dOnU072Ha2rtqFeEAABEAABEAABEACBaiEAGbRaMKIQEAABEAABEAABEACBuiXAe7yrqqooitPpdLlcxcXFOTk52dnZFy5cuHTpUl5eHvuEsnLqdrulrl27bty4saSkxO12FxcXR0ZGvvfee7yivm4bhtpBAARAAARAAARAAASqhQBk0GrBiEJAAARAAARAAARAAATqkAAtiqfd4Wmb+PLy8mPHji1evPjNN98cNmzYH/7wh1dfffW///u/d+7cmZ+fL8syLZknMVR69tln9+7dS66kJSUlb7/9dkxMDC2t1y2hr8NGomoQAAEQAAEQAAEQAIGqEAhOGbQAfyAAAiAAAiAAAiAQagSqMiVD3ioSUBRFVVVZlmnBe25u7saNG1955ZVf//rXzz333IABA/r06fOrX/3qwQcf7Nq1a3x8/MmTJ10uF3uGSs8//3xaWhqtoi8rK5s9e/aiRYto2Tz5hFbRPmQHARAAARAAARAAARCocwKQQUPtDQv2ggAIgAAIgAAIBCmBOp/X3c4GUABPkjUrKiq+/PLL3r17P/XUU9OmTdu2bduJW3/r1q2LjIz893//9wcffPDtt9+uqKig3ZNuLop/4YUX0tPTyTW0vLz8r3/96+rVq0kAhQx6Ow8stB0EQAAEQAAEQKA+EQhmGbQ+cUZbQAAEQAAEQAAE6jEB0mXrcQODv2m0AxLJmpmZmePGjfvNb36TlJRksVgqKiocDof91t/BgwcHDBjQtGnT//qv/6qoqNA0raKi4icZ9OjRoySD2u32gwcPZmRkcPTQ4G8/LAQBEAABEAABEAABEKiUAGTQShEhAQiAAAiAAAiAAAh4JwAZ1DufWrjKG8EXFhbOmzfvueeee+ONN65cuSLLcnl5ud1upx2TLly4MGXKlHvuuefxxx+32Wy0gv7mTvEvvPDC0aNHVVUtLS29dOnSjRs3bDabLMtwBa2FzkMVIAACIAACIAACIFA7BCCD1g5n1AICIAACIAACIFCPCUAGrfPOJcdNt9tttVqHDh36q1/96p133rl+/brT6SwpKSkvLy8tLa2oqLhw4cKYMWNatmzZu3fvsrIykkE1TftJBnW73VeuXNmxY0dBQQHFCcX+SFXv2tWrV/fo0aNx48YS/kAABEAABEAABECgJgk0bty4R48eq1evNpvAQAY1I4PzIAACIAACIAACIOAjAcigPoKquWS0RZKqqpcvX+7WrVvr1q0nTJjwww8/OJ3O0tJSu93ucDjy8/M3bdr07LPP9uvXLyEhwel0qqqq3Pr7lzdoQUFBRkZGfn4++YHCIbSKfTZlypSafNlB2SAAAiAAAiAAAiDggcCUKVM8zmEgg3rEgpMgAAIgAAIgAAIg4DsByKC+s6qhlOy1efHixX79+rVo0eLpp59es2bNlStXnE6noigXL1789NNPf/e733Xp0mXZsmU3btxg5VSW5X95g169ejU5OXns2LGjRo1asGBBampqXl5eDRld74tdvXo1vZfEx8eXlpbW+/aigSAAAiAAAiAAAnVLoLS0ND4+nqYfHn1CIYPWbQehdhAAARAAARAAgXpAADJonXei+9afpmmlpaU7dux4/vnnIyIiOnXq9Kc//Wn69OkTJkzo1atXp06dfve73y1btsxqtTqdTk3TXC6X3W6/GRu0d+/ex48fV1X1xo0be/fu/etf/zpjxoy//e1v33zzzZdffpmUlLR///78/HwKQepyuWgRfp03O8gN6NGjhyRJ8fHxQW4nzAMBEAABEAABEKhPBEgJ7dGjh7FRkEGNTHAGBEAABEAABEAABPwiABnUL1w1kZiWt8uyrGma3W7fvn37mDFjOnfu/MADD9x///2PPfbY2LFjly5dmpaWVl5eTok1TSOH0JuxQV988UXaIsnpdFJUULfbrSiKzWbLzs7+4osvevbsOWrUqL1799LOSjXRhvpXJsUDhR9o/etZtAgEQAAEQAAEgplAaWmpJEmNGzc2GgkZ1MgEZ0AABEAABEAABEDALwKQQf3CVXOJXS4XrY53uVxWq/XYsWNbb/2lp6cXFxdzveqtP03T3G630+n8aVF8enq63W5XFIU2lSeV1Gazpaenz5kzZ+7cuStXrkxLSysqKnK73RUVFdhEnoGaHdCSNLOrOA8CIAACIAACIAACNUTAbBICGbSGgKNYEAABEAABEACB24cAZNA67+uKigpSL1kJpfXrbrebdjmiTeHJD5RX0JPZNxfFv/DCC8eOHSPpky7b7fZr166tWLHi/fffX7p0aW5ursvlIvdRRVHcbnedtzn4DTB7Awl+y2EhCIAACIAACIBASBMwm4RABg3pboXxIAACIAACIAACwUAAMmid9wI5gbKbJ3l6UgxPTdNIA5VluaKi4sKFCzk5ORznk/TMf22RROppcXHx3r17J06cGB0dnZqa6nA4qAhFUVwuF7aP97G/zd5AfMyOZCAAAiAAAiAAAiAQGAGzSQhk0MB4IhcIgAAIgAAIgAAIMAHIoIyiDg9YqCRlk3czIm2U/l+5cmX+/PnvvPPO0qVLKyoqODzozdigx44dI4fS8vLyr7/++o9//GOPHj127NhB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NiuAGNRmm6bMivGlr/T09Hfffff111//OwYtKirasGHD6tWr7927JwiCXq8vLi6eNWvWsmXLcnJydDqdIAhJSUmDBw/29vb28vLy9vZWKpXUFVQmkymVSrlc7uzs3Lx58/nz52dkZGi12vDw8Pbt2+/ZsycvL4+mBGX/XZptlFnFqrEzOjqa7g8iIiLy8/OrxkXhKiAAAQhAAAIQsFmB/Pz8iIgIuv0os08oYlCbbbuqUbHc3NwuXbpI102ywetCDFrxRmGrIbGFtv6aZlen0wUFBdG/M2PHjn0aHusqLoaSEIDAUyKAGNS+Gpr6YvI8361bt9dff/3B3KDFxcV6vb6oqIjiTr1eHxsb27p165iYGEow1Wr1okWL6tev7+zsrFQqnZ2dHR0dlUol5aEuLi4ymUylUj377LM//vijRqPJycnZuXPnqFGjRowYceHCBVolSdoJlBajty84S2vr7+/PcVxERISlH0R5CEAAAhCAAAQg8NAClIT6+/ubHgExqKkJ9jxtAohBK97i0iXCxowZExsbGxERwVbNCgwMNJ2WtOIHR0kIQAAC9iuAGNTu2o7m/OzWrZuvr296evqDGJSu4cqVKwsWLAgMDOzXr198fHx2drZer7969eqIESOeeeYZmUzm6Ojo4OCgUqlq1apVt27datWq0cqSMpmsdu3awcHBNOX8tWvXxowZ8+WXX6amplL6Sctusv9aSMGo3cFZVGGaDxT9QC1CQ2EIQAACEIAABB5RID8/n+M4lUplehzEoKYm2PO0CSAGtajFTVf0omXBFi9ezB4hLTogCkMAAhCoAgKIQe2uEakvZq9evV555ZXz588/WCmeruHYsWNfffVVUlIS7bl9+/aSJUuef/55mUwml8sdHR1VKlW10hf1BqVB8XK53MXF5fXXX79165ZWq9VoNGfOnPlrDcevv/46PT1dr9fTyvKiKNKJWRhqd3AWVZiGilj0ERSGAAQgAAEIQAACjy5g7iYEMeij2+II9i5QWFg4e/bsv5Y6WLt27VPyVPLoTVZQUJCSkrJz586UlJRy1sh69BPhCBCAAATsQgAxqF00E6skG5veu3fvxo0b//777w9iUFodXhAErVZ7//791NTUpKSkDh06ODg40KSfbm5ujo6ONWrU8PT0VKlUTk5O7u7uLi4u9GuLFi2+++67e/fu6fX6gwcPfvzx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s1jvJ0+eBFB//PEHqdi/f//SLANUKpX6QXhq1apVmh3x4OStW7eIkyQRGBj4trEuen4hsZJOnjz522+/bd68edmyZTNnzpwwYcKgQYM6dOggkUj27dv3888/+/v7+/j4eHh4uLi4tGnThjj2tsSgQYNycnLe6ZtCofjyyy+JkRYtWjx48EAkEj169Cg4OLh79+7kUtETY8aMEYvFs2fPhiqzZ8/m8/kcnZRY27t37zudxAJIAAkgASSABJCAQRMASVSn05HE3zMBEEBNTU3NzMw+/PBDkEHNzMxMTEyIDMpZDapQKO7duzdv3rwjR46ApGrQaMrWecBatjbRGhJAAkgACSABJIAE3knAoCchOTk57AjgkydPlslkDMMIhcJWrVoRAavoiaVLl2o0GoZh7t69y67122+/vZPk2wqoVKo5c+awrVEU1aNHD1hl8LZaRckXCASNGjXiWD5z5kxR6pIyCQkJZ86cOXz48K5duzZs2ODv7z9nzpxvv/3W1dV10KBBPXv2bN26db169czMzDgNsT/2799fIpGMHDmSnVnE9Oeff17EYwcOHTpEbJ4/f57P548ePZrkQKJOnTr+/v7x8fFZWVlXrlyZPHkypwD52K1bt1evXt28efOjjz6CTDc3N5FINGjQIFKGJEaNGgUKO+GGCSSABJAAEkACSMD4CNA0rdFoFAqFWq2GffF/TwZgRzyIoY0bN4YETI+sra1JiCRQT8naz/T0dG9v70OHDqEMyrlXACsnEz8iASSABJAAEkACSOB9EzDoSUhKSoqDgwPRqmbOnAkyaHJyco0aNUh+0ROTJk0CtSspKYldy9XVtYhSnf540TT9448/sq1RFOXr68vegaVfqyg5WVlZ+sstX716VZS6pMzdu3f/+OOP33//fd++fZs2bfL39589e/aUKVNGjBjh5OTUsWPHpk2b1q5dG2b7nF6Qjy4uLhKJpFevXiSn6IlWrVqRswiIVwUmBALBZ599RlHUF198IRaLlyxZwmmlbt269+/fT0pKWrNmzeLFix89eiSTyQ4fPswpZmNjM3/+/MzMTIZhUlJSQkNDw8LCDhw4sHr1arVafePGjXbt2pEqH3zwwezZs7Ozswt0CTORABJAAkgACSABYyJAzvCEE0L/3RRPDgalKKpVq1YggMK7lZVV+/bt165dm5aWxpZBaZoWCATe3t6H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DaSOyQwiQASIABEgAkSACBABIkAEiAARIAJEgAgQASLQmAnwPI8TN8Gh0+lycnIWLFjw1VdfKRQKFElLZVB7e/vmzZs3a9bM2tqa4zhHR0eYFuro6NiyZct333133759Go0GlsbjtqONmS+VnQgQASJABIgAESACRIAIEAEiQASIABEgAkSACBCBhkBAb7jwvPjMzMxff/11+vTpGzZsUKvVWq327t6gMPezQ4cOXbt2bd26tZ3hcnFxadKkCWwY2rp166VLlxYUFECKcNYSuPV6PRQV5oeitipakN8QcJANRIAIEAEiQASIABEgAkSACBABIkAEiAARIAJEgAhYHgFcxQ6O69evDx8+fOnSpfHx8VqtFjy1Wi1nY2NjbW3dunXrvn37jh49+sknn7S2trazs2vTpg3MCW3atOlbb721bdu2tLQ0lUoFc0J1Oh2mgoIryqAokuLWpJbHl0pEBIgAESACRIAIEAEiQASIABEgAkSACBABIkAEiEC9E4AZmTDlU6fThYSEvPrqqxs3biwpKdHr9VqtFiTKuyfFOzg4DBky5NixY56enm3atLG2tnZycnJ0dLSxsbG1tbWzs3vuuee++eabqKiowsJCiAkyqE6ny8jIuHHjRnx8fHp6ulwuh6RhKT6EqXcWZAARIAJEgAgQASJABIgAESACRIAIEAEiQASIABEgAhZJAKdmgiAZHh7ev3//TZs2qdVqdipnqQwKh8W///77Fy9ePHjw4FdffdWiRQuJ4YJHEonEwcGhY8eOY8aM+fPPP2/fvo3nLvE8f/jw4YULF37//fcHDhy4efNmcXExnKSEu5NaJF8qFBEgAkSACBABIkAEiAARIAJEgAgQASJABIgAESAC9U6A3a7zzp07Z8+enTt37vHjx3EeKKxc5+zs7BwcHKytrV966aUff/wxPT393Llzn3zyyaOPPmpvuKysrGxsbOzt7W1sbFq0aPHyyy/Pnj07KCiooKAADpuPi4s7depUSEjIzZs3s7OzlUolTBfFfUnrnQUZQASIABEgAkSACBABIkAEiAARIAJEgAgQASJABIiARRLA2aA8z1+8ePG77747ePBgRkYGHCJfZm9QOzs7a2vrxx9/fOrUqcnJyYWFhREREe7u7o888oi1tbVEIrG1tbVmrtatW/fr1++HH35IS0sDtRWmf6LyijIo+FgkXyoU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";

  // src/subscreens/dark-magic-subscreen/tome-of-knowledge-pages/effects.ts
  var EffectsPage = class extends BasePage {
    get name() {
      return "Effects";
    }
    load(container) {
      super.load(container);
      const t1 = PageMarkup.text({
        content: "Effects are constructor from which you can create your spells."
      });
      const img = PageMarkup.image({
        source: limits_default,
        width: "60%",
        height: "auto"
      });
      img.style.marginTop = "0.25em";
      const t22 = PageMarkup.text({
        content: `In the <b>Limits</b> section, you can limit the use of spells with certain effects.`
      });
      const imagesContainer = PageMarkup.flexContainer({ gapX: "0.5em" });
      imagesContainer.style.marginTop = "0.5em";
      imagesContainer.append(
        PageMarkup.image({
          source: spell_editor_main_default,
          width: "45%",
          height: "auto"
        }),
        PageMarkup.image({
          source: spell_editor_effects_default,
          width: "45%",
          height: "auto"
        })
      );
      const t3 = PageMarkup.text({
        content: "In the spell editor, you can specify the icon, name, and effects of your spell. There are also descriptions of each effect and which atoms they consist of."
      });
      const t4 = PageMarkup.text({
        content: "Spells can only be edited by their creators. That is, if someone gives you a spell, you won't be able to edit it."
      });
      const t5 = PageMarkup.text({
        content: "<b>To be continued</b>",
        fontSize: "lg"
      });
      container.append(t1, img, t22, imagesContainer, t3, t4, t5);
    }
  };

  // src/subscreens/dark-magic-subscreen/tomeOfKnowledgeSubscreen.ts
  var pages = [
    new BasicsPage(),
    new EffectsPage()
  ];
  var TomeOfKnowledgeSubscreen = class extends te {
    get name() {
      return `Tome of Knowledge`;
    }
    async load() {
      this.createBackNextButton({
        x: 125,
        y: 90,
        width: 1700 - 60,
        height: 90,
        isBold: true,
        items: pages.map((p5) => [p5.name, p5]),
        currentIndex: 0,
        onChange: (value) => {
          container.innerHTML = "";
          value.load(container);
        }
      });
      this.createButton({
        x: 1815,
        y: 90,
        width: 90,
        height: 90,
        icon: "Icons/Exit.png",
        onClick: () => this.exit(),
        modules: {
          base: [
            new u({
              zIndex: "10"
            })
          ]
        }
      });
      const container = this.createScrollView({
        scroll: "y",
        x: 125,
        y: 215,
        width: 1750,
        height: 735
      });
      pages[0].load(container);
    }
  };

  // src/subscreens/darkMagicSubscreen.ts
  var DarkMagicSubscreen = class extends te {
    get icon() {
      return createElement4(Skull);
    }
    get name() {
      return "Dark Magic";
    }
    load() {
      super.load();
      [
        new MySpellsSubscreen(),
        new SpellEditorSubscreen(),
        new LimitsSubscreen()
      ].forEach((t3, i5) => {
        t3.icon.style.width = "auto";
        t3.icon.style.height = "70%";
        this.createButton({
          text: t3.name,
          icon: t3.icon,
          x: 165,
          y: 320 + 115 * i5,
          width: 600,
          padding: 2,
          onClick: () => this.setSubscreen(t3)
        }).style.fontWeight = "bold";
      });
      this.createButton({
        text: "Tome of Knowledge",
        icon: evilBook_default,
        x: 165,
        y: 320 + 115 * 3 + 150,
        style: "inverted",
        width: 600,
        padding: 2,
        onClick: () => this.setSubscreen(new TomeOfKnowledgeSubscreen())
      }).style.fontWeight = "bold";
      this.createText({
        text: "QWERTYUIOPASDFGHJKLZXCVBNM",
        x: 165,
        y: 230,
        width: 2e3 - 2 * 165,
        modules: {
          base: [
            new ShuffleTextModule(),
            new u({
              fontFamily: "Kitnyx2",
              fontWeight: "bold",
              letterSpacing: "1em",
              overflow: "hidden",
              textAlign: "center",
              textShadow: "0 0 0.2em var(--tmd-text)"
            })
          ]
        }
      });
      const radius = 210;
      const centerX = 1365;
      const centerY = 615;
      this.createText({
        text: "Atoms Of Magic",
        x: centerX - radius / 2,
        y: centerY - 40,
        width: 200,
        modules: {
          base: [
            new u({
              textAlign: "center"
            })
          ]
        }
      });
      Object.values(atoms).forEach((atom, i5) => {
        const angle = i5 / Object.values(atoms).length * 2 * Math.PI;
        const x5 = centerX + radius * Math.cos(angle) - 35;
        const y5 = centerY + radius * Math.sin(angle) - 35;
        const iconContainer = this.createContainer({
          x: x5,
          y: y5,
          modules: {
            base: [
              new y({
                base: {
                  borderRadius: "50%",
                  padding: "0.2em",
                  filter: `drop-shadow(0 0 0.12em ${atom.iconColor})`
                }
              })
            ]
          }
        });
        iconContainer.append(
          this.createSvg({
            place: false,
            dataurl: atom.iconDataUrl,
            fill: atom.iconColor,
            size: 70
          })
        );
        this.createText({
          text: atom.name,
          color: atom.iconColor,
          x: x5,
          y: y5 + 80,
          width: 80,
          fontSize: 2,
          modules: {
            base: [
              new u({
                textAlign: "center"
              })
            ]
          }
        });
      });
    }
    exit() {
      super.exit();
      this.setSubscreen(new MainSubscreen());
    }
  };

  // src/assets/images/qam.png
  var qam_default = "data:image/png;base64,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";

  // src/subscreens/quickAccessMenuSubscreen.ts
  var QuickAccessMenuSubscreen = class extends te {
    get icon() {
      return createElement4(PanelsTopLeft);
    }
    get name() {
      return "Quick Access Menu";
    }
    load() {
      super.load();
      this.createCheckbox({
        isChecked: modStorage.qam?.enabled,
        text: "Enabled",
        x: 200,
        y: 200,
        onChange() {
          modStorage.qam ??= {};
          modStorage.qam.enabled = !modStorage.qam.enabled;
          if (modStorage.qam.enabled) createQAMButton();
          else removeQuickMenu();
        }
      });
      this.createImage({
        x: 200,
        y: 300,
        src: qam_default,
        width: 350,
        modules: {
          base: [
            new u({
              border: "2px solid var(--tmd-accent, #e4e4e4)"
            })
          ]
        }
      });
      this.createText({
        x: 580,
        y: 300,
        width: 600,
        withBorder: true,
        text: `You can forget about the text commands. Any actions are performed through the "Quick Access Menu" (QAM).<br>Most of the functions and mechanics are located there.<br>The button to open the menu remembers its last position (Linked to the device and not to the account)`,
        padding: 2
      });
      this.createText({
        text: "Features",
        x: 1300,
        y: 200
      });
      const container = this.createScrollView({
        x: 1300,
        y: 280,
        width: 600,
        height: 620,
        scroll: "y",
        modules: {
          base: [
            new u({
              display: "flex",
              flexDirection: "column",
              rowGap: "0.45em"
            })
          ]
        }
      });
      qamFeatures.forEach((i5) => {
        container.append(
          this.createCheckbox({
            text: i5.subscreen.name,
            isChecked: isFeatureEnabled(i5.id),
            place: false,
            onChange: () => toggleFeature(i5.id)
          })
        );
      });
    }
    exit() {
      super.exit();
      this.setSubscreen(new MainSubscreen());
    }
  };

  // src/modules/cheats.ts
  function refreshBonus() {
    const skills = Player.Skill;
    if (modStorage.cheats?.permanentSkillsBoost) {
      skills.forEach((skill) => {
        skill.ModifierLevel = 5;
        skill.ModifierTimeout = Date.now() + 36e5;
      });
      const id = setInterval(() => {
        if (!modStorage.cheats?.permanentSkillsBoost) {
          return clearInterval(id);
        }
        const skills2 = Player.Skill;
        skills2.forEach((skill) => {
          skill.ModifierLevel = 5;
          skill.ModifierTimeout = Date.now() + 36e5;
        });
        ServerSend("AccountUpdate", {
          Skill: skills2
        });
      }, 1e5);
    } else {
      skills.forEach((skill) => {
        delete skill.ModifierLevel;
        delete skill.ModifierTimeout;
      });
    }
    ServerSend("AccountUpdate", {
      Skill: skills
    });
  }
  function loadCheats() {
    refreshBonus();
    c3("ServerSend", d.MODIFY_BEHAVIOR, (args, next) => {
      const message = args[0];
      const params = args[1];
      if (message === "ChatRoomCharacterItemUpdate") {
        if (modStorage.cheats?.autoTight && params.Target !== Player.MemberNumber) {
          const target = N2(params.Target);
          const item = InventoryGet(target, params.Group);
          if (item) {
            item.Difficulty = 1e3;
            params.Difficulty = 1e3;
          }
        }
      }
      if (message === "ChatRoomChat" && modStorage.cheats?.anonymousMode && (params.Type === "Action" && params.Content !== "Beep" || params.Type === "Status")) return null;
      return next(args);
    });
    c3("ChatRoomPlayerIsAdmin", d.OVERRIDE_BEHAVIOR, (args, next) => {
      if (modStorage.cheats?.mapSuperPower && next(args) === false) {
        return ChatRoomMapViewIsActive() && CurrentScreen !== "ChatAdmin" && !CurrentCharacter;
      }
      return next(args);
    });
    c3("CommonDrawAppearanceBuild", d.ADD_BEHAVIOR, (args, next) => {
      if (!modStorage.cheats?.xray) return next(args);
      const C4 = args[0];
      C4.AppearanceLayers?.forEach((Layer) => {
        const A4 = Layer.Asset;
        if (A4.Group?.Clothing) {
          A4.DynamicBeforeDraw = true;
        }
      });
      return next(args);
    });
    c3("CommonCallFunctionByNameWarn", d.OVERRIDE_BEHAVIOR, (args, next) => {
      const funcName = args[0];
      const params = args[1];
      if (!params) {
        return next(args);
      }
      const C4 = params["C"];
      const CA = params["CA"];
      const regex = /Assets(.+)BeforeDraw/i;
      if (regex.test(funcName) && modStorage.cheats?.xray) {
        const ret = next(args) ?? {};
        if (CA) {
          const layerName = (params["L"] ?? "")?.trim().slice(1) ?? "";
          const layerIx = CA.Asset.Layer.findIndex((l6) => l6.Name === layerName);
          const originalLayerOpacity = CA.Asset.Layer[layerIx]?.Opacity ?? CA.Asset.Opacity;
          const curOpacity = ret.Opacity ?? originalLayerOpacity ?? 1;
          ret.Opacity = curOpacity * 0.4;
          ret.AlphaMasks = [];
        }
        return ret;
      } else
        return next(args);
    });
    c3("ExtendedItemLoad", d.OBSERVE, (args, next) => {
      if (!modStorage.cheats?.showPadlocksPasswords) return next(args);
      if (!DialogFocusSourceItem || !["PasswordPadlock", "TimerPasswordPadlock"].includes(DialogFocusItem.Asset?.Name)) return next(args);
      if (InventoryItemMiscPasswordPadlockIsSet()) {
        h2(() => !!document.getElementById("Password")).then(() => document.getElementById("Password").setAttribute("placeholder", DialogFocusSourceItem.Property?.Password));
      }
      return next(args);
    });
    c3("ChatRoomFocusCharacter", d.OBSERVE, (args, next) => {
      next(args);
      if (!modStorage.cheats?.allowActivities) return next(args);
      const C4 = CharacterGetCurrent();
      if (!C4) return next(args);
      if (ServerChatRoomGetAllowItem(Player, C4)) return next(args);
      if (C4.HasOnBlacklist(Player)) {
        Q2.error({
          title: "Activities cheat denied",
          message: "You are blacklisted or ghosted by this player",
          duration: 4500
        });
        return next(args);
      }
      if (DialogMenuMode !== "dialog") return next(args);
      setTimeout(() => DialogSetStatus("(You don't have access to use or remove items, but you can perform activities.)"), 250);
    });
    c3("DialogClick", d.OVERRIDE_BEHAVIOR, (args, next) => {
      const C4 = CharacterGetCurrent();
      if (MouseX < 500 && modStorage.cheats?.allowActivities && !!C4 && !ServerChatRoomGetAllowItem(Player, C4)) return;
      next(args);
      if (!modStorage.cheats?.allowActivities) return;
      if (!C4) return;
      if (ServerChatRoomGetAllowItem(Player, C4)) return;
      const X5 = MouseX < 500 ? 0 : 500;
      for (const Group of AssetGroup) {
        if (!Group.IsItem()) continue;
        const Zone = Group.Zone.find((Z3) => DialogClickedInZone(C4, Z3, 1, X5, 0, C4.HeightRatio));
        if (Zone) {
          DialogChangeFocusToGroup(C4, Group);
          DialogChangeMode("activities");
          break;
        }
      }
      const isExitButtonExists = !!document.getElementById("bcc-exit-dialog-button");
      if (!isExitButtonExists) {
        const button = ElementButton.Create("bcc-exit-dialog-button", () => DialogChangeMode("dialog"), { tooltip: "(BCC) Back", image: "Icons/Exit.png" });
        document.body.append(button);
        O(button, 40, 20, "top-right");
        ElementSetSize(button, 90, 90);
        button.addEventListener("click", () => {
          button.remove();
          DialogChangeFocusToGroup(C4, null);
        });
      }
    });
    c3("DialogMenuBack", d.OBSERVE, (args, next) => {
      const isExitButtonExists = !!document.getElementById("bcc-exit-dialog-button");
      if (!isExitButtonExists) return next(args);
      ElementRemove("bcc-exit-dialog-button");
      DialogChangeFocusToGroup(CharacterGetCurrent(), null);
    });
    c3("DialogMenuMapping.activities.Resize", d.OBSERVE, (args, next) => {
      if (!modStorage.cheats?.allowActivities) return next(args);
      const button = document.getElementById("bcc-exit-dialog-button");
      if (button) {
        O(button, 40, 20, "top-right");
        ElementSetSize(button, 90, 90);
      }
      return next(args);
    });
    c3("ChatRoomDrawArousalOverlay", d.OBSERVE, (args, next) => {
      if (!modStorage.cheats?.disableArousalOverlay) return next(args);
      return;
    });
  }

  // src/subscreens/cheatsSubscreen.ts
  var booleanCheats = [
    {
      name: "Permanent skills boost",
      storageKey: "permanentSkillsBoost"
    },
    {
      name: "Auto tight restraint",
      storageKey: "autoTight"
    },
    {
      name: "Anonymous mode",
      storageKey: "anonymousMode"
    },
    {
      name: "Always allow interactions with activities",
      storageKey: "allowActivities"
    },
    {
      name: "Map super power",
      storageKey: "mapSuperPower"
    },
    {
      name: "Xray vision",
      storageKey: "xray"
    },
    {
      name: "Always show padlocks passwords",
      storageKey: "showPadlocksPasswords"
    },
    {
      name: "Disable arousal overlay",
      storageKey: "disableArousalOverlay"
    }
  ];
  function appendReputationElements(container, subscreen) {
    Player.Reputation.forEach((r5) => {
      const _container = subscreen.createContainer({
        place: false,
        modules: {
          base: [
            new u({
              display: "flex",
              alignItems: "center",
              justifyContent: "space-between"
            })
          ]
        }
      });
      const input = subscreen.createInput({
        width: 100,
        place: false,
        value: r5.Value.toString(),
        modules: {
          base: [
            new u({
              padding: "0.2em"
            })
          ]
        },
        onChange() {
          DialogSetReputation(r5.Type, parseInt(input.value, 10));
          ServerPlayerReputationSync();
        }
      });
      _container.append(
        subscreen.createText({
          text: r5.Type + ":",
          place: false
        }),
        input
      );
      container.append(_container);
    });
  }
  function appendSkillsElements(container, subscreen) {
    Player.Skill.forEach((s5) => {
      const _container = subscreen.createContainer({
        place: false,
        modules: {
          base: [
            new u({
              display: "flex",
              alignItems: "center",
              justifyContent: "space-between"
            })
          ]
        }
      });
      const input = subscreen.createInput({
        width: 100,
        place: false,
        value: s5.Level.toString(),
        modules: {
          base: [
            new u({
              padding: "0.2em"
            })
          ]
        },
        onChange() {
          s5.Level = parseInt(input.value, 10);
          ServerPlayerSkillSync();
        }
      });
      _container.append(
        subscreen.createText({
          text: s5.Type + ":",
          place: false
        }),
        input
      );
      container.append(_container);
    });
  }
  var CheatsSubscreen = class extends te {
    get icon() {
      return createElement4(HandCoins);
    }
    get name() {
      return "Cheats";
    }
    load() {
      super.load();
      let y5 = 220;
      this.createText({
        text: "Money:",
        x: 200,
        y: y5,
        height: 60
      });
      const input = this.createInput({
        value: Player.Money.toString(),
        x: 360,
        y: y5 - 10,
        width: 400,
        height: 60,
        onChange() {
          if (parseInt(input.value, 10) < 0 || Number.isNaN(parseInt(input.value, 10))) return;
          Player.Money = parseInt(input.value, 10);
          ServerPlayerSync();
        }
      });
      y5 += 90;
      const booleanCheatsContainer = this.createContainer({
        x: 200,
        y: y5,
        width: 1e3,
        height: 650,
        modules: {
          base: [
            new u({
              display: "flex",
              flexDirection: "column",
              rowGap: "0.45em",
              overflowY: "scroll"
            })
          ]
        }
      });
      for (const cheat of booleanCheats) {
        booleanCheatsContainer.append(
          this.createCheckbox({
            text: cheat.name,
            place: false,
            isChecked: modStorage.cheats?.[cheat.storageKey],
            onChange() {
              if (!modStorage.cheats) modStorage.cheats = {};
              modStorage.cheats[cheat.storageKey] = !modStorage.cheats[cheat.storageKey];
              if (cheat.storageKey === "permanentSkillsBoost") refreshBonus();
              if (cheat.storageKey === "xray") {
                ChatRoomCharacter.forEach((c7) => {
                  CharacterLoadCanvas(c7);
                });
              }
            }
          })
        );
      }
      this.createButton({
        text: "Get All Items",
        x: 1200,
        y: 220,
        padding: 2,
        onClick: () => {
          const ids = [];
          AssetFemale3DCG.forEach((group) => {
            group.Asset.forEach((item) => {
              if (typeof item === "string") return;
              if (item.Name) {
                let exists = false;
                for (let I6 = 0; I6 < Player.Inventory.length; I6++) {
                  if (Player.Inventory[I6].Name === item.Name && Player.Inventory[I6].Group === group.Group) exists = true;
                }
                if (!exists && item.InventoryID) {
                  InventoryAdd(Player, item.Name, group.Group, false);
                  if (!ids.includes(item.InventoryID)) {
                    ids.push(item.InventoryID);
                  }
                }
              }
            });
          });
          if (ids.length === 0) {
            return Q2.warn({
              message: `You already have all items`,
              duration: 4e3
            });
          }
          Q2.success({
            title: "New items were added to your inventory",
            message: `Items added: ${ids.length}`,
            duration: 6e3
          });
          ServerPlayerInventorySync();
        }
      });
      this.createSelect({
        x: 1200,
        y: 220 + 120,
        width: 500,
        currentOption: "reputation",
        options: [
          {
            name: "reputation",
            text: "Reputation"
          },
          {
            name: "skills",
            text: "Skills"
          }
        ],
        onChange: (name) => {
          if (name === "skills") {
            container.innerHTML = "";
            appendSkillsElements(container, this);
          } else {
            container.innerHTML = "";
            appendReputationElements(container, this);
          }
        }
      });
      const container = this.createScrollView({
        x: 1200,
        y: 220 + 120 + 95,
        width: 500,
        height: 495,
        scroll: "y",
        modules: {
          base: [
            new u({
              display: "flex",
              flexDirection: "column",
              rowGap: "0.2em"
            })
          ]
        }
      });
      appendReputationElements(container, this);
    }
    exit() {
      super.exit();
      this.setSubscreen(new MainSubscreen());
    }
  };

  // src/subscreens/attributionsSubscreen.ts
  var AttributionsSubscreen = class extends te {
    get name() {
      return "Attributions";
    }
    load() {
      super.load();
      this.createText({
        text: "Kitnyx2 font by KitTheCat",
        x: 220,
        y: 240
      });
      this.createText({
        text: "Game icons by https://game-icons.net licensed under <b>CC BY 3.0</b>",
        x: 220,
        y: 320
      });
      this.createText({
        text: "Lucide icons by https://lucide.dev licensed under <b>ISC</b> and <b>MIT (for portions derived from Feather)</b>",
        x: 220,
        y: 400,
        width: 1600
      });
      this.createSvg({
        x: 1550,
        y: 750,
        dataurl: hearts_default,
        size: 180,
        fill: "var(--tmd-accent, red)",
        stroke: "var(--tmd-accent, red)"
      });
      this.createSvg({
        x: 1700,
        y: 550,
        dataurl: hearts_default,
        size: 200,
        fill: "var(--tmd-accent, red)",
        stroke: "var(--tmd-accent, red)"
      });
      this.createSvg({
        x: 1775,
        y: 800,
        dataurl: hearts_default,
        size: 140,
        fill: "var(--tmd-accent, red)",
        stroke: "var(--tmd-accent, red)"
      });
    }
    exit() {
      super.exit();
      this.setSubscreen(new MainSubscreen());
    }
  };

  // src/subscreens/resetSettingsSubscreen.ts
  var ResetSettingsSubscreen = class extends te {
    get name() {
      return "Reset Settings";
    }
    load() {
      super.load();
      this.createText({
        text: "Caution!",
        x: 400,
        y: 240,
        width: 1200,
        modules: {
          base: [
            new u({
              textAlign: "center",
              fontWeight: "bold"
            })
          ]
        }
      });
      this.createText({
        text: "Are you sure you want to reset all your BCC settings to default?",
        x: 400,
        y: 350,
        width: 1200,
        modules: {
          base: [
            new u({
              textAlign: "center"
            })
          ]
        }
      });
      this.createText({
        text: "This action cannot be undone!",
        x: 400,
        y: 460,
        width: 1200,
        modules: {
          base: [
            new u({
              textAlign: "center"
            })
          ]
        }
      });
      this.createButton({
        text: "Confirm",
        x: 750,
        y: 700,
        width: 500,
        padding: 2,
        onClick: () => {
          resetStorage();
          this.exit();
        }
      });
    }
    exit() {
      super.exit();
      this.setSubscreen(new MainSubscreen());
    }
  };

  // src/subscreens/mainSubscreen.ts
  var quotes = [
    "Chaos is not always the opposite of order",
    "Chaos is complex order, not mess",
    "I find peace in chaos, because it contains the possibility of everything",
    "War is the father of all things, and chaos is their mother",
    "Chaos is a feature, not a bug of the universe",
    "There is a love for chaos in every creator because only out of it is new things born",
    "Chaos often turns out to be not destruction, but a different form of organization \u2014 more complex, dynamic and full of possibilities",
    "\u1F1C\u03C1\u03B9\u03C2"
  ];
  var MainSubscreen = class extends te {
    constructor(animations = false) {
      super();
      this.animations = animations;
    }
    load() {
      super.load();
      this.createCard({
        anchor: "bottom-right",
        x: 90,
        y: 65,
        name: "Version",
        value: version,
        icon: createElement4(GitPullRequest),
        modules: this.animations ? {
          value: [
            new x2({
              duration: 850
            })
          ]
        } : void 0
      });
      this.createText({
        text: "BONDAGE CLUB CHAOS",
        fontSize: 12,
        x: 150,
        y: 80,
        width: 1600,
        modules: {
          base: [
            new PaintTextModule(this.animations)
          ]
        }
      });
      this.createText({
        text: quotes[y2(0, quotes.length - 1)],
        fontSize: 3,
        x: 800,
        y: 230,
        width: 1e3,
        modules: {
          base: [
            new u({
              textAlign: "center",
              fontWeight: "bold"
            })
          ]
        }
      });
      [
        new ChaosAuraSubscreen(),
        new OverlaySubscreen(),
        new DarkMagicSubscreen(),
        new QuickAccessMenuSubscreen(),
        new CheatsSubscreen()
      ].forEach((t3, i5) => {
        this.createButton({
          text: t3.name,
          icon: t3.icon,
          x: 165,
          y: 280 + 115 * i5,
          width: 575,
          padding: 2,
          modules: {
            base: [
              new TentaclesModule()
            ],
            icon: [
              new u({
                width: "auto",
                height: "70%"
              })
            ]
          },
          onClick: () => this.setSubscreen(t3)
        }).style.fontWeight = "bold";
      });
      this.createButton({
        text: "Source Code",
        icon: createElement4(CodeXml),
        x: 1050,
        y: 400,
        width: 485,
        padding: 2,
        onClick() {
          window.open("https://github.com/FurryZoi/Bondage-Club-Chaos", "_blank");
        }
      });
      this.createButton({
        text: "Issues",
        icon: createElement4(Bug),
        x: 1050,
        y: 510,
        width: 485,
        padding: 2,
        onClick() {
          window.open("https://github.com/FurryZoi/Bondage-Club-Chaos/issues", "_blank");
        }
      });
      this.createButton({
        text: "Attributions",
        icon: createElement4(Heart),
        x: 1050,
        y: 620,
        width: 485,
        padding: 2,
        onClick: () => this.setSubscreen(new AttributionsSubscreen())
      });
      this.createButton({
        text: "Reset Settings",
        icon: createElement4(Trash22),
        x: 1050,
        y: 730,
        style: "inverted",
        width: 485,
        padding: 2,
        onClick: () => this.setSubscreen(new ResetSettingsSubscreen())
      });
    }
    exit() {
      super.exit();
      this.setSubscreen(null);
      syncStorage();
      PreferenceSubscreenExtensionsClear();
    }
  };

  // src/modules/settings.ts
  function loadSettingsSubscreen() {
    PreferenceRegisterExtensionSetting({
      Identifier: "BCC",
      ButtonText: "BCC Settings",
      Image: mouthWatering_default.replace('width="512"', 'width="85"').replace('height="512"', 'height="85"'),
      click: () => {
        ee()?.click();
      },
      run: () => {
        ee()?.run();
      },
      exit: () => false,
      load: () => {
        $(new MainSubscreen(true));
      }
    });
  }

  // src/assets/Kitnyx2.ttf
  var Kitnyx2_default = "data:font/ttf;base64,AAEAAAANAIAAAwBQT1MvMlrOd3AAAAFYAAAAYGNtYXC7xH8oAAAC9AAAAZpjdnQgACECeQAABJgAAAAEZ2FzcAAAABAAAEk4AAAACGdseWZHEYIeAAAFPAAAQOhoZWFkK1DGIQAAANwAAAA2aGhlYQbTA4sAAAEUAAAAJGhtdHjJiA9AAAABuAAAATxsb2NhZCJ1QAAABJwAAACgbWF4cACVAKIAAAE4AAAAIG5hbWX0q+kyAABGJAAAAklwb3N0ehLN3AAASHAAAADIcHJlcGgGjIUAAASQAAAABwABAAAAAQAAQG4IZ18PPPUACwPoAAAAAOQ6wXoAAAAA5DrBegAh/2wDmwLcAAAACAACAAAAAAAAAAEAAALc/2wAWgPPAAAAAAObAAEAAAAAAAAAAAAAAAAAAABPAAEAAABPAJ8ABAAAAAAAAgAAAAEAAQAAAEAAAAAAAAAABAKUAZAABQAAAooCvAAAAIwCigK8AAAB4AAxAQIAAAIABQMAAAAAAAAAAAADAAAAQAAAAAAAAAAAQ0xHUgBAAAAiGgMg/zgAWgLcAJQAAAABAAAAAALUAo8AAAAgAAEBbAAhAPoAAAFNAAAA+gAAAPoAAAJzADgCdAA5A4oAMwG1ADcBvgA3AW8ANgKIADUCagA2AZYAOAJkADUCFAA3AgkAOQIcADgCQQA2AgoANwLzADcB4gA4AvgAOAIgADgDFwA5AggANwIHADcDOQA0AyEAMgMjADcC3QAyArkAOAMpADMDNAAyAkMANQIuADICxwA1AvsANgOmADMDEAAzAnkANAJ5ADQDJAAzAYoAMwHtADIC+AAyA88ANQOhADUDrQAzAmcANQJtADgDHAA5AgsAOAILADgDOgA0Ax0AMgMfADEC2gAyArgAOAMjADIDNAAyAkIANQIpADYCxgA1AvcAMwOhADMDDwAzAngANAJ3ADQDIQAzAYkANAHsADIC9gAyA70ANQOWADUDrQAzAmgANQD6AAAC9gA4AAAAAwAAAAMAAAAcAAEAAAAAAJQAAwABAAAAHAAEAHgAAAAaABAAAwAKAAAADQAgACsAOQA9AD8AWgBeAHoAoCIa//8AAAAAAA0AIAAoAC0APQA/AEEAXgBhAKAiGv//AAH/9v/k/93/3P/Z/9j/1//U/9L/rd40AAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQYAAAEAAAAAAAAAAQIAAAADAAAAAAAAAAAAAAAAAAAAAQAABAAAAAAAAAAFBgcIAAkKCwwNDg8QERITFBUAAAAWABcAGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEAAAAyAAAzNDU2Nzg5Ojs8PT4/QEFCQ0RFRkdISUpLTAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE4AAAAAAABNAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALgB/4WwBI0AACECeQAAABQAFAAUABQAFACSARIBeAI2AuADCANWA+gESgTkBZ4F8AZAByAHcAgECHYI7glCCY4KOArUC2oLmAvWDAwMpAzUDRoNeA2qDgAOVA6wDzAPyhBEEQARZBGaEfoSdhL6E4IT4hRoFL4VfBYyFtQXAhdMF5gYLBhiGKYZDBlKGaYaABpsGu4bhBv6HLAdDh1GHageKh62HzgfoB+gIHQAAgAhAAABKgKaAAMABwAAMxEhESczESMhAQnox8cCmv1mIQJYAAAAAAMAOP+ZAjsCwAAnADYAVQAAATYzMhcWFRQHBgcGBwYHDgEHBgcGIyInJjU0NjMyNjc+ATc2Nz4CATYzMhYVFAcGIyInJjU0BzYzMhceARcWFxYXFhUUBiMiJyYnLgEnLgEjIiY1NAIMDA0GCQcGCQwNGhwcKIAnMwIdKy0ICAwrIRs1KXMmHRYLEhT+WgYUExkEDh0MCRoKBxoWEjYxHQ0bOiqNEAgJFzIpDyxNKTQ1MQ4CsQ8HBgwLBAkSFBYYHCdUDhIBCwcICgkOBxQQTCQdEgkUG/6lAxYRCwkcBAseHIcHAQEMEggPHyZ9GgcRGjkgDCguGQ4MCwoAAAMAOf+ZAjwCvwAhADIAVwAAEzYzMhceARcWFx4BMzIXFhUUBwYjIiYjLgEnJicmJyY1NAE2MzIXFhUUBwYHIyInJjU0FzYzMhcWFRQGIyIGBwYHDgEHDgEjIiY1NDc2NzY3PgE3PgE3NlgIBgwsD1kDF0osMzUxBwYHCRwEFwg2MB0IIEhpQAGCDCELCRgMCxUHIAkDCQ4UMgsHDCohGzUxThxzEA8OCQoOBwYODxkHWRgdXAoyArcIMRJNAxUsGg4GBgoLBwcBAQwSBRImZT0UCf6SGwQLHRMMCwEeCQQHWgMJBgsJDgcUEjcUahYUCxAJCAYGFRYUBlMRFTcDFQACADP/nANSAtEAMgBGAAATNjMgFxYVFAcGKwEiJiMiDwIGFRAXFhUUBw4BIyImJyYnJjU0NjU0JyY1NDc2NTQ3NgE2MzIXFhUUBwYjIiYnLgEnJjU0w0HZAV0MDA4Mo1IcdRxySHECAQoCAQIIEBEFAQIEAwEFAg8JCwkBbBk2GBAwJRUgGA8MEQ0CAQLPAgQGDg8GBAECBGUWO/65IAooJhhRISVuihoTXCKUImgSBgkUAwQBAwUF/pwdCBc/JRULBAkNHx8MDg0AAAACADf/nQF/AsIAdgCEAAATNjMyFx4BFxYXFhUUBwYHDgIHDgEHDgEHBgcGBwYVFBcWFx4BMzI3NjMyNjc2NzY1NDMyFh0BBgcGFRQGIyIHBiMiJiMmJy4BJyY9AT4BNzY3Njc+ATc2NzY3NjQnJjQmJyYnJiMiBwYHBgcOASMiNTQ3Njc2EzYyFxYVFAcGBwYmNTS1DBgZEBMfGhEUDAEEEgg0Cg0JIQkEPAQECgkRDQEDGwsrDgoBAgsQDwcJCh0XDQoDJA8tEAoFAw4CDAQdHxUPDCACBQwQGDIUCSAJFAg/BwENDikGBRMMBwQLERQkCQcMDRcGCSMoIgkWDxYDCyMTEAK9BQUFISobIhQNCggpJxJPBBYNKg0GRQgHBgQZFg4NCTsYCQ8DBAkOEgwiLSoPFQ83LxIGCyAFAwEBDwoNETE8ChYRERkYMh4NKA4dCERFBxQUFQRABwUGAwMGHTMuIRUXASQzMzv9vAkHCREHCSIFAhAUHQAAAAIAN/+LAYgC0QBnAHgAABM2MzIXHgIXHgEdAQ4BBw4BBw4BIgcGFRQXHgEXFjMyNjM2Nz4BNTQyFRQGFQYHBhQHBgcGIyInJiMiJicmNTQ2NzY3Njc2NzY3Njc2NTQnJicmIyIHBgcGBw4BIyI1NDc2NTY3PgEXNjIXFhUUBwYHBiMiJyY1NLwKEi0UDCMsAgwGASlECCADEksIExICAhsLKBoCCgMiByQWNAEEKBESEy0YCg8VGgUGHgscBQsQJiUROAsTBkAHAQ4SFSAhBwQVDjIKBw4MGAMFAjQXGAsJMg8XAQQOEBYVDg4CzgMLBi9GAxISEQ8uUVkLKQQYVRwcDQQQGT4FFAEDCTMvGjEvAggCNDUXDg4OBQMJCx0RKkcaFBAXJicWSBAeBklEBwoNFhkjNAEFET80JhgaBwkPDydIIBaZCQkNFQUCChAREBEYEAABADb/kQE6AIMAFwAANzYzMh4BHQEOAQcnJisBIiYvAT4BNzMythAbPxQGBBAEOR9OHB8IAgEEEgUqLIECCixKXgQNAwICHFJeBRMFAAAAAAEANf+TAlYC1gAzAAASNjMyFxYXFhUUBwYHBgcGBwYrASImNTQ3NhM3JyYrARUUAw8BBicuASc1NDcSNTQnJjQ3URhbVEDxBgcBAgQGAQMGBQkCEAYCCQICT0GYjA8ECgwKCAMBAw8DAwcCzAoBAgYGVE091EJXXHcLBSJjfQIRATXAAgOXsv66egYGBgUMGA40RwF3hkIQDAwLAAMANv+bAjcC3AAZAD8AZAAAATcHIgYrAScHBgcGHQEWFx4BMzIfATc2NzYDNjMyFx4BFRQCBgcOAQcGKwEiJicmNTQ3Njc2PwI2FxYzMjc2BjYzMhcWFRQHBhUUFxYVFAYHBgcGIyImNTQ2NzY1NCcmNTQ2NQIGAVI5UCkhWgIEBhcCAwErX5MuOAUGAwqgGz8+FRkLCAgEAQQGB3Nt3xACCgEEEAsBAQsKCBp3IA4QLBAKCQcEAQECAQoBAgYHCgkPCAIDAQIBAj5uAQgBZnI942cjSgUEAgMESEocQgIjAwMEEyWN/oc6YjobBQYGCTYyJRqZmV12cgoJAwgCArgQBwUcJB8TLDAoDRQYNCc8BwgOCxptBQQZEwwiLQwtCgAAAAABADj/lQFeAtYARQAAEzYzMhYVFBceARUUFxYVFAcGIyInJicmLwEHBhUUBwYdARYVFAcGIicuASc1NDc2NTQnJjU0NzY9AScHBgcGIyImNTQ3NroRFAcQDBEtDw8GBw0LBhgOBwoJAgMFEQEGBw4KBwMBEAUBAQMEAQ5KDQMMCA5qDwKsKgsFBg8ZbRIHFxkGBAgJBxs0IBQTYU+WhhxeNxUPERAGBwcFEyYRNGYjOyYZHDFAJzYeDSUTbQoDDwgKkhYAAwA1/5ICLgLOAB4ARgBrAAATNjIXHgEVFAcGHQEUAgcGByMiJjU0NzY1Njc2Nz4BJTYzMhcWFRQHBgcGBxQHBgcGBwYUBiMiJyY1NDc+ATc2PQE0NzY1NAE2MzIXHgEXFjMyNzYzMhcWFRQHBiMiJicmIyIHBiMiJyY1NDZcCQoIBgMPBQkEBA4HCgcCBAIECgUBBAGxBggKCQcBAgQNAgQGAwMFBA8LCQgGBwIMAwYPBP7XBQ0eDQtCEAUGCg8SCQcHCBAcHw5NEw8OHBMKCwcGBycCxwcGBA8eQWYhhB59/v4JCgEOFwc4YLfAFS9xJhICBwkIDxEPKhY2zIEUHVBWFxQgFAgGCAxGF6cfK3AWlFAWHB/+kgEHBRQCAQ4PBwgHCxAcFAgHIw8GBgwULwAAAAABADf/mQHcAs8AgQAAEjYzMhYzFhcWFxYXFj4BNzY3PgE3PgEzMhYVFA8BDgEHDgEHDgEVFB4BMjMyFhcWFRQHBisBFxYXFhcWFx4BFxYzMhYVFAYrASYnLgEnJicmIyIHDgEHDgEHBiYnJjU0NzY3PgE3Nj0BBwYiJyY1NDc2Nz4BNzY1NCcuAScuASMiNTcQDgILA0QmIAYEAgEDAwEDCQg9DAxSCAkNByYlGhYbDQcFDwMNFhYrFAUHBwg8PQIDAgUWDwgDEgkMExcSDhQOOhsIEQkMBAkEAwMFHigaHRMNCAUEGBIiHBYFDzkPKAgIBwg3OAIEAwMIDRENLxYfAr8QAQUsJkMmAgECBQMHEhBNCQopDgoOBRMSFB0kFxUPbBYCAwICBQcICQcIEA4yZyIYLxIgBQYNEAsIBDQQRREXEDEbLUI3JBgCAQIHBQcODAkxKC4iXTgkAgEGCAgJBwgCAgIkFRQRHVw1Eg0RFQAAAAACADn/lgHRAsoAJwA2AAABNjMyFhUUBw4BFRQWFxYUBiMiJyYvAQcGBwYjIic1JjU0PwI2NzYCNjMyFxYVFAcGIyInJjUBWAYGCQ8dGCgcPVkRBwoHDU5STU8FBAYQBgFSVTU6BQF7EhEdCwUODQ4JCxMCxwMNCQpyX8YWDTVrmg4PCRGIkJaZAwMQAgEBDaKq1OYGAv1REhcMBQsNDQYJGwAAAAMAOP+OAeMCzgAUACUAMwAAATYyFxYVFAcCBgcGIyInJj0BNBMSAzYzMhcUFhUUBiMiJy4BNTQlNjMyFhUUBwYiJyY1NAEnBRYHBQQIBAcGCAkICAkI3wsSIQQBFhAJCgcNAXcJCw0TCQkkCQcCxggHBTFGv/56awcGBwYSFSsBZgFr/nAKGgEDAQwQAwIUCAYNBRELCgoJCQcKEQAAAAAEADb/9gILAkIAEwBPAGIAngAAEyYjIgcGBwYVFBcWFxY3Njc2NTQnNjMyFxYzMhcWFxYVFAcGDwEXFjMyNz4BNzU0JyY1NDMyFxYXFhUUBw4BBwYiJyYnLgEnNCcmNTQ3PgEAJiMiBwYVFBcWMzI3Njc2NTQnJTYzMhcWFx4BFxQXFhUUBwYHBiMiJiMiJyYnJjU0NzY/AScmIyIHDgEHFRQWFxYVFAYjIiYnJjU0Nz4BvRMPCAwTCgIOEAgHFisJA2YSFREEBgQNIA4LCQEBCglKERkzGQsIAi0PFw0PHBMLAQMoKBUyFbEkDR8GCwoGDRoBXQwOIhITDhUkCgkUCgIM/sEVGRsVvRwNHgYLCgYQERwrDgwDDiAOCwkBAQoJShEZMxkKCAIdFAsOCxIoDwsBAiQCBwgECCYMAgobIAMEBAQrDgspQwcFBhgLFRISDAggFRMDARQIEhQJNB0KChcJEywZDwsILTEOBwEFCQMjEgEZERANECUh/ncMEhMjHA4XAwglDAEJGVsIAQYIAyMSARkQDwwSLxAaDBgLFRISDAggFRMDARQIEhUIGy0MBgwJDighGQ8LCCoyAAAAAgA3/5UB0gLLACYANQAAEjYzMhcWFxYVNjc2NzYzMhYUBw4BFRQWFxYVFAYjIiYnJi8CJjUXNjMyFxYVFAcGIyImNTQ3FAUECQpJSyYtUAoHCggRWTwdKRcdDggPEScFAzhUVbYLCQ8NDgYMHA8UArsQBwqQlAFBT40MCQ8Ommk4DBXIXnIKCQ4wnRML3KmoCDYGDQwLBwsYEg0fAAAAAAMANwCVAr0BxwAVAC0AZQAAASYjDgEHDgEVFBYXHgE7ATc+ATU0JiUvAgcOAQcVFBcWFx4BMzI2Nz4BNTQmJzYzMhcWFxYzMjc2NzYzMhceARcWHQEGBwYHBiMiJiMmJyYnJiMiBwYHBgcGIyInLgEnJj0BPgECYREKNyUSETIzEhYbISgXFgoQ/pwZLy4UGAoBCAkQDBAZKCgTDy8ytRMsKBo8OQkDAhIeMRVDLAsNLgcNAg8ZKAkbBBUGMhUwIBQEAxIiKxI3DxQXEA4sBg0CJQGKCgMIDAs3DQpCDA8IExEdKSslERACARATGCobGQ4RDQkECg8MOgcEREUJBAtRDBcqFgkFBCsNGEIPJBsvCwMBAgoYKhsWKhQIAgEIBygLGkMNJz4AAwA4/6kBqwKyABIAKABOAAAlJiMiBw4BFRQXFjMyNzY1NCcmAyYjIgcOAR0BFxY7ATI+Ajc2NTQmBzU0OwEWHwERFx4BFx4BFxQWFRQGBwYiJy4BJy4BPQEjIiYnLgEBVwwOGwcNBQQIGxoeEQ4MpxAECg8XCA4OEQwMCQkCAwYIjnEJMRoMLSYfEhALAgEkKRgsExISCAcCKCQdEhENbgQHEBYiLAoRDwgvKBMOAhYEBggRJy8NDQEEBAYMLScYSQ9vAxcL/hUBAQoTESMjAwwCLjANBwkIExQPQa3pChISHwAAAwA4//cCwAJMACMALwBVAAABNjMyFhcWFxYVFAcOASAmJyY1NDc2MzIXFjMyNTQmLwEmNTQDNjIWFRQGIyImNTQFPgE7AjIWFxYVFAcGIyInJiMiFRQXFhcWFRQGIyInLgEnJjU0AcAHBQotPmQJBgcGT/5EWwYDCAdBAchEXWVKJiYHWgsIEQ0JCg7+9QUxb5KSbzEFBwcGQGVlPV9tTksEAQwJBgMHxQgIAkUHIjRUCQcICAcGAgQKBAYLCAcCAQMBQCAgBwoI/vIJFwYHCgwICmAFAgIFBwsKBwYBAQIDQT8HAwUKDgIEowkICggAAgA4/5gB5wLPACMANwAAEzYzMhceARUUBwYHBiMiJicmND8BJyYjIgcGByMiJyYnJjU0EzYzMhcWHQEUBiMiJiMmLwE3PgGrdAcJBwumDYgPCFI9GgcKcnIoJgMCISAIBQk4PQcHUAY5bAYGDyEFIgxTCgoDAgYCW3QJDPkFBxr/DwUCBggShoYyMSwtAgQGCAwECP5sAwYFUSgoEwECBwdJPCEAAAAAAQA5/5EC3wLOADMAABI0NjMyHgIzMjc2NzYyFxYVFAYPARceARcWFxYVFCMiJiMmLwEHDgIHIyI1NDc2NzYnUBEJCAqHgwIFkJMICg4JBjlkniYKXRtdAwIXAQUBCIGClEJBGAUEFJaVAgONArEQDQq9trS2CAgHBAYMS3vDNA6DJYEKBAYVAQK1t7dSTRcBEw24uAIDxgACADf/mAHRAr4AYgB0AAATNjMyFxYXHgEXFhUUBwYjIiYnJicuAScmIyIHBgcOARUUFhcWFxYXFhcWFxYVFAcGBw4BIyInJicuAScuATU0NjMyFhcWHwIWMzI/ATU0JicmJyYnLgEnJi8BNTQ3Njc+ARc0NjMyFxYXFhUUBw4BIiYnJs4NGC4vJw0SJgwJCAcKDQcCAg0NGx40JQgMEyAfDgQMDRcYaikGDQsqEQgYGy8iEgouBBI8GAYZDQgLDQkTLhoeFAg6KhMOFhEGCDYeSA8UFRILCiUeEy4hGA8QHwMBEAgMJA0LGwK6BBAOBgk7JRsjHwgHDyAnHh8aCxMCBB4cHSMaExgcHx9oKQwVDC06JTMaFRkUAQQCBzojCU0KBw4RGzssGgICKhQtKCcZEg0TMRxMFBoqJC8uFhYiHA2uFh8IEB8FCBQQCAQECRYAAAAAAgA3/5oB0ALDAFsAawAAEzYzMhceARcWFRQGIyImNS4BJy4BJyYjIgcOAQcGFRQWFxYXHgEXHgEXFhcWFRQHBgcGBwYiJyYnLgE0NzYzMhcWFx4BMzI/ATU0JyYnJicmJyYnJi8BNTQ2NzYTNjMyFhcVFAcGIyInJjU0zBYSMEYcHg4eCg0IEAEECQ0aGjUnEQcRRgMEBAsNExFCFBYzCAsMJxIIFhYWFmwTKSsTFggJBw4QFCoVHSA+LBILCBMRBQk1USMXExEcTAEvCgUTGQIUDQ0ZDwYCvgUbCxocOzEdFgsGLyAVHhsJFAIDRgkMJBsTFhwZFkcQEjUOFAwpOig2HBQWCQoKFjwaTBAGBiw7KhULLBIvLxUTExEKEzFNLx4mJC80LUYB/bgCFhMIFQwIFQoRIQAAAQA0/6QDBgLLAGgAAAE2MzIfARUUFhcWFxYzMjc+ATc2NTQnLgEnJjU0NzYzMhceARcWFRQHDgEHBgcGBwYjIicmLwEVBwYjIi8BEScuAS8BBwYHBhUUFxYVFBcWFRQHBiMiJyYnJjU0Nz4BNzYzMhceAR8BEQGGCQYHBwoHDBQxFCceFB0zCwYBBBUlLAcGEgwKFzMSDQcHCw8WNhktCxAVHisYEAoJBgcHCgsQLTk4ExEYIQIELxsIBwgJDTUYBggKQB0PGxcSOCYVEwLBCgcIupxpGioTCAUINyUXEQ4KLxwSEw4HCAkBAi4lGScfICIdFB4bDAIBCg8UDfAJCgcIAaMXIBUCAg4LHCYfBggOEycuGwoGCAcJI0wUHyYYHEcRCQECBw8NAQoAAQAy/5wC6QLWABoAABM2MzIfAhYVFA8BISAvAREQBwYjIicuARkBOgl/oo7lCQkHB/70/usoMgYHCwcIBQIC0AYCAgkJBgUJCAMC/oD+gAYHBANrASoBkwAAAAACADcAWQLuAbwAFgAlAAABNjMyFx4CFxYVFAYHIyInJic1NDc2ATchFxYVFA8BIQUnJjU0AX0MDCcJAQQGAQcnIwwcGAsBBw/+5wcClgkJBwf+sv6yBgcBuQMZAwkMAxIKFx8DGgsbDg8KFf7PCgkHCAUJCAEJCQQFAAAAAgAy/5UCqwLXAAoAHQAABRElIQcGAg8BNiABPgEzMhYfAREPASEnNTQ+ATcTAnv++f75AwIGAQJaAWj+JAZZztpOBwoICP2qEwICAQU3AtoBLz/+TTKKAQMHBQMCBgj83wgJE2saesM5ASUAAgA4/6gChgLRABUAZgAAASYjIg8BFxYXHgEzMjc+ATc2NTQnJgE2Mx4BFx4BFRQXFhcWFxY3NjMyFxYXFhUUBw4BBwYjIi8BBgcOAQcGBw4BIyImJyY1NDc+ATc+ATc+ATU0JicmJyYnJicmIyIHBiMiJjU0NgIzFBEaIBICAgQEKxUKBwogBQgLBf4qD1c+NRgNJQgXBAQBAhkeHjAkFQQHDQgmEhMcFBQTAQEBDBUgNhSHMhcOBgoHBRlCaEgSFQgJBAQCAhYXGiVFEQlICR0TFgGuCRcOQT0NDhQDBB0KEDA7DwkBKgEBCQ4HJAUDDB9SOgECDA8kFBUgKToaDyUJCgYGISlAMBssCwUJAwcJBgcHBwMCAwwTFiZPXNsNDy0/IiQKDQEECQwPCwAAAAEAM/+NAvEC0gAaAAATNjMyHwEDAh0BFgQXFhUUBw4BIyEvARMSNzZOBwkIBwgIBwECfAgGBgRd9P6xCgoHCwQCAswGBgf+f/68NgkBBQcFCgkIBQIJCAFKAc4PBQAAAAIAMv+PAvwCygAcAC0AABM2MzIfAREXFjMyFhcWHQEUDgIjIickJyYnJhElNjMyFRQHDgEjIicuATU0NjIQBgcICYFp3Yw9BQcFFiwnEeb+qgQHAgIBUBARPwgKKxYODRQcIwK+DAcJ/QoCAwMFBwwFBQUFAQIEAgIGAwGPOwRQIAoNEQUHLxoWJAAAAwA1/4oCEQLQABgALQA9AAABNjMyHQEGAwIHBisCIiY1NDc2Ejc2NzYXNjMyFhUUBwYHAgYjIiY1NDc2ExIBNjMyFhcWFAcGIyInJjU0AUoKBhYEAwUEBAkGAg4HAQEEAQICAqUFDQ8IAQUDBBAKCBABBAUG/n8QGh0gDAwJGDYjDiMCywUpCzb+rf6tGRIYN0EzNgEhL9ENCgMIFDEyJcTK/v8WEg4KB0EBTQFy/rwIFBoZPAoZCBQyPAABADL/lQH7AscAHAAAATYzMh8BAwIGBwYiJjU0NxInJi8CJj8BMxc3EgHTBgoJBwgKBwYFCBIOAQsDVmm/CAgGBcPBAQkCvwgGB/52/ud0BggOFxQPATEDAwIDCgoLCwEJAWsAAgA1AOgClAH+ABsAOAAAATYzMhceARcVFA8BJyYnJj0BNDc2MzIfATU0Nhc2MzIXFhcUBgcGISAnJjU0NzYzMh4BMwUnJjU0AgoJBgcIBwIBBwjx3xMLBQWEaXNiAmQHDAoFCQICBQf+5/7kCQsGBj4SNmInAQ4DAgH1CQcFFTcrHwcJAwMFAwsFDAUEAwI5KhEeBwUJijkSBQcFBhAJCAYBAQJZOgUcAAAAAAIANgAMAskCTwAZADcAAAE2MzIXFhUUBwYHDgEjIScmNDc+ATsBITU0ATI2MzIXHgEXFhUUBwYjIicuAScmKwEFJyY1ND8BApwGBw0GBgECBwRa3/7KBQYHBS9rjAEk/uklgBh6CAoEAgEHCAkKBggDBAKtev7bBwcHBwJMAwcGIiciaQcFAgkJDgcFAjp9/rMBAgMIaB0kKAcICAmnAwIBCQoEAwsJAAIAM//oA24CvwAPADwAAAE2MzIXFhUUBiMiJjU0NzYHNjIfAQsBFxYzNzU0JyY1NDc+ATc2MzIXFhUUBg8BEwcGIyInJiMiLwETPgEBBhANEg0XKhscFgoNuAcQBgkBAqdsGSQCAwcGNpyOBz0GCA7AwQYJByMCcHpONAkIAwIDArsEChMaERwXHRQKC0cIBQb+1/7ZBAIBGyDstjQ8BwYDAgIGCAoJDgIC/asGBAIDCQgBNeZRAAACADP/4QLfAp8AEQBXAAABNjMyFxYVFAcGIyInJjU0NzYXNjMyFxYVFAcOAQcGBwYHIyIkJyYnJjU0PgE9AQcGDwERFAYHBisBIicmPQEQNzY3MjYzMhYVFAcGAwYVFB4BMzI3NhMSAhYKDBYLEBoPESEIAgcKrQYLDAYGAgEEAQMFAw0ROv76BQkDAQQEaWwWGAIEBwsECQMGBAnAEzUJLRkCAQYDBsQ0GgECBQQCnAMIChUcDAcdCgIHDRISCAgGLwZqLu8rog0IAQcCBAYDMDvxxAQ9AgIDA/7T2FYEBQwY3UwBPQQJAwEMFQYeH/7znTEsBAUBAgE2ATUAAAAAAwA0/5sCRgLEACoAVwBoAAABLgErAQ4BBw4BFRQHBgcGHQEXFhcWFxYzMjY3Njc+ATc2NzY/AScmJy4BJz4DMzIXHgEXFhcVFAYHBgcGBwYHBgcGIyInLgEnLgMvAjU0Njc+ARM2MzIXFhUUBwYjIicuATU0AYoTPAoCC0ELCCAIGxQVExEyMAsJNygVDycjDB8DAwYICwQKCzEkFpYHEAcLBQ0yOCE0RQQLBAQDBQMDFDpZGxAXFTIpHwsmCxkPEwI1LBA/TAkHCAcIBwYJCw0JBAJ3CBICKQwIMAMBEjpaYlFJIx8yLwYFAwcTMRFEEBERGLJOGhs+LBZCAwgEAxETGkFVLQgjyBodBAcWEyx4HggCBBEfCyQNIxshNBlt4kcbOP6XBgcIGxkHBwoHCQwYAAACADT/oAJGAswAKQBPAAABLgErAQ4BBw4BFRQHBgcGFQcXFhceATMyNjc2Nz4BNzY3Nj8BJyYnLgEnNjMyFx4BFxYXFRQGBw4BBwYHBg8BJy4BJy4DLwI1NDc+AQGKEzwKAgtBCwggCB0VEQETETIwFjUmFhAnIw0fAwMGBwsECgsxJBaLFg4PLTgjNEUECQQBEQEEEjpZIDcyKR4LJgsZDxMCEyBUAn8IEgIqDAgvAwISQWBQV0giHzIvDAMIEzESRBIUDRO0TxobPiwWSAwQExxAVi4JIrkcC0AJDid3HgsFBREeCyQNIxshNBhkV5GJAAAABAAz/30C8QLPABgAQABcAH0AAAEnIgMGFRQzMjcyNz4BNz4BNzY1NCcmJyYnNjMyFx4BFxYfARYVFAYVDgEHBgcOAQcGBw4BIyIGIyIuATU0NxI2AxI1JgcOAQcGBw4BBxQGFRQWFxYXFhceATsBNgM2Mh8BAwIGBwYjIicuAScmJyY1NDY1PgE3Njc+ATc+AQIeEwEPAgcECwEcEDwJCyUICggdNDBWCAkRKy1hEwIGBxABAg4WGBsMOQsKCAovEAMKAggHAwUGB7cFAS8NLQsaFRUNAgEKERUlGAkHNQUBAxEbJAcJBgUHCAYKEissYhMFChEBAQ8XFhoMPA0JGAKKCv2CPAceBhAJPBEUdiszQTkZZj85TQgaGng1BxERKzQGIApEUUZIJhA1BQQGCA8BCyYoMN8BLqj+tAEOGgEYByoOIURBTD4IGgUhKS47KhwMCSgFAwUJBwf+of7XqAgIGhl6NQ8ZKzoFHQlDUkZEJhE4BQMQAAIAM/+NAVkC2QAZAEEAAAUSNTQmDgQHDgEHBgcGFRQXFhceATMyAz4BMzIXFhcVFhUUAgcOASMiJiMmJy4BJyYnJjU0NjU2NzY3Njc+AQEcDwMFBgoICwQXNw0YGg0HHjAYMQQGHAkuEhAGCAMBCwMCCQ8BCAISIC9fEwcIEQECHw8CG1UDEjgCozsCAgICBQUGAg04GS10QUszGGk3HDEC8gcPBQUcCwwLZP3lOjEaAQEUHXU1FRQrOQUdCWtdMAdaOAIMAAAAAQAy/5UBuQLDACIAABM2MzIXHgEdARceARcWFRQGIyInJi8BFRQHBiMiJy4BERA2OggHCAgFA6JxNQcJFA0PDE9SewcHCQoHBQICArsICAU2e64CAgQFCAgLDgEEAQLDwggHBwRtAR4BJGYAAwAy/6ECxgLPABAAKgA8AAAANjMyHwEDAgcGIyInJjQ3EiU2MzIXFhUUBw4CBwYHBiInJjU0NzYTPgETNxcWFxYVFAcGIyInLgEnJjQCmA4HBQsJBgcGBg8KBgMDBv2uBwsKBwYBAQECAQMHBhQIBwEBBQICXgjOzQgHCglORjiTOgYHAsEOBwj+ef55CAkGA3K0AW58CAcGITM0IIGsNfsIBwgHJC0nLAFTwkr+mAkDAgcGCgwGBgECAgUGFAAAAwA1AMsDmwFyAC8AQwBVAAABNjMyFxYVFAcOAQcGIyInJicmKwEOAQcOASImNTQ2Nz4BMzIXFhceARcWMzI3PgE3NjMyFxYVFAcGIyImIy4BJyY1NAUUBiInJiMiJjU0NzYzMhceAQKuBhAICgkBAyQlHhYUJzUbIEILKSEJBgsUDhUJD0MjEA9EFhgmJQwDCBYcEqgICxwLDwIKGwIGAREPBQb9WhIsBAUHCQ4ZEAoPEgwFAUYsCgkMCgcqKhIODRMgJQIYJRgRDgsPPwoSGAMPGR0XBwIJDBcRBAsPFgcDEgECCAsLChQwGBMGBRgOIAwIEgwLAAADADX/zwNuAn0AFwBHAFoAAAA2MzIXFhUUBwYHAgcGKwEiJjU0NzY3Ngc2MzIXFhUUBwYHBiInJicmKwEOAQcOASImNTQ2Nz4BMzIXFhceARcWMzI3PgE3NgU2MzIXHgEVFAYjIicmIyImNTQDQBIGBwgHAQUFCAcDDAELDAYFAgKCBwcMBwQODzMbLiM1GyBCCykhCQYLFA4VCQ9EIxAOQxcYJiUHCgkTHBIEBP2cEgkPEQwFFBQWBAYGCQ4CcQwIBxETEJau/vsWDAwlJ66afWDVBQkEDyQeIBcMDBMgJQEaJRgQDgsPPgoTGAMPGh0WBwIIDBccHzEIEQwMERcUBgYXDh8AAAADADP/9gN6AowAGABLAF8AABI2MzIXHgEXFBYVFAcGFRQHBiMiJyY1NDclNjMyFhUUBw4BBwYjIicmJyYrAQ4BBw4BIyImNTQ2Nz4BMzIXHgEXHgEXFjMyNz4BNzYXNjMyFxYVFAcGIyImIy4BJyY1NDcMCQoHBQICAQIDBwYJCwgGAgJjCAUHEgIEHyQeFhQnNhsgQQspIQkGDAsJDhcID0IjEwkdNwoZJCUMAwgWHBECAqIICxwLDwIKGwIGAREPBQYCgAwHBTeMF1EQTAoMcm4HBggGTQHwTAYSCgMQLCgSDg0TICUCGCUYERALDT4LEhcCBRgLHRcHAgkMFhwfKQQLDxYHAxIBAggLCgsUAAIANQB2AjQBkAAwAEEAAAE2MzIXFhUUBw4BBwYjIicmJyYrAQ4BBw4BIiY1NDY3PgEzMhceARceARcWMzI3PgEHNjMyFxQWFRQHBiMiJyY1NAIDBhEGCwkBBCEpGxcZIjUbIEILKSAJBgwUDhYJD0MjDw8cNgkZJCUMAwcXHBLlDRQhBgEMDRYUCw0BZSsICAkLCSktEwwMEyAlARklGBEOCw8/ChIYAwYYCh0XBwIJDBeRByACBQEIDA0IChETAAMAOP9+AjUCswAWAFMAXAAAEyYjIgcGBwYHBhUUFxYzMjY3Njc2NTQnNjMyFx4BHwEWOwE2MzIWFRQHDgEHDgEjIicmNTQ2NzY3Njc2IyInLgEvAQcOAQcGKwEmJy4BNTQ3NjMyATYXFBUWBisBwgkMCBwZAgECBAIILRYKBAYCAUQHDhMPECMDAxWgGREaKRwkGEEiez8GAQMSJUtuHhsBAhQESBFECSUEBBwMCRUQOxkJBBgQDxABCwwCAQoJCgJ1CwICBQEFCxUQBBEDCQwSBAcKRQMEBCANDQcBDBAMIxc5Ins8AQYRCSpLbhgVAwMHAgUBAw8OIQUDBCEMDhY7FQ384A0FAQIICwABADn/lgLjAtoANwAAEzQ2MzIXFgAzNgA3MzIWFRQHAAcGFx4BFRQHBicuAiMiAwYHIgYjIic0JjU0NzY3PgI1Ni4BVAwIAgYFARMCAgE3BgIHERn+5QcDhFIzCgoIA4SCAgb3LgcBAwEQBgF9LRwWOhsBi4wCxAkNAgL+gQEBfAIRBgce/qUMB7hyTQwHBQcFAra0/s05AQERAQIBCJo3IxtIIQECxcgAAAAAAgA4/6IB1QLJAHEAgwAAEzYzMhcWFx4BFxYVFAYjIicmNTQ3NDY1NCcuAScmIyIHDgEHBgcGFRQXHgEXFhcWFx4BFxYXFhUUBwYHBgcGByMiJy4BJyYvATc2MzIXFhcWFx4BFxYzMjc2NTQnJicmJyYnJicuATU0JyYnJjU0Njc2FzYzMhYXFhUUByMiJicmNDc21BYSLkIgDw4gBgYOCwcFCgEBFA0VHzYkDwYUExgeBAMLAg0CGEQnKRMdDRMKBwMKHxEbGCIQFhgSERFLFwsKBwgHBwQLES0TDx0QCT8rFQMIGwwNFiIHExpsCgoEAR8uHFgGCxYjBgMuCBonAwENDwLEBRoLEQ4/GBcUFxwEBwkIBgIJAyEtHRMLEwIFDRkgEAwSKhYFFgUwPyQtFCkPFSAWDAkVUB8SDg0CAgIIDTxSJgkHBgQhNTAVBwQCLhggDRQ0GgoVHiIJDxSDCgIUEycKEiQ0KBh7AhsVCwgpBR8ZBQ4QEAAAAAACADj/owHVAskAcAB/AAATNjMyFxYXHgEXFhUUBiMiJyY1NDc0NjU0Jy4BJyYrAQYHBgcOARUUHgMXFhcWFx4BFxYXFhUUBwYHBgcOASMiJicmLwE3NjMyFxYXFhceARcWMzI2NzY1NCYnJicmJyYnLgE1NCcmNTQ3PgE3PgETNjIXFhUUBwYjIicmNTTkAwsoHUsZDiAGBg4LBwUKAQEUDRUfOyIEBREPIB8NAgYEDAMYRCcpEx0NEwoHAwofFBoTFSYuIx45FgsKBwgHBwQLESsTEBkSCDBNBAEVEAwNFiIHExpsCg8EBQ4fIR8TDCQLEQwNEhgQBwLIAQgTGw4/GBcUFxwEBwkIBgIJAyEtHRMLFQMDBB4eGyMPFRIJFQUwPyQtFCkPFSAWDAkVUB8UDQoDDRszSyYJBwYEITYtFQkEAjEjBw4gPBAKFR4iCQ8UgwoCFB00GhATEx4gFP2sDAwTERAMDRUKDRMAAQA0/7ADBwLVAHEAAAE2MzIXFh0BFBYXFhczMjc+ATc2NTQnJicmNTQ3NjMyFxYXHgEVFAYHDgEHDgEHIicmJyYGBwYHBiMiJy4BNTcnLgEnJiMiBwYHBhUUFx4CFRQHBiMiJicuAScmNTQ3PgE3PgE7ATIWHwE3NjU0JjUnAYgJBAUKBg4eIT8NTycOCQUBDwgmLgYHCgEUHREZKQsFByIWIyYoLh8tFAsCBAMGAwoICAQCAQkIHhAfQhMEGiUkAgQUNAcECBIyDw0IAQEICDAVHBYoDDYvExMDAgECAswJCQVMbL1pHiEFPRYYGwULNhwNFBcNBgYIAgINE1EgDUcPFi0OGAwBCxETCgJ6dgoFCAU9kMsXFiIECQEGKCcqCBYjKDIJBQkGLx8eGx4LDxIVFjwPFQcJDg0zICgKKQlRAAAAAQAy/5EC5QLNABsAABMyNjMyHwIWFRQHIiclFRQDDgEmJyYDJjU0Nn4TQQWIhfIJBhU+/v7NAwIMEgQEAwEOAswBAgMKCAgQAgMCvTz+ucYKAQUGAY+DlHoOAAACADEAWgLrAbwAFgAtAAABNjMyFxYXFhUUBgcGIyInJicmNTQ3NgM2MzIXHgEXFgcGBwYHBiMiJicmNz4BAY8BAxMNEQ0CHhoIDRoVEAIBMxb8O5a7bEIXBAUEAxwbaVj3fjQEDgoFGgG7AQoMKwUKFB0FAhYREwYJLwkE/swBAgICBwsHBwECAQICBQ8MBQMAAAAAAgAy/5YCqALUABQALwAAASYnKwEPAQYCHQEUFxYzIDc+AREQJTsBHgEXHgIUFRAGBwYjIi8CJjU0NxI3NgJ4A9TPNjECAgkDAscBRAcEAv5CvWuCNAUDAgMKtyZWYVJ5BwYEBgYGAqAFAQIUEv38ZRwvAwIDAmYBAwFpOAICBQMOVpWb/nEMAgECAgoISmHjAYoIBwAAAAACADj/qwKGAtEAGABmAAABJiMiBwYHBhUUFx4BMzI3PgE3NjU0Jy4BATYzMhYzHgEXHgEXFhc3NjMyFxYXFhUUBwYHBiMiLwEHFA4BFRQGBwYHIyInJjU0NjMyNjc2NzY1NCcuAScmJyYnLgEjIgcGIyInJjU0AkAaEQYSLA0CCAUpFQYIDSEGCgIECP4qHhsIHQZKPhoeGgIEBRUiHA4NMxEWEBMrEB4ZEhACAgE0KjGPKB4GCAwjJYgTSAwEBAEGAwUDBRoTQEYSNjIBEgUHAakQBAwbAx5YEg0TAgQaDBYrCxYgEQEtAgECERodQzg1DQsSBA8aH0o6HSAYCAYGKwghGAc1Ug4QAgYICAcOCQMNSCAoIjgMvRceLUomHBUCAggICBIAAAEAMv+NAu0C0gAgAAATNjIWHQEUDgEHAhUUFgUeARcWDwIGIyAnJjU0ExI1NEwICBACBAEHBAE+7VIGCAMERVGG/nkNBAcJAssHDiAZDV6fOv72TysEBAIDBggKCwMDCgMoPQEeAX4XEAAAAAIAMv+QAvwCygAWACkAABM2FxYSFgQXFhUUBw4BBysBJicuARkBATYzMhcWFRQHIicmJzQmNTQ3NjwNDgQHAgKKCAYGBTWZ9WKKCAYCAWYMBTAIAU8cDxwGARgOAr4MCwL9AwIDBgYHCAcGAgEBBwVmAScBjP61AjgHDUgCCxIrAgcBFxQMAAADADX/bAIQArQAEQAtAEAAAAE2HwELAQYiJyY1NDc2EjU+ARc2MzIfAQMCBwYjIi8BJjQmNTQ+ATcSPQEmNTQBNjMyFx4BFRQGByImJyY1NDc2AUoODQkGBxEOBQYDAQUBAqUHCQgHCQgIBQgJBwYDAwICAwIGAf6HFBEfEwwUJS8gHQsOAw4CqQsLB/5x/nAMBgY6MqdaATEEXiECCgcH/m3+bQQIBgICBRQSFVKxVgFQGQwEBwv+vwYQCjYWIhoBCg8TJA4JKwAAAAABADb/cQH3AqgAJgAAATYyFx4EFRQDAgYHBi8BNzY1NCYkJyY0NzYzMhcWMzI3NhM2AdQIDAgBAwEBAQkIBQcMDgkEBQL+iQoHBwYqAX6HJyQBBQUDAp8JCAECAwcOCxz+wv7OagcMDAekliATAgcIBhIGBgIDAwMBA2sAAgA1AMwCkgHcABgAPwAAATYyFxYVFAcGIyInJicmNDc2MzIWMzI2NBc2MzIXFhcWFRQHBiEiJicmNTQ3NjMyFxYzMjYzPwE1NCc0LgE1NAIKBhIGBwQFcByUwwcHBwhWL9ckOQZmCQcFBwgCAwYF/uLOUgUIBwmTIWxcKg8qBDUCAgEBAdQICAhHSQQIAgMHBhIGBgQGahwJBQY9RSUyBAUCBQYJCAcJAgIBAhANEDoKGQ4FEgAAAAIAM//uAsMCMAAZADkAAAE2MzIfAQcUDwIGKwEvASY3PgE3JTc2NTQBMj8BFxYVFAcGFRQXFhUUBwYiJy4BJyYhIiYnJjQ3NgKWBgYICAkBBANURI9m4wcJCQVL2gEkAwL+b62KfQkIAQICAQcIDAgJBQUD/tzOVwUHBwYCKgYHB2BfDg4DAgIJDAsGAgIDHyI3Ov6zAgEJCAkHBgwcKioPFBYHCAgKpQMDAgQHEAcGAAAAAAIAM//KA24CnwARAEcAAAE2MzIXFhUUBwYiJyYnJjQ3Ngc+ARceARcTFxYzMjc2NTQnJjU0Nz4BNzY7ATIXFgcOAQcGBwYVFBcWFRQHBiMiLgEnJj0BEwEGEgYRDxQVFDYMBwIBCwq1CAgIBgIBAT54V0ICAgQCBAQWOUGUUTYFCgoENozBAwEDAwcINkqnbwIFAQKbBA0SFBQNDQ0HFwYSCgpDCAEGBUze/tkDBAIBQ3bVhgYwBQYDAgMGDw0FAwIEAwEsWKKvNz8HCAUGAgSjlQE3AAAAAAIAM//AAtwCegAUAFoAAAE2MzIXFhUUBwYjIiYjLgEnJjU0Nhc2MhcWFRQDDgIjIicuAjU0PgE3Ej0BLgEnIyIGBwYZAQYjIiYDJjU0Nz4BNzYzMhcWFRQDBhUUHwIWOwE+ATc2EzQCEwoQFgsPDhEcAgUBChEDAQ6xBg4IBgUDAwocG3h/MQoBAgEEAgMKEjGwAgEOCAcMAwIHBhhSI0F7BgUJAQECemIXEwwHAQUGAnUFCAwTEgwPAQITCwIECxkPCAgIRiT+yK1BCgMDAwonED1zOQECHBENBQEFAgH+1P7VCgwBO+4CTAcGAgIBBwcyOf67JEAxBhUEAgIDBxUCDT4AAwA0/5oCRALCACoAUwBjAAABLgErAQ4BBw4BFRQHBgcGFQcXFhcWFxYzMjY3Njc+ATc2NzY/AScmJy4BJzYzMhYzFhcWFx4BFxYXFRQHDgEHBgcGBwYjIicuAScmJy4BNTQ3PgETNjMyFxYVFAcGIyInJjU0AYkTPAoCC0ELCB8IGhUUARMQMzUFCjcoFA8lJA0fAwMGBwsECgwvIxeKGwkCBgESAwwYMSQzQgYLBA4CAxM8WBgQDCE2KjAyFRIJEyBUdAkHCAcIBwYJDQsMAnQIEgIqDAgvAwESOFxeU0oiIDExAwYDBxMxEkQSFA0TtE4aHjorF0gNAQIDBggQHT9UKwtBmjA0DQwoehwIAwUVMDImICkuYlmQiP6uBgcIGxkHBwoJFBgAAAAAAgA0/6ICRALIACkATQAAAS4BKwEOAQcOARQHBgcGHQEXFhcWFxYzMjY3Njc+ATc2NzY/AScmJy4BJzYzMhceARcWFxUUBgcOAQcGBwYHBiMiJy4CLwI1NDc+AQGJEzwKAgtBCwggBxwUFBMQMzUFCjYoFQ8lJA0fAwQFBwsECgsxIxaLFw0OLzciNEUECwQDCgIDFDlZHg8DJjcpYhgXAhMgVAJ8CBICKgwILwYQPFheVEkiIDExAwYDBxMxE0ISFQ0Ts04bGz0sFkcMEBMaQVcrCCPIGRIcEBEtdx4JAgUVYiopNBhjV5CIAAAEADP/gQLvAtAAGgA+AFYAdwAAASciAh0BMzI3Njc+ATc2NzY3NDY1NCYnJicmJzYzMhceARcWHwEWFRQGFQ4BBwYHDgEHBgcGIyInJjU0ExI2AzYSNSYHDgEHDgEHBhUUFhcWFxYXHgEzAz4BMzIfAQMCBgcGIyIuAScmJyY1NDY1PgE3Njc+ATc2AhwTAg4BChoFFRAvCBkbCQMBChIWJy9WCAkRKyxhEwIHBhEBAg4WFxwMOAwHCxkvFQcGBQYHwQEPAS8VNQ8IJAYNCBMVJRAQCDQGKgovEhAHCQYFBwgGChBYYhMHCBEBAQ8XFhoNOg0GAosK/YZTEA8DDgozEC5zK0kIFgUiKjE7LjhNCBoZeTUHEREwNwUaCEVRRUYnEDQFAwgWBwY6HgECASyn/PwBAtAOARgLNhoOch0/QjQsMzkrExUKJgL4Bw8GB/6h/tqnCAgyejQVFDA4BRoIQ1FGRCYSNgUCAAAAAgA0/4UBVwLOABwAPQAAJTQSNTQjIgcOAQcGBw4BHQEeARceBBcWHwEDPgEzMh8BAw4CFQ4BIyIuAScuAScuATU0NzY3Njc+AQEcCwQDKQwwChYXFg0BCREIDxgHJgQZExMxCi4TEgcJBwMEAgERBg9YYhMCCgILBgkbFyFBAhMdHQJBHQUVByoNHkdDRjMRNzEuFyAiCyoFGgsLAvkHDwYH/qaI8FwBBAkyeTUFHQUfLz9YKXAuRSsBDQABADL/kQG4ArwAIgAAEzYzMhceAR0BFx4BFxYUBwYjIicmLwEVFAYHBiInLgEREDY6CAcICAUConE0BwoKCg8QDVpHdwIEBxQGBQICArQICAUxf64CAgQFCBIIBwEEAQLCiDwFBwYEbQEdASNmAAAAAwAy/6ACxALLABMAKwA9AAABNjMyHwEDAgcGKwEiJyY1NDcSNgU2MzIWFRQHBgMPAQYjIicmNTQ3NhM+ARM3FxYXFhUUBwYjIicuAScmNAKdBwcFCwkHBgYDCgYMBgMDBgX9qwgKCQ4BAQUDCAcICQgHAQEFAgJeCM3MCAcKCU1HN5M6BQcCxAcHB/56/pgfEAYDOTqxAV+SCAkOKTAqJP6j/wcGCAckLCcrAVPBSf6aCAICBwYKDAYGAQICBQYUAAAAAAMANQDRA4oBewAyAEYAWQAAATYzMhcWFRQHDgEHBiInJicmIyIOAQcOASImNTQ2Nz4BNzYzMhcWFx4BFxYXFjMyNz4BNzYzMhcWFRQHBiMiJiMuAScmNTQFNjMyFx4BFRQGIyInJicuAT0BAp4GEAgKCAEDIyUeLCU1Gx9FISQPBgYMFA4VCQw6IAgMGjAfCAQRAxU4DAMIFhwSpwYMHQsPAgobAQYCEQ8FBv0UDQsPEQwFFBQVBQMKBgIBTywKCAoLCCspEg4NEyAlFBYZGBEOCw8+Cg0eAgESDQkEEwMXDAIJCxcSAwsPFQcDEgECCAsLChQCBxEMCxEXFAUFAgEKGyUAAwA1/+IDYwKNABsASwBeAAABNjMyFxYVFAcCBwIHBiMiJyY1NBM2NzY3Njc2AzYzMhcWFRQHDgEHBiMiJyYnJisBDgEHDgEiJjU0Njc+ATMyFxYXHgEXFjMyNz4BJTYzMhceAxUUBiMiLwE2NDcDPAoGCAgHAQkCCQQGDAoHBQkBAgUEAQIBmQYRCAoJAgMlJhsXGCI2GyBBCykhCQYMFA4WCQ9DIxAPRBYZJCUMAwgWHBL9pw0KDxIIBAUBFBIREhEBAQKGBwgHEhMQ/vs//uwGCQcHISABOyA1uwYBAQH+4CwKCQkCEiorEgwMEyAlAhglGBEOCw8/ChIYAw8ZHRcHAgkMFwsHEggECgkJGBQJCAwvDAAAAAMAMwAFA3oCnAAUAEYAWQAAEzYzMhceARcUFhUUBwYVFAYjIiYQATYzMhcWFRQHBgcGBwYjIicmJyYrAQ4BBw4BIyImNTQ2Nz4BMzIXFhceARcWMzI3PgE3NjMyFxYVFAcGIyImIyYnJjU0OgcICQcFAgIBAgMOCgkKAloGEAgKCQEFIAweGxgXIjQcH0MLKSEJBgwLCQ0XCA9DIxENRBYYJiUHCgkTHBKoBgwdCw8CChwCBAIcCQYClQcHBTiMF1AQTQYIdHMOCgJ+/ussCgkMCgc2GQkODQwSIiQCGCUYERELDT0LEhgDDxkdFgcCCAwXEgMLDxUHAxMBBBIKCxQAAAAAAgA1AIUCNAGgADUARgAAATYzMhcWFRQHBgcGBwYjIicmJyYnJiMiBw4BBw4BIyImNTQ2Nz4BMzIXHgEXHgEXFjMyNz4BBzYzMhcUFhUUBwYjIicmNTQCAwYRCAoIAQUeEBkeFhQnNRsOHRgUDQkpIAkGDAoLDRYJD0QjEA0cNgkYJSUHCgkTHBLlDhMhBgEMDhUUCw0BdCwKCAoLCDgXCwwODRMgEQsJAQEZJRcRDgoPPwoTGAMGGAsdFgcCCAwXkQggAgUBCAwOCAoREwAAAAMAOP+sAr8CvgAhADYAkgAAJSYjIgcGBwYHBgcGFRQXHgEyFxYzMjY3PgE/AScmJyYnJgMmIyIHDgMHBhUUFxYzMjc2NTQDIiYjIicmJyY1NDc+ATc+AT8CNjc2PwEnIi4BLwEHBgcGIicuAScuATU0NzI2OwEWFx4BHwEeATsBNjMyFhUUBwYHBhcWFx4BFxYXFhUUBw4BBwYHDgEjIicmAS4DBQEeJhsuExQGBC4XFSAaF2tuVRMQJQQFFCMwM3JTFAkLCRwLCAcCAgQHDTAaBQEIEDsOJjEoCgURCUAYHyIbH3NsEgoKCBIPQkoMJQULHQwgCyQdDgkDNwwYCgozFAIFAgECfTIYEh0nGjKlSgsCAT84PydALBEICj4XDhYUfi0WBxr+AwQEER0YFhgQEjIoFAsGBg0VET4RFRwvFxkGBAGGDAIBAQMEBQsQFwcPKwYICf06DDAmKBQUMSARPA4SDAICcmwPBgwKAQYIAQMQIREFAQINEwwNFl8CBgMoBQoDAwMGAQsQDDCfSgsDAQQCDxMfQxoVDRoeVA4IBQUJAQMAAAAAABAAxgABAAAAAAABAAcAAAABAAAAAAACAAcABwABAAAAAAADACoADgABAAAAAAAEAA8AOAABAAAAAAAFAA8ARwABAAAAAAAGAA8AVgABAAAAAAAKABwAZQADAAEECQABAA4AgQADAAEECQACAA4AjwADAAEECQADAFQAnQADAAEECQAEAB4A8QADAAEECQAFAB4BDwADAAEECQAGAB4BLQADAAEECQAKADgBSwADAAEECQAQAA4AgQADAAEECQARAA4Aj0tpdG55eDJSZWd1bGFyQ2FsbGlncmFwaHIgOiBLaXRueXgyIFJlZ3VsYXIgOiAwMi0wNS0yMDI1S2l0bnl4MiBSZWd1bGFyVmVyc2lvbiAwMDEuMDAxS2l0bnl4Mi1SZWd1bGFyQ3JlYXRlZCB3aXRoIENhbGxpZ3JhcGhyLmNvbQBLAGkAdABuAHkAeAAyAFIAZQBnAHUAbABhAHIAQwBhAGwAbABpAGcAcgBhAHAAaAByACAAOgAgAEsAaQB0AG4AeQB4ADIAIABSAGUAZwB1AGwAYQByACAAOgAgADAAMgAtADAANQAtADIAMAAyADUASwBpAHQAbgB5AHgAMgAgAFIAZQBnAHUAbABhAHIAVgBlAHIAcwBpAG8AbgAgADAAMAAxAC4AMAAwADEASwBpAHQAbgB5AHgAMgAtAFIAZQBnAHUAbABhAHIAQwByAGUAYQB0AGUAZAAgAHcAaQB0AGgAIABDAGEAbABsAGkAZwByAGEAcABoAHIALgBjAG8AbQAAAAACAAAAAAAA/7UAMgAAAAAAAAAAAAAAAAAAAAAAAAAAAE8AAAABAAIBAgADAAsADAANAA4AEAARABIAEwAUABUAFgAXABgAGQAaABsAHAAgACIAJAAlACYAJwAoACkAKgArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ADsAPAA9AEEARABFAEYARwBIAEkASgBLAEwATQBOAE8AUABRAFIAUwBUAFUAVgBXAFgAWQBaAFsAXABdAQMApQJDUgRuYnNwAAEAAf//AA8=";

  // src/modules/overlay.ts
  function loadOverlay() {
    c3(
      "ChatRoomCharacterViewDrawOverlay",
      d.ADD_BEHAVIOR,
      (args, next) => {
        next(args);
        if (ChatRoomHideIconState !== 0) return;
        const [C4, CharX, CharY, Zoom] = args;
        let bccData;
        if (C4.IsPlayer()) {
          bccData = modStorage;
        } else {
          if (!C4.BCC) return;
          bccData = C4.BCC;
        }
        const versionText = modStorage.overlay?.versionText ?? 2;
        const effectsIcons = modStorage.overlay?.effectsIcons ?? 2;
        if (MouseHovering(CharX, CharY, 500 * Zoom, 1e3 * Zoom) && versionText === 1 || versionText === 2) {
          DrawTextFit(
            `BCC v${bccData?.version}`,
            CharX + 250 * Zoom,
            CharY + 60 * Zoom,
            140 * Zoom,
            "Black"
          );
        }
        if (MouseHovering(CharX, CharY, 500 * Zoom, 1e3 * Zoom) && effectsIcons === 1 || effectsIcons === 2) {
          let spellIconY = 200;
          for (const spell of bccData?.darkMagic?.state?.spells ?? []) {
            DrawCircle(CharX + 400 * Zoom, CharY + spellIconY * Zoom, 20 * Zoom, 2, "#c4b2e2ff", "#e6d6ffff");
            DrawImageResize(getSpellIcon(spell.icon).dataurl, CharX + 400 * Zoom - 12 * Zoom, CharY + spellIconY * Zoom - 12 * Zoom, 25 * Zoom, 25 * Zoom);
            if (MouseIn(CharX + 400 * Zoom - 20 * Zoom, CharY + spellIconY * Zoom - 20 * Zoom, 40 * Zoom, 40 * Zoom)) {
              DrawRect(CharX + 200 * Zoom - 75 * Zoom, CharY + spellIconY * Zoom - 10 * Zoom, 240 * Zoom, 100 * Zoom, S()?.base?.element ?? "#e6d6ffff");
              I("DrawTextFit", [spell.name, CharX + 240 * Zoom, CharY + 10 * Zoom + spellIconY * Zoom, 200 * Zoom, "Black"]);
              I("DrawTextFit", [`Casted by: ${spell.castedBy?.name} (${spell.castedBy?.id})`, CharX + 240 * Zoom, CharY + 40 * Zoom + spellIconY * Zoom, 200 * Zoom, "Black"]);
              I("DrawTextFit", [`Created by: ${spell.createdBy?.name} (${spell.createdBy?.id})`, CharX + 240 * Zoom, CharY + 70 * Zoom + spellIconY * Zoom, 200 * Zoom, "Black"]);
            }
            spellIconY += 45;
            if (spellIconY >= 700) break;
          }
        }
      }
    );
  }

  // node_modules/.pnpm/@sugarch+bc-mod-hook-manager@0.3.4_bondage-club-mod-sdk@1.2.0/node_modules/@sugarch/bc-mod-hook-manager/dist/index.mjs
  var t = class {
    constructor(t3) {
      this.hookMng = t3, this.workList = [];
    }
    run(t3, o5) {
      let i5, n4 = false;
      for (const s5 of this.workList) if ("inject" === s5.value) s5.work(t3, o5);
      else if ("next" === s5.value) i5 = o5(t3), n4 = true;
      else if ("override" === s5.value) i5 = s5.work(t3, o5), n4 = true;
      else if ("flag" === s5.value) {
        if (!s5.flag) break;
        s5.once && (s5.flag = false);
      } else if ("check" === s5.value && !s5.work(t3, o5)) break;
      return n4 ? i5 : o5(t3);
    }
    next() {
      return this.workList.push({ value: "next" }), this;
    }
    inject(t3) {
      return this.workList.push({ value: "inject", work: t3 }), this;
    }
    inside(t3, { once: o5 = false, priority: i5 = 1 } = {}) {
      const n4 = { value: "flag", flag: false, once: o5 };
      return this.hookMng.hookFunction(t3, i5, (t4, o6) => {
        n4.flag = true;
        const i6 = o6(t4);
        return n4.flag = false, i6;
      }), this.workList.push(n4), this;
    }
    when(t3) {
      return this.workList.push({ value: "check", work: t3 }), this;
    }
    override(t3) {
      return this.workList.push({ value: "override", work: t3 }), this;
    }
  };
  var o2;
  var i2 = class {
    static info(t3) {
      o2?.info(t3);
    }
    static warn(t3) {
      o2?.warn(t3);
    }
    static error(t3) {
      o2?.error(t3);
    }
  };
  var n = class {
    constructor(t3 = false) {
      this.done = t3, this.list = [];
    }
    run() {
      for (this.done = true; this.list.length > 0; ) this.list.shift()();
    }
    push(t3) {
      this.done ? t3() : this.list.push(t3);
    }
  };
  var s2 = new n();
  var r2 = new n();
  var e = new n();
  var h4 = new n();
  function l3() {
    return null != globalThis.Player && "number" == typeof globalThis.Player.MemberNumber;
  }
  var u3 = new class {
    constructor() {
      this.mMod = void 0;
    }
    get mod() {
      return this.mMod;
    }
    push(t3, o5) {
      t3.push(o5);
    }
    initWithMod(t3) {
      this.mMod = t3, h4.run(), r2.run();
      const o5 = () => e.run();
      l3() ? o5() : this.mod.hookFunction("LoginResponse", 0, (t4, i5) => {
        i5(t4), l3() && o5();
      }), s2.run();
    }
    afterInit(t3) {
      this.push(s2, t3);
    }
    afterPlayerLogin(t3) {
      this.push(e, t3);
    }
    patchFunction(t3, o5) {
      this.push(h4, () => this.mod.patchFunction(t3, o5));
    }
    invokeOriginal(t3, ...o5) {
      return this.mod ? this.mod.callOriginal(t3, o5) : globalThis[t3]?.(...o5);
    }
    hookFunction(t3, o5, i5) {
      this.push(r2, () => this.mod.hookFunction(t3, o5, i5));
    }
    progressiveHook(o5, i5 = 1) {
      const n4 = new t(this);
      return this.hookFunction(o5, i5, (t3, o6) => n4.run(t3, o6)), n4;
    }
    insideFlag(t3, o5 = 1) {
      const i5 = { inside: false, args: void 0 };
      return this.hookFunction(t3, o5, (t4, o6) => {
        i5.inside = true, i5.args = t4;
        const n4 = o6(t4);
        return i5.inside = false, n4;
      }), i5;
    }
    hookPlayerFunction(t3, o5, i5) {
      var n4;
      n4 = () => this.mod.hookFunction(t3, o5, i5), l3() ? e.push(n4) : n4();
    }
    globalFunction(t3, o5) {
      "function" != typeof o5 && i2.warn("globalFunction: param is not a function"), null == globalThis[t3] ? globalThis[t3] = o5 : globalThis[t3] != o5 && i2.warn(`globalFunction: ${t3} is already defined`);
    }
    randomGlobalFunction(t3, o5) {
      const i5 = (t4) => t4 + Math.random().toString(16).substring(2);
      let n4 = i5(t3);
      for (; null != globalThis[n4]; ) n4 = i5(t3);
      return globalThis[n4] = o5, n4;
    }
    setLogger(t3) {
      !(function(t4) {
        o2 = t4;
      })(t3);
    }
  }();

  // node_modules/.pnpm/@sugarch+bc-event-handler@1.0.1_@sugarch+bc-mod-hook-manager@0.3.4_bondage-club-mod-sdk_184b91b29ea27c2053f106ec0a17f4bd/node_modules/@sugarch/bc-event-handler/dist/index.mjs
  function t2(e2) {
    return e2 && e2.__esModule && Object.prototype.hasOwnProperty.call(e2, "default") ? e2.default : e2;
  }
  var r3;
  var n2;
  var s3;
  var i3;
  function o3() {
    if (n2) return r3;
    n2 = 1;
    const e2 = "object" == typeof process && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...e3) => console.error("SEMVER", ...e3) : () => {
    };
    return r3 = e2;
  }
  function a3() {
    if (i3) return s3;
    i3 = 1;
    const e2 = Number.MAX_SAFE_INTEGER || 9007199254740991;
    return s3 = { MAX_LENGTH: 256, MAX_SAFE_COMPONENT_LENGTH: 16, MAX_SAFE_BUILD_LENGTH: 250, MAX_SAFE_INTEGER: e2, RELEASE_TYPES: ["major", "premajor", "minor", "preminor", "patch", "prepatch", "prerelease"], SEMVER_SPEC_VERSION: "2.0.0", FLAG_INCLUDE_PRERELEASE: 1, FLAG_LOOSE: 2 };
  }
  var h5;
  var c5;
  var E2;
  var l4;
  var f4;
  var p3;
  var u4;
  var I4;
  var v2;
  var m2;
  var R3;
  var d4 = { exports: {} };
  function N3() {
    return h5 || (h5 = 1, (function(e2, t3) {
      const { MAX_SAFE_COMPONENT_LENGTH: r5, MAX_SAFE_BUILD_LENGTH: n4, MAX_LENGTH: s5 } = a3(), i5 = o3(), h7 = (t3 = e2.exports = {}).re = [], c7 = t3.safeRe = [], E4 = t3.src = [], l6 = t3.safeSrc = [], f6 = t3.t = {};
      let p5 = 0;
      const u6 = "[a-zA-Z0-9-]", I6 = [["\\s", 1], ["\\d", s5], [u6, n4]], v4 = (e3, t4, r6) => {
        const n5 = ((e4) => {
          for (const [t5, r7] of I6) e4 = e4.split(`${t5}*`).join(`${t5}{0,${r7}}`).split(`${t5}+`).join(`${t5}{1,${r7}}`);
          return e4;
        })(t4), s6 = p5++;
        i5(e3, s6, t4), f6[e3] = s6, E4[s6] = t4, l6[s6] = n5, h7[s6] = new RegExp(t4, r6 ? "g" : void 0), c7[s6] = new RegExp(n5, r6 ? "g" : void 0);
      };
      v4("NUMERICIDENTIFIER", "0|[1-9]\\d*"), v4("NUMERICIDENTIFIERLOOSE", "\\d+"), v4("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${u6}*`), v4("MAINVERSION", `(${E4[f6.NUMERICIDENTIFIER]})\\.(${E4[f6.NUMERICIDENTIFIER]})\\.(${E4[f6.NUMERICIDENTIFIER]})`), v4("MAINVERSIONLOOSE", `(${E4[f6.NUMERICIDENTIFIERLOOSE]})\\.(${E4[f6.NUMERICIDENTIFIERLOOSE]})\\.(${E4[f6.NUMERICIDENTIFIERLOOSE]})`), v4("PRERELEASEIDENTIFIER", `(?:${E4[f6.NONNUMERICIDENTIFIER]}|${E4[f6.NUMERICIDENTIFIER]})`), v4("PRERELEASEIDENTIFIERLOOSE", `(?:${E4[f6.NONNUMERICIDENTIFIER]}|${E4[f6.NUMERICIDENTIFIERLOOSE]})`), v4("PRERELEASE", `(?:-(${E4[f6.PRERELEASEIDENTIFIER]}(?:\\.${E4[f6.PRERELEASEIDENTIFIER]})*))`), v4("PRERELEASELOOSE", `(?:-?(${E4[f6.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${E4[f6.PRERELEASEIDENTIFIERLOOSE]})*))`), v4("BUILDIDENTIFIER", `${u6}+`), v4("BUILD", `(?:\\+(${E4[f6.BUILDIDENTIFIER]}(?:\\.${E4[f6.BUILDIDENTIFIER]})*))`), v4("FULLPLAIN", `v?${E4[f6.MAINVERSION]}${E4[f6.PRERELEASE]}?${E4[f6.BUILD]}?`), v4("FULL", `^${E4[f6.FULLPLAIN]}$`), v4("LOOSEPLAIN", `[v=\\s]*${E4[f6.MAINVERSIONLOOSE]}${E4[f6.PRERELEASELOOSE]}?${E4[f6.BUILD]}?`), v4("LOOSE", `^${E4[f6.LOOSEPLAIN]}$`), v4("GTLT", "((?:<|>)?=?)"), v4("XRANGEIDENTIFIERLOOSE", `${E4[f6.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), v4("XRANGEIDENTIFIER", `${E4[f6.NUMERICIDENTIFIER]}|x|X|\\*`), v4("XRANGEPLAIN", `[v=\\s]*(${E4[f6.XRANGEIDENTIFIER]})(?:\\.(${E4[f6.XRANGEIDENTIFIER]})(?:\\.(${E4[f6.XRANGEIDENTIFIER]})(?:${E4[f6.PRERELEASE]})?${E4[f6.BUILD]}?)?)?`), v4("XRANGEPLAINLOOSE", `[v=\\s]*(${E4[f6.XRANGEIDENTIFIERLOOSE]})(?:\\.(${E4[f6.XRANGEIDENTIFIERLOOSE]})(?:\\.(${E4[f6.XRANGEIDENTIFIERLOOSE]})(?:${E4[f6.PRERELEASELOOSE]})?${E4[f6.BUILD]}?)?)?`), v4("XRANGE", `^${E4[f6.GTLT]}\\s*${E4[f6.XRANGEPLAIN]}$`), v4("XRANGELOOSE", `^${E4[f6.GTLT]}\\s*${E4[f6.XRANGEPLAINLOOSE]}$`), v4("COERCEPLAIN", `(^|[^\\d])(\\d{1,${r5}})(?:\\.(\\d{1,${r5}}))?(?:\\.(\\d{1,${r5}}))?`), v4("COERCE", `${E4[f6.COERCEPLAIN]}(?:$|[^\\d])`), v4("COERCEFULL", E4[f6.COERCEPLAIN] + `(?:${E4[f6.PRERELEASE]})?(?:${E4[f6.BUILD]})?(?:$|[^\\d])`), v4("COERCERTL", E4[f6.COERCE], true), v4("COERCERTLFULL", E4[f6.COERCEFULL], true), v4("LONETILDE", "(?:~>?)"), v4("TILDETRIM", `(\\s*)${E4[f6.LONETILDE]}\\s+`, true), t3.tildeTrimReplace = "$1~", v4("TILDE", `^${E4[f6.LONETILDE]}${E4[f6.XRANGEPLAIN]}$`), v4("TILDELOOSE", `^${E4[f6.LONETILDE]}${E4[f6.XRANGEPLAINLOOSE]}$`), v4("LONECARET", "(?:\\^)"), v4("CARETTRIM", `(\\s*)${E4[f6.LONECARET]}\\s+`, true), t3.caretTrimReplace = "$1^", v4("CARET", `^${E4[f6.LONECARET]}${E4[f6.XRANGEPLAIN]}$`), v4("CARETLOOSE", `^${E4[f6.LONECARET]}${E4[f6.XRANGEPLAINLOOSE]}$`), v4("COMPARATORLOOSE", `^${E4[f6.GTLT]}\\s*(${E4[f6.LOOSEPLAIN]})$|^$`), v4("COMPARATOR", `^${E4[f6.GTLT]}\\s*(${E4[f6.FULLPLAIN]})$|^$`), v4("COMPARATORTRIM", `(\\s*)${E4[f6.GTLT]}\\s*(${E4[f6.LOOSEPLAIN]}|${E4[f6.XRANGEPLAIN]})`, true), t3.comparatorTrimReplace = "$1$2$3", v4("HYPHENRANGE", `^\\s*(${E4[f6.XRANGEPLAIN]})\\s+-\\s+(${E4[f6.XRANGEPLAIN]})\\s*$`), v4("HYPHENRANGELOOSE", `^\\s*(${E4[f6.XRANGEPLAINLOOSE]})\\s+-\\s+(${E4[f6.XRANGEPLAINLOOSE]})\\s*$`), v4("STAR", "(<|>)?=?\\s*\\*"), v4("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), v4("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
    })(d4, d4.exports)), d4.exports;
  }
  function O3() {
    if (u4) return p3;
    u4 = 1;
    const e2 = o3(), { MAX_LENGTH: t3, MAX_SAFE_INTEGER: r5 } = a3(), { safeRe: n4, t: s5 } = N3(), i5 = (function() {
      if (E2) return c5;
      E2 = 1;
      const e3 = Object.freeze({ loose: true }), t4 = Object.freeze({});
      return c5 = (r6) => r6 ? "object" != typeof r6 ? e3 : r6 : t4;
    })(), { compareIdentifiers: h7 } = (function() {
      if (f4) return l4;
      f4 = 1;
      const e3 = /^[0-9]+$/, t4 = (t5, r6) => {
        const n5 = e3.test(t5), s6 = e3.test(r6);
        return n5 && s6 && (t5 = +t5, r6 = +r6), t5 === r6 ? 0 : n5 && !s6 ? -1 : s6 && !n5 ? 1 : t5 < r6 ? -1 : 1;
      };
      return l4 = { compareIdentifiers: t4, rcompareIdentifiers: (e4, r6) => t4(r6, e4) }, l4;
    })();
    class I6 {
      constructor(o5, a5) {
        if (a5 = i5(a5), o5 instanceof I6) {
          if (o5.loose === !!a5.loose && o5.includePrerelease === !!a5.includePrerelease) return o5;
          o5 = o5.version;
        } else if ("string" != typeof o5) throw new TypeError(`Invalid version. Must be a string. Got type "${typeof o5}".`);
        if (o5.length > t3) throw new TypeError(`version is longer than ${t3} characters`);
        e2("SemVer", o5, a5), this.options = a5, this.loose = !!a5.loose, this.includePrerelease = !!a5.includePrerelease;
        const h8 = o5.trim().match(a5.loose ? n4[s5.LOOSE] : n4[s5.FULL]);
        if (!h8) throw new TypeError(`Invalid Version: ${o5}`);
        if (this.raw = o5, this.major = +h8[1], this.minor = +h8[2], this.patch = +h8[3], this.major > r5 || this.major < 0) throw new TypeError("Invalid major version");
        if (this.minor > r5 || this.minor < 0) throw new TypeError("Invalid minor version");
        if (this.patch > r5 || this.patch < 0) throw new TypeError("Invalid patch version");
        h8[4] ? this.prerelease = h8[4].split(".").map((e3) => {
          if (/^[0-9]+$/.test(e3)) {
            const t4 = +e3;
            if (t4 >= 0 && t4 < r5) return t4;
          }
          return e3;
        }) : this.prerelease = [], this.build = h8[5] ? h8[5].split(".") : [], this.format();
      }
      format() {
        return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
      }
      toString() {
        return this.version;
      }
      compare(t4) {
        if (e2("SemVer.compare", this.version, this.options, t4), !(t4 instanceof I6)) {
          if ("string" == typeof t4 && t4 === this.version) return 0;
          t4 = new I6(t4, this.options);
        }
        return t4.version === this.version ? 0 : this.compareMain(t4) || this.comparePre(t4);
      }
      compareMain(e3) {
        return e3 instanceof I6 || (e3 = new I6(e3, this.options)), h7(this.major, e3.major) || h7(this.minor, e3.minor) || h7(this.patch, e3.patch);
      }
      comparePre(t4) {
        if (t4 instanceof I6 || (t4 = new I6(t4, this.options)), this.prerelease.length && !t4.prerelease.length) return -1;
        if (!this.prerelease.length && t4.prerelease.length) return 1;
        if (!this.prerelease.length && !t4.prerelease.length) return 0;
        let r6 = 0;
        do {
          const n5 = this.prerelease[r6], s6 = t4.prerelease[r6];
          if (e2("prerelease compare", r6, n5, s6), void 0 === n5 && void 0 === s6) return 0;
          if (void 0 === s6) return 1;
          if (void 0 === n5) return -1;
          if (n5 !== s6) return h7(n5, s6);
        } while (++r6);
      }
      compareBuild(t4) {
        t4 instanceof I6 || (t4 = new I6(t4, this.options));
        let r6 = 0;
        do {
          const n5 = this.build[r6], s6 = t4.build[r6];
          if (e2("build compare", r6, n5, s6), void 0 === n5 && void 0 === s6) return 0;
          if (void 0 === s6) return 1;
          if (void 0 === n5) return -1;
          if (n5 !== s6) return h7(n5, s6);
        } while (++r6);
      }
      inc(e3, t4, r6) {
        if (e3.startsWith("pre")) {
          if (!t4 && false === r6) throw new Error("invalid increment argument: identifier is empty");
          if (t4) {
            const e4 = `-${t4}`.match(this.options.loose ? n4[s5.PRERELEASELOOSE] : n4[s5.PRERELEASE]);
            if (!e4 || e4[1] !== t4) throw new Error(`invalid identifier: ${t4}`);
          }
        }
        switch (e3) {
          case "premajor":
            this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t4, r6);
            break;
          case "preminor":
            this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t4, r6);
            break;
          case "prepatch":
            this.prerelease.length = 0, this.inc("patch", t4, r6), this.inc("pre", t4, r6);
            break;
          case "prerelease":
            0 === this.prerelease.length && this.inc("patch", t4, r6), this.inc("pre", t4, r6);
            break;
          case "release":
            if (0 === this.prerelease.length) throw new Error(`version ${this.raw} is not a prerelease`);
            this.prerelease.length = 0;
            break;
          case "major":
            0 === this.minor && 0 === this.patch && 0 !== this.prerelease.length || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
            break;
          case "minor":
            0 === this.patch && 0 !== this.prerelease.length || this.minor++, this.patch = 0, this.prerelease = [];
            break;
          case "patch":
            0 === this.prerelease.length && this.patch++, this.prerelease = [];
            break;
          case "pre": {
            const e4 = Number(r6) ? 1 : 0;
            if (0 === this.prerelease.length) this.prerelease = [e4];
            else {
              let n5 = this.prerelease.length;
              for (; --n5 >= 0; ) "number" == typeof this.prerelease[n5] && (this.prerelease[n5]++, n5 = -2);
              if (-1 === n5) {
                if (t4 === this.prerelease.join(".") && false === r6) throw new Error("invalid increment argument: identifier already exists");
                this.prerelease.push(e4);
              }
            }
            if (t4) {
              let n5 = [t4, e4];
              false === r6 && (n5 = [t4]), 0 === h7(this.prerelease[0], t4) ? isNaN(this.prerelease[1]) && (this.prerelease = n5) : this.prerelease = n5;
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${e3}`);
        }
        return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
      }
    }
    return p3 = I6;
  }
  var A2;
  var L3;
  var $2;
  var S2;
  var y3 = (function() {
    if (R3) return m2;
    R3 = 1;
    const e2 = (function() {
      if (v2) return I4;
      v2 = 1;
      const e3 = O3();
      return I4 = (t3, r5, n4 = false) => {
        if (t3 instanceof e3) return t3;
        try {
          return new e3(t3, r5);
        } catch (e4) {
          if (!n4) return null;
          throw e4;
        }
      }, I4;
    })();
    return m2 = (t3, r5) => {
      const n4 = e2(t3, r5);
      return n4 ? n4.version : null;
    }, m2;
  })();
  var _2 = t2(y3);
  var C2 = (function() {
    if (S2) return $2;
    S2 = 1;
    const e2 = (function() {
      if (L3) return A2;
      L3 = 1;
      const e3 = O3();
      return A2 = (t3, r5, n4) => new e3(t3, n4).compare(new e3(r5, n4)), A2;
    })();
    return $2 = (t3, r5, n4) => e2(t3, r5, n4) < 0, $2;
  })();
  var T3 = t2(C2);
  function g4(e2) {
    return globalThis[e2];
  }
  var P4 = class _P {
    static _initStorage() {
      var e2, t3;
      g4(this._namespace) || (e2 = this._namespace, t3 = {}, globalThis[e2] = t3);
    }
    static get(e2, t3) {
      this._initStorage();
      const r5 = g4(this._namespace);
      return e2 in r5 || (r5[e2] = t3()), r5[e2];
    }
    static getMayOverride(e2, t3) {
      this._initStorage();
      const r5 = g4(this._namespace);
      return r5[e2] = t3(r5[e2]), r5[e2];
    }
    static getByVersion(e2, t3, r5, n4) {
      if (this._initStorage(), !_2(t3)) throw new Error(`Invalid version for ${e2}: ${t3}`);
      const s5 = g4(this._namespace), i5 = `${e2}.__Version`, o5 = s5[e2], a5 = s5[i5];
      return o5 ? a5 && !T3(a5, t3) || (s5[e2] = n4(a5, o5), s5[i5] = t3) : (s5[e2] = r5(o5), s5[i5] = t3), s5[e2];
    }
    static set(e2, t3) {
      this._initStorage(), g4(this._namespace)[e2] = t3;
    }
    static has(e2) {
      return this._initStorage(), e2 in g4(this._namespace);
    }
    static delete(e2) {
      this._initStorage();
      const t3 = g4(this._namespace);
      return e2 in t3 && delete t3[e2];
    }
    static setImplementation(e2) {
      const t3 = ["get", "set", "has", "delete"];
      for (const r5 of t3) {
        if ("function" != typeof e2[r5]) throw new Error(`Implementation must provide a '${r5}' function`);
        _P[r5] = e2[r5];
      }
    }
    static createNamespace(e2) {
      return { get: (t3, r5) => _P.get(`${e2}.${t3}`, r5), getMayOverride: (t3, r5) => _P.getMayOverride(`${e2}.${t3}`, r5), set: (t3, r5) => _P.set(`${e2}.${t3}`, r5), has: (t3) => _P.has(`${e2}.${t3}`), delete: (t3) => _P.delete(`${e2}.${t3}`) };
    }
  };
  function w4(e2) {
    return new Promise((t3) => setTimeout(t3, e2));
  }
  function M3(e2, t3 = 100) {
    return (async () => {
      for (; !e2(); ) await w4(t3);
    })();
  }
  P4._namespace = "__BC_LUZI_GLOBALS__", P4.createNamespace("OnceFlag");
  var D3;
  var b = { exports: {} };
  var F2 = (D3 || (D3 = 1, (function(e2) {
    var t3 = Object.prototype.hasOwnProperty, r5 = "~";
    function n4() {
    }
    function s5(e3, t4, r6) {
      this.fn = e3, this.context = t4, this.once = r6 || false;
    }
    function i5(e3, t4, n5, i6, o6) {
      if ("function" != typeof n5) throw new TypeError("The listener must be a function");
      var a6 = new s5(n5, i6 || e3, o6), h7 = r5 ? r5 + t4 : t4;
      return e3._events[h7] ? e3._events[h7].fn ? e3._events[h7] = [e3._events[h7], a6] : e3._events[h7].push(a6) : (e3._events[h7] = a6, e3._eventsCount++), e3;
    }
    function o5(e3, t4) {
      0 === --e3._eventsCount ? e3._events = new n4() : delete e3._events[t4];
    }
    function a5() {
      this._events = new n4(), this._eventsCount = 0;
    }
    Object.create && (n4.prototype = /* @__PURE__ */ Object.create(null), new n4().__proto__ || (r5 = false)), a5.prototype.eventNames = function() {
      var e3, n5, s6 = [];
      if (0 === this._eventsCount) return s6;
      for (n5 in e3 = this._events) t3.call(e3, n5) && s6.push(r5 ? n5.slice(1) : n5);
      return Object.getOwnPropertySymbols ? s6.concat(Object.getOwnPropertySymbols(e3)) : s6;
    }, a5.prototype.listeners = function(e3) {
      var t4 = r5 ? r5 + e3 : e3, n5 = this._events[t4];
      if (!n5) return [];
      if (n5.fn) return [n5.fn];
      for (var s6 = 0, i6 = n5.length, o6 = new Array(i6); s6 < i6; s6++) o6[s6] = n5[s6].fn;
      return o6;
    }, a5.prototype.listenerCount = function(e3) {
      var t4 = r5 ? r5 + e3 : e3, n5 = this._events[t4];
      return n5 ? n5.fn ? 1 : n5.length : 0;
    }, a5.prototype.emit = function(e3, t4, n5, s6, i6, o6) {
      var a6 = r5 ? r5 + e3 : e3;
      if (!this._events[a6]) return false;
      var h7, c7, E4 = this._events[a6], l6 = arguments.length;
      if (E4.fn) {
        switch (E4.once && this.removeListener(e3, E4.fn, void 0, true), l6) {
          case 1:
            return E4.fn.call(E4.context), true;
          case 2:
            return E4.fn.call(E4.context, t4), true;
          case 3:
            return E4.fn.call(E4.context, t4, n5), true;
          case 4:
            return E4.fn.call(E4.context, t4, n5, s6), true;
          case 5:
            return E4.fn.call(E4.context, t4, n5, s6, i6), true;
          case 6:
            return E4.fn.call(E4.context, t4, n5, s6, i6, o6), true;
        }
        for (c7 = 1, h7 = new Array(l6 - 1); c7 < l6; c7++) h7[c7 - 1] = arguments[c7];
        E4.fn.apply(E4.context, h7);
      } else {
        var f6, p5 = E4.length;
        for (c7 = 0; c7 < p5; c7++) switch (E4[c7].once && this.removeListener(e3, E4[c7].fn, void 0, true), l6) {
          case 1:
            E4[c7].fn.call(E4[c7].context);
            break;
          case 2:
            E4[c7].fn.call(E4[c7].context, t4);
            break;
          case 3:
            E4[c7].fn.call(E4[c7].context, t4, n5);
            break;
          case 4:
            E4[c7].fn.call(E4[c7].context, t4, n5, s6);
            break;
          default:
            if (!h7) for (f6 = 1, h7 = new Array(l6 - 1); f6 < l6; f6++) h7[f6 - 1] = arguments[f6];
            E4[c7].fn.apply(E4[c7].context, h7);
        }
      }
      return true;
    }, a5.prototype.on = function(e3, t4, r6) {
      return i5(this, e3, t4, r6, false);
    }, a5.prototype.once = function(e3, t4, r6) {
      return i5(this, e3, t4, r6, true);
    }, a5.prototype.removeListener = function(e3, t4, n5, s6) {
      var i6 = r5 ? r5 + e3 : e3;
      if (!this._events[i6]) return this;
      if (!t4) return o5(this, i6), this;
      var a6 = this._events[i6];
      if (a6.fn) a6.fn !== t4 || s6 && !a6.once || n5 && a6.context !== n5 || o5(this, i6);
      else {
        for (var h7 = 0, c7 = [], E4 = a6.length; h7 < E4; h7++) (a6[h7].fn !== t4 || s6 && !a6[h7].once || n5 && a6[h7].context !== n5) && c7.push(a6[h7]);
        c7.length ? this._events[i6] = 1 === c7.length ? c7[0] : c7 : o5(this, i6);
      }
      return this;
    }, a5.prototype.removeAllListeners = function(e3) {
      var t4;
      return e3 ? (t4 = r5 ? r5 + e3 : e3, this._events[t4] && o5(this, t4)) : (this._events = new n4(), this._eventsCount = 0), this;
    }, a5.prototype.off = a5.prototype.removeListener, a5.prototype.addListener = a5.prototype.on, a5.prefixed = r5, a5.EventEmitter = a5, e2.exports = a5;
  })(b)), b.exports);
  var G2 = t2(F2);
  var U2 = "1.0.1";
  var x3 = class {
    constructor() {
      this.handler = new G2(), u3.hookFunction("ChatRoomMessage", 10, (e2, t3) => {
        const { Type: r5 } = e2[0];
        return "ServerMessage" !== r5 && "Status" !== r5 && this.handler.emit(r5, e2[0]), t3(e2);
      }), u3.hookFunction("ChatRoomSync", 1, (e2, t3) => {
        const r5 = Player && !ServerPlayerIsInChatRoom() && RelogData?.ChatRoomName !== e2[0].Name, n4 = t3(e2);
        return r5 && this.handler.emit("PlayerJoin", Player), n4;
      }), u3.hookFunction("ServerSend", 1, (e2, t3) => ("ChatRoomLeave" === e2[0] && Player && this.handler.emit("PlayerLeave", Player), t3(e2)));
    }
    on(...e2) {
      this.handler.on(...e2);
    }
    off(...e2) {
      this.handler.off(...e2);
    }
    once(...e2) {
      this.handler.once(...e2);
    }
  };
  var X3 = P4.get(`ChatRoomEvents@${U2}`, () => new x3());
  var j2 = class {
    constructor() {
      this.handler = new G2(), u3.hookFunction("ActivityOrgasmStop", 9, (e2, t3) => {
        const [r5, n4] = e2;
        r5.IsPlayer() && (ActivityOrgasmRuined ? this.handler.emit("ruined", { Player: r5 }) : n4 >= 60 && this.handler.emit("resisted", { Player: r5 })), t3(e2);
      }), u3.hookFunction("ActivityOrgasmStart", 9, (e2, t3) => {
        const [r5] = e2;
        r5.IsPlayer() && !ActivityOrgasmRuined && this.handler.emit("orgasmed", { Player: r5 }), t3(e2);
      });
    }
    on(...e2) {
      this.handler.on(...e2);
    }
    once(...e2) {
      this.handler.once(...e2);
    }
    off(...e2) {
      this.handler.off(...e2);
    }
  };
  var k3 = P4.get(`OrgasmEvents@${U2}`, () => new j2());
  var H = class {
    constructor() {
      this.handler = new G2(), (async () => {
        var e2;
        await M3(() => Array.isArray(ChatRoomMessageHandlers)), ChatRoomRegisterMessageHandler((e2 = this.handler, { Description: `SugarChain ChatMessage Handler v${U2}`, Priority: 1024, Callback: (t3, r5, n4, s5) => (e2.emit(t3.Type, t3, r5, n4, s5), false) }));
      })();
    }
    on(...e2) {
      this.handler.on(...e2);
    }
    once(...e2) {
      this.handler.once(...e2);
    }
    off(...e2) {
      this.handler.off(...e2);
    }
  };
  var B2 = P4.get(`ChatRoomMessageHandlerEvents@${U2}`, () => new H());
  var V2 = { pullActivityInfo: function(...e2) {
    const [t3, r5, n4, s5] = e2;
    if ("Activity" !== t3.Type || !t3.Dictionary || !s5) return;
    const { ActivityName: i5, ActivityAsset: o5, CraftingNames: a5, FocusGroup: h7, TargetMemberNumber: c7 } = s5;
    if (!(i5 && h7 && c7 && r5.MemberNumber)) return;
    return { SourceCharacter: r5.MemberNumber, SourceCharacterC: r5, TargetCharacter: c7, ActivityGroup: h7, ActivityName: i5, Asset: void 0 !== o5 ? { Asset: o5, CraftName: a5?.ActivityAsset } : void 0, Dictionary: t3.Dictionary };
  } };
  var z = { OthersOnSelf: /* @__PURE__ */ new Set(["OthersOnSelf", "AnyOnSelf", "SelfInvolved", "AnyInvolved"]), SelfOnSelf: /* @__PURE__ */ new Set(["SelfOnSelf", "AnyOnSelf", "SelfInvolved", "AnyInvolved"]), SelfOnOthers: /* @__PURE__ */ new Set(["SelfOnOthers", "SelfInvolved", "AnyInvolved"]), OthersOnOthers: /* @__PURE__ */ new Set(["AnyInvolved"]) };
  var J = class {
    constructor() {
      this._handlers = [], (async () => {
        var e2;
        await M3(() => Array.isArray(ChatRoomMessageHandlers)), ChatRoomRegisterMessageHandler((e2 = (...e3) => this.emit(...e3), { Description: `SugarChain Activity Handler v${U2}`, Priority: 290, Callback: (t3, r5, n4, s5) => {
          const i5 = V2.pullActivityInfo(t3, r5, n4, s5);
          if (!i5) return false;
          const o5 = i5.TargetCharacter === Player.MemberNumber ? r5.MemberNumber === i5.TargetCharacter ? z.SelfOnSelf : z.OthersOnSelf : i5.SourceCharacter === Player.MemberNumber ? z.SelfOnOthers : z.OthersOnOthers;
          return e2(o5, i5.ActivityName, r5, Player, i5), false;
        } }));
      })();
    }
    emit(e2, t3, ...r5) {
      const n4 = [...this._handlers], s5 = [];
      for (const i5 of n4) if (null !== i5.activity && t3 !== i5.activity || !e2.has(i5.mode)) s5.push(i5);
      else {
        try {
          i5.listener(...r5);
        } catch (e3) {
          console.error(`Error in activity event listener for ${i5.activity} (${i5.mode}):`, e3);
        }
        i5.once || s5.push(i5);
      }
      this._handlers = s5;
    }
    on(e2, t3, r5) {
      this._handlers.push({ mode: e2, activity: t3, listener: r5, once: false });
    }
    once(e2, t3, r5) {
      this._handlers.push({ mode: e2, activity: t3, listener: r5, once: true });
    }
    onAny(e2, t3) {
      this._handlers.push({ mode: e2, activity: null, listener: t3, once: false });
    }
    onceAny(e2, t3) {
      this._handlers.push({ mode: e2, activity: null, listener: t3, once: true });
    }
    off(e2, t3, r5) {
      this._handlers = r5 ? this._handlers.filter((n4) => n4.mode !== e2 || n4.activity !== t3 || n4.listener !== r5) : this._handlers.filter((r6) => r6.mode !== e2 || r6.activity !== t3);
    }
  };
  var Y2 = P4.get(`ActivityEvents@${U2}`, () => new J());
  var Z = class {
    isAllowed(e2) {
      return e2 in this.modifiers;
    }
    constructor() {
      this.modifiers = { ChatRoomChat: [], ChatRoomCharacterUpdate: [], ChatRoomCharacterExpressionUpdate: [], ChatRoomCharacterPoseUpdate: [], ChatRoomCharacterArousalUpdate: [], ChatRoomCharacterItemUpdate: [], ChatRoomCharacterMapDataUpdate: [], ChatRoomGame: [] }, u3.hookFunction("ServerSend", 10, (e2, t3) => {
        const [r5, n4] = e2;
        if (this.isAllowed(r5)) {
          const t4 = this.modifiers[r5];
          for (const r6 of t4) e2[1] = r6(n4);
        }
        return t3(e2);
      });
    }
    addModifier(e2, t3) {
      this.modifiers[e2].push(t3);
    }
    removeModifier(e2, t3) {
      const r5 = this.modifiers[e2].indexOf(t3);
      r5 > -1 && this.modifiers[e2].splice(r5, 1);
    }
  };
  var W2 = P4.get("ServerSendModifiers", () => new Z());

  // node_modules/.pnpm/@sugarch+bc-activity-manager@1.1.1_@sugarch+bc-event-handler@1.0.1_@sugarch+bc-mod-hook_268353b0c07c410468a5e413195f47b5/node_modules/@sugarch/bc-activity-manager/dist/index.mjs
  var i4;
  var r4 = class {
    static info(t3) {
      i4?.info(t3);
    }
    static warn(t3) {
      i4?.warn(t3);
    }
    static error(t3) {
      i4?.error(t3);
    }
  };
  var s4 = /* @__PURE__ */ new Set();
  function n3(e2, i5) {
    s4.has(e2) ? r4.warn(`Handler for ${e2} already exists, skipping`) : Y2.on(i5.mode ?? "SelfInvolved", e2, (t3, e3, r5) => {
      i5.run?.(e3, t3, r5);
    });
  }
  var a4 = [];
  var o4 = false;
  function c6(t3) {
    o4 ? t3() : a4.push(t3);
  }
  function E3(t3, e2, i5) {
    return (function(t4, e3) {
      const i6 = "TW" !== TranslationLanguage ? TranslationLanguage : "CN";
      let r5 = t4(i6);
      return void 0 !== r5 ? r5 : (r5 = "CN" === i6 ? t4("CN") : t4("EN") || t4("CN"), void 0 !== r5 ? r5 : e3);
    })((i6) => t3[i6]?.[e2], i5);
  }
  var h6 = {};
  function u5(t3, e2) {
    for (const [i5, r5] of Object.entries(t3)) r5 && e2(i5, r5);
  }
  function m3(t3, e2, i5, r5) {
    u5(e2, (e3, s5) => {
      h6[e3] = (function(t4, e4, i6 = {}) {
        const r6 = { ...i6 };
        return u5(t4, (t5, i7) => {
          const { key: s6, value: n4 } = e4(t5, i7);
          r6[s6] = n4;
        }), r6;
      })(s5, (e4, s6) => ({ key: `${t3}Chat${i5}-${e4}-${r5}`, value: s6 }), h6[e3] || {});
    });
  }
  var p4 = { ItemVulva: "ItemPenis", ItemVulvaPiercings: "ItemGlans" };
  function I5(t3, e2, i5, r5, s5) {
    l5(e2) ? (function(t4, e3, i6, r6, s6) {
      u5(e3, (e4, n4) => {
        h6[e4] || (h6[e4] = {});
        for (const a5 of s6) {
          h6[e4][`${t4}Chat${i6}-${a5}-${r6}`] = n4;
          const s7 = p4[a5];
          s7 && (h6[e4][`${t4}Chat${i6}-${s7}-${r6}`] = n4);
        }
      });
    })(t3, e2, i5, r5, s5) : m3(t3, e2, i5, r5);
  }
  function l5(t3) {
    return Object.values(t3).some((t4) => "string" == typeof t4);
  }
  function A3(t3) {
    const { activity: e2, label: i5, labelSelf: r5, dialog: s5, dialogSelf: n4 } = t3, { Name: a5, Target: o5, TargetSelf: c7 } = e2, E4 = i5 ?? r5 ?? { CN: a5 };
    l5(E4) ? u5(E4, (t4, e3) => {
      h6[t4] || (h6[t4] = {}), h6[t4][`Activity${a5}`] = e3;
    }) : u5(E4, (t4, e3) => {
      h6[t4] || (h6[t4] = {}), h6[t4][`Activity${a5}`] = Object.values(e3)[0] || a5;
    }), I5("Label-", E4, "Other", a5, o5), s5 && I5("", s5, "Other", a5, o5);
    const m4 = "boolean" == typeof c7 && c7 ? o5 : Array.isArray(c7) ? c7 : [], p5 = r5 || i5;
    p5 && I5("Label-", p5, "Self", a5, m4);
    const A4 = n4 || s5;
    A4 && I5("", A4, "Self", a5, m4);
  }
  var f5 = {};
  function g5(t3) {
    f5[t3.name] = t3;
  }
  function N4(t3, e2) {
    return e2.map((e3) => {
      if ("function" == typeof e3) {
        const i5 = (function(t4) {
          for (; ; ) {
            const e4 = `${t4}_prereq_${Math.random().toString(36).substring(2)}`;
            if (!f5[e4]) return e4;
          }
        })(t3);
        return g5({ name: i5, test: e3 }), i5;
      }
      return e3;
    });
  }
  var R4 = {};
  function d5(t3) {
    R4[t3.activity.Name] = t3;
  }
  function $3(t3) {
    return !!R4[t3];
  }
  function v3(t3) {
    return t3 && t3.__esModule && Object.prototype.hasOwnProperty.call(t3, "default") ? t3.default : t3;
  }
  var L4;
  var y4;
  var O4;
  var S3;
  function T4() {
    if (y4) return L4;
    y4 = 1;
    const t3 = "object" == typeof process && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...t4) => console.error("SEMVER", ...t4) : () => {
    };
    return L4 = t3;
  }
  function D4() {
    if (S3) return O4;
    S3 = 1;
    const t3 = Number.MAX_SAFE_INTEGER || 9007199254740991;
    return O4 = { MAX_LENGTH: 256, MAX_SAFE_COMPONENT_LENGTH: 16, MAX_SAFE_BUILD_LENGTH: 250, MAX_SAFE_INTEGER: t3, RELEASE_TYPES: ["major", "premajor", "minor", "preminor", "patch", "prepatch", "prerelease"], SEMVER_SPEC_VERSION: "2.0.0", FLAG_INCLUDE_PRERELEASE: 1, FLAG_LOOSE: 2 };
  }
  var C3;
  var F3;
  var w5;
  var P5;
  var G3;
  var M4;
  var b2;
  var _3;
  var U3;
  var X4;
  var k4;
  var j3 = { exports: {} };
  function B3() {
    return C3 || (C3 = 1, (function(t3, e2) {
      const { MAX_SAFE_COMPONENT_LENGTH: i5, MAX_SAFE_BUILD_LENGTH: r5, MAX_LENGTH: s5 } = D4(), n4 = T4(), a5 = (e2 = t3.exports = {}).re = [], o5 = e2.safeRe = [], c7 = e2.src = [], E4 = e2.safeSrc = [], h7 = e2.t = {};
      let u6 = 0;
      const m4 = "[a-zA-Z0-9-]", p5 = [["\\s", 1], ["\\d", s5], [m4, r5]], I6 = (t4, e3, i6) => {
        const r6 = ((t5) => {
          for (const [e4, i7] of p5) t5 = t5.split(`${e4}*`).join(`${e4}{0,${i7}}`).split(`${e4}+`).join(`${e4}{1,${i7}}`);
          return t5;
        })(e3), s6 = u6++;
        n4(t4, s6, e3), h7[t4] = s6, c7[s6] = e3, E4[s6] = r6, a5[s6] = new RegExp(e3, i6 ? "g" : void 0), o5[s6] = new RegExp(r6, i6 ? "g" : void 0);
      };
      I6("NUMERICIDENTIFIER", "0|[1-9]\\d*"), I6("NUMERICIDENTIFIERLOOSE", "\\d+"), I6("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${m4}*`), I6("MAINVERSION", `(${c7[h7.NUMERICIDENTIFIER]})\\.(${c7[h7.NUMERICIDENTIFIER]})\\.(${c7[h7.NUMERICIDENTIFIER]})`), I6("MAINVERSIONLOOSE", `(${c7[h7.NUMERICIDENTIFIERLOOSE]})\\.(${c7[h7.NUMERICIDENTIFIERLOOSE]})\\.(${c7[h7.NUMERICIDENTIFIERLOOSE]})`), I6("PRERELEASEIDENTIFIER", `(?:${c7[h7.NONNUMERICIDENTIFIER]}|${c7[h7.NUMERICIDENTIFIER]})`), I6("PRERELEASEIDENTIFIERLOOSE", `(?:${c7[h7.NONNUMERICIDENTIFIER]}|${c7[h7.NUMERICIDENTIFIERLOOSE]})`), I6("PRERELEASE", `(?:-(${c7[h7.PRERELEASEIDENTIFIER]}(?:\\.${c7[h7.PRERELEASEIDENTIFIER]})*))`), I6("PRERELEASELOOSE", `(?:-?(${c7[h7.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${c7[h7.PRERELEASEIDENTIFIERLOOSE]})*))`), I6("BUILDIDENTIFIER", `${m4}+`), I6("BUILD", `(?:\\+(${c7[h7.BUILDIDENTIFIER]}(?:\\.${c7[h7.BUILDIDENTIFIER]})*))`), I6("FULLPLAIN", `v?${c7[h7.MAINVERSION]}${c7[h7.PRERELEASE]}?${c7[h7.BUILD]}?`), I6("FULL", `^${c7[h7.FULLPLAIN]}$`), I6("LOOSEPLAIN", `[v=\\s]*${c7[h7.MAINVERSIONLOOSE]}${c7[h7.PRERELEASELOOSE]}?${c7[h7.BUILD]}?`), I6("LOOSE", `^${c7[h7.LOOSEPLAIN]}$`), I6("GTLT", "((?:<|>)?=?)"), I6("XRANGEIDENTIFIERLOOSE", `${c7[h7.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), I6("XRANGEIDENTIFIER", `${c7[h7.NUMERICIDENTIFIER]}|x|X|\\*`), I6("XRANGEPLAIN", `[v=\\s]*(${c7[h7.XRANGEIDENTIFIER]})(?:\\.(${c7[h7.XRANGEIDENTIFIER]})(?:\\.(${c7[h7.XRANGEIDENTIFIER]})(?:${c7[h7.PRERELEASE]})?${c7[h7.BUILD]}?)?)?`), I6("XRANGEPLAINLOOSE", `[v=\\s]*(${c7[h7.XRANGEIDENTIFIERLOOSE]})(?:\\.(${c7[h7.XRANGEIDENTIFIERLOOSE]})(?:\\.(${c7[h7.XRANGEIDENTIFIERLOOSE]})(?:${c7[h7.PRERELEASELOOSE]})?${c7[h7.BUILD]}?)?)?`), I6("XRANGE", `^${c7[h7.GTLT]}\\s*${c7[h7.XRANGEPLAIN]}$`), I6("XRANGELOOSE", `^${c7[h7.GTLT]}\\s*${c7[h7.XRANGEPLAINLOOSE]}$`), I6("COERCEPLAIN", `(^|[^\\d])(\\d{1,${i5}})(?:\\.(\\d{1,${i5}}))?(?:\\.(\\d{1,${i5}}))?`), I6("COERCE", `${c7[h7.COERCEPLAIN]}(?:$|[^\\d])`), I6("COERCEFULL", c7[h7.COERCEPLAIN] + `(?:${c7[h7.PRERELEASE]})?(?:${c7[h7.BUILD]})?(?:$|[^\\d])`), I6("COERCERTL", c7[h7.COERCE], true), I6("COERCERTLFULL", c7[h7.COERCEFULL], true), I6("LONETILDE", "(?:~>?)"), I6("TILDETRIM", `(\\s*)${c7[h7.LONETILDE]}\\s+`, true), e2.tildeTrimReplace = "$1~", I6("TILDE", `^${c7[h7.LONETILDE]}${c7[h7.XRANGEPLAIN]}$`), I6("TILDELOOSE", `^${c7[h7.LONETILDE]}${c7[h7.XRANGEPLAINLOOSE]}$`), I6("LONECARET", "(?:\\^)"), I6("CARETTRIM", `(\\s*)${c7[h7.LONECARET]}\\s+`, true), e2.caretTrimReplace = "$1^", I6("CARET", `^${c7[h7.LONECARET]}${c7[h7.XRANGEPLAIN]}$`), I6("CARETLOOSE", `^${c7[h7.LONECARET]}${c7[h7.XRANGEPLAINLOOSE]}$`), I6("COMPARATORLOOSE", `^${c7[h7.GTLT]}\\s*(${c7[h7.LOOSEPLAIN]})$|^$`), I6("COMPARATOR", `^${c7[h7.GTLT]}\\s*(${c7[h7.FULLPLAIN]})$|^$`), I6("COMPARATORTRIM", `(\\s*)${c7[h7.GTLT]}\\s*(${c7[h7.LOOSEPLAIN]}|${c7[h7.XRANGEPLAIN]})`, true), e2.comparatorTrimReplace = "$1$2$3", I6("HYPHENRANGE", `^\\s*(${c7[h7.XRANGEPLAIN]})\\s+-\\s+(${c7[h7.XRANGEPLAIN]})\\s*$`), I6("HYPHENRANGELOOSE", `^\\s*(${c7[h7.XRANGEPLAINLOOSE]})\\s+-\\s+(${c7[h7.XRANGEPLAINLOOSE]})\\s*$`), I6("STAR", "(<|>)?=?\\s*\\*"), I6("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), I6("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
    })(j3, j3.exports)), j3.exports;
  }
  function x4() {
    if (b2) return M4;
    b2 = 1;
    const t3 = T4(), { MAX_LENGTH: e2, MAX_SAFE_INTEGER: i5 } = D4(), { safeRe: r5, t: s5 } = B3(), n4 = (function() {
      if (w5) return F3;
      w5 = 1;
      const t4 = Object.freeze({ loose: true }), e3 = Object.freeze({});
      return F3 = (i6) => i6 ? "object" != typeof i6 ? t4 : i6 : e3;
    })(), { compareIdentifiers: a5 } = (function() {
      if (G3) return P5;
      G3 = 1;
      const t4 = /^[0-9]+$/, e3 = (e4, i6) => {
        const r6 = t4.test(e4), s6 = t4.test(i6);
        return r6 && s6 && (e4 = +e4, i6 = +i6), e4 === i6 ? 0 : r6 && !s6 ? -1 : s6 && !r6 ? 1 : e4 < i6 ? -1 : 1;
      };
      return P5 = { compareIdentifiers: e3, rcompareIdentifiers: (t5, i6) => e3(i6, t5) }, P5;
    })();
    class o5 {
      constructor(a6, c7) {
        if (c7 = n4(c7), a6 instanceof o5) {
          if (a6.loose === !!c7.loose && a6.includePrerelease === !!c7.includePrerelease) return a6;
          a6 = a6.version;
        } else if ("string" != typeof a6) throw new TypeError(`Invalid version. Must be a string. Got type "${typeof a6}".`);
        if (a6.length > e2) throw new TypeError(`version is longer than ${e2} characters`);
        t3("SemVer", a6, c7), this.options = c7, this.loose = !!c7.loose, this.includePrerelease = !!c7.includePrerelease;
        const E4 = a6.trim().match(c7.loose ? r5[s5.LOOSE] : r5[s5.FULL]);
        if (!E4) throw new TypeError(`Invalid Version: ${a6}`);
        if (this.raw = a6, this.major = +E4[1], this.minor = +E4[2], this.patch = +E4[3], this.major > i5 || this.major < 0) throw new TypeError("Invalid major version");
        if (this.minor > i5 || this.minor < 0) throw new TypeError("Invalid minor version");
        if (this.patch > i5 || this.patch < 0) throw new TypeError("Invalid patch version");
        E4[4] ? this.prerelease = E4[4].split(".").map((t4) => {
          if (/^[0-9]+$/.test(t4)) {
            const e3 = +t4;
            if (e3 >= 0 && e3 < i5) return e3;
          }
          return t4;
        }) : this.prerelease = [], this.build = E4[5] ? E4[5].split(".") : [], this.format();
      }
      format() {
        return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
      }
      toString() {
        return this.version;
      }
      compare(e3) {
        if (t3("SemVer.compare", this.version, this.options, e3), !(e3 instanceof o5)) {
          if ("string" == typeof e3 && e3 === this.version) return 0;
          e3 = new o5(e3, this.options);
        }
        return e3.version === this.version ? 0 : this.compareMain(e3) || this.comparePre(e3);
      }
      compareMain(t4) {
        return t4 instanceof o5 || (t4 = new o5(t4, this.options)), a5(this.major, t4.major) || a5(this.minor, t4.minor) || a5(this.patch, t4.patch);
      }
      comparePre(e3) {
        if (e3 instanceof o5 || (e3 = new o5(e3, this.options)), this.prerelease.length && !e3.prerelease.length) return -1;
        if (!this.prerelease.length && e3.prerelease.length) return 1;
        if (!this.prerelease.length && !e3.prerelease.length) return 0;
        let i6 = 0;
        do {
          const r6 = this.prerelease[i6], s6 = e3.prerelease[i6];
          if (t3("prerelease compare", i6, r6, s6), void 0 === r6 && void 0 === s6) return 0;
          if (void 0 === s6) return 1;
          if (void 0 === r6) return -1;
          if (r6 !== s6) return a5(r6, s6);
        } while (++i6);
      }
      compareBuild(e3) {
        e3 instanceof o5 || (e3 = new o5(e3, this.options));
        let i6 = 0;
        do {
          const r6 = this.build[i6], s6 = e3.build[i6];
          if (t3("build compare", i6, r6, s6), void 0 === r6 && void 0 === s6) return 0;
          if (void 0 === s6) return 1;
          if (void 0 === r6) return -1;
          if (r6 !== s6) return a5(r6, s6);
        } while (++i6);
      }
      inc(t4, e3, i6) {
        if (t4.startsWith("pre")) {
          if (!e3 && false === i6) throw new Error("invalid increment argument: identifier is empty");
          if (e3) {
            const t5 = `-${e3}`.match(this.options.loose ? r5[s5.PRERELEASELOOSE] : r5[s5.PRERELEASE]);
            if (!t5 || t5[1] !== e3) throw new Error(`invalid identifier: ${e3}`);
          }
        }
        switch (t4) {
          case "premajor":
            this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", e3, i6);
            break;
          case "preminor":
            this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", e3, i6);
            break;
          case "prepatch":
            this.prerelease.length = 0, this.inc("patch", e3, i6), this.inc("pre", e3, i6);
            break;
          case "prerelease":
            0 === this.prerelease.length && this.inc("patch", e3, i6), this.inc("pre", e3, i6);
            break;
          case "release":
            if (0 === this.prerelease.length) throw new Error(`version ${this.raw} is not a prerelease`);
            this.prerelease.length = 0;
            break;
          case "major":
            0 === this.minor && 0 === this.patch && 0 !== this.prerelease.length || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
            break;
          case "minor":
            0 === this.patch && 0 !== this.prerelease.length || this.minor++, this.patch = 0, this.prerelease = [];
            break;
          case "patch":
            0 === this.prerelease.length && this.patch++, this.prerelease = [];
            break;
          case "pre": {
            const t5 = Number(i6) ? 1 : 0;
            if (0 === this.prerelease.length) this.prerelease = [t5];
            else {
              let r6 = this.prerelease.length;
              for (; --r6 >= 0; ) "number" == typeof this.prerelease[r6] && (this.prerelease[r6]++, r6 = -2);
              if (-1 === r6) {
                if (e3 === this.prerelease.join(".") && false === i6) throw new Error("invalid increment argument: identifier already exists");
                this.prerelease.push(t5);
              }
            }
            if (e3) {
              let r6 = [e3, t5];
              false === i6 && (r6 = [e3]), 0 === a5(this.prerelease[0], e3) ? isNaN(this.prerelease[1]) && (this.prerelease = r6) : this.prerelease = r6;
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${t4}`);
        }
        return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
      }
    }
    return M4 = o5;
  }
  var W3;
  var V3;
  var H2;
  var z2;
  var Z2 = v3((function() {
    if (k4) return X4;
    k4 = 1;
    const t3 = (function() {
      if (U3) return _3;
      U3 = 1;
      const t4 = x4();
      return _3 = (e2, i5, r5 = false) => {
        if (e2 instanceof t4) return e2;
        try {
          return new t4(e2, i5);
        } catch (t5) {
          if (!r5) return null;
          throw t5;
        }
      };
    })();
    return X4 = (e2, i5) => {
      const r5 = t3(e2, i5);
      return r5 ? r5.version : null;
    };
  })());
  var q3 = (function() {
    if (z2) return H2;
    z2 = 1;
    const t3 = (function() {
      if (V3) return W3;
      V3 = 1;
      const t4 = x4();
      return W3 = (e2, i5, r5) => new t4(e2, r5).compare(new t4(i5, r5)), W3;
    })();
    return H2 = (e2, i5, r5) => t3(e2, i5, r5) < 0, H2;
  })();
  var Y3 = v3(q3);
  function J2(t3) {
    return globalThis[t3];
  }
  var Q3 = class _Q {
    static _initStorage() {
      var t3, e2;
      J2(this._namespace) || (t3 = this._namespace, e2 = {}, globalThis[t3] = e2);
    }
    static get(t3, e2) {
      this._initStorage();
      const i5 = J2(this._namespace);
      return t3 in i5 || (i5[t3] = e2()), i5[t3];
    }
    static getMayOverride(t3, e2) {
      this._initStorage();
      const i5 = J2(this._namespace);
      return i5[t3] = e2(i5[t3]), i5[t3];
    }
    static getByVersion(t3, e2, i5, r5) {
      if (this._initStorage(), !Z2(e2)) throw new Error(`Invalid version for ${t3}: ${e2}`);
      const s5 = J2(this._namespace), n4 = `${t3}.__Version`, a5 = s5[t3], o5 = s5[n4];
      return a5 ? o5 && !Y3(o5, e2) || (s5[t3] = r5(o5, a5), s5[n4] = e2) : (s5[t3] = i5(a5), s5[n4] = e2), s5[t3];
    }
    static set(t3, e2) {
      this._initStorage(), J2(this._namespace)[t3] = e2;
    }
    static has(t3) {
      return this._initStorage(), t3 in J2(this._namespace);
    }
    static delete(t3) {
      this._initStorage();
      const e2 = J2(this._namespace);
      return t3 in e2 && delete e2[t3];
    }
    static setImplementation(t3) {
      const e2 = ["get", "set", "has", "delete"];
      for (const i5 of e2) {
        if ("function" != typeof t3[i5]) throw new Error(`Implementation must provide a '${i5}' function`);
        _Q[i5] = t3[i5];
      }
    }
    static createNamespace(t3) {
      return { get: (e2, i5) => _Q.get(`${t3}.${e2}`, i5), getMayOverride: (e2, i5) => _Q.getMayOverride(`${t3}.${e2}`, i5), set: (e2, i5) => _Q.set(`${t3}.${e2}`, i5), has: (e2) => _Q.has(`${t3}.${e2}`), delete: (e2) => _Q.delete(`${t3}.${e2}`) };
    }
  };
  Q3._namespace = "__BC_LUZI_GLOBALS__";
  var K2 = Q3.createNamespace("OnceFlag");
  function tt(t3, e2) {
    K2.get(t3, () => false) || (K2.set(t3, true), e2());
  }
  function et(t3) {
    return new Promise((e2) => setTimeout(e2, t3));
  }
  function it(t3, e2 = 100) {
    return (async () => {
      for (; !t3(); ) await et(e2);
    })();
  }
  var rt = class {
    static get emptyImage() {
      return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAACXBIWXMAAC4jAAAuIwF4pT92AAAAG3RFWHRTb2Z0d2FyZQBDZWxzeXMgU3R1ZGlvIFRvb2zBp+F8AAAADUlEQVQI12P4//8/AwAI/AL+XJ/P2gAAAABJRU5ErkJggg==";
    }
    static assetPreviewIconPath(t3) {
      const e2 = "Asset" in t3 ? t3.Asset : t3;
      return `${AssetGetPreviewPath(e2)}/${e2.Name}.png`;
    }
    static activityPreviewIconPath(t3) {
      return `Assets/Female3DCG/Activity/${("Activity" in t3 ? t3.Activity : t3).Name}.png`;
    }
  };
  function st(t3, e2) {
    const i5 = /* @__PURE__ */ new Set();
    let r5 = t3;
    for (; e2[r5]; ) {
      if (i5.has(r5)) return console.warn(`Circular dependency detected during resolution: ${r5}`), "";
      i5.add(r5), r5 = e2[r5];
    }
    return r5;
  }
  function nt(t3) {
    const e2 = {};
    for (const i5 of Object.keys(t3)) {
      const r5 = st(i5, t3);
      if (!r5) return console.warn(`Circular dependency detected during optimization: ${i5}`), null;
      e2[i5] = r5;
    }
    return e2;
  }
  var at = class {
    constructor(t3, e2) {
      this.path = t3, this.storage = e2;
    }
    map(t3) {
      const e2 = Array.isArray(t3) ? t3 : [t3], i5 = {};
      for (const t4 of e2) i5[t4] = this.path;
      return this.storage.addImgMapping(i5), this;
    }
    resolve(t3) {
      return this.storage.addImgMapping({ [this.path]: t3 }), this;
    }
  };
  var ot = new class {
    constructor() {
      this.basic = {}, this.custom = {}, this.customSrc = {};
    }
    addImgMapping(t3) {
      const e2 = { ...this.customSrc, ...t3 }, i5 = nt(e2);
      i5 ? (this.customSrc = e2, this.custom = i5) : console.warn("Failed to add mappings due to circular dependencies.");
    }
    rebuildCustomMapping() {
      const t3 = nt(this.customSrc);
      t3 ? this.custom = t3 : console.warn("Failed to rebuild mappings due to circular dependencies.");
    }
    migrateTo(t3) {
      t3.customSrc = { ...t3.customSrc, ...this.customSrc }, t3.basic = { ...t3.basic, ...this.basic }, t3.rebuildCustomMapping(), this.customSrc = t3.customSrc, this.basic = t3.basic, this.custom = t3.custom;
    }
    setBasicImgMapping(t3) {
      this.basic = { ...t3, ...this.basic };
    }
    mapImgSrc(t3) {
      if ("string" != typeof t3) return t3;
      if (!t3.endsWith(".png")) return t3;
      if (t3.startsWith("blob:")) return t3;
      if (t3.startsWith("data:")) return t3;
      if (t3.startsWith("http:")) return t3;
      if (t3.startsWith("https:")) return t3;
      if (t3.startsWith("@nomap/")) return t3;
      const e2 = t3.startsWith("./") ? t3.slice(2) : t3;
      let i5 = e2;
      return this.custom[i5] && (i5 = this.custom[i5]), this.basic[i5] && (i5 = this.basic[i5]), i5 !== e2 ? i5 : t3;
    }
    mapImg(t3, e2) {
      let i5 = t3;
      i5.startsWith("data:image") || i5.startsWith("http") || (this.custom[i5] && (i5 = this.custom[i5]), this.basic[i5] && (i5 = this.basic[i5]), i5 !== t3 && e2(i5));
    }
  }();
  var Et = class {
    constructor() {
      tt("ImgMappingOnce.GLDrawLoadImage.crossOrigin", () => {
        u3.patchFunction("GLDrawLoadImage", { "Img.src = url;": 'Img.crossOrigin = "Anonymous";\n		Img.src = url;' });
      }), ["DrawImageEx", "DrawImageResize", "GLDrawImage", "DrawGetImage"].forEach((t3) => {
        u3.hookFunction(t3, 10, (t4, e2) => (t4[0] = ot.mapImgSrc(t4[0]), e2(t4)));
      }), tt("ImgMappingOnce.nomap", () => {
        ["DrawImageEx", "DrawImageResize", "GLDrawImage", "DrawGetImage"].forEach((t3) => {
          u3.hookFunction(t3, 0, (t4, e2) => ("string" == typeof t4[0] && t4[0].startsWith("@nomap/") && (t4[0] = t4[0].substring(7)), e2(t4)));
        });
      }), u3.hookFunction("GLDrawLoadTextureAlphaMask", 0, (t3, e2) => (Array.isArray(t3[5]) && (t3[5] = t3[5].map((t4) => ({ ...t4, Url: ot.mapImgSrc(t4.Url) }))), e2(t3))), (async () => {
        await it(() => void 0 !== globalThis.ElementButton), u3.hookFunction("ElementButton.CreateForAsset", 0, (t3, e2) => (ot.mapImg(rt.assetPreviewIconPath(t3[1]), (e3) => {
          t3[4] = { ...t3[4], image: e3 };
        }), e2(t3))), u3.hookFunction("ElementButton.CreateForActivity", 0, (t3, e2) => {
          const i5 = t3[1], r5 = t3[4]?.image ?? (i5.Item ? rt.assetPreviewIconPath(i5.Item.Asset) : `Assets/Female3DCG/Activity/${i5.Activity.Name}.png`);
          return ot.mapImg(r5, (e3) => {
            t3[4] = { ...t3[4], image: e3 };
          }), e2(t3);
        }), u3.hookFunction("ElementButton.Create", 0, (t3, e2) => {
          if (t3[0]?.startsWith("dialog-inventory")) {
            const e3 = t3[2];
            e3?.icons && (e3.icons = e3.icons.map((t4) => {
              if ("string" == typeof t4 && t4.endsWith("Padlock")) {
                const e4 = `Assets/Female3DCG/ItemMisc/Preview/${t4}.png`, i5 = ot.mapImgSrc(e4);
                if (i5 !== e4) return { name: t4, iconSrc: i5, tooltipText: InterfaceTextGet("PreviewIconPadlock").replace("AssetName", AssetGet("Female3DCG", "ItemMisc", t4)?.Description ?? t4) };
              }
              return t4;
            }));
          }
          if (t3[0]?.startsWith("dialog-expression-button-grid-Emoticon")) {
            const e3 = t3[2];
            e3?.image && (e3.image = ot.mapImgSrc(e3.image));
          }
          return e2(t3);
        });
      })();
    }
    get storage() {
      return ot;
    }
    addImgMapping(t3) {
      ot.addImgMapping(t3);
    }
    setBasicImgMapping(t3) {
      ot.setBasicImgMapping(t3);
    }
    createVirtualPath(t3) {
      return new at(t3, ot);
    }
  };
  var ht = Q3.get("ImageMapping@2.1.3", () => new Et());
  function ut(t3, e2) {
    if ("function" == typeof e2) return void (mt[t3.Name] = e2);
    const i5 = {}, r5 = rt.activityPreviewIconPath(t3);
    Array.isArray(e2) ? i5[r5] = `Assets/Female3DCG/${e2[0]}/Preview/${e2[1]}.png` : "None" === e2 || void 0 === e2 ? i5[r5] = rt.emptyImage : e2.startsWith("http") || e2.startsWith("data:image") ? i5[r5] = e2 : i5[r5] = rt.activityPreviewIconPath({ Name: e2 }), ht.addImgMapping(i5);
  }
  var mt = {};
  var pt = {};
  var It = {};
  var lt = {};
  function At(t3) {
    t3.override && (pt[t3.activity.Name] && r4.warn(`Override for ${t3.activity.Name} already exists, skipping`), pt[t3.activity.Name] || (pt[t3.activity.Name] = t3.override)), t3.item && (It[t3.activity.Name] && r4.warn(`Item provider for ${t3.activity.Name} already exists, skipping`), It[t3.activity.Name] || (It[t3.activity.Name] = t3.item)), t3.dictionary && (lt[t3.activity.Name] && r4.warn(`Dictionary processor for ${t3.activity.Name} already exists, skipping`), lt[t3.activity.Name] || (lt[t3.activity.Name] = t3.dictionary));
  }
  var ft = class {
    addPrerequisites(t3) {
      c6(() => t3.forEach((t4) => g5(t4)));
    }
    checkActivityAvailability(t3) {
      return !ActivityFemale3DCGOrdering.includes(t3);
    }
    addCustomActivity(t3) {
      Array.isArray(t3) || (t3 = [t3]);
      for (const e2 of t3) {
        const t4 = { ...e2 };
        c6(() => {
          t4.activity.Prerequisite = N4(t4.activity.Name, t4.activity.Prerequisite), "R121" === GameVersion ? t4.activity.ActivityID = -1 : t4.activity.ActivityID = void 0, ActivityFemale3DCG.push(t4.activity), ActivityFemale3DCGOrdering.push(t4.activity.Name), A3(t4), n3(t4.activity.Name, t4), d5(t4), At(t4), ut(t4.activity, t4.useImage);
        });
      }
    }
    removeCustomActivity(t3) {
      ActivityFemale3DCG = ActivityFemale3DCG.filter((e2) => e2.Name !== t3), ActivityFemale3DCGOrdering = ActivityFemale3DCGOrdering.filter((e2) => e2 !== t3);
    }
    activityIsCustom(t3) {
      return $3(t3);
    }
    addCustomActivities(t3) {
      this.addCustomActivity(t3);
    }
    activityTrigger(t3) {
      c6(() => n3(t3.name, t3));
    }
    init() {
      (async () => {
        await it(() => Array.isArray(ActivityFemale3DCG) && ActivityFemale3DCG.length > 0 && Array.isArray(ActivityFemale3DCGOrdering)), (function(t3 = {}) {
          const { startMsg: e2 = "Start loading", endMsg: i5 = "Loading completed, time usage: " } = t3, s5 = Date.now();
          for (r4.info(e2), o4 = true; a4.length > 0; ) {
            const t4 = a4.shift();
            t4 && t4();
          }
          const n4 = Date.now();
          r4.info(`${i5} ${n4 - s5}ms`);
        })();
      })(), (function() {
        u3.hookFunction("ActivityRun", 0, (t4, e2) => {
          const i5 = pt[t4[3].Activity.Name];
          if (i5) return i5(t4[0], t4[1], t4[2], t4[3]);
          const r5 = It[t4[3].Activity.Name];
          if (r5) {
            const e3 = r5(t4[0], t4[1], t4[2], t4[3]);
            e3 && (t4[3].Item = e3);
          }
          return e2(t4);
        }), u3.hookFunction("PreferenceGetActivityFactor", 0, (t4, e2) => $3(t4[1]) ? 2 : e2(t4));
        const t3 = u3.insideFlag("ActivityRun");
        u3.hookFunction("ServerSend", 0, (e2, i5) => {
          if (!t3.inside || !t3.args) return i5(e2);
          if ("ChatRoomChat" != e2[0]) return i5(e2);
          const r5 = e2[1], s5 = r5.Dictionary, n4 = t3.args ? t3.args[3].Activity : null;
          if (!n4) return i5(e2);
          const a5 = lt[n4.Name];
          if (!a5) return i5(e2);
          if (!s5.some((t4) => t4?.ActivityName === n4?.Name)) return i5(e2);
          const o5 = t3.args, c7 = a5(Array.from(s5), o5[0], o5[1], o5[2], o5[3]);
          i5([e2[0], { ...r5, Dictionary: c7 }]);
        });
      })(), u3.hookFunction("ElementButton.CreateForActivity", 1, (t3, e2) => {
        const [i5, r5, s5] = t3, n4 = mt[r5.Activity.Name];
        if (n4) {
          const e3 = n4(r5.Activity, s5, r5.Group) ?? rt.emptyImage;
          e3 && (t3[4] = { ...t3[4], image: e3 });
        }
        return e2(t3);
      }), (function() {
        const t3 = (t4) => E3(h6, t4);
        u3.hookFunction("ActivityDictionaryText", 1, (e2, i5) => t3(e2[0]) || i5(e2)), u3.progressiveHook("ServerSend", 1).inside("ActivityRun").inject((e2) => {
          const { Content: i5, Dictionary: r5, Type: s5 } = e2[1];
          if ("Activity" !== s5 || !r5) return;
          const n4 = t3(i5);
          n4 && r5.push({ Tag: `MISSING ACTIVITY DESCRIPTION FOR KEYWORD ${i5}`, Text: n4 });
        });
      })(), u3.hookFunction("ActivityCheckPrerequisite", 1, (t3, e2) => {
        const i5 = f5[t3[0]];
        return i5 ? i5.test(...t3) : e2(t3);
      });
    }
    setLogger(t3) {
      !(function(t4) {
        i4 = t4;
      })(t3);
    }
    typePrerequisiteNames() {
      return this;
    }
    typeActivityNames() {
      return this;
    }
  };
  var gt = new ft();

  // src/modules/activities.ts
  function addActivities() {
    gt.addCustomActivity({
      activity: {
        Name: "BCC_StealPanties" /* STEAL_PANTIES */,
        Prerequisite: ["UseHands", (_4, _acter, acted) => !!InventoryGet(acted, "Panties")],
        MaxProgress: 0,
        Target: ["ItemPelvis", "ItemButt", "ItemVulva", "ItemVulvaPiercings"]
      },
      useImage: (_activity, target, _group) => {
        const asset = InventoryGet(target, "Panties")?.Asset;
        return AssetGetPreviewPath(asset) + "/" + asset?.Name + ".png";
      },
      label: { EN: "Steal Panties" },
      dialog: { EN: "SourceCharacter steals TargetCharacter's panties." },
      run: (_player, sender, info) => {
        if (!sender.IsPlayer()) return;
        const target = N2(info.TargetCharacter);
        InventoryRemove(target, "Panties");
        InventoryWear(Player, "Panties", "ItemHandheld", "red", 10, Player.MemberNumber, {
          Item: "Panties",
          Name: `${O2(target)}'s panties`,
          Description: "",
          Color: "red",
          Property: "Normal",
          Lock: "",
          Private: false,
          ItemProperty: {},
          Type: null,
          TypeRecord: null,
          MemberNumber: target.MemberNumber,
          MemberName: O2(target)
        });
        ChatRoomCharacterUpdate(target);
        ChatRoomCharacterUpdate(Player);
      }
    });
    gt.addCustomActivity({
      activity: {
        Name: "BCC_SuckOnTipOfHair" /* SUCK_ON_TIP_HAIR */,
        Prerequisite: ["UseMouth"],
        MaxProgress: 0,
        Target: ["ItemHead", "ItemHood", "ItemEars"]
      },
      useImage: "Kiss",
      label: { EN: "Suck on tip of hair" },
      dialog: { EN: "SourceCharacter sucks on TargetCharacter's tip of hair." },
      run: (_player, sender, info) => {
        if (!sender.IsPlayer()) return;
        const target = N2(info.TargetCharacter);
        const hairColor = InventoryGet(target, "HairFront")?.Color?.[0] ?? "#6a3628";
        InventoryWear(Player, "Tentacles", "ItemMouth2", hairColor, 10, target.MemberNumber, {
          Item: "Tentacles",
          Name: `${O2(target)}'s tip of hair`,
          Description: "",
          Color: hairColor,
          Property: "Decoy",
          Lock: "",
          Private: false,
          ItemProperty: {},
          Type: null,
          TypeRecord: null,
          MemberNumber: target.MemberNumber,
          MemberName: O2(target)
        });
        ChatRoomCharacterUpdate(Player);
      }
    });
    u3.initWithMod(o);
    gt.init();
  }

  // src/index.ts
  function start() {
    C({
      name: "BCC",
      fullName: "Bondage Club Chaos",
      key: "BCC",
      version,
      fontFamily: "Yusei Magic",
      singleToastsTheme: {
        backgroundColor: "#191919",
        titleColor: "#e600d2",
        messageColor: "#a9a9a9",
        iconFillColor: "#e600d2",
        iconStrokeColor: "#731f71",
        progressBarColor: "#242424"
      }
    });
    k2(`${styles_default2}@font-face { font-family: Kitnyx2; src: url(${Kitnyx2_default}); }`);
    loadStorage();
    loadSettingsSubscreen();
    loadCheats();
    loadQuickAccessMenu();
    loadChaosAura();
    loadOverlay();
    loadDarkMagic();
    addActivities();
    Q2.success({
      title: `${c2.fullName} loaded`,
      message: `v${version}`,
      duration: 4500
    });
  }
  P3(start);
})();
/*! Bundled license information:

reflect-metadata/Reflect.js:
  (*! *****************************************************************************
  Copyright (C) Microsoft. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)

react/cjs/react.development.js:
  (**
   * @license React
   * react.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.development.js:
  (**
   * @license React
   * scheduler.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.development.js:
  (**
   * @license React
   * react-dom.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom-client.development.js:
  (**
   * @license React
   * react-dom-client.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-runtime.development.js:
  (**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

lucide/dist/esm/defaultAttributes.js:
lucide/dist/esm/createElement.js:
lucide/dist/esm/icons/check.js:
lucide/dist/esm/icons/chevron-down.js:
lucide/dist/esm/icons/circle-x.js:
lucide/dist/esm/icons/trash-2.js:
lucide/dist/esm/lucide.js:
  (**
   * @license lucide v0.541.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/shared/src/utils.js:
lucide-react/dist/esm/defaultAttributes.js:
lucide-react/dist/esm/Icon.js:
lucide-react/dist/esm/createLucideIcon.js:
lucide-react/dist/esm/icons/circle-alert.js:
lucide-react/dist/esm/icons/circle-check.js:
lucide-react/dist/esm/icons/circle-x.js:
lucide-react/dist/esm/icons/info.js:
lucide-react/dist/esm/lucide-react.js:
  (**
   * @license lucide-react v0.542.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide/dist/esm/defaultAttributes.js:
lucide/dist/esm/createElement.js:
lucide/dist/esm/icons/align-vertical-space-around.js:
lucide/dist/esm/icons/arrow-down.js:
lucide/dist/esm/icons/arrow-up.js:
lucide/dist/esm/icons/ban.js:
lucide/dist/esm/icons/book-heart.js:
lucide/dist/esm/icons/bug.js:
lucide/dist/esm/icons/check.js:
lucide/dist/esm/icons/chevron-down.js:
lucide/dist/esm/icons/clipboard-copy.js:
lucide/dist/esm/icons/clipboard-paste.js:
lucide/dist/esm/icons/code-xml.js:
lucide/dist/esm/icons/copy-plus.js:
lucide/dist/esm/icons/eye.js:
lucide/dist/esm/icons/git-commit-vertical.js:
lucide/dist/esm/icons/git-compare-arrows.js:
lucide/dist/esm/icons/git-pull-request-arrow.js:
lucide/dist/esm/icons/git-pull-request-closed.js:
lucide/dist/esm/icons/git-pull-request.js:
lucide/dist/esm/icons/hand-coins.js:
lucide/dist/esm/icons/hat-glasses.js:
lucide/dist/esm/icons/heart.js:
lucide/dist/esm/icons/lock-open.js:
lucide/dist/esm/icons/lock.js:
lucide/dist/esm/icons/log-out.js:
lucide/dist/esm/icons/map-pinned.js:
lucide/dist/esm/icons/maximize.js:
lucide/dist/esm/icons/panel-left-close.js:
lucide/dist/esm/icons/panels-top-left.js:
lucide/dist/esm/icons/person-standing.js:
lucide/dist/esm/icons/send-to-back.js:
lucide/dist/esm/icons/settings.js:
lucide/dist/esm/icons/shell.js:
lucide/dist/esm/icons/shield-alert.js:
lucide/dist/esm/icons/shield-minus.js:
lucide/dist/esm/icons/skull.js:
lucide/dist/esm/icons/target.js:
lucide/dist/esm/icons/trash-2.js:
lucide/dist/esm/icons/wand.js:
lucide/dist/esm/icons/x.js:
lucide/dist/esm/lucide.js:
  (**
   * @license lucide v0.554.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

@sugarch/bc-mod-hook-manager/dist/index.mjs:
  (**
   * @sugarch/bc-mod-hook-manager v0.3.4
   * 
   * Copyright (c) 2025 SugarChain Studio
   * License: MIT
   * https://github.com/SugarChain-Studio/sugarch-utilities
   * @preserve
   *)

@sugarch/bc-event-handler/dist/index.mjs:
  (**
   * @sugarch/bc-event-handler v1.0.1
   * 
   * Copyright (c) 2025 SugarChain Studio
   * License: MIT
   * https://github.com/SugarChain-Studio/sugarch-utilities
   * @preserve
   *)
  (**
   * @sugarch/bc-mod-utility v0.2.11
   * 
   * Copyright (c) 2025 SugarChain Studio
   * License: MIT
   * https://github.com/SugarChain-Studio/sugarch-utilities
   * @preserve
   *)

@sugarch/bc-activity-manager/dist/index.mjs:
  (**
   * @sugarch/bc-activity-manager v1.1.1
   * 
   * Copyright (c) 2025 SugarChain Studio
   * License: MIT
   * https://github.com/SugarChain-Studio/sugarch-utilities
   * @preserve
   *)
  (**
   * @sugarch/bc-mod-utility v0.2.11
   * 
   * Copyright (c) 2025 SugarChain Studio
   * License: MIT
   * https://github.com/SugarChain-Studio/sugarch-utilities
   * @preserve
   *)
  (**
   * @sugarch/bc-image-mapping v2.1.3
   * 
   * Copyright (c) 2025 SugarChain Studio
   * License: MIT
   * https://github.com/SugarChain-Studio/sugarch-utilities
   * @preserve
   *)
*/
//# sourceMappingURL=bundle.js.map
