(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __decorateClass = (decorators, target, key, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
    for (var i8 = decorators.length - 1, decorator; i8 >= 0; i8--)
      if (decorator = decorators[i8])
        result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    if (kind && result) __defProp(target, key, result);
    return result;
  };

  // node_modules/.pnpm/reflect-metadata@0.2.2/node_modules/reflect-metadata/Reflect.js
  var require_Reflect = __commonJS({
    "node_modules/.pnpm/reflect-metadata@0.2.2/node_modules/reflect-metadata/Reflect.js"() {
      var Reflect2;
      (function(Reflect3) {
        (function(factory) {
          var root = typeof globalThis === "object" ? globalThis : typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : sloppyModeThis();
          var exporter = makeExporter(Reflect3);
          if (typeof root.Reflect !== "undefined") {
            exporter = makeExporter(root.Reflect, exporter);
          }
          factory(exporter, root);
          if (typeof root.Reflect === "undefined") {
            root.Reflect = Reflect3;
          }
          function makeExporter(target, previous) {
            return function(key, value) {
              Object.defineProperty(target, key, { configurable: true, writable: true, value });
              if (previous)
                previous(key, value);
            };
          }
          function functionThis() {
            try {
              return Function("return this;")();
            } catch (_4) {
            }
          }
          function indirectEvalThis() {
            try {
              return (void 0, eval)("(function() { return this; })()");
            } catch (_4) {
            }
          }
          function sloppyModeThis() {
            return functionThis() || indirectEvalThis();
          }
        })(function(exporter, root) {
          var hasOwn = Object.prototype.hasOwnProperty;
          var supportsSymbol = typeof Symbol === "function";
          var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
          var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
          var supportsCreate = typeof Object.create === "function";
          var supportsProto = { __proto__: [] } instanceof Array;
          var downLevel = !supportsCreate && !supportsProto;
          var HashMap = {
            // create an object in dictionary mode (a.k.a. "slow" mode in v8)
            create: supportsCreate ? function() {
              return MakeDictionary(/* @__PURE__ */ Object.create(null));
            } : supportsProto ? function() {
              return MakeDictionary({ __proto__: null });
            } : function() {
              return MakeDictionary({});
            },
            has: downLevel ? function(map, key) {
              return hasOwn.call(map, key);
            } : function(map, key) {
              return key in map;
            },
            get: downLevel ? function(map, key) {
              return hasOwn.call(map, key) ? map[key] : void 0;
            } : function(map, key) {
              return map[key];
            }
          };
          var functionPrototype = Object.getPrototypeOf(Function);
          var _Map = typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
          var _Set = typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
          var _WeakMap = typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
          var registrySymbol = supportsSymbol ? Symbol.for("@reflect-metadata:registry") : void 0;
          var metadataRegistry = GetOrCreateMetadataRegistry();
          var metadataProvider = CreateMetadataProvider(metadataRegistry);
          function decorate(decorators, target, propertyKey, attributes) {
            if (!IsUndefined(propertyKey)) {
              if (!IsArray(decorators))
                throw new TypeError();
              if (!IsObject3(target))
                throw new TypeError();
              if (!IsObject3(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
                throw new TypeError();
              if (IsNull(attributes))
                attributes = void 0;
              propertyKey = ToPropertyKey(propertyKey);
              return DecorateProperty(decorators, target, propertyKey, attributes);
            } else {
              if (!IsArray(decorators))
                throw new TypeError();
              if (!IsConstructor(target))
                throw new TypeError();
              return DecorateConstructor(decorators, target);
            }
          }
          exporter("decorate", decorate);
          function metadata(metadataKey, metadataValue) {
            function decorator(target, propertyKey) {
              if (!IsObject3(target))
                throw new TypeError();
              if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
                throw new TypeError();
              OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
            }
            return decorator;
          }
          exporter("metadata", metadata);
          function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
            if (!IsObject3(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
          }
          exporter("defineMetadata", defineMetadata);
          function hasMetadata(metadataKey, target, propertyKey) {
            if (!IsObject3(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasMetadata(metadataKey, target, propertyKey);
          }
          exporter("hasMetadata", hasMetadata);
          function hasOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject3(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
          }
          exporter("hasOwnMetadata", hasOwnMetadata);
          function getMetadata(metadataKey, target, propertyKey) {
            if (!IsObject3(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetMetadata(metadataKey, target, propertyKey);
          }
          exporter("getMetadata", getMetadata);
          function getOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject3(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
          }
          exporter("getOwnMetadata", getOwnMetadata);
          function getMetadataKeys(target, propertyKey) {
            if (!IsObject3(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryMetadataKeys(target, propertyKey);
          }
          exporter("getMetadataKeys", getMetadataKeys);
          function getOwnMetadataKeys(target, propertyKey) {
            if (!IsObject3(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryOwnMetadataKeys(target, propertyKey);
          }
          exporter("getOwnMetadataKeys", getOwnMetadataKeys);
          function deleteMetadata(metadataKey, target, propertyKey) {
            if (!IsObject3(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            if (!IsObject3(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            var provider = GetMetadataProvider(
              target,
              propertyKey,
              /*Create*/
              false
            );
            if (IsUndefined(provider))
              return false;
            return provider.OrdinaryDeleteMetadata(metadataKey, target, propertyKey);
          }
          exporter("deleteMetadata", deleteMetadata);
          function DecorateConstructor(decorators, target) {
            for (var i8 = decorators.length - 1; i8 >= 0; --i8) {
              var decorator = decorators[i8];
              var decorated = decorator(target);
              if (!IsUndefined(decorated) && !IsNull(decorated)) {
                if (!IsConstructor(decorated))
                  throw new TypeError();
                target = decorated;
              }
            }
            return target;
          }
          function DecorateProperty(decorators, target, propertyKey, descriptor) {
            for (var i8 = decorators.length - 1; i8 >= 0; --i8) {
              var decorator = decorators[i8];
              var decorated = decorator(target, propertyKey, descriptor);
              if (!IsUndefined(decorated) && !IsNull(decorated)) {
                if (!IsObject3(decorated))
                  throw new TypeError();
                descriptor = decorated;
              }
            }
            return descriptor;
          }
          function OrdinaryHasMetadata(MetadataKey, O5, P5) {
            var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O5, P5);
            if (hasOwn2)
              return true;
            var parent = OrdinaryGetPrototypeOf(O5);
            if (!IsNull(parent))
              return OrdinaryHasMetadata(MetadataKey, parent, P5);
            return false;
          }
          function OrdinaryHasOwnMetadata(MetadataKey, O5, P5) {
            var provider = GetMetadataProvider(
              O5,
              P5,
              /*Create*/
              false
            );
            if (IsUndefined(provider))
              return false;
            return ToBoolean(provider.OrdinaryHasOwnMetadata(MetadataKey, O5, P5));
          }
          function OrdinaryGetMetadata(MetadataKey, O5, P5) {
            var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O5, P5);
            if (hasOwn2)
              return OrdinaryGetOwnMetadata(MetadataKey, O5, P5);
            var parent = OrdinaryGetPrototypeOf(O5);
            if (!IsNull(parent))
              return OrdinaryGetMetadata(MetadataKey, parent, P5);
            return void 0;
          }
          function OrdinaryGetOwnMetadata(MetadataKey, O5, P5) {
            var provider = GetMetadataProvider(
              O5,
              P5,
              /*Create*/
              false
            );
            if (IsUndefined(provider))
              return;
            return provider.OrdinaryGetOwnMetadata(MetadataKey, O5, P5);
          }
          function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O5, P5) {
            var provider = GetMetadataProvider(
              O5,
              P5,
              /*Create*/
              true
            );
            provider.OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O5, P5);
          }
          function OrdinaryMetadataKeys(O5, P5) {
            var ownKeys = OrdinaryOwnMetadataKeys(O5, P5);
            var parent = OrdinaryGetPrototypeOf(O5);
            if (parent === null)
              return ownKeys;
            var parentKeys = OrdinaryMetadataKeys(parent, P5);
            if (parentKeys.length <= 0)
              return ownKeys;
            if (ownKeys.length <= 0)
              return parentKeys;
            var set = new _Set();
            var keys = [];
            for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
              var key = ownKeys_1[_i];
              var hasKey = set.has(key);
              if (!hasKey) {
                set.add(key);
                keys.push(key);
              }
            }
            for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
              var key = parentKeys_1[_a];
              var hasKey = set.has(key);
              if (!hasKey) {
                set.add(key);
                keys.push(key);
              }
            }
            return keys;
          }
          function OrdinaryOwnMetadataKeys(O5, P5) {
            var provider = GetMetadataProvider(
              O5,
              P5,
              /*create*/
              false
            );
            if (!provider) {
              return [];
            }
            return provider.OrdinaryOwnMetadataKeys(O5, P5);
          }
          function Type2(x6) {
            if (x6 === null)
              return 1;
            switch (typeof x6) {
              case "undefined":
                return 0;
              case "boolean":
                return 2;
              case "string":
                return 3;
              case "symbol":
                return 4;
              case "number":
                return 5;
              case "object":
                return x6 === null ? 1 : 6;
              default:
                return 6;
            }
          }
          function IsUndefined(x6) {
            return x6 === void 0;
          }
          function IsNull(x6) {
            return x6 === null;
          }
          function IsSymbol(x6) {
            return typeof x6 === "symbol";
          }
          function IsObject3(x6) {
            return typeof x6 === "object" ? x6 !== null : typeof x6 === "function";
          }
          function ToPrimitive(input, PreferredType) {
            switch (Type2(input)) {
              case 0:
                return input;
              case 1:
                return input;
              case 2:
                return input;
              case 3:
                return input;
              case 4:
                return input;
              case 5:
                return input;
            }
            var hint = PreferredType === 3 ? "string" : PreferredType === 5 ? "number" : "default";
            var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
            if (exoticToPrim !== void 0) {
              var result = exoticToPrim.call(input, hint);
              if (IsObject3(result))
                throw new TypeError();
              return result;
            }
            return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
          }
          function OrdinaryToPrimitive(O5, hint) {
            if (hint === "string") {
              var toString_1 = O5.toString;
              if (IsCallable(toString_1)) {
                var result = toString_1.call(O5);
                if (!IsObject3(result))
                  return result;
              }
              var valueOf = O5.valueOf;
              if (IsCallable(valueOf)) {
                var result = valueOf.call(O5);
                if (!IsObject3(result))
                  return result;
              }
            } else {
              var valueOf = O5.valueOf;
              if (IsCallable(valueOf)) {
                var result = valueOf.call(O5);
                if (!IsObject3(result))
                  return result;
              }
              var toString_2 = O5.toString;
              if (IsCallable(toString_2)) {
                var result = toString_2.call(O5);
                if (!IsObject3(result))
                  return result;
              }
            }
            throw new TypeError();
          }
          function ToBoolean(argument) {
            return !!argument;
          }
          function ToString(argument) {
            return "" + argument;
          }
          function ToPropertyKey(argument) {
            var key = ToPrimitive(
              argument,
              3
              /* String */
            );
            if (IsSymbol(key))
              return key;
            return ToString(key);
          }
          function IsArray(argument) {
            return Array.isArray ? Array.isArray(argument) : argument instanceof Object ? argument instanceof Array : Object.prototype.toString.call(argument) === "[object Array]";
          }
          function IsCallable(argument) {
            return typeof argument === "function";
          }
          function IsConstructor(argument) {
            return typeof argument === "function";
          }
          function IsPropertyKey(argument) {
            switch (Type2(argument)) {
              case 3:
                return true;
              case 4:
                return true;
              default:
                return false;
            }
          }
          function SameValueZero(x6, y5) {
            return x6 === y5 || x6 !== x6 && y5 !== y5;
          }
          function GetMethod(V4, P5) {
            var func = V4[P5];
            if (func === void 0 || func === null)
              return void 0;
            if (!IsCallable(func))
              throw new TypeError();
            return func;
          }
          function GetIterator(obj) {
            var method = GetMethod(obj, iteratorSymbol);
            if (!IsCallable(method))
              throw new TypeError();
            var iterator = method.call(obj);
            if (!IsObject3(iterator))
              throw new TypeError();
            return iterator;
          }
          function IteratorValue(iterResult) {
            return iterResult.value;
          }
          function IteratorStep(iterator) {
            var result = iterator.next();
            return result.done ? false : result;
          }
          function IteratorClose(iterator) {
            var f6 = iterator["return"];
            if (f6)
              f6.call(iterator);
          }
          function OrdinaryGetPrototypeOf(O5) {
            var proto = Object.getPrototypeOf(O5);
            if (typeof O5 !== "function" || O5 === functionPrototype)
              return proto;
            if (proto !== functionPrototype)
              return proto;
            var prototype = O5.prototype;
            var prototypeProto = prototype && Object.getPrototypeOf(prototype);
            if (prototypeProto == null || prototypeProto === Object.prototype)
              return proto;
            var constructor = prototypeProto.constructor;
            if (typeof constructor !== "function")
              return proto;
            if (constructor === O5)
              return proto;
            return constructor;
          }
          function CreateMetadataRegistry() {
            var fallback;
            if (!IsUndefined(registrySymbol) && typeof root.Reflect !== "undefined" && !(registrySymbol in root.Reflect) && typeof root.Reflect.defineMetadata === "function") {
              fallback = CreateFallbackProvider(root.Reflect);
            }
            var first;
            var second;
            var rest;
            var targetProviderMap = new _WeakMap();
            var registry = {
              registerProvider,
              getProvider,
              setProvider
            };
            return registry;
            function registerProvider(provider) {
              if (!Object.isExtensible(registry)) {
                throw new Error("Cannot add provider to a frozen registry.");
              }
              switch (true) {
                case fallback === provider:
                  break;
                case IsUndefined(first):
                  first = provider;
                  break;
                case first === provider:
                  break;
                case IsUndefined(second):
                  second = provider;
                  break;
                case second === provider:
                  break;
                default:
                  if (rest === void 0)
                    rest = new _Set();
                  rest.add(provider);
                  break;
              }
            }
            function getProviderNoCache(O5, P5) {
              if (!IsUndefined(first)) {
                if (first.isProviderFor(O5, P5))
                  return first;
                if (!IsUndefined(second)) {
                  if (second.isProviderFor(O5, P5))
                    return first;
                  if (!IsUndefined(rest)) {
                    var iterator = GetIterator(rest);
                    while (true) {
                      var next = IteratorStep(iterator);
                      if (!next) {
                        return void 0;
                      }
                      var provider = IteratorValue(next);
                      if (provider.isProviderFor(O5, P5)) {
                        IteratorClose(iterator);
                        return provider;
                      }
                    }
                  }
                }
              }
              if (!IsUndefined(fallback) && fallback.isProviderFor(O5, P5)) {
                return fallback;
              }
              return void 0;
            }
            function getProvider(O5, P5) {
              var providerMap = targetProviderMap.get(O5);
              var provider;
              if (!IsUndefined(providerMap)) {
                provider = providerMap.get(P5);
              }
              if (!IsUndefined(provider)) {
                return provider;
              }
              provider = getProviderNoCache(O5, P5);
              if (!IsUndefined(provider)) {
                if (IsUndefined(providerMap)) {
                  providerMap = new _Map();
                  targetProviderMap.set(O5, providerMap);
                }
                providerMap.set(P5, provider);
              }
              return provider;
            }
            function hasProvider(provider) {
              if (IsUndefined(provider))
                throw new TypeError();
              return first === provider || second === provider || !IsUndefined(rest) && rest.has(provider);
            }
            function setProvider(O5, P5, provider) {
              if (!hasProvider(provider)) {
                throw new Error("Metadata provider not registered.");
              }
              var existingProvider = getProvider(O5, P5);
              if (existingProvider !== provider) {
                if (!IsUndefined(existingProvider)) {
                  return false;
                }
                var providerMap = targetProviderMap.get(O5);
                if (IsUndefined(providerMap)) {
                  providerMap = new _Map();
                  targetProviderMap.set(O5, providerMap);
                }
                providerMap.set(P5, provider);
              }
              return true;
            }
          }
          function GetOrCreateMetadataRegistry() {
            var metadataRegistry2;
            if (!IsUndefined(registrySymbol) && IsObject3(root.Reflect) && Object.isExtensible(root.Reflect)) {
              metadataRegistry2 = root.Reflect[registrySymbol];
            }
            if (IsUndefined(metadataRegistry2)) {
              metadataRegistry2 = CreateMetadataRegistry();
            }
            if (!IsUndefined(registrySymbol) && IsObject3(root.Reflect) && Object.isExtensible(root.Reflect)) {
              Object.defineProperty(root.Reflect, registrySymbol, {
                enumerable: false,
                configurable: false,
                writable: false,
                value: metadataRegistry2
              });
            }
            return metadataRegistry2;
          }
          function CreateMetadataProvider(registry) {
            var metadata2 = new _WeakMap();
            var provider = {
              isProviderFor: function(O5, P5) {
                var targetMetadata = metadata2.get(O5);
                if (IsUndefined(targetMetadata))
                  return false;
                return targetMetadata.has(P5);
              },
              OrdinaryDefineOwnMetadata: OrdinaryDefineOwnMetadata2,
              OrdinaryHasOwnMetadata: OrdinaryHasOwnMetadata2,
              OrdinaryGetOwnMetadata: OrdinaryGetOwnMetadata2,
              OrdinaryOwnMetadataKeys: OrdinaryOwnMetadataKeys2,
              OrdinaryDeleteMetadata
            };
            metadataRegistry.registerProvider(provider);
            return provider;
            function GetOrCreateMetadataMap(O5, P5, Create) {
              var targetMetadata = metadata2.get(O5);
              var createdTargetMetadata = false;
              if (IsUndefined(targetMetadata)) {
                if (!Create)
                  return void 0;
                targetMetadata = new _Map();
                metadata2.set(O5, targetMetadata);
                createdTargetMetadata = true;
              }
              var metadataMap = targetMetadata.get(P5);
              if (IsUndefined(metadataMap)) {
                if (!Create)
                  return void 0;
                metadataMap = new _Map();
                targetMetadata.set(P5, metadataMap);
                if (!registry.setProvider(O5, P5, provider)) {
                  targetMetadata.delete(P5);
                  if (createdTargetMetadata) {
                    metadata2.delete(O5);
                  }
                  throw new Error("Wrong provider for target.");
                }
              }
              return metadataMap;
            }
            function OrdinaryHasOwnMetadata2(MetadataKey, O5, P5) {
              var metadataMap = GetOrCreateMetadataMap(
                O5,
                P5,
                /*Create*/
                false
              );
              if (IsUndefined(metadataMap))
                return false;
              return ToBoolean(metadataMap.has(MetadataKey));
            }
            function OrdinaryGetOwnMetadata2(MetadataKey, O5, P5) {
              var metadataMap = GetOrCreateMetadataMap(
                O5,
                P5,
                /*Create*/
                false
              );
              if (IsUndefined(metadataMap))
                return void 0;
              return metadataMap.get(MetadataKey);
            }
            function OrdinaryDefineOwnMetadata2(MetadataKey, MetadataValue, O5, P5) {
              var metadataMap = GetOrCreateMetadataMap(
                O5,
                P5,
                /*Create*/
                true
              );
              metadataMap.set(MetadataKey, MetadataValue);
            }
            function OrdinaryOwnMetadataKeys2(O5, P5) {
              var keys = [];
              var metadataMap = GetOrCreateMetadataMap(
                O5,
                P5,
                /*Create*/
                false
              );
              if (IsUndefined(metadataMap))
                return keys;
              var keysObj = metadataMap.keys();
              var iterator = GetIterator(keysObj);
              var k4 = 0;
              while (true) {
                var next = IteratorStep(iterator);
                if (!next) {
                  keys.length = k4;
                  return keys;
                }
                var nextValue = IteratorValue(next);
                try {
                  keys[k4] = nextValue;
                } catch (e2) {
                  try {
                    IteratorClose(iterator);
                  } finally {
                    throw e2;
                  }
                }
                k4++;
              }
            }
            function OrdinaryDeleteMetadata(MetadataKey, O5, P5) {
              var metadataMap = GetOrCreateMetadataMap(
                O5,
                P5,
                /*Create*/
                false
              );
              if (IsUndefined(metadataMap))
                return false;
              if (!metadataMap.delete(MetadataKey))
                return false;
              if (metadataMap.size === 0) {
                var targetMetadata = metadata2.get(O5);
                if (!IsUndefined(targetMetadata)) {
                  targetMetadata.delete(P5);
                  if (targetMetadata.size === 0) {
                    metadata2.delete(targetMetadata);
                  }
                }
              }
              return true;
            }
          }
          function CreateFallbackProvider(reflect) {
            var defineMetadata2 = reflect.defineMetadata, hasOwnMetadata2 = reflect.hasOwnMetadata, getOwnMetadata2 = reflect.getOwnMetadata, getOwnMetadataKeys2 = reflect.getOwnMetadataKeys, deleteMetadata2 = reflect.deleteMetadata;
            var metadataOwner = new _WeakMap();
            var provider = {
              isProviderFor: function(O5, P5) {
                var metadataPropertySet = metadataOwner.get(O5);
                if (!IsUndefined(metadataPropertySet) && metadataPropertySet.has(P5)) {
                  return true;
                }
                if (getOwnMetadataKeys2(O5, P5).length) {
                  if (IsUndefined(metadataPropertySet)) {
                    metadataPropertySet = new _Set();
                    metadataOwner.set(O5, metadataPropertySet);
                  }
                  metadataPropertySet.add(P5);
                  return true;
                }
                return false;
              },
              OrdinaryDefineOwnMetadata: defineMetadata2,
              OrdinaryHasOwnMetadata: hasOwnMetadata2,
              OrdinaryGetOwnMetadata: getOwnMetadata2,
              OrdinaryOwnMetadataKeys: getOwnMetadataKeys2,
              OrdinaryDeleteMetadata: deleteMetadata2
            };
            return provider;
          }
          function GetMetadataProvider(O5, P5, Create) {
            var registeredProvider = metadataRegistry.getProvider(O5, P5);
            if (!IsUndefined(registeredProvider)) {
              return registeredProvider;
            }
            if (Create) {
              if (metadataRegistry.setProvider(O5, P5, metadataProvider)) {
                return metadataProvider;
              }
              throw new Error("Illegal state.");
            }
            return void 0;
          }
          function CreateMapPolyfill() {
            var cacheSentinel = {};
            var arraySentinel = [];
            var MapIterator = (
              /** @class */
              (function() {
                function MapIterator2(keys, values, selector) {
                  this._index = 0;
                  this._keys = keys;
                  this._values = values;
                  this._selector = selector;
                }
                MapIterator2.prototype["@@iterator"] = function() {
                  return this;
                };
                MapIterator2.prototype[iteratorSymbol] = function() {
                  return this;
                };
                MapIterator2.prototype.next = function() {
                  var index = this._index;
                  if (index >= 0 && index < this._keys.length) {
                    var result = this._selector(this._keys[index], this._values[index]);
                    if (index + 1 >= this._keys.length) {
                      this._index = -1;
                      this._keys = arraySentinel;
                      this._values = arraySentinel;
                    } else {
                      this._index++;
                    }
                    return { value: result, done: false };
                  }
                  return { value: void 0, done: true };
                };
                MapIterator2.prototype.throw = function(error) {
                  if (this._index >= 0) {
                    this._index = -1;
                    this._keys = arraySentinel;
                    this._values = arraySentinel;
                  }
                  throw error;
                };
                MapIterator2.prototype.return = function(value) {
                  if (this._index >= 0) {
                    this._index = -1;
                    this._keys = arraySentinel;
                    this._values = arraySentinel;
                  }
                  return { value, done: true };
                };
                return MapIterator2;
              })()
            );
            var Map2 = (
              /** @class */
              (function() {
                function Map3() {
                  this._keys = [];
                  this._values = [];
                  this._cacheKey = cacheSentinel;
                  this._cacheIndex = -2;
                }
                Object.defineProperty(Map3.prototype, "size", {
                  get: function() {
                    return this._keys.length;
                  },
                  enumerable: true,
                  configurable: true
                });
                Map3.prototype.has = function(key) {
                  return this._find(
                    key,
                    /*insert*/
                    false
                  ) >= 0;
                };
                Map3.prototype.get = function(key) {
                  var index = this._find(
                    key,
                    /*insert*/
                    false
                  );
                  return index >= 0 ? this._values[index] : void 0;
                };
                Map3.prototype.set = function(key, value) {
                  var index = this._find(
                    key,
                    /*insert*/
                    true
                  );
                  this._values[index] = value;
                  return this;
                };
                Map3.prototype.delete = function(key) {
                  var index = this._find(
                    key,
                    /*insert*/
                    false
                  );
                  if (index >= 0) {
                    var size = this._keys.length;
                    for (var i8 = index + 1; i8 < size; i8++) {
                      this._keys[i8 - 1] = this._keys[i8];
                      this._values[i8 - 1] = this._values[i8];
                    }
                    this._keys.length--;
                    this._values.length--;
                    if (SameValueZero(key, this._cacheKey)) {
                      this._cacheKey = cacheSentinel;
                      this._cacheIndex = -2;
                    }
                    return true;
                  }
                  return false;
                };
                Map3.prototype.clear = function() {
                  this._keys.length = 0;
                  this._values.length = 0;
                  this._cacheKey = cacheSentinel;
                  this._cacheIndex = -2;
                };
                Map3.prototype.keys = function() {
                  return new MapIterator(this._keys, this._values, getKey);
                };
                Map3.prototype.values = function() {
                  return new MapIterator(this._keys, this._values, getValue);
                };
                Map3.prototype.entries = function() {
                  return new MapIterator(this._keys, this._values, getEntry);
                };
                Map3.prototype["@@iterator"] = function() {
                  return this.entries();
                };
                Map3.prototype[iteratorSymbol] = function() {
                  return this.entries();
                };
                Map3.prototype._find = function(key, insert) {
                  if (!SameValueZero(this._cacheKey, key)) {
                    this._cacheIndex = -1;
                    for (var i8 = 0; i8 < this._keys.length; i8++) {
                      if (SameValueZero(this._keys[i8], key)) {
                        this._cacheIndex = i8;
                        break;
                      }
                    }
                  }
                  if (this._cacheIndex < 0 && insert) {
                    this._cacheIndex = this._keys.length;
                    this._keys.push(key);
                    this._values.push(void 0);
                  }
                  return this._cacheIndex;
                };
                return Map3;
              })()
            );
            return Map2;
            function getKey(key, _4) {
              return key;
            }
            function getValue(_4, value) {
              return value;
            }
            function getEntry(key, value) {
              return [key, value];
            }
          }
          function CreateSetPolyfill() {
            var Set2 = (
              /** @class */
              (function() {
                function Set3() {
                  this._map = new _Map();
                }
                Object.defineProperty(Set3.prototype, "size", {
                  get: function() {
                    return this._map.size;
                  },
                  enumerable: true,
                  configurable: true
                });
                Set3.prototype.has = function(value) {
                  return this._map.has(value);
                };
                Set3.prototype.add = function(value) {
                  return this._map.set(value, value), this;
                };
                Set3.prototype.delete = function(value) {
                  return this._map.delete(value);
                };
                Set3.prototype.clear = function() {
                  this._map.clear();
                };
                Set3.prototype.keys = function() {
                  return this._map.keys();
                };
                Set3.prototype.values = function() {
                  return this._map.keys();
                };
                Set3.prototype.entries = function() {
                  return this._map.entries();
                };
                Set3.prototype["@@iterator"] = function() {
                  return this.keys();
                };
                Set3.prototype[iteratorSymbol] = function() {
                  return this.keys();
                };
                return Set3;
              })()
            );
            return Set2;
          }
          function CreateWeakMapPolyfill() {
            var UUID_SIZE = 16;
            var keys = HashMap.create();
            var rootKey = CreateUniqueKey();
            return (
              /** @class */
              (function() {
                function WeakMap2() {
                  this._key = CreateUniqueKey();
                }
                WeakMap2.prototype.has = function(target) {
                  var table = GetOrCreateWeakMapTable(
                    target,
                    /*create*/
                    false
                  );
                  return table !== void 0 ? HashMap.has(table, this._key) : false;
                };
                WeakMap2.prototype.get = function(target) {
                  var table = GetOrCreateWeakMapTable(
                    target,
                    /*create*/
                    false
                  );
                  return table !== void 0 ? HashMap.get(table, this._key) : void 0;
                };
                WeakMap2.prototype.set = function(target, value) {
                  var table = GetOrCreateWeakMapTable(
                    target,
                    /*create*/
                    true
                  );
                  table[this._key] = value;
                  return this;
                };
                WeakMap2.prototype.delete = function(target) {
                  var table = GetOrCreateWeakMapTable(
                    target,
                    /*create*/
                    false
                  );
                  return table !== void 0 ? delete table[this._key] : false;
                };
                WeakMap2.prototype.clear = function() {
                  this._key = CreateUniqueKey();
                };
                return WeakMap2;
              })()
            );
            function CreateUniqueKey() {
              var key;
              do
                key = "@@WeakMap@@" + CreateUUID();
              while (HashMap.has(keys, key));
              keys[key] = true;
              return key;
            }
            function GetOrCreateWeakMapTable(target, create2) {
              if (!hasOwn.call(target, rootKey)) {
                if (!create2)
                  return void 0;
                Object.defineProperty(target, rootKey, { value: HashMap.create() });
              }
              return target[rootKey];
            }
            function FillRandomBytes(buffer, size) {
              for (var i8 = 0; i8 < size; ++i8)
                buffer[i8] = Math.random() * 255 | 0;
              return buffer;
            }
            function GenRandomBytes(size) {
              if (typeof Uint8Array === "function") {
                var array = new Uint8Array(size);
                if (typeof crypto !== "undefined") {
                  crypto.getRandomValues(array);
                } else if (typeof msCrypto !== "undefined") {
                  msCrypto.getRandomValues(array);
                } else {
                  FillRandomBytes(array, size);
                }
                return array;
              }
              return FillRandomBytes(new Array(size), size);
            }
            function CreateUUID() {
              var data = GenRandomBytes(UUID_SIZE);
              data[6] = data[6] & 79 | 64;
              data[8] = data[8] & 191 | 128;
              var result = "";
              for (var offset = 0; offset < UUID_SIZE; ++offset) {
                var byte = data[offset];
                if (offset === 4 || offset === 6 || offset === 8)
                  result += "-";
                if (byte < 16)
                  result += "0";
                result += byte.toString(16).toLowerCase();
              }
              return result;
            }
          }
          function MakeDictionary(obj) {
            obj.__ = void 0;
            delete obj.__;
            return obj;
          }
        });
      })(Reflect2 || (Reflect2 = {}));
    }
  });

  // node_modules/.pnpm/bondage-club-mod-sdk@1.2.0/node_modules/bondage-club-mod-sdk/dist/bcmodsdk.js
  var require_bcmodsdk = __commonJS({
    "node_modules/.pnpm/bondage-club-mod-sdk@1.2.0/node_modules/bondage-club-mod-sdk/dist/bcmodsdk.js"(exports) {
      var bcModSdk = (function() {
        "use strict";
        const o4 = "1.2.0";
        function e2(o5) {
          alert("Mod ERROR:\n" + o5);
          const e3 = new Error(o5);
          throw console.error(e3), e3;
        }
        const t4 = new TextEncoder();
        function n5(o5) {
          return !!o5 && "object" == typeof o5 && !Array.isArray(o5);
        }
        function r5(o5) {
          const e3 = /* @__PURE__ */ new Set();
          return o5.filter(((o6) => !e3.has(o6) && e3.add(o6)));
        }
        const i8 = /* @__PURE__ */ new Map(), a5 = /* @__PURE__ */ new Set();
        function c7(o5) {
          a5.has(o5) || (a5.add(o5), console.warn(o5));
        }
        function s4(o5) {
          const e3 = [], t5 = /* @__PURE__ */ new Map(), n6 = /* @__PURE__ */ new Set();
          for (const r7 of f6.values()) {
            const i10 = r7.patching.get(o5.name);
            if (i10) {
              e3.push(...i10.hooks);
              for (const [e4, a6] of i10.patches.entries()) t5.has(e4) && t5.get(e4) !== a6 && c7(`ModSDK: Mod '${r7.name}' is patching function ${o5.name} with same pattern that is already applied by different mod, but with different pattern:
Pattern:
${e4}
Patch1:
${t5.get(e4) || ""}
Patch2:
${a6}`), t5.set(e4, a6), n6.add(r7.name);
            }
          }
          e3.sort(((o6, e4) => e4.priority - o6.priority));
          const r6 = (function(o6, e4) {
            if (0 === e4.size) return o6;
            let t6 = o6.toString().replaceAll("\r\n", "\n");
            for (const [n7, r7] of e4.entries()) t6.includes(n7) || c7(`ModSDK: Patching ${o6.name}: Patch ${n7} not applied`), t6 = t6.replaceAll(n7, r7);
            return (0, eval)(`(${t6})`);
          })(o5.original, t5);
          let i9 = function(e4) {
            var t6, i10;
            const a6 = null === (i10 = (t6 = m5.errorReporterHooks).hookChainExit) || void 0 === i10 ? void 0 : i10.call(t6, o5.name, n6), c8 = r6.apply(this, e4);
            return null == a6 || a6(), c8;
          };
          for (let t6 = e3.length - 1; t6 >= 0; t6--) {
            const n7 = e3[t6], r7 = i9;
            i9 = function(e4) {
              var t7, i10;
              const a6 = null === (i10 = (t7 = m5.errorReporterHooks).hookEnter) || void 0 === i10 ? void 0 : i10.call(t7, o5.name, n7.mod), c8 = n7.hook.apply(this, [e4, (o6) => {
                if (1 !== arguments.length || !Array.isArray(e4)) throw new Error(`Mod ${n7.mod} failed to call next hook: Expected args to be array, got ${typeof o6}`);
                return r7.call(this, o6);
              }]);
              return null == a6 || a6(), c8;
            };
          }
          return { hooks: e3, patches: t5, patchesSources: n6, enter: i9, final: r6 };
        }
        function l5(o5, e3 = false) {
          let r6 = i8.get(o5);
          if (r6) e3 && (r6.precomputed = s4(r6));
          else {
            let e4 = window;
            const a6 = o5.split(".");
            for (let t5 = 0; t5 < a6.length - 1; t5++) if (e4 = e4[a6[t5]], !n5(e4)) throw new Error(`ModSDK: Function ${o5} to be patched not found; ${a6.slice(0, t5 + 1).join(".")} is not object`);
            const c8 = e4[a6[a6.length - 1]];
            if ("function" != typeof c8) throw new Error(`ModSDK: Function ${o5} to be patched not found`);
            const l6 = (function(o6) {
              let e5 = -1;
              for (const n6 of t4.encode(o6)) {
                let o7 = 255 & (e5 ^ n6);
                for (let e6 = 0; e6 < 8; e6++) o7 = 1 & o7 ? -306674912 ^ o7 >>> 1 : o7 >>> 1;
                e5 = e5 >>> 8 ^ o7;
              }
              return ((-1 ^ e5) >>> 0).toString(16).padStart(8, "0").toUpperCase();
            })(c8.toString().replaceAll("\r\n", "\n")), d5 = { name: o5, original: c8, originalHash: l6 };
            r6 = Object.assign(Object.assign({}, d5), { precomputed: s4(d5), router: () => {
            }, context: e4, contextProperty: a6[a6.length - 1] }), r6.router = /* @__PURE__ */ (function(o6) {
              return function(...e5) {
                return o6.precomputed.enter.apply(this, [e5]);
              };
            })(r6), i8.set(o5, r6), e4[r6.contextProperty] = r6.router;
          }
          return r6;
        }
        function d4() {
          for (const o5 of i8.values()) o5.precomputed = s4(o5);
        }
        function p4() {
          const o5 = /* @__PURE__ */ new Map();
          for (const [e3, t5] of i8) o5.set(e3, { name: e3, original: t5.original, originalHash: t5.originalHash, sdkEntrypoint: t5.router, currentEntrypoint: t5.context[t5.contextProperty], hookedByMods: r5(t5.precomputed.hooks.map(((o6) => o6.mod))), patchedByMods: Array.from(t5.precomputed.patchesSources) });
          return o5;
        }
        const f6 = /* @__PURE__ */ new Map();
        function u4(o5) {
          f6.get(o5.name) !== o5 && e2(`Failed to unload mod '${o5.name}': Not registered`), f6.delete(o5.name), o5.loaded = false, d4();
        }
        function g5(o5, t5) {
          o5 && "object" == typeof o5 || e2("Failed to register mod: Expected info object, got " + typeof o5), "string" == typeof o5.name && o5.name || e2("Failed to register mod: Expected name to be non-empty string, got " + typeof o5.name);
          let r6 = `'${o5.name}'`;
          "string" == typeof o5.fullName && o5.fullName || e2(`Failed to register mod ${r6}: Expected fullName to be non-empty string, got ${typeof o5.fullName}`), r6 = `'${o5.fullName} (${o5.name})'`, "string" != typeof o5.version && e2(`Failed to register mod ${r6}: Expected version to be string, got ${typeof o5.version}`), o5.repository || (o5.repository = void 0), void 0 !== o5.repository && "string" != typeof o5.repository && e2(`Failed to register mod ${r6}: Expected repository to be undefined or string, got ${typeof o5.version}`), null == t5 && (t5 = {}), t5 && "object" == typeof t5 || e2(`Failed to register mod ${r6}: Expected options to be undefined or object, got ${typeof t5}`);
          const i9 = true === t5.allowReplace, a6 = f6.get(o5.name);
          a6 && (a6.allowReplace && i9 || e2(`Refusing to load mod ${r6}: it is already loaded and doesn't allow being replaced.
Was the mod loaded multiple times?`), u4(a6));
          const c8 = (o6) => {
            let e3 = g6.patching.get(o6.name);
            return e3 || (e3 = { hooks: [], patches: /* @__PURE__ */ new Map() }, g6.patching.set(o6.name, e3)), e3;
          }, s5 = (o6, t6) => (...n6) => {
            var i10, a7;
            const c9 = null === (a7 = (i10 = m5.errorReporterHooks).apiEndpointEnter) || void 0 === a7 ? void 0 : a7.call(i10, o6, g6.name);
            g6.loaded || e2(`Mod ${r6} attempted to call SDK function after being unloaded`);
            const s6 = t6(...n6);
            return null == c9 || c9(), s6;
          }, p5 = { unload: s5("unload", (() => u4(g6))), hookFunction: s5("hookFunction", ((o6, t6, n6) => {
            "string" == typeof o6 && o6 || e2(`Mod ${r6} failed to patch a function: Expected function name string, got ${typeof o6}`);
            const i10 = l5(o6), a7 = c8(i10);
            "number" != typeof t6 && e2(`Mod ${r6} failed to hook function '${o6}': Expected priority number, got ${typeof t6}`), "function" != typeof n6 && e2(`Mod ${r6} failed to hook function '${o6}': Expected hook function, got ${typeof n6}`);
            const s6 = { mod: g6.name, priority: t6, hook: n6 };
            return a7.hooks.push(s6), d4(), () => {
              const o7 = a7.hooks.indexOf(s6);
              o7 >= 0 && (a7.hooks.splice(o7, 1), d4());
            };
          })), patchFunction: s5("patchFunction", ((o6, t6) => {
            "string" == typeof o6 && o6 || e2(`Mod ${r6} failed to patch a function: Expected function name string, got ${typeof o6}`);
            const i10 = l5(o6), a7 = c8(i10);
            n5(t6) || e2(`Mod ${r6} failed to patch function '${o6}': Expected patches object, got ${typeof t6}`);
            for (const [n6, i11] of Object.entries(t6)) "string" == typeof i11 ? a7.patches.set(n6, i11) : null === i11 ? a7.patches.delete(n6) : e2(`Mod ${r6} failed to patch function '${o6}': Invalid format of patch '${n6}'`);
            d4();
          })), removePatches: s5("removePatches", ((o6) => {
            "string" == typeof o6 && o6 || e2(`Mod ${r6} failed to patch a function: Expected function name string, got ${typeof o6}`);
            const t6 = l5(o6);
            c8(t6).patches.clear(), d4();
          })), callOriginal: s5("callOriginal", ((o6, t6, n6) => {
            "string" == typeof o6 && o6 || e2(`Mod ${r6} failed to call a function: Expected function name string, got ${typeof o6}`);
            const i10 = l5(o6);
            return Array.isArray(t6) || e2(`Mod ${r6} failed to call a function: Expected args array, got ${typeof t6}`), i10.original.apply(null != n6 ? n6 : globalThis, t6);
          })), getOriginalHash: s5("getOriginalHash", ((o6) => {
            "string" == typeof o6 && o6 || e2(`Mod ${r6} failed to get hash: Expected function name string, got ${typeof o6}`);
            return l5(o6).originalHash;
          })) }, g6 = { name: o5.name, fullName: o5.fullName, version: o5.version, repository: o5.repository, allowReplace: i9, api: p5, loaded: true, patching: /* @__PURE__ */ new Map() };
          return f6.set(o5.name, g6), Object.freeze(p5);
        }
        function h6() {
          const o5 = [];
          for (const e3 of f6.values()) o5.push({ name: e3.name, fullName: e3.fullName, version: e3.version, repository: e3.repository });
          return o5;
        }
        let m5;
        const y5 = void 0 === window.bcModSdk ? window.bcModSdk = (function() {
          const e3 = { version: o4, apiVersion: 1, registerMod: g5, getModsInfo: h6, getPatchingInfo: p4, errorReporterHooks: Object.seal({ apiEndpointEnter: null, hookEnter: null, hookChainExit: null }) };
          return m5 = e3, Object.freeze(e3);
        })() : (n5(window.bcModSdk) || e2("Failed to init Mod SDK: Name already in use"), 1 !== window.bcModSdk.apiVersion && e2(`Failed to init Mod SDK: Different version already loaded ('1.2.0' vs '${window.bcModSdk.version}')`), window.bcModSdk.version !== o4 && alert(`Mod SDK warning: Loading different but compatible versions ('1.2.0' vs '${window.bcModSdk.version}')
One of mods you are using is using an old version of SDK. It will work for now but please inform author to update`), window.bcModSdk);
        return "undefined" != typeof exports && (Object.defineProperty(exports, "__esModule", { value: true }), exports.default = y5), y5;
      })();
    }
  });

  // node_modules/.pnpm/react@19.2.0/node_modules/react/cjs/react.development.js
  var require_react_development = __commonJS({
    "node_modules/.pnpm/react@19.2.0/node_modules/react/cjs/react.development.js"(exports, module) {
      "use strict";
      (function() {
        function defineDeprecationWarning(methodName, info) {
          Object.defineProperty(Component.prototype, methodName, {
            get: function() {
              console.warn(
                "%s(...) is deprecated in plain JavaScript React classes. %s",
                info[0],
                info[1]
              );
            }
          });
        }
        function getIteratorFn(maybeIterable) {
          if (null === maybeIterable || "object" !== typeof maybeIterable)
            return null;
          maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
          return "function" === typeof maybeIterable ? maybeIterable : null;
        }
        function warnNoop(publicInstance, callerName) {
          publicInstance = (publicInstance = publicInstance.constructor) && (publicInstance.displayName || publicInstance.name) || "ReactClass";
          var warningKey = publicInstance + "." + callerName;
          didWarnStateUpdateForUnmountedComponent[warningKey] || (console.error(
            "Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.",
            callerName,
            publicInstance
          ), didWarnStateUpdateForUnmountedComponent[warningKey] = true);
        }
        function Component(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        function ComponentDummy() {
        }
        function PureComponent(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        function noop() {
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkKeyStringCoercion(value) {
          try {
            testStringCoercion(value);
            var JSCompiler_inline_result = false;
          } catch (e2) {
            JSCompiler_inline_result = true;
          }
          if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(
              JSCompiler_inline_result,
              "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
              JSCompiler_inline_result$jscomp$0
            );
            return testStringCoercion(value);
          }
        }
        function getComponentNameFromType(type) {
          if (null == type) return null;
          if ("function" === typeof type)
            return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
          if ("string" === typeof type) return type;
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
              return "Activity";
          }
          if ("object" === typeof type)
            switch ("number" === typeof type.tag && console.error(
              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
            ), type.$$typeof) {
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_CONTEXT_TYPE:
                return type.displayName || "Context";
              case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
              case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
              case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                  return getComponentNameFromType(type(innerType));
                } catch (x6) {
                }
            }
          return null;
        }
        function getTaskName(type) {
          if (type === REACT_FRAGMENT_TYPE) return "<>";
          if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE)
            return "<...>";
          try {
            var name = getComponentNameFromType(type);
            return name ? "<" + name + ">" : "<...>";
          } catch (x6) {
            return "<...>";
          }
        }
        function getOwner() {
          var dispatcher = ReactSharedInternals.A;
          return null === dispatcher ? null : dispatcher.getOwner();
        }
        function UnknownOwner() {
          return Error("react-stack-top-frame");
        }
        function hasValidKey(config) {
          if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) return false;
          }
          return void 0 !== config.key;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error(
              "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
              displayName
            ));
          }
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function elementRefGetterWithDeprecationWarning() {
          var componentName = getComponentNameFromType(this.type);
          didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error(
            "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
          ));
          componentName = this.props.ref;
          return void 0 !== componentName ? componentName : null;
        }
        function ReactElement(type, key, props, owner, debugStack, debugTask) {
          var refProp = props.ref;
          type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type,
            key,
            props,
            _owner: owner
          };
          null !== (void 0 !== refProp ? refProp : null) ? Object.defineProperty(type, "ref", {
            enumerable: false,
            get: elementRefGetterWithDeprecationWarning
          }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
          type._store = {};
          Object.defineProperty(type._store, "validated", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: 0
          });
          Object.defineProperty(type, "_debugInfo", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: null
          });
          Object.defineProperty(type, "_debugStack", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: debugStack
          });
          Object.defineProperty(type, "_debugTask", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: debugTask
          });
          Object.freeze && (Object.freeze(type.props), Object.freeze(type));
          return type;
        }
        function cloneAndReplaceKey(oldElement, newKey) {
          newKey = ReactElement(
            oldElement.type,
            newKey,
            oldElement.props,
            oldElement._owner,
            oldElement._debugStack,
            oldElement._debugTask
          );
          oldElement._store && (newKey._store.validated = oldElement._store.validated);
          return newKey;
        }
        function validateChildKeys(node) {
          isValidElement(node) ? node._store && (node._store.validated = 1) : "object" === typeof node && null !== node && node.$$typeof === REACT_LAZY_TYPE && ("fulfilled" === node._payload.status ? isValidElement(node._payload.value) && node._payload.value._store && (node._payload.value._store.validated = 1) : node._store && (node._store.validated = 1));
        }
        function isValidElement(object) {
          return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function escape(key) {
          var escaperLookup = { "=": "=0", ":": "=2" };
          return "$" + key.replace(/[=:]/g, function(match) {
            return escaperLookup[match];
          });
        }
        function getElementKey(element, index) {
          return "object" === typeof element && null !== element && null != element.key ? (checkKeyStringCoercion(element.key), escape("" + element.key)) : index.toString(36);
        }
        function resolveThenable(thenable) {
          switch (thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenable.reason;
            default:
              switch ("string" === typeof thenable.status ? thenable.then(noop, noop) : (thenable.status = "pending", thenable.then(
                function(fulfilledValue) {
                  "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
                },
                function(error) {
                  "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
                }
              )), thenable.status) {
                case "fulfilled":
                  return thenable.value;
                case "rejected":
                  throw thenable.reason;
              }
          }
          throw thenable;
        }
        function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
          var type = typeof children;
          if ("undefined" === type || "boolean" === type) children = null;
          var invokeCallback = false;
          if (null === children) invokeCallback = true;
          else
            switch (type) {
              case "bigint":
              case "string":
              case "number":
                invokeCallback = true;
                break;
              case "object":
                switch (children.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    invokeCallback = true;
                    break;
                  case REACT_LAZY_TYPE:
                    return invokeCallback = children._init, mapIntoArray(
                      invokeCallback(children._payload),
                      array,
                      escapedPrefix,
                      nameSoFar,
                      callback
                    );
                }
            }
          if (invokeCallback) {
            invokeCallback = children;
            callback = callback(invokeCallback);
            var childKey = "" === nameSoFar ? "." + getElementKey(invokeCallback, 0) : nameSoFar;
            isArrayImpl(callback) ? (escapedPrefix = "", null != childKey && (escapedPrefix = childKey.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c7) {
              return c7;
            })) : null != callback && (isValidElement(callback) && (null != callback.key && (invokeCallback && invokeCallback.key === callback.key || checkKeyStringCoercion(callback.key)), escapedPrefix = cloneAndReplaceKey(
              callback,
              escapedPrefix + (null == callback.key || invokeCallback && invokeCallback.key === callback.key ? "" : ("" + callback.key).replace(
                userProvidedKeyEscapeRegex,
                "$&/"
              ) + "/") + childKey
            ), "" !== nameSoFar && null != invokeCallback && isValidElement(invokeCallback) && null == invokeCallback.key && invokeCallback._store && !invokeCallback._store.validated && (escapedPrefix._store.validated = 2), callback = escapedPrefix), array.push(callback));
            return 1;
          }
          invokeCallback = 0;
          childKey = "" === nameSoFar ? "." : nameSoFar + ":";
          if (isArrayImpl(children))
            for (var i8 = 0; i8 < children.length; i8++)
              nameSoFar = children[i8], type = childKey + getElementKey(nameSoFar, i8), invokeCallback += mapIntoArray(
                nameSoFar,
                array,
                escapedPrefix,
                type,
                callback
              );
          else if (i8 = getIteratorFn(children), "function" === typeof i8)
            for (i8 === children.entries && (didWarnAboutMaps || console.warn(
              "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
            ), didWarnAboutMaps = true), children = i8.call(children), i8 = 0; !(nameSoFar = children.next()).done; )
              nameSoFar = nameSoFar.value, type = childKey + getElementKey(nameSoFar, i8++), invokeCallback += mapIntoArray(
                nameSoFar,
                array,
                escapedPrefix,
                type,
                callback
              );
          else if ("object" === type) {
            if ("function" === typeof children.then)
              return mapIntoArray(
                resolveThenable(children),
                array,
                escapedPrefix,
                nameSoFar,
                callback
              );
            array = String(children);
            throw Error(
              "Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead."
            );
          }
          return invokeCallback;
        }
        function mapChildren(children, func, context) {
          if (null == children) return children;
          var result = [], count = 0;
          mapIntoArray(children, result, "", "", function(child) {
            return func.call(context, child, count++);
          });
          return result;
        }
        function lazyInitializer(payload) {
          if (-1 === payload._status) {
            var ioInfo = payload._ioInfo;
            null != ioInfo && (ioInfo.start = ioInfo.end = performance.now());
            ioInfo = payload._result;
            var thenable = ioInfo();
            thenable.then(
              function(moduleObject) {
                if (0 === payload._status || -1 === payload._status) {
                  payload._status = 1;
                  payload._result = moduleObject;
                  var _ioInfo = payload._ioInfo;
                  null != _ioInfo && (_ioInfo.end = performance.now());
                  void 0 === thenable.status && (thenable.status = "fulfilled", thenable.value = moduleObject);
                }
              },
              function(error) {
                if (0 === payload._status || -1 === payload._status) {
                  payload._status = 2;
                  payload._result = error;
                  var _ioInfo2 = payload._ioInfo;
                  null != _ioInfo2 && (_ioInfo2.end = performance.now());
                  void 0 === thenable.status && (thenable.status = "rejected", thenable.reason = error);
                }
              }
            );
            ioInfo = payload._ioInfo;
            if (null != ioInfo) {
              ioInfo.value = thenable;
              var displayName = thenable.displayName;
              "string" === typeof displayName && (ioInfo.name = displayName);
            }
            -1 === payload._status && (payload._status = 0, payload._result = thenable);
          }
          if (1 === payload._status)
            return ioInfo = payload._result, void 0 === ioInfo && console.error(
              "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?",
              ioInfo
            ), "default" in ioInfo || console.error(
              "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))",
              ioInfo
            ), ioInfo.default;
          throw payload._result;
        }
        function resolveDispatcher() {
          var dispatcher = ReactSharedInternals.H;
          null === dispatcher && console.error(
            "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
          );
          return dispatcher;
        }
        function releaseAsyncTransition() {
          ReactSharedInternals.asyncTransitions--;
        }
        function enqueueTask(task) {
          if (null === enqueueTaskImpl)
            try {
              var requireString = ("require" + Math.random()).slice(0, 7);
              enqueueTaskImpl = (module && module[requireString]).call(
                module,
                "timers"
              ).setImmediate;
            } catch (_err) {
              enqueueTaskImpl = function(callback) {
                false === didWarnAboutMessageChannel && (didWarnAboutMessageChannel = true, "undefined" === typeof MessageChannel && console.error(
                  "This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."
                ));
                var channel = new MessageChannel();
                channel.port1.onmessage = callback;
                channel.port2.postMessage(void 0);
              };
            }
          return enqueueTaskImpl(task);
        }
        function aggregateErrors(errors) {
          return 1 < errors.length && "function" === typeof AggregateError ? new AggregateError(errors) : errors[0];
        }
        function popActScope(prevActQueue, prevActScopeDepth) {
          prevActScopeDepth !== actScopeDepth - 1 && console.error(
            "You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "
          );
          actScopeDepth = prevActScopeDepth;
        }
        function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
          var queue = ReactSharedInternals.actQueue;
          if (null !== queue)
            if (0 !== queue.length)
              try {
                flushActQueue(queue);
                enqueueTask(function() {
                  return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                });
                return;
              } catch (error) {
                ReactSharedInternals.thrownErrors.push(error);
              }
            else ReactSharedInternals.actQueue = null;
          0 < ReactSharedInternals.thrownErrors.length ? (queue = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject(queue)) : resolve(returnValue);
        }
        function flushActQueue(queue) {
          if (!isFlushing) {
            isFlushing = true;
            var i8 = 0;
            try {
              for (; i8 < queue.length; i8++) {
                var callback = queue[i8];
                do {
                  ReactSharedInternals.didUsePromise = false;
                  var continuation = callback(false);
                  if (null !== continuation) {
                    if (ReactSharedInternals.didUsePromise) {
                      queue[i8] = callback;
                      queue.splice(0, i8);
                      return;
                    }
                    callback = continuation;
                  } else break;
                } while (1);
              }
              queue.length = 0;
            } catch (error) {
              queue.splice(0, i8 + 1), ReactSharedInternals.thrownErrors.push(error);
            } finally {
              isFlushing = false;
            }
          }
        }
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
        var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, didWarnStateUpdateForUnmountedComponent = {}, ReactNoopUpdateQueue = {
          isMounted: function() {
            return false;
          },
          enqueueForceUpdate: function(publicInstance) {
            warnNoop(publicInstance, "forceUpdate");
          },
          enqueueReplaceState: function(publicInstance) {
            warnNoop(publicInstance, "replaceState");
          },
          enqueueSetState: function(publicInstance) {
            warnNoop(publicInstance, "setState");
          }
        }, assign = Object.assign, emptyObject = {};
        Object.freeze(emptyObject);
        Component.prototype.isReactComponent = {};
        Component.prototype.setState = function(partialState, callback) {
          if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
            throw Error(
              "takes an object of state variables to update or a function which returns an object of state variables."
            );
          this.updater.enqueueSetState(this, partialState, callback, "setState");
        };
        Component.prototype.forceUpdate = function(callback) {
          this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
        };
        var deprecatedAPIs = {
          isMounted: [
            "isMounted",
            "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."
          ],
          replaceState: [
            "replaceState",
            "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."
          ]
        };
        for (fnName in deprecatedAPIs)
          deprecatedAPIs.hasOwnProperty(fnName) && defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
        ComponentDummy.prototype = Component.prototype;
        deprecatedAPIs = PureComponent.prototype = new ComponentDummy();
        deprecatedAPIs.constructor = PureComponent;
        assign(deprecatedAPIs, Component.prototype);
        deprecatedAPIs.isPureReactComponent = true;
        var isArrayImpl = Array.isArray, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = {
          H: null,
          A: null,
          T: null,
          S: null,
          actQueue: null,
          asyncTransitions: 0,
          isBatchingLegacy: false,
          didScheduleLegacyUpdate: false,
          didUsePromise: false,
          thrownErrors: [],
          getCurrentStack: null,
          recentlyCreatedOwnerStacks: 0
        }, hasOwnProperty = Object.prototype.hasOwnProperty, createTask = console.createTask ? console.createTask : function() {
          return null;
        };
        deprecatedAPIs = {
          react_stack_bottom_frame: function(callStackForError) {
            return callStackForError();
          }
        };
        var specialPropKeyWarningShown, didWarnAboutOldJSXRuntime;
        var didWarnAboutElementRef = {};
        var unknownOwnerDebugStack = deprecatedAPIs.react_stack_bottom_frame.bind(
          deprecatedAPIs,
          UnknownOwner
        )();
        var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
        var didWarnAboutMaps = false, userProvidedKeyEscapeRegex = /\/+/g, reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
          if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
            var event = new window.ErrorEvent("error", {
              bubbles: true,
              cancelable: true,
              message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
              error
            });
            if (!window.dispatchEvent(event)) return;
          } else if ("object" === typeof process && "function" === typeof process.emit) {
            process.emit("uncaughtException", error);
            return;
          }
          console.error(error);
        }, didWarnAboutMessageChannel = false, enqueueTaskImpl = null, actScopeDepth = 0, didWarnNoAwaitAct = false, isFlushing = false, queueSeveralMicrotasks = "function" === typeof queueMicrotask ? function(callback) {
          queueMicrotask(function() {
            return queueMicrotask(callback);
          });
        } : enqueueTask;
        deprecatedAPIs = Object.freeze({
          __proto__: null,
          c: function(size) {
            return resolveDispatcher().useMemoCache(size);
          }
        });
        var fnName = {
          map: mapChildren,
          forEach: function(children, forEachFunc, forEachContext) {
            mapChildren(
              children,
              function() {
                forEachFunc.apply(this, arguments);
              },
              forEachContext
            );
          },
          count: function(children) {
            var n5 = 0;
            mapChildren(children, function() {
              n5++;
            });
            return n5;
          },
          toArray: function(children) {
            return mapChildren(children, function(child) {
              return child;
            }) || [];
          },
          only: function(children) {
            if (!isValidElement(children))
              throw Error(
                "React.Children.only expected to receive a single React element child."
              );
            return children;
          }
        };
        exports.Activity = REACT_ACTIVITY_TYPE;
        exports.Children = fnName;
        exports.Component = Component;
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.Profiler = REACT_PROFILER_TYPE;
        exports.PureComponent = PureComponent;
        exports.StrictMode = REACT_STRICT_MODE_TYPE;
        exports.Suspense = REACT_SUSPENSE_TYPE;
        exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
        exports.__COMPILER_RUNTIME = deprecatedAPIs;
        exports.act = function(callback) {
          var prevActQueue = ReactSharedInternals.actQueue, prevActScopeDepth = actScopeDepth;
          actScopeDepth++;
          var queue = ReactSharedInternals.actQueue = null !== prevActQueue ? prevActQueue : [], didAwaitActCall = false;
          try {
            var result = callback();
          } catch (error) {
            ReactSharedInternals.thrownErrors.push(error);
          }
          if (0 < ReactSharedInternals.thrownErrors.length)
            throw popActScope(prevActQueue, prevActScopeDepth), callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
          if (null !== result && "object" === typeof result && "function" === typeof result.then) {
            var thenable = result;
            queueSeveralMicrotasks(function() {
              didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error(
                "You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"
              ));
            });
            return {
              then: function(resolve, reject) {
                didAwaitActCall = true;
                thenable.then(
                  function(returnValue) {
                    popActScope(prevActQueue, prevActScopeDepth);
                    if (0 === prevActScopeDepth) {
                      try {
                        flushActQueue(queue), enqueueTask(function() {
                          return recursivelyFlushAsyncActWork(
                            returnValue,
                            resolve,
                            reject
                          );
                        });
                      } catch (error$0) {
                        ReactSharedInternals.thrownErrors.push(error$0);
                      }
                      if (0 < ReactSharedInternals.thrownErrors.length) {
                        var _thrownError = aggregateErrors(
                          ReactSharedInternals.thrownErrors
                        );
                        ReactSharedInternals.thrownErrors.length = 0;
                        reject(_thrownError);
                      }
                    } else resolve(returnValue);
                  },
                  function(error) {
                    popActScope(prevActQueue, prevActScopeDepth);
                    0 < ReactSharedInternals.thrownErrors.length ? (error = aggregateErrors(
                      ReactSharedInternals.thrownErrors
                    ), ReactSharedInternals.thrownErrors.length = 0, reject(error)) : reject(error);
                  }
                );
              }
            };
          }
          var returnValue$jscomp$0 = result;
          popActScope(prevActQueue, prevActScopeDepth);
          0 === prevActScopeDepth && (flushActQueue(queue), 0 !== queue.length && queueSeveralMicrotasks(function() {
            didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error(
              "A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"
            ));
          }), ReactSharedInternals.actQueue = null);
          if (0 < ReactSharedInternals.thrownErrors.length)
            throw callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
          return {
            then: function(resolve, reject) {
              didAwaitActCall = true;
              0 === prevActScopeDepth ? (ReactSharedInternals.actQueue = queue, enqueueTask(function() {
                return recursivelyFlushAsyncActWork(
                  returnValue$jscomp$0,
                  resolve,
                  reject
                );
              })) : resolve(returnValue$jscomp$0);
            }
          };
        };
        exports.cache = function(fn) {
          return function() {
            return fn.apply(null, arguments);
          };
        };
        exports.cacheSignal = function() {
          return null;
        };
        exports.captureOwnerStack = function() {
          var getCurrentStack = ReactSharedInternals.getCurrentStack;
          return null === getCurrentStack ? null : getCurrentStack();
        };
        exports.cloneElement = function(element, config, children) {
          if (null === element || void 0 === element)
            throw Error(
              "The argument must be a React element, but you passed " + element + "."
            );
          var props = assign({}, element.props), key = element.key, owner = element._owner;
          if (null != config) {
            var JSCompiler_inline_result;
            a: {
              if (hasOwnProperty.call(config, "ref") && (JSCompiler_inline_result = Object.getOwnPropertyDescriptor(
                config,
                "ref"
              ).get) && JSCompiler_inline_result.isReactWarning) {
                JSCompiler_inline_result = false;
                break a;
              }
              JSCompiler_inline_result = void 0 !== config.ref;
            }
            JSCompiler_inline_result && (owner = getOwner());
            hasValidKey(config) && (checkKeyStringCoercion(config.key), key = "" + config.key);
            for (propName in config)
              !hasOwnProperty.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
          }
          var propName = arguments.length - 2;
          if (1 === propName) props.children = children;
          else if (1 < propName) {
            JSCompiler_inline_result = Array(propName);
            for (var i8 = 0; i8 < propName; i8++)
              JSCompiler_inline_result[i8] = arguments[i8 + 2];
            props.children = JSCompiler_inline_result;
          }
          props = ReactElement(
            element.type,
            key,
            props,
            owner,
            element._debugStack,
            element._debugTask
          );
          for (key = 2; key < arguments.length; key++)
            validateChildKeys(arguments[key]);
          return props;
        };
        exports.createContext = function(defaultValue) {
          defaultValue = {
            $$typeof: REACT_CONTEXT_TYPE,
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            _threadCount: 0,
            Provider: null,
            Consumer: null
          };
          defaultValue.Provider = defaultValue;
          defaultValue.Consumer = {
            $$typeof: REACT_CONSUMER_TYPE,
            _context: defaultValue
          };
          defaultValue._currentRenderer = null;
          defaultValue._currentRenderer2 = null;
          return defaultValue;
        };
        exports.createElement = function(type, config, children) {
          for (var i8 = 2; i8 < arguments.length; i8++)
            validateChildKeys(arguments[i8]);
          i8 = {};
          var key = null;
          if (null != config)
            for (propName in didWarnAboutOldJSXRuntime || !("__self" in config) || "key" in config || (didWarnAboutOldJSXRuntime = true, console.warn(
              "Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform"
            )), hasValidKey(config) && (checkKeyStringCoercion(config.key), key = "" + config.key), config)
              hasOwnProperty.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (i8[propName] = config[propName]);
          var childrenLength = arguments.length - 2;
          if (1 === childrenLength) i8.children = children;
          else if (1 < childrenLength) {
            for (var childArray = Array(childrenLength), _i = 0; _i < childrenLength; _i++)
              childArray[_i] = arguments[_i + 2];
            Object.freeze && Object.freeze(childArray);
            i8.children = childArray;
          }
          if (type && type.defaultProps)
            for (propName in childrenLength = type.defaultProps, childrenLength)
              void 0 === i8[propName] && (i8[propName] = childrenLength[propName]);
          key && defineKeyPropWarningGetter(
            i8,
            "function" === typeof type ? type.displayName || type.name || "Unknown" : type
          );
          var propName = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
          return ReactElement(
            type,
            key,
            i8,
            getOwner(),
            propName ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
            propName ? createTask(getTaskName(type)) : unknownOwnerDebugTask
          );
        };
        exports.createRef = function() {
          var refObject = { current: null };
          Object.seal(refObject);
          return refObject;
        };
        exports.forwardRef = function(render) {
          null != render && render.$$typeof === REACT_MEMO_TYPE ? console.error(
            "forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))."
          ) : "function" !== typeof render ? console.error(
            "forwardRef requires a render function but was given %s.",
            null === render ? "null" : typeof render
          ) : 0 !== render.length && 2 !== render.length && console.error(
            "forwardRef render functions accept exactly two parameters: props and ref. %s",
            1 === render.length ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."
          );
          null != render && null != render.defaultProps && console.error(
            "forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?"
          );
          var elementType = { $$typeof: REACT_FORWARD_REF_TYPE, render }, ownName;
          Object.defineProperty(elementType, "displayName", {
            enumerable: false,
            configurable: true,
            get: function() {
              return ownName;
            },
            set: function(name) {
              ownName = name;
              render.name || render.displayName || (Object.defineProperty(render, "name", { value: name }), render.displayName = name);
            }
          });
          return elementType;
        };
        exports.isValidElement = isValidElement;
        exports.lazy = function(ctor) {
          ctor = { _status: -1, _result: ctor };
          var lazyType = {
            $$typeof: REACT_LAZY_TYPE,
            _payload: ctor,
            _init: lazyInitializer
          }, ioInfo = {
            name: "lazy",
            start: -1,
            end: -1,
            value: null,
            owner: null,
            debugStack: Error("react-stack-top-frame"),
            debugTask: console.createTask ? console.createTask("lazy()") : null
          };
          ctor._ioInfo = ioInfo;
          lazyType._debugInfo = [{ awaited: ioInfo }];
          return lazyType;
        };
        exports.memo = function(type, compare) {
          null == type && console.error(
            "memo: The first argument must be a component. Instead received: %s",
            null === type ? "null" : typeof type
          );
          compare = {
            $$typeof: REACT_MEMO_TYPE,
            type,
            compare: void 0 === compare ? null : compare
          };
          var ownName;
          Object.defineProperty(compare, "displayName", {
            enumerable: false,
            configurable: true,
            get: function() {
              return ownName;
            },
            set: function(name) {
              ownName = name;
              type.name || type.displayName || (Object.defineProperty(type, "name", { value: name }), type.displayName = name);
            }
          });
          return compare;
        };
        exports.startTransition = function(scope) {
          var prevTransition = ReactSharedInternals.T, currentTransition = {};
          currentTransition._updatedFibers = /* @__PURE__ */ new Set();
          ReactSharedInternals.T = currentTransition;
          try {
            var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
            null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
            "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && (ReactSharedInternals.asyncTransitions++, returnValue.then(releaseAsyncTransition, releaseAsyncTransition), returnValue.then(noop, reportGlobalError));
          } catch (error) {
            reportGlobalError(error);
          } finally {
            null === prevTransition && currentTransition._updatedFibers && (scope = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < scope && console.warn(
              "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
            )), null !== prevTransition && null !== currentTransition.types && (null !== prevTransition.types && prevTransition.types !== currentTransition.types && console.error(
              "We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React."
            ), prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
          }
        };
        exports.unstable_useCacheRefresh = function() {
          return resolveDispatcher().useCacheRefresh();
        };
        exports.use = function(usable) {
          return resolveDispatcher().use(usable);
        };
        exports.useActionState = function(action, initialState, permalink) {
          return resolveDispatcher().useActionState(
            action,
            initialState,
            permalink
          );
        };
        exports.useCallback = function(callback, deps) {
          return resolveDispatcher().useCallback(callback, deps);
        };
        exports.useContext = function(Context) {
          var dispatcher = resolveDispatcher();
          Context.$$typeof === REACT_CONSUMER_TYPE && console.error(
            "Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?"
          );
          return dispatcher.useContext(Context);
        };
        exports.useDebugValue = function(value, formatterFn) {
          return resolveDispatcher().useDebugValue(value, formatterFn);
        };
        exports.useDeferredValue = function(value, initialValue) {
          return resolveDispatcher().useDeferredValue(value, initialValue);
        };
        exports.useEffect = function(create2, deps) {
          null == create2 && console.warn(
            "React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?"
          );
          return resolveDispatcher().useEffect(create2, deps);
        };
        exports.useEffectEvent = function(callback) {
          return resolveDispatcher().useEffectEvent(callback);
        };
        exports.useId = function() {
          return resolveDispatcher().useId();
        };
        exports.useImperativeHandle = function(ref, create2, deps) {
          return resolveDispatcher().useImperativeHandle(ref, create2, deps);
        };
        exports.useInsertionEffect = function(create2, deps) {
          null == create2 && console.warn(
            "React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?"
          );
          return resolveDispatcher().useInsertionEffect(create2, deps);
        };
        exports.useLayoutEffect = function(create2, deps) {
          null == create2 && console.warn(
            "React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?"
          );
          return resolveDispatcher().useLayoutEffect(create2, deps);
        };
        exports.useMemo = function(create2, deps) {
          return resolveDispatcher().useMemo(create2, deps);
        };
        exports.useOptimistic = function(passthrough, reducer) {
          return resolveDispatcher().useOptimistic(passthrough, reducer);
        };
        exports.useReducer = function(reducer, initialArg, init) {
          return resolveDispatcher().useReducer(reducer, initialArg, init);
        };
        exports.useRef = function(initialValue) {
          return resolveDispatcher().useRef(initialValue);
        };
        exports.useState = function(initialState) {
          return resolveDispatcher().useState(initialState);
        };
        exports.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
          return resolveDispatcher().useSyncExternalStore(
            subscribe,
            getSnapshot,
            getServerSnapshot
          );
        };
        exports.useTransition = function() {
          return resolveDispatcher().useTransition();
        };
        exports.version = "19.2.0";
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
      })();
    }
  });

  // node_modules/.pnpm/react@19.2.0/node_modules/react/index.js
  var require_react = __commonJS({
    "node_modules/.pnpm/react@19.2.0/node_modules/react/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_react_development();
      }
    }
  });

  // node_modules/.pnpm/scheduler@0.27.0/node_modules/scheduler/cjs/scheduler.development.js
  var require_scheduler_development = __commonJS({
    "node_modules/.pnpm/scheduler@0.27.0/node_modules/scheduler/cjs/scheduler.development.js"(exports) {
      "use strict";
      (function() {
        function performWorkUntilDeadline() {
          needsPaint = false;
          if (isMessageLoopRunning) {
            var currentTime = exports.unstable_now();
            startTime = currentTime;
            var hasMoreWork = true;
            try {
              a: {
                isHostCallbackScheduled = false;
                isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
                isPerformingWork = true;
                var previousPriorityLevel = currentPriorityLevel;
                try {
                  b: {
                    advanceTimers(currentTime);
                    for (currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost()); ) {
                      var callback = currentTask.callback;
                      if ("function" === typeof callback) {
                        currentTask.callback = null;
                        currentPriorityLevel = currentTask.priorityLevel;
                        var continuationCallback = callback(
                          currentTask.expirationTime <= currentTime
                        );
                        currentTime = exports.unstable_now();
                        if ("function" === typeof continuationCallback) {
                          currentTask.callback = continuationCallback;
                          advanceTimers(currentTime);
                          hasMoreWork = true;
                          break b;
                        }
                        currentTask === peek(taskQueue) && pop(taskQueue);
                        advanceTimers(currentTime);
                      } else pop(taskQueue);
                      currentTask = peek(taskQueue);
                    }
                    if (null !== currentTask) hasMoreWork = true;
                    else {
                      var firstTimer = peek(timerQueue);
                      null !== firstTimer && requestHostTimeout(
                        handleTimeout,
                        firstTimer.startTime - currentTime
                      );
                      hasMoreWork = false;
                    }
                  }
                  break a;
                } finally {
                  currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
                }
                hasMoreWork = void 0;
              }
            } finally {
              hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
            }
          }
        }
        function push(heap, node) {
          var index = heap.length;
          heap.push(node);
          a: for (; 0 < index; ) {
            var parentIndex = index - 1 >>> 1, parent = heap[parentIndex];
            if (0 < compare(parent, node))
              heap[parentIndex] = node, heap[index] = parent, index = parentIndex;
            else break a;
          }
        }
        function peek(heap) {
          return 0 === heap.length ? null : heap[0];
        }
        function pop(heap) {
          if (0 === heap.length) return null;
          var first = heap[0], last = heap.pop();
          if (last !== first) {
            heap[0] = last;
            a: for (var index = 0, length = heap.length, halfLength = length >>> 1; index < halfLength; ) {
              var leftIndex = 2 * (index + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
              if (0 > compare(left, last))
                rightIndex < length && 0 > compare(right, left) ? (heap[index] = right, heap[rightIndex] = last, index = rightIndex) : (heap[index] = left, heap[leftIndex] = last, index = leftIndex);
              else if (rightIndex < length && 0 > compare(right, last))
                heap[index] = right, heap[rightIndex] = last, index = rightIndex;
              else break a;
            }
          }
          return first;
        }
        function compare(a5, b3) {
          var diff = a5.sortIndex - b3.sortIndex;
          return 0 !== diff ? diff : a5.id - b3.id;
        }
        function advanceTimers(currentTime) {
          for (var timer = peek(timerQueue); null !== timer; ) {
            if (null === timer.callback) pop(timerQueue);
            else if (timer.startTime <= currentTime)
              pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
            else break;
            timer = peek(timerQueue);
          }
        }
        function handleTimeout(currentTime) {
          isHostTimeoutScheduled = false;
          advanceTimers(currentTime);
          if (!isHostCallbackScheduled)
            if (null !== peek(taskQueue))
              isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());
            else {
              var firstTimer = peek(timerQueue);
              null !== firstTimer && requestHostTimeout(
                handleTimeout,
                firstTimer.startTime - currentTime
              );
            }
        }
        function shouldYieldToHost() {
          return needsPaint ? true : exports.unstable_now() - startTime < frameInterval ? false : true;
        }
        function requestHostTimeout(callback, ms) {
          taskTimeoutID = localSetTimeout(function() {
            callback(exports.unstable_now());
          }, ms);
        }
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
        exports.unstable_now = void 0;
        if ("object" === typeof performance && "function" === typeof performance.now) {
          var localPerformance = performance;
          exports.unstable_now = function() {
            return localPerformance.now();
          };
        } else {
          var localDate = Date, initialTime = localDate.now();
          exports.unstable_now = function() {
            return localDate.now() - initialTime;
          };
        }
        var taskQueue = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = false, isHostCallbackScheduled = false, isHostTimeoutScheduled = false, needsPaint = false, localSetTimeout = "function" === typeof setTimeout ? setTimeout : null, localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null, localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null, isMessageLoopRunning = false, taskTimeoutID = -1, frameInterval = 5, startTime = -1;
        if ("function" === typeof localSetImmediate)
          var schedulePerformWorkUntilDeadline = function() {
            localSetImmediate(performWorkUntilDeadline);
          };
        else if ("undefined" !== typeof MessageChannel) {
          var channel = new MessageChannel(), port = channel.port2;
          channel.port1.onmessage = performWorkUntilDeadline;
          schedulePerformWorkUntilDeadline = function() {
            port.postMessage(null);
          };
        } else
          schedulePerformWorkUntilDeadline = function() {
            localSetTimeout(performWorkUntilDeadline, 0);
          };
        exports.unstable_IdlePriority = 5;
        exports.unstable_ImmediatePriority = 1;
        exports.unstable_LowPriority = 4;
        exports.unstable_NormalPriority = 3;
        exports.unstable_Profiling = null;
        exports.unstable_UserBlockingPriority = 2;
        exports.unstable_cancelCallback = function(task) {
          task.callback = null;
        };
        exports.unstable_forceFrameRate = function(fps) {
          0 > fps || 125 < fps ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          ) : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
        };
        exports.unstable_getCurrentPriorityLevel = function() {
          return currentPriorityLevel;
        };
        exports.unstable_next = function(eventHandler) {
          switch (currentPriorityLevel) {
            case 1:
            case 2:
            case 3:
              var priorityLevel = 3;
              break;
            default:
              priorityLevel = currentPriorityLevel;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
        exports.unstable_requestPaint = function() {
          needsPaint = true;
        };
        exports.unstable_runWithPriority = function(priorityLevel, eventHandler) {
          switch (priorityLevel) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
              break;
            default:
              priorityLevel = 3;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
        exports.unstable_scheduleCallback = function(priorityLevel, callback, options) {
          var currentTime = exports.unstable_now();
          "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
          switch (priorityLevel) {
            case 1:
              var timeout = -1;
              break;
            case 2:
              timeout = 250;
              break;
            case 5:
              timeout = 1073741823;
              break;
            case 4:
              timeout = 1e4;
              break;
            default:
              timeout = 5e3;
          }
          timeout = options + timeout;
          priorityLevel = {
            id: taskIdCounter++,
            callback,
            priorityLevel,
            startTime: options,
            expirationTime: timeout,
            sortIndex: -1
          };
          options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline())));
          return priorityLevel;
        };
        exports.unstable_shouldYield = shouldYieldToHost;
        exports.unstable_wrapCallback = function(callback) {
          var parentPriorityLevel = currentPriorityLevel;
          return function() {
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = parentPriorityLevel;
            try {
              return callback.apply(this, arguments);
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          };
        };
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
      })();
    }
  });

  // node_modules/.pnpm/scheduler@0.27.0/node_modules/scheduler/index.js
  var require_scheduler = __commonJS({
    "node_modules/.pnpm/scheduler@0.27.0/node_modules/scheduler/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_scheduler_development();
      }
    }
  });

  // node_modules/.pnpm/react-dom@19.2.0_react@19.2.0/node_modules/react-dom/cjs/react-dom.development.js
  var require_react_dom_development = __commonJS({
    "node_modules/.pnpm/react-dom@19.2.0_react@19.2.0/node_modules/react-dom/cjs/react-dom.development.js"(exports) {
      "use strict";
      (function() {
        function noop() {
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function createPortal$1(children, containerInfo, implementation) {
          var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
          try {
            testStringCoercion(key);
            var JSCompiler_inline_result = false;
          } catch (e2) {
            JSCompiler_inline_result = true;
          }
          JSCompiler_inline_result && (console.error(
            "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
            "function" === typeof Symbol && Symbol.toStringTag && key[Symbol.toStringTag] || key.constructor.name || "Object"
          ), testStringCoercion(key));
          return {
            $$typeof: REACT_PORTAL_TYPE,
            key: null == key ? null : "" + key,
            children,
            containerInfo,
            implementation
          };
        }
        function getCrossOriginStringAs(as, input) {
          if ("font" === as) return "";
          if ("string" === typeof input)
            return "use-credentials" === input ? input : "";
        }
        function getValueDescriptorExpectingObjectForWarning(thing) {
          return null === thing ? "`null`" : void 0 === thing ? "`undefined`" : "" === thing ? "an empty string" : 'something with type "' + typeof thing + '"';
        }
        function getValueDescriptorExpectingEnumForWarning(thing) {
          return null === thing ? "`null`" : void 0 === thing ? "`undefined`" : "" === thing ? "an empty string" : "string" === typeof thing ? JSON.stringify(thing) : "number" === typeof thing ? "`" + thing + "`" : 'something with type "' + typeof thing + '"';
        }
        function resolveDispatcher() {
          var dispatcher = ReactSharedInternals.H;
          null === dispatcher && console.error(
            "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
          );
          return dispatcher;
        }
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
        var React2 = require_react(), Internals = {
          d: {
            f: noop,
            r: function() {
              throw Error(
                "Invalid form element. requestFormReset must be passed a form that was rendered by React."
              );
            },
            D: noop,
            C: noop,
            L: noop,
            m: noop,
            X: noop,
            S: noop,
            M: noop
          },
          p: 0,
          findDOMNode: null
        }, REACT_PORTAL_TYPE = Symbol.for("react.portal"), ReactSharedInternals = React2.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
        "function" === typeof Map && null != Map.prototype && "function" === typeof Map.prototype.forEach && "function" === typeof Set && null != Set.prototype && "function" === typeof Set.prototype.clear && "function" === typeof Set.prototype.forEach || console.error(
          "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"
        );
        exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
        exports.createPortal = function(children, container) {
          var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
          if (!container || 1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType)
            throw Error("Target container is not a DOM element.");
          return createPortal$1(children, container, null, key);
        };
        exports.flushSync = function(fn) {
          var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
          try {
            if (ReactSharedInternals.T = null, Internals.p = 2, fn)
              return fn();
          } finally {
            ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f() && console.error(
              "flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."
            );
          }
        };
        exports.preconnect = function(href, options) {
          "string" === typeof href && href ? null != options && "object" !== typeof options ? console.error(
            "ReactDOM.preconnect(): Expected the `options` argument (second) to be an object but encountered %s instead. The only supported option at this time is `crossOrigin` which accepts a string.",
            getValueDescriptorExpectingEnumForWarning(options)
          ) : null != options && "string" !== typeof options.crossOrigin && console.error(
            "ReactDOM.preconnect(): Expected the `crossOrigin` option (second argument) to be a string but encountered %s instead. Try removing this option or passing a string value instead.",
            getValueDescriptorExpectingObjectForWarning(options.crossOrigin)
          ) : console.error(
            "ReactDOM.preconnect(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
            getValueDescriptorExpectingObjectForWarning(href)
          );
          "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
        };
        exports.prefetchDNS = function(href) {
          if ("string" !== typeof href || !href)
            console.error(
              "ReactDOM.prefetchDNS(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
              getValueDescriptorExpectingObjectForWarning(href)
            );
          else if (1 < arguments.length) {
            var options = arguments[1];
            "object" === typeof options && options.hasOwnProperty("crossOrigin") ? console.error(
              "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. It looks like the you are attempting to set a crossOrigin property for this DNS lookup hint. Browsers do not perform DNS queries using CORS and setting this attribute on the resource hint has no effect. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
              getValueDescriptorExpectingEnumForWarning(options)
            ) : console.error(
              "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
              getValueDescriptorExpectingEnumForWarning(options)
            );
          }
          "string" === typeof href && Internals.d.D(href);
        };
        exports.preinit = function(href, options) {
          "string" === typeof href && href ? null == options || "object" !== typeof options ? console.error(
            "ReactDOM.preinit(): Expected the `options` argument (second) to be an object with an `as` property describing the type of resource to be preinitialized but encountered %s instead.",
            getValueDescriptorExpectingEnumForWarning(options)
          ) : "style" !== options.as && "script" !== options.as && console.error(
            'ReactDOM.preinit(): Expected the `as` property in the `options` argument (second) to contain a valid value describing the type of resource to be preinitialized but encountered %s instead. Valid values for `as` are "style" and "script".',
            getValueDescriptorExpectingEnumForWarning(options.as)
          ) : console.error(
            "ReactDOM.preinit(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
            getValueDescriptorExpectingObjectForWarning(href)
          );
          if ("string" === typeof href && options && "string" === typeof options.as) {
            var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin), integrity = "string" === typeof options.integrity ? options.integrity : void 0, fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
            "style" === as ? Internals.d.S(
              href,
              "string" === typeof options.precedence ? options.precedence : void 0,
              {
                crossOrigin,
                integrity,
                fetchPriority
              }
            ) : "script" === as && Internals.d.X(href, {
              crossOrigin,
              integrity,
              fetchPriority,
              nonce: "string" === typeof options.nonce ? options.nonce : void 0
            });
          }
        };
        exports.preinitModule = function(href, options) {
          var encountered = "";
          "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
          void 0 !== options && "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && "as" in options && "script" !== options.as && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingEnumForWarning(options.as) + ".");
          if (encountered)
            console.error(
              "ReactDOM.preinitModule(): Expected up to two arguments, a non-empty `href` string and, optionally, an `options` object with a valid `as` property.%s",
              encountered
            );
          else
            switch (encountered = options && "string" === typeof options.as ? options.as : "script", encountered) {
              case "script":
                break;
              default:
                encountered = getValueDescriptorExpectingEnumForWarning(encountered), console.error(
                  'ReactDOM.preinitModule(): Currently the only supported "as" type for this function is "script" but received "%s" instead. This warning was generated for `href` "%s". In the future other module types will be supported, aligning with the import-attributes proposal. Learn more here: (https://github.com/tc39/proposal-import-attributes)',
                  encountered,
                  href
                );
            }
          if ("string" === typeof href)
            if ("object" === typeof options && null !== options) {
              if (null == options.as || "script" === options.as)
                encountered = getCrossOriginStringAs(
                  options.as,
                  options.crossOrigin
                ), Internals.d.M(href, {
                  crossOrigin: encountered,
                  integrity: "string" === typeof options.integrity ? options.integrity : void 0,
                  nonce: "string" === typeof options.nonce ? options.nonce : void 0
                });
            } else null == options && Internals.d.M(href);
        };
        exports.preload = function(href, options) {
          var encountered = "";
          "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
          null == options || "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : "string" === typeof options.as && options.as || (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
          encountered && console.error(
            'ReactDOM.preload(): Expected two arguments, a non-empty `href` string and an `options` object with an `as` property valid for a `<link rel="preload" as="..." />` tag.%s',
            encountered
          );
          if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
            encountered = options.as;
            var crossOrigin = getCrossOriginStringAs(
              encountered,
              options.crossOrigin
            );
            Internals.d.L(href, encountered, {
              crossOrigin,
              integrity: "string" === typeof options.integrity ? options.integrity : void 0,
              nonce: "string" === typeof options.nonce ? options.nonce : void 0,
              type: "string" === typeof options.type ? options.type : void 0,
              fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
              referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
              imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
              imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
              media: "string" === typeof options.media ? options.media : void 0
            });
          }
        };
        exports.preloadModule = function(href, options) {
          var encountered = "";
          "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
          void 0 !== options && "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && "as" in options && "string" !== typeof options.as && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
          encountered && console.error(
            'ReactDOM.preloadModule(): Expected two arguments, a non-empty `href` string and, optionally, an `options` object with an `as` property valid for a `<link rel="modulepreload" as="..." />` tag.%s',
            encountered
          );
          "string" === typeof href && (options ? (encountered = getCrossOriginStringAs(
            options.as,
            options.crossOrigin
          ), Internals.d.m(href, {
            as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
            crossOrigin: encountered,
            integrity: "string" === typeof options.integrity ? options.integrity : void 0
          })) : Internals.d.m(href));
        };
        exports.requestFormReset = function(form) {
          Internals.d.r(form);
        };
        exports.unstable_batchedUpdates = function(fn, a5) {
          return fn(a5);
        };
        exports.useFormState = function(action, initialState, permalink) {
          return resolveDispatcher().useFormState(action, initialState, permalink);
        };
        exports.useFormStatus = function() {
          return resolveDispatcher().useHostTransitionStatus();
        };
        exports.version = "19.2.0";
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
      })();
    }
  });

  // node_modules/.pnpm/react-dom@19.2.0_react@19.2.0/node_modules/react-dom/index.js
  var require_react_dom = __commonJS({
    "node_modules/.pnpm/react-dom@19.2.0_react@19.2.0/node_modules/react-dom/index.js"(exports, module) {
      "use strict";
      if (false) {
        checkDCE();
        module.exports = null;
      } else {
        module.exports = require_react_dom_development();
      }
    }
  });

  // node_modules/.pnpm/react-dom@19.2.0_react@19.2.0/node_modules/react-dom/cjs/react-dom-client.development.js
  var require_react_dom_client_development = __commonJS({
    "node_modules/.pnpm/react-dom@19.2.0_react@19.2.0/node_modules/react-dom/cjs/react-dom-client.development.js"(exports) {
      "use strict";
      (function() {
        function findHook(fiber, id) {
          for (fiber = fiber.memoizedState; null !== fiber && 0 < id; )
            fiber = fiber.next, id--;
          return fiber;
        }
        function copyWithSetImpl(obj, path, index, value) {
          if (index >= path.length) return value;
          var key = path[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
          updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);
          return updated;
        }
        function copyWithRename(obj, oldPath, newPath) {
          if (oldPath.length !== newPath.length)
            console.warn("copyWithRename() expects paths of the same length");
          else {
            for (var i8 = 0; i8 < newPath.length - 1; i8++)
              if (oldPath[i8] !== newPath[i8]) {
                console.warn(
                  "copyWithRename() expects paths to be the same except for the deepest key"
                );
                return;
              }
            return copyWithRenameImpl(obj, oldPath, newPath, 0);
          }
        }
        function copyWithRenameImpl(obj, oldPath, newPath, index) {
          var oldKey = oldPath[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
          index + 1 === oldPath.length ? (updated[newPath[index]] = updated[oldKey], isArrayImpl(updated) ? updated.splice(oldKey, 1) : delete updated[oldKey]) : updated[oldKey] = copyWithRenameImpl(
            obj[oldKey],
            oldPath,
            newPath,
            index + 1
          );
          return updated;
        }
        function copyWithDeleteImpl(obj, path, index) {
          var key = path[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
          if (index + 1 === path.length)
            return isArrayImpl(updated) ? updated.splice(key, 1) : delete updated[key], updated;
          updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);
          return updated;
        }
        function shouldSuspendImpl() {
          return false;
        }
        function shouldErrorImpl() {
          return null;
        }
        function warnInvalidHookAccess() {
          console.error(
            "Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks"
          );
        }
        function warnInvalidContextAccess() {
          console.error(
            "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
          );
        }
        function noop() {
        }
        function warnForMissingKey() {
        }
        function setToSortedString(set) {
          var array = [];
          set.forEach(function(value) {
            array.push(value);
          });
          return array.sort().join(", ");
        }
        function createFiber(tag, pendingProps, key, mode) {
          return new FiberNode(tag, pendingProps, key, mode);
        }
        function scheduleRoot(root2, element) {
          root2.context === emptyContextObject && (updateContainerImpl(root2.current, 2, element, root2, null, null), flushSyncWork$1());
        }
        function scheduleRefresh(root2, update) {
          if (null !== resolveFamily) {
            var staleFamilies = update.staleFamilies;
            update = update.updatedFamilies;
            flushPendingEffects();
            scheduleFibersWithFamiliesRecursively(
              root2.current,
              update,
              staleFamilies
            );
            flushSyncWork$1();
          }
        }
        function setRefreshHandler(handler) {
          resolveFamily = handler;
        }
        function isValidContainer(node) {
          return !(!node || 1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType);
        }
        function getNearestMountedFiber(fiber) {
          var node = fiber, nearestMounted = fiber;
          if (fiber.alternate) for (; node.return; ) node = node.return;
          else {
            fiber = node;
            do
              node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return;
            while (fiber);
          }
          return 3 === node.tag ? nearestMounted : null;
        }
        function getSuspenseInstanceFromFiber(fiber) {
          if (13 === fiber.tag) {
            var suspenseState = fiber.memoizedState;
            null === suspenseState && (fiber = fiber.alternate, null !== fiber && (suspenseState = fiber.memoizedState));
            if (null !== suspenseState) return suspenseState.dehydrated;
          }
          return null;
        }
        function getActivityInstanceFromFiber(fiber) {
          if (31 === fiber.tag) {
            var activityState = fiber.memoizedState;
            null === activityState && (fiber = fiber.alternate, null !== fiber && (activityState = fiber.memoizedState));
            if (null !== activityState) return activityState.dehydrated;
          }
          return null;
        }
        function assertIsMounted(fiber) {
          if (getNearestMountedFiber(fiber) !== fiber)
            throw Error("Unable to find node on an unmounted component.");
        }
        function findCurrentFiberUsingSlowPath(fiber) {
          var alternate = fiber.alternate;
          if (!alternate) {
            alternate = getNearestMountedFiber(fiber);
            if (null === alternate)
              throw Error("Unable to find node on an unmounted component.");
            return alternate !== fiber ? null : fiber;
          }
          for (var a5 = fiber, b3 = alternate; ; ) {
            var parentA = a5.return;
            if (null === parentA) break;
            var parentB = parentA.alternate;
            if (null === parentB) {
              b3 = parentA.return;
              if (null !== b3) {
                a5 = b3;
                continue;
              }
              break;
            }
            if (parentA.child === parentB.child) {
              for (parentB = parentA.child; parentB; ) {
                if (parentB === a5) return assertIsMounted(parentA), fiber;
                if (parentB === b3) return assertIsMounted(parentA), alternate;
                parentB = parentB.sibling;
              }
              throw Error("Unable to find node on an unmounted component.");
            }
            if (a5.return !== b3.return) a5 = parentA, b3 = parentB;
            else {
              for (var didFindChild = false, _child = parentA.child; _child; ) {
                if (_child === a5) {
                  didFindChild = true;
                  a5 = parentA;
                  b3 = parentB;
                  break;
                }
                if (_child === b3) {
                  didFindChild = true;
                  b3 = parentA;
                  a5 = parentB;
                  break;
                }
                _child = _child.sibling;
              }
              if (!didFindChild) {
                for (_child = parentB.child; _child; ) {
                  if (_child === a5) {
                    didFindChild = true;
                    a5 = parentB;
                    b3 = parentA;
                    break;
                  }
                  if (_child === b3) {
                    didFindChild = true;
                    b3 = parentB;
                    a5 = parentA;
                    break;
                  }
                  _child = _child.sibling;
                }
                if (!didFindChild)
                  throw Error(
                    "Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue."
                  );
              }
            }
            if (a5.alternate !== b3)
              throw Error(
                "Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue."
              );
          }
          if (3 !== a5.tag)
            throw Error("Unable to find node on an unmounted component.");
          return a5.stateNode.current === a5 ? fiber : alternate;
        }
        function findCurrentHostFiberImpl(node) {
          var tag = node.tag;
          if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
          for (node = node.child; null !== node; ) {
            tag = findCurrentHostFiberImpl(node);
            if (null !== tag) return tag;
            node = node.sibling;
          }
          return null;
        }
        function getIteratorFn(maybeIterable) {
          if (null === maybeIterable || "object" !== typeof maybeIterable)
            return null;
          maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
          return "function" === typeof maybeIterable ? maybeIterable : null;
        }
        function getComponentNameFromType(type) {
          if (null == type) return null;
          if ("function" === typeof type)
            return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
          if ("string" === typeof type) return type;
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
              return "Activity";
          }
          if ("object" === typeof type)
            switch ("number" === typeof type.tag && console.error(
              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
            ), type.$$typeof) {
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_CONTEXT_TYPE:
                return type.displayName || "Context";
              case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
              case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
              case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                  return getComponentNameFromType(type(innerType));
                } catch (x6) {
                }
            }
          return null;
        }
        function getComponentNameFromOwner(owner) {
          return "number" === typeof owner.tag ? getComponentNameFromFiber(owner) : "string" === typeof owner.name ? owner.name : null;
        }
        function getComponentNameFromFiber(fiber) {
          var type = fiber.type;
          switch (fiber.tag) {
            case 31:
              return "Activity";
            case 24:
              return "Cache";
            case 9:
              return (type._context.displayName || "Context") + ".Consumer";
            case 10:
              return type.displayName || "Context";
            case 18:
              return "DehydratedFragment";
            case 11:
              return fiber = type.render, fiber = fiber.displayName || fiber.name || "", type.displayName || ("" !== fiber ? "ForwardRef(" + fiber + ")" : "ForwardRef");
            case 7:
              return "Fragment";
            case 26:
            case 27:
            case 5:
              return type;
            case 4:
              return "Portal";
            case 3:
              return "Root";
            case 6:
              return "Text";
            case 16:
              return getComponentNameFromType(type);
            case 8:
              return type === REACT_STRICT_MODE_TYPE ? "StrictMode" : "Mode";
            case 22:
              return "Offscreen";
            case 12:
              return "Profiler";
            case 21:
              return "Scope";
            case 13:
              return "Suspense";
            case 19:
              return "SuspenseList";
            case 25:
              return "TracingMarker";
            case 1:
            case 0:
            case 14:
            case 15:
              if ("function" === typeof type)
                return type.displayName || type.name || null;
              if ("string" === typeof type) return type;
              break;
            case 29:
              type = fiber._debugInfo;
              if (null != type) {
                for (var i8 = type.length - 1; 0 <= i8; i8--)
                  if ("string" === typeof type[i8].name) return type[i8].name;
              }
              if (null !== fiber.return)
                return getComponentNameFromFiber(fiber.return);
          }
          return null;
        }
        function createCursor(defaultValue) {
          return { current: defaultValue };
        }
        function pop(cursor, fiber) {
          0 > index$jscomp$0 ? console.error("Unexpected pop.") : (fiber !== fiberStack[index$jscomp$0] && console.error("Unexpected Fiber popped."), cursor.current = valueStack[index$jscomp$0], valueStack[index$jscomp$0] = null, fiberStack[index$jscomp$0] = null, index$jscomp$0--);
        }
        function push(cursor, value, fiber) {
          index$jscomp$0++;
          valueStack[index$jscomp$0] = cursor.current;
          fiberStack[index$jscomp$0] = fiber;
          cursor.current = value;
        }
        function requiredContext(c7) {
          null === c7 && console.error(
            "Expected host context to exist. This error is likely caused by a bug in React. Please file an issue."
          );
          return c7;
        }
        function pushHostContainer(fiber, nextRootInstance) {
          push(rootInstanceStackCursor, nextRootInstance, fiber);
          push(contextFiberStackCursor, fiber, fiber);
          push(contextStackCursor, null, fiber);
          var nextRootContext = nextRootInstance.nodeType;
          switch (nextRootContext) {
            case 9:
            case 11:
              nextRootContext = 9 === nextRootContext ? "#document" : "#fragment";
              nextRootInstance = (nextRootInstance = nextRootInstance.documentElement) ? (nextRootInstance = nextRootInstance.namespaceURI) ? getOwnHostContext(nextRootInstance) : HostContextNamespaceNone : HostContextNamespaceNone;
              break;
            default:
              if (nextRootContext = nextRootInstance.tagName, nextRootInstance = nextRootInstance.namespaceURI)
                nextRootInstance = getOwnHostContext(nextRootInstance), nextRootInstance = getChildHostContextProd(
                  nextRootInstance,
                  nextRootContext
                );
              else
                switch (nextRootContext) {
                  case "svg":
                    nextRootInstance = HostContextNamespaceSvg;
                    break;
                  case "math":
                    nextRootInstance = HostContextNamespaceMath;
                    break;
                  default:
                    nextRootInstance = HostContextNamespaceNone;
                }
          }
          nextRootContext = nextRootContext.toLowerCase();
          nextRootContext = updatedAncestorInfoDev(null, nextRootContext);
          nextRootContext = {
            context: nextRootInstance,
            ancestorInfo: nextRootContext
          };
          pop(contextStackCursor, fiber);
          push(contextStackCursor, nextRootContext, fiber);
        }
        function popHostContainer(fiber) {
          pop(contextStackCursor, fiber);
          pop(contextFiberStackCursor, fiber);
          pop(rootInstanceStackCursor, fiber);
        }
        function getHostContext() {
          return requiredContext(contextStackCursor.current);
        }
        function pushHostContext(fiber) {
          null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber, fiber);
          var context = requiredContext(contextStackCursor.current);
          var type = fiber.type;
          var nextContext = getChildHostContextProd(context.context, type);
          type = updatedAncestorInfoDev(context.ancestorInfo, type);
          nextContext = { context: nextContext, ancestorInfo: type };
          context !== nextContext && (push(contextFiberStackCursor, fiber, fiber), push(contextStackCursor, nextContext, fiber));
        }
        function popHostContext(fiber) {
          contextFiberStackCursor.current === fiber && (pop(contextStackCursor, fiber), pop(contextFiberStackCursor, fiber));
          hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor, fiber), HostTransitionContext._currentValue = NotPendingTransition);
        }
        function disabledLog() {
        }
        function disableLogs() {
          if (0 === disabledDepth) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
        function reenableLogs() {
          disabledDepth--;
          if (0 === disabledDepth) {
            var props = { configurable: true, enumerable: true, writable: true };
            Object.defineProperties(console, {
              log: assign({}, props, { value: prevLog }),
              info: assign({}, props, { value: prevInfo }),
              warn: assign({}, props, { value: prevWarn }),
              error: assign({}, props, { value: prevError }),
              group: assign({}, props, { value: prevGroup }),
              groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),
              groupEnd: assign({}, props, { value: prevGroupEnd })
            });
          }
          0 > disabledDepth && console.error(
            "disabledDepth fell below zero. This is a bug in React. Please file an issue."
          );
        }
        function formatOwnerStack(error) {
          var prevPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          error = error.stack;
          Error.prepareStackTrace = prevPrepareStackTrace;
          error.startsWith("Error: react-stack-top-frame\n") && (error = error.slice(29));
          prevPrepareStackTrace = error.indexOf("\n");
          -1 !== prevPrepareStackTrace && (error = error.slice(prevPrepareStackTrace + 1));
          prevPrepareStackTrace = error.indexOf("react_stack_bottom_frame");
          -1 !== prevPrepareStackTrace && (prevPrepareStackTrace = error.lastIndexOf(
            "\n",
            prevPrepareStackTrace
          ));
          if (-1 !== prevPrepareStackTrace)
            error = error.slice(0, prevPrepareStackTrace);
          else return "";
          return error;
        }
        function describeBuiltInComponentFrame(name) {
          if (void 0 === prefix)
            try {
              throw Error();
            } catch (x6) {
              var match = x6.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
              suffix = -1 < x6.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x6.stack.indexOf("@") ? "@unknown:0:0" : "";
            }
          return "\n" + prefix + name + suffix;
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) return "";
          var frame = componentFrameCache.get(fn);
          if (void 0 !== frame) return frame;
          reentry = true;
          frame = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher2 = null;
          previousDispatcher2 = ReactSharedInternals.H;
          ReactSharedInternals.H = null;
          disableLogs();
          try {
            var RunInRootFrame = {
              DetermineComponentFrameRoot: function() {
                try {
                  if (construct) {
                    var Fake = function() {
                      throw Error();
                    };
                    Object.defineProperty(Fake.prototype, "props", {
                      set: function() {
                        throw Error();
                      }
                    });
                    if ("object" === typeof Reflect && Reflect.construct) {
                      try {
                        Reflect.construct(Fake, []);
                      } catch (x6) {
                        var control = x6;
                      }
                      Reflect.construct(fn, [], Fake);
                    } else {
                      try {
                        Fake.call();
                      } catch (x$0) {
                        control = x$0;
                      }
                      fn.call(Fake.prototype);
                    }
                  } else {
                    try {
                      throw Error();
                    } catch (x$1) {
                      control = x$1;
                    }
                    (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {
                    });
                  }
                } catch (sample) {
                  if (sample && control && "string" === typeof sample.stack)
                    return [sample.stack, control.stack];
                }
                return [null, null];
              }
            };
            RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
            var namePropDescriptor = Object.getOwnPropertyDescriptor(
              RunInRootFrame.DetermineComponentFrameRoot,
              "name"
            );
            namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
              RunInRootFrame.DetermineComponentFrameRoot,
              "name",
              { value: "DetermineComponentFrameRoot" }
            );
            var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
            if (sampleStack && controlStack) {
              var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
              for (_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes(
                "DetermineComponentFrameRoot"
              ); )
                namePropDescriptor++;
              for (; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes(
                "DetermineComponentFrameRoot"
              ); )
                _RunInRootFrame$Deter++;
              if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length)
                for (namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]; )
                  _RunInRootFrame$Deter--;
              for (; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)
                if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                  if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
                    do
                      if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                        var _frame = "\n" + sampleLines[namePropDescriptor].replace(
                          " at new ",
                          " at "
                        );
                        fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName));
                        "function" === typeof fn && componentFrameCache.set(fn, _frame);
                        return _frame;
                      }
                    while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
                  }
                  break;
                }
            }
          } finally {
            reentry = false, ReactSharedInternals.H = previousDispatcher2, reenableLogs(), Error.prepareStackTrace = frame;
          }
          sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
          "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
          return sampleLines;
        }
        function describeFiber(fiber, childFiber) {
          switch (fiber.tag) {
            case 26:
            case 27:
            case 5:
              return describeBuiltInComponentFrame(fiber.type);
            case 16:
              return describeBuiltInComponentFrame("Lazy");
            case 13:
              return fiber.child !== childFiber && null !== childFiber ? describeBuiltInComponentFrame("Suspense Fallback") : describeBuiltInComponentFrame("Suspense");
            case 19:
              return describeBuiltInComponentFrame("SuspenseList");
            case 0:
            case 15:
              return describeNativeComponentFrame(fiber.type, false);
            case 11:
              return describeNativeComponentFrame(fiber.type.render, false);
            case 1:
              return describeNativeComponentFrame(fiber.type, true);
            case 31:
              return describeBuiltInComponentFrame("Activity");
            default:
              return "";
          }
        }
        function getStackByFiberInDevAndProd(workInProgress2) {
          try {
            var info = "", previous = null;
            do {
              info += describeFiber(workInProgress2, previous);
              var debugInfo = workInProgress2._debugInfo;
              if (debugInfo)
                for (var i8 = debugInfo.length - 1; 0 <= i8; i8--) {
                  var entry = debugInfo[i8];
                  if ("string" === typeof entry.name) {
                    var JSCompiler_temp_const = info;
                    a: {
                      var name = entry.name, env = entry.env, location = entry.debugLocation;
                      if (null != location) {
                        var childStack = formatOwnerStack(location), idx = childStack.lastIndexOf("\n"), lastLine = -1 === idx ? childStack : childStack.slice(idx + 1);
                        if (-1 !== lastLine.indexOf(name)) {
                          var JSCompiler_inline_result = "\n" + lastLine;
                          break a;
                        }
                      }
                      JSCompiler_inline_result = describeBuiltInComponentFrame(
                        name + (env ? " [" + env + "]" : "")
                      );
                    }
                    info = JSCompiler_temp_const + JSCompiler_inline_result;
                  }
                }
              previous = workInProgress2;
              workInProgress2 = workInProgress2.return;
            } while (workInProgress2);
            return info;
          } catch (x6) {
            return "\nError generating stack: " + x6.message + "\n" + x6.stack;
          }
        }
        function describeFunctionComponentFrameWithoutLineNumber(fn) {
          return (fn = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(fn) : "";
        }
        function getCurrentFiberOwnerNameInDevOrNull() {
          if (null === current) return null;
          var owner = current._debugOwner;
          return null != owner ? getComponentNameFromOwner(owner) : null;
        }
        function getCurrentFiberStackInDev() {
          if (null === current) return "";
          var workInProgress2 = current;
          try {
            var info = "";
            6 === workInProgress2.tag && (workInProgress2 = workInProgress2.return);
            switch (workInProgress2.tag) {
              case 26:
              case 27:
              case 5:
                info += describeBuiltInComponentFrame(workInProgress2.type);
                break;
              case 13:
                info += describeBuiltInComponentFrame("Suspense");
                break;
              case 19:
                info += describeBuiltInComponentFrame("SuspenseList");
                break;
              case 31:
                info += describeBuiltInComponentFrame("Activity");
                break;
              case 30:
              case 0:
              case 15:
              case 1:
                workInProgress2._debugOwner || "" !== info || (info += describeFunctionComponentFrameWithoutLineNumber(
                  workInProgress2.type
                ));
                break;
              case 11:
                workInProgress2._debugOwner || "" !== info || (info += describeFunctionComponentFrameWithoutLineNumber(
                  workInProgress2.type.render
                ));
            }
            for (; workInProgress2; )
              if ("number" === typeof workInProgress2.tag) {
                var fiber = workInProgress2;
                workInProgress2 = fiber._debugOwner;
                var debugStack = fiber._debugStack;
                if (workInProgress2 && debugStack) {
                  var formattedStack = formatOwnerStack(debugStack);
                  "" !== formattedStack && (info += "\n" + formattedStack);
                }
              } else if (null != workInProgress2.debugStack) {
                var ownerStack = workInProgress2.debugStack;
                (workInProgress2 = workInProgress2.owner) && ownerStack && (info += "\n" + formatOwnerStack(ownerStack));
              } else break;
            var JSCompiler_inline_result = info;
          } catch (x6) {
            JSCompiler_inline_result = "\nError generating stack: " + x6.message + "\n" + x6.stack;
          }
          return JSCompiler_inline_result;
        }
        function runWithFiberInDEV(fiber, callback, arg0, arg1, arg2, arg3, arg4) {
          var previousFiber = current;
          setCurrentFiber(fiber);
          try {
            return null !== fiber && fiber._debugTask ? fiber._debugTask.run(
              callback.bind(null, arg0, arg1, arg2, arg3, arg4)
            ) : callback(arg0, arg1, arg2, arg3, arg4);
          } finally {
            setCurrentFiber(previousFiber);
          }
          throw Error(
            "runWithFiberInDEV should never be called in production. This is a bug in React."
          );
        }
        function setCurrentFiber(fiber) {
          ReactSharedInternals.getCurrentStack = null === fiber ? null : getCurrentFiberStackInDev;
          isRendering = false;
          current = fiber;
        }
        function typeName(value) {
          return "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
        }
        function willCoercionThrow(value) {
          try {
            return testStringCoercion(value), false;
          } catch (e2) {
            return true;
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkAttributeStringCoercion(value, attributeName) {
          if (willCoercionThrow(value))
            return console.error(
              "The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.",
              attributeName,
              typeName(value)
            ), testStringCoercion(value);
        }
        function checkCSSPropertyStringCoercion(value, propName) {
          if (willCoercionThrow(value))
            return console.error(
              "The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.",
              propName,
              typeName(value)
            ), testStringCoercion(value);
        }
        function checkFormFieldValueStringCoercion(value) {
          if (willCoercionThrow(value))
            return console.error(
              "Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before using it here.",
              typeName(value)
            ), testStringCoercion(value);
        }
        function injectInternals(internals) {
          if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return false;
          var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
          if (hook.isDisabled) return true;
          if (!hook.supportsFiber)
            return console.error(
              "The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://react.dev/link/react-devtools"
            ), true;
          try {
            rendererID = hook.inject(internals), injectedHook = hook;
          } catch (err) {
            console.error("React instrumentation encountered an error: %o.", err);
          }
          return hook.checkDCE ? true : false;
        }
        function setIsStrictModeForDevtools(newIsStrictMode) {
          "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
          if (injectedHook && "function" === typeof injectedHook.setStrictMode)
            try {
              injectedHook.setStrictMode(rendererID, newIsStrictMode);
            } catch (err) {
              hasLoggedError || (hasLoggedError = true, console.error(
                "React instrumentation encountered an error: %o",
                err
              ));
            }
        }
        function clz32Fallback(x6) {
          x6 >>>= 0;
          return 0 === x6 ? 32 : 31 - (log(x6) / LN2 | 0) | 0;
        }
        function getHighestPriorityLanes(lanes) {
          var pendingSyncLanes = lanes & 42;
          if (0 !== pendingSyncLanes) return pendingSyncLanes;
          switch (lanes & -lanes) {
            case 1:
              return 1;
            case 2:
              return 2;
            case 4:
              return 4;
            case 8:
              return 8;
            case 16:
              return 16;
            case 32:
              return 32;
            case 64:
              return 64;
            case 128:
              return 128;
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
              return lanes & 261888;
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return lanes & 3932160;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
              return lanes & 62914560;
            case 67108864:
              return 67108864;
            case 134217728:
              return 134217728;
            case 268435456:
              return 268435456;
            case 536870912:
              return 536870912;
            case 1073741824:
              return 0;
            default:
              return console.error(
                "Should have found matching lanes. This is a bug in React."
              ), lanes;
          }
        }
        function getNextLanes(root2, wipLanes, rootHasPendingCommit) {
          var pendingLanes = root2.pendingLanes;
          if (0 === pendingLanes) return 0;
          var nextLanes = 0, suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes;
          root2 = root2.warmLanes;
          var nonIdlePendingLanes = pendingLanes & 134217727;
          0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = nonIdlePendingLanes & ~root2, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = pendingLanes & ~root2, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
          return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, rootHasPendingCommit = wipLanes & -wipLanes, suspendedLanes >= rootHasPendingCommit || 32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)) ? wipLanes : nextLanes;
        }
        function checkIfRootIsPrerendering(root2, renderLanes2) {
          return 0 === (root2.pendingLanes & ~(root2.suspendedLanes & ~root2.pingedLanes) & renderLanes2);
        }
        function computeExpirationTime(lane, currentTime) {
          switch (lane) {
            case 1:
            case 2:
            case 4:
            case 8:
            case 64:
              return currentTime + 250;
            case 16:
            case 32:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return currentTime + 5e3;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
              return -1;
            case 67108864:
            case 134217728:
            case 268435456:
            case 536870912:
            case 1073741824:
              return -1;
            default:
              return console.error(
                "Should have found matching lanes. This is a bug in React."
              ), -1;
          }
        }
        function claimNextRetryLane() {
          var lane = nextRetryLane;
          nextRetryLane <<= 1;
          0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
          return lane;
        }
        function createLaneMap(initial) {
          for (var laneMap = [], i8 = 0; 31 > i8; i8++) laneMap.push(initial);
          return laneMap;
        }
        function markRootUpdated$1(root2, updateLane) {
          root2.pendingLanes |= updateLane;
          268435456 !== updateLane && (root2.suspendedLanes = 0, root2.pingedLanes = 0, root2.warmLanes = 0);
        }
        function markRootFinished(root2, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
          var previouslyPendingLanes = root2.pendingLanes;
          root2.pendingLanes = remainingLanes;
          root2.suspendedLanes = 0;
          root2.pingedLanes = 0;
          root2.warmLanes = 0;
          root2.expiredLanes &= remainingLanes;
          root2.entangledLanes &= remainingLanes;
          root2.errorRecoveryDisabledLanes &= remainingLanes;
          root2.shellSuspendCounter = 0;
          var entanglements = root2.entanglements, expirationTimes = root2.expirationTimes, hiddenUpdates = root2.hiddenUpdates;
          for (remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes; ) {
            var index = 31 - clz32(remainingLanes), lane = 1 << index;
            entanglements[index] = 0;
            expirationTimes[index] = -1;
            var hiddenUpdatesForLane = hiddenUpdates[index];
            if (null !== hiddenUpdatesForLane)
              for (hiddenUpdates[index] = null, index = 0; index < hiddenUpdatesForLane.length; index++) {
                var update = hiddenUpdatesForLane[index];
                null !== update && (update.lane &= -536870913);
              }
            remainingLanes &= ~lane;
          }
          0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, 0);
          0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root2.tag && (root2.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
        }
        function markSpawnedDeferredLane(root2, spawnedLane, entangledLanes) {
          root2.pendingLanes |= spawnedLane;
          root2.suspendedLanes &= ~spawnedLane;
          var spawnedLaneIndex = 31 - clz32(spawnedLane);
          root2.entangledLanes |= spawnedLane;
          root2.entanglements[spawnedLaneIndex] = root2.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 261930;
        }
        function markRootEntangled(root2, entangledLanes) {
          var rootEntangledLanes = root2.entangledLanes |= entangledLanes;
          for (root2 = root2.entanglements; rootEntangledLanes; ) {
            var index = 31 - clz32(rootEntangledLanes), lane = 1 << index;
            lane & entangledLanes | root2[index] & entangledLanes && (root2[index] |= entangledLanes);
            rootEntangledLanes &= ~lane;
          }
        }
        function getBumpedLaneForHydration(root2, renderLanes2) {
          var renderLane = renderLanes2 & -renderLanes2;
          renderLane = 0 !== (renderLane & 42) ? 1 : getBumpedLaneForHydrationByLane(renderLane);
          return 0 !== (renderLane & (root2.suspendedLanes | renderLanes2)) ? 0 : renderLane;
        }
        function getBumpedLaneForHydrationByLane(lane) {
          switch (lane) {
            case 2:
              lane = 1;
              break;
            case 8:
              lane = 4;
              break;
            case 32:
              lane = 16;
              break;
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
              lane = 128;
              break;
            case 268435456:
              lane = 134217728;
              break;
            default:
              lane = 0;
          }
          return lane;
        }
        function addFiberToLanesMap(root2, fiber, lanes) {
          if (isDevToolsPresent)
            for (root2 = root2.pendingUpdatersLaneMap; 0 < lanes; ) {
              var index = 31 - clz32(lanes), lane = 1 << index;
              root2[index].add(fiber);
              lanes &= ~lane;
            }
        }
        function movePendingFibersToMemoized(root2, lanes) {
          if (isDevToolsPresent)
            for (var pendingUpdatersLaneMap = root2.pendingUpdatersLaneMap, memoizedUpdaters = root2.memoizedUpdaters; 0 < lanes; ) {
              var index = 31 - clz32(lanes);
              root2 = 1 << index;
              index = pendingUpdatersLaneMap[index];
              0 < index.size && (index.forEach(function(fiber) {
                var alternate = fiber.alternate;
                null !== alternate && memoizedUpdaters.has(alternate) || memoizedUpdaters.add(fiber);
              }), index.clear());
              lanes &= ~root2;
            }
        }
        function lanesToEventPriority(lanes) {
          lanes &= -lanes;
          return 0 !== DiscreteEventPriority && DiscreteEventPriority < lanes ? 0 !== ContinuousEventPriority && ContinuousEventPriority < lanes ? 0 !== (lanes & 134217727) ? DefaultEventPriority : IdleEventPriority : ContinuousEventPriority : DiscreteEventPriority;
        }
        function resolveUpdatePriority() {
          var updatePriority = ReactDOMSharedInternals.p;
          if (0 !== updatePriority) return updatePriority;
          updatePriority = window.event;
          return void 0 === updatePriority ? DefaultEventPriority : getEventPriority(updatePriority.type);
        }
        function runWithPriority(priority, fn) {
          var previousPriority = ReactDOMSharedInternals.p;
          try {
            return ReactDOMSharedInternals.p = priority, fn();
          } finally {
            ReactDOMSharedInternals.p = previousPriority;
          }
        }
        function detachDeletedInstance(node) {
          delete node[internalInstanceKey];
          delete node[internalPropsKey];
          delete node[internalEventHandlersKey];
          delete node[internalEventHandlerListenersKey];
          delete node[internalEventHandlesSetKey];
        }
        function getClosestInstanceFromNode(targetNode) {
          var targetInst = targetNode[internalInstanceKey];
          if (targetInst) return targetInst;
          for (var parentNode = targetNode.parentNode; parentNode; ) {
            if (targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey]) {
              parentNode = targetInst.alternate;
              if (null !== targetInst.child || null !== parentNode && null !== parentNode.child)
                for (targetNode = getParentHydrationBoundary(targetNode); null !== targetNode; ) {
                  if (parentNode = targetNode[internalInstanceKey])
                    return parentNode;
                  targetNode = getParentHydrationBoundary(targetNode);
                }
              return targetInst;
            }
            targetNode = parentNode;
            parentNode = targetNode.parentNode;
          }
          return null;
        }
        function getInstanceFromNode(node) {
          if (node = node[internalInstanceKey] || node[internalContainerInstanceKey]) {
            var tag = node.tag;
            if (5 === tag || 6 === tag || 13 === tag || 31 === tag || 26 === tag || 27 === tag || 3 === tag)
              return node;
          }
          return null;
        }
        function getNodeFromInstance(inst) {
          var tag = inst.tag;
          if (5 === tag || 26 === tag || 27 === tag || 6 === tag)
            return inst.stateNode;
          throw Error("getNodeFromInstance: Invalid argument.");
        }
        function getResourcesFromRoot(root2) {
          var resources = root2[internalRootNodeResourcesKey];
          resources || (resources = root2[internalRootNodeResourcesKey] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() });
          return resources;
        }
        function markNodeAsHoistable(node) {
          node[internalHoistableMarker] = true;
        }
        function registerTwoPhaseEvent(registrationName, dependencies) {
          registerDirectEvent(registrationName, dependencies);
          registerDirectEvent(registrationName + "Capture", dependencies);
        }
        function registerDirectEvent(registrationName, dependencies) {
          registrationNameDependencies[registrationName] && console.error(
            "EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.",
            registrationName
          );
          registrationNameDependencies[registrationName] = dependencies;
          var lowerCasedName = registrationName.toLowerCase();
          possibleRegistrationNames[lowerCasedName] = registrationName;
          "onDoubleClick" === registrationName && (possibleRegistrationNames.ondblclick = registrationName);
          for (registrationName = 0; registrationName < dependencies.length; registrationName++)
            allNativeEvents.add(dependencies[registrationName]);
        }
        function checkControlledValueProps(tagName, props) {
          hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || null == props.value || ("select" === tagName ? console.error(
            "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`."
          ) : console.error(
            "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."
          ));
          props.onChange || props.readOnly || props.disabled || null == props.checked || console.error(
            "You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`."
          );
        }
        function isAttributeNameSafe(attributeName) {
          if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
            return true;
          if (hasOwnProperty.call(illegalAttributeNameCache, attributeName))
            return false;
          if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
            return validatedAttributeNameCache[attributeName] = true;
          illegalAttributeNameCache[attributeName] = true;
          console.error("Invalid attribute name: `%s`", attributeName);
          return false;
        }
        function getValueForAttributeOnCustomComponent(node, name, expected) {
          if (isAttributeNameSafe(name)) {
            if (!node.hasAttribute(name)) {
              switch (typeof expected) {
                case "symbol":
                case "object":
                  return expected;
                case "function":
                  return expected;
                case "boolean":
                  if (false === expected) return expected;
              }
              return void 0 === expected ? void 0 : null;
            }
            node = node.getAttribute(name);
            if ("" === node && true === expected) return true;
            checkAttributeStringCoercion(expected, name);
            return node === "" + expected ? expected : node;
          }
        }
        function setValueForAttribute(node, name, value) {
          if (isAttributeNameSafe(name))
            if (null === value) node.removeAttribute(name);
            else {
              switch (typeof value) {
                case "undefined":
                case "function":
                case "symbol":
                  node.removeAttribute(name);
                  return;
                case "boolean":
                  var prefix2 = name.toLowerCase().slice(0, 5);
                  if ("data-" !== prefix2 && "aria-" !== prefix2) {
                    node.removeAttribute(name);
                    return;
                  }
              }
              checkAttributeStringCoercion(value, name);
              node.setAttribute(name, "" + value);
            }
        }
        function setValueForKnownAttribute(node, name, value) {
          if (null === value) node.removeAttribute(name);
          else {
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                node.removeAttribute(name);
                return;
            }
            checkAttributeStringCoercion(value, name);
            node.setAttribute(name, "" + value);
          }
        }
        function setValueForNamespacedAttribute(node, namespace, name, value) {
          if (null === value) node.removeAttribute(name);
          else {
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                node.removeAttribute(name);
                return;
            }
            checkAttributeStringCoercion(value, name);
            node.setAttributeNS(namespace, name, "" + value);
          }
        }
        function getToStringValue(value) {
          switch (typeof value) {
            case "bigint":
            case "boolean":
            case "number":
            case "string":
            case "undefined":
              return value;
            case "object":
              return checkFormFieldValueStringCoercion(value), value;
            default:
              return "";
          }
        }
        function isCheckable(elem) {
          var type = elem.type;
          return (elem = elem.nodeName) && "input" === elem.toLowerCase() && ("checkbox" === type || "radio" === type);
        }
        function trackValueOnNode(node, valueField, currentValue) {
          var descriptor = Object.getOwnPropertyDescriptor(
            node.constructor.prototype,
            valueField
          );
          if (!node.hasOwnProperty(valueField) && "undefined" !== typeof descriptor && "function" === typeof descriptor.get && "function" === typeof descriptor.set) {
            var get = descriptor.get, set = descriptor.set;
            Object.defineProperty(node, valueField, {
              configurable: true,
              get: function() {
                return get.call(this);
              },
              set: function(value) {
                checkFormFieldValueStringCoercion(value);
                currentValue = "" + value;
                set.call(this, value);
              }
            });
            Object.defineProperty(node, valueField, {
              enumerable: descriptor.enumerable
            });
            return {
              getValue: function() {
                return currentValue;
              },
              setValue: function(value) {
                checkFormFieldValueStringCoercion(value);
                currentValue = "" + value;
              },
              stopTracking: function() {
                node._valueTracker = null;
                delete node[valueField];
              }
            };
          }
        }
        function track(node) {
          if (!node._valueTracker) {
            var valueField = isCheckable(node) ? "checked" : "value";
            node._valueTracker = trackValueOnNode(
              node,
              valueField,
              "" + node[valueField]
            );
          }
        }
        function updateValueIfChanged(node) {
          if (!node) return false;
          var tracker = node._valueTracker;
          if (!tracker) return true;
          var lastValue = tracker.getValue();
          var value = "";
          node && (value = isCheckable(node) ? node.checked ? "true" : "false" : node.value);
          node = value;
          return node !== lastValue ? (tracker.setValue(node), true) : false;
        }
        function getActiveElement(doc) {
          doc = doc || ("undefined" !== typeof document ? document : void 0);
          if ("undefined" === typeof doc) return null;
          try {
            return doc.activeElement || doc.body;
          } catch (e2) {
            return doc.body;
          }
        }
        function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
          return value.replace(
            escapeSelectorAttributeValueInsideDoubleQuotesRegex,
            function(ch) {
              return "\\" + ch.charCodeAt(0).toString(16) + " ";
            }
          );
        }
        function validateInputProps(element, props) {
          void 0 === props.checked || void 0 === props.defaultChecked || didWarnCheckedDefaultChecked || (console.error(
            "%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
            getCurrentFiberOwnerNameInDevOrNull() || "A component",
            props.type
          ), didWarnCheckedDefaultChecked = true);
          void 0 === props.value || void 0 === props.defaultValue || didWarnValueDefaultValue$1 || (console.error(
            "%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
            getCurrentFiberOwnerNameInDevOrNull() || "A component",
            props.type
          ), didWarnValueDefaultValue$1 = true);
        }
        function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name) {
          element.name = "";
          null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type ? (checkAttributeStringCoercion(type, "type"), element.type = type) : element.removeAttribute("type");
          if (null != value)
            if ("number" === type) {
              if (0 === value && "" === element.value || element.value != value)
                element.value = "" + getToStringValue(value);
            } else
              element.value !== "" + getToStringValue(value) && (element.value = "" + getToStringValue(value));
          else
            "submit" !== type && "reset" !== type || element.removeAttribute("value");
          null != value ? setDefaultValue(element, type, getToStringValue(value)) : null != defaultValue ? setDefaultValue(element, type, getToStringValue(defaultValue)) : null != lastDefaultValue && element.removeAttribute("value");
          null == checked && null != defaultChecked && (element.defaultChecked = !!defaultChecked);
          null != checked && (element.checked = checked && "function" !== typeof checked && "symbol" !== typeof checked);
          null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name ? (checkAttributeStringCoercion(name, "name"), element.name = "" + getToStringValue(name)) : element.removeAttribute("name");
        }
        function initInput(element, value, defaultValue, checked, defaultChecked, type, name, isHydrating2) {
          null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type && (checkAttributeStringCoercion(type, "type"), element.type = type);
          if (null != value || null != defaultValue) {
            if (!("submit" !== type && "reset" !== type || void 0 !== value && null !== value)) {
              track(element);
              return;
            }
            defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
            value = null != value ? "" + getToStringValue(value) : defaultValue;
            isHydrating2 || value === element.value || (element.value = value);
            element.defaultValue = value;
          }
          checked = null != checked ? checked : defaultChecked;
          checked = "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
          element.checked = isHydrating2 ? element.checked : !!checked;
          element.defaultChecked = !!checked;
          null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name && (checkAttributeStringCoercion(name, "name"), element.name = name);
          track(element);
        }
        function setDefaultValue(node, type, value) {
          "number" === type && getActiveElement(node.ownerDocument) === node || node.defaultValue === "" + value || (node.defaultValue = "" + value);
        }
        function validateOptionProps(element, props) {
          null == props.value && ("object" === typeof props.children && null !== props.children ? React2.Children.forEach(props.children, function(child) {
            null == child || "string" === typeof child || "number" === typeof child || "bigint" === typeof child || didWarnInvalidChild || (didWarnInvalidChild = true, console.error(
              "Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>."
            ));
          }) : null == props.dangerouslySetInnerHTML || didWarnInvalidInnerHTML || (didWarnInvalidInnerHTML = true, console.error(
            "Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."
          )));
          null == props.selected || didWarnSelectedSetOnOption || (console.error(
            "Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."
          ), didWarnSelectedSetOnOption = true);
        }
        function getDeclarationErrorAddendum() {
          var ownerName = getCurrentFiberOwnerNameInDevOrNull();
          return ownerName ? "\n\nCheck the render method of `" + ownerName + "`." : "";
        }
        function updateOptions(node, multiple, propValue, setDefaultSelected) {
          node = node.options;
          if (multiple) {
            multiple = {};
            for (var i8 = 0; i8 < propValue.length; i8++)
              multiple["$" + propValue[i8]] = true;
            for (propValue = 0; propValue < node.length; propValue++)
              i8 = multiple.hasOwnProperty("$" + node[propValue].value), node[propValue].selected !== i8 && (node[propValue].selected = i8), i8 && setDefaultSelected && (node[propValue].defaultSelected = true);
          } else {
            propValue = "" + getToStringValue(propValue);
            multiple = null;
            for (i8 = 0; i8 < node.length; i8++) {
              if (node[i8].value === propValue) {
                node[i8].selected = true;
                setDefaultSelected && (node[i8].defaultSelected = true);
                return;
              }
              null !== multiple || node[i8].disabled || (multiple = node[i8]);
            }
            null !== multiple && (multiple.selected = true);
          }
        }
        function validateSelectProps(element, props) {
          for (element = 0; element < valuePropNames.length; element++) {
            var propName = valuePropNames[element];
            if (null != props[propName]) {
              var propNameIsArray = isArrayImpl(props[propName]);
              props.multiple && !propNameIsArray ? console.error(
                "The `%s` prop supplied to <select> must be an array if `multiple` is true.%s",
                propName,
                getDeclarationErrorAddendum()
              ) : !props.multiple && propNameIsArray && console.error(
                "The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s",
                propName,
                getDeclarationErrorAddendum()
              );
            }
          }
          void 0 === props.value || void 0 === props.defaultValue || didWarnValueDefaultValue || (console.error(
            "Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components"
          ), didWarnValueDefaultValue = true);
        }
        function validateTextareaProps(element, props) {
          void 0 === props.value || void 0 === props.defaultValue || didWarnValDefaultVal || (console.error(
            "%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components",
            getCurrentFiberOwnerNameInDevOrNull() || "A component"
          ), didWarnValDefaultVal = true);
          null != props.children && null == props.value && console.error(
            "Use the `defaultValue` or `value` props instead of setting children on <textarea>."
          );
        }
        function updateTextarea(element, value, defaultValue) {
          if (null != value && (value = "" + getToStringValue(value), value !== element.value && (element.value = value), null == defaultValue)) {
            element.defaultValue !== value && (element.defaultValue = value);
            return;
          }
          element.defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
        }
        function initTextarea(element, value, defaultValue, children) {
          if (null == value) {
            if (null != children) {
              if (null != defaultValue)
                throw Error(
                  "If you supply `defaultValue` on a <textarea>, do not pass children."
                );
              if (isArrayImpl(children)) {
                if (1 < children.length)
                  throw Error("<textarea> can only have at most one child.");
                children = children[0];
              }
              defaultValue = children;
            }
            null == defaultValue && (defaultValue = "");
            value = defaultValue;
          }
          defaultValue = getToStringValue(value);
          element.defaultValue = defaultValue;
          children = element.textContent;
          children === defaultValue && "" !== children && null !== children && (element.value = children);
          track(element);
        }
        function findNotableNode(node, indent) {
          return void 0 === node.serverProps && 0 === node.serverTail.length && 1 === node.children.length && 3 < node.distanceFromLeaf && node.distanceFromLeaf > 15 - indent ? findNotableNode(node.children[0], indent) : node;
        }
        function indentation(indent) {
          return "  " + "  ".repeat(indent);
        }
        function added(indent) {
          return "+ " + "  ".repeat(indent);
        }
        function removed(indent) {
          return "- " + "  ".repeat(indent);
        }
        function describeFiberType(fiber) {
          switch (fiber.tag) {
            case 26:
            case 27:
            case 5:
              return fiber.type;
            case 16:
              return "Lazy";
            case 31:
              return "Activity";
            case 13:
              return "Suspense";
            case 19:
              return "SuspenseList";
            case 0:
            case 15:
              return fiber = fiber.type, fiber.displayName || fiber.name || null;
            case 11:
              return fiber = fiber.type.render, fiber.displayName || fiber.name || null;
            case 1:
              return fiber = fiber.type, fiber.displayName || fiber.name || null;
            default:
              return null;
          }
        }
        function describeTextNode(content, maxLength) {
          return needsEscaping.test(content) ? (content = JSON.stringify(content), content.length > maxLength - 2 ? 8 > maxLength ? '{"..."}' : "{" + content.slice(0, maxLength - 7) + '..."}' : "{" + content + "}") : content.length > maxLength ? 5 > maxLength ? '{"..."}' : content.slice(0, maxLength - 3) + "..." : content;
        }
        function describeTextDiff(clientText, serverProps, indent) {
          var maxLength = 120 - 2 * indent;
          if (null === serverProps)
            return added(indent) + describeTextNode(clientText, maxLength) + "\n";
          if ("string" === typeof serverProps) {
            for (var firstDiff = 0; firstDiff < serverProps.length && firstDiff < clientText.length && serverProps.charCodeAt(firstDiff) === clientText.charCodeAt(firstDiff); firstDiff++) ;
            firstDiff > maxLength - 8 && 10 < firstDiff && (clientText = "..." + clientText.slice(firstDiff - 8), serverProps = "..." + serverProps.slice(firstDiff - 8));
            return added(indent) + describeTextNode(clientText, maxLength) + "\n" + removed(indent) + describeTextNode(serverProps, maxLength) + "\n";
          }
          return indentation(indent) + describeTextNode(clientText, maxLength) + "\n";
        }
        function objectName(object) {
          return Object.prototype.toString.call(object).replace(/^\[object (.*)\]$/, function(m5, p0) {
            return p0;
          });
        }
        function describeValue(value, maxLength) {
          switch (typeof value) {
            case "string":
              return value = JSON.stringify(value), value.length > maxLength ? 5 > maxLength ? '"..."' : value.slice(0, maxLength - 4) + '..."' : value;
            case "object":
              if (null === value) return "null";
              if (isArrayImpl(value)) return "[...]";
              if (value.$$typeof === REACT_ELEMENT_TYPE)
                return (maxLength = getComponentNameFromType(value.type)) ? "<" + maxLength + ">" : "<...>";
              var name = objectName(value);
              if ("Object" === name) {
                name = "";
                maxLength -= 2;
                for (var propName in value)
                  if (value.hasOwnProperty(propName)) {
                    var jsonPropName = JSON.stringify(propName);
                    jsonPropName !== '"' + propName + '"' && (propName = jsonPropName);
                    maxLength -= propName.length - 2;
                    jsonPropName = describeValue(
                      value[propName],
                      15 > maxLength ? maxLength : 15
                    );
                    maxLength -= jsonPropName.length;
                    if (0 > maxLength) {
                      name += "" === name ? "..." : ", ...";
                      break;
                    }
                    name += ("" === name ? "" : ",") + propName + ":" + jsonPropName;
                  }
                return "{" + name + "}";
              }
              return name;
            case "function":
              return (maxLength = value.displayName || value.name) ? "function " + maxLength : "function";
            default:
              return String(value);
          }
        }
        function describePropValue(value, maxLength) {
          return "string" !== typeof value || needsEscaping.test(value) ? "{" + describeValue(value, maxLength - 2) + "}" : value.length > maxLength - 2 ? 5 > maxLength ? '"..."' : '"' + value.slice(0, maxLength - 5) + '..."' : '"' + value + '"';
        }
        function describeExpandedElement(type, props, rowPrefix) {
          var remainingRowLength = 120 - rowPrefix.length - type.length, properties = [], propName;
          for (propName in props)
            if (props.hasOwnProperty(propName) && "children" !== propName) {
              var propValue = describePropValue(
                props[propName],
                120 - rowPrefix.length - propName.length - 1
              );
              remainingRowLength -= propName.length + propValue.length + 2;
              properties.push(propName + "=" + propValue);
            }
          return 0 === properties.length ? rowPrefix + "<" + type + ">\n" : 0 < remainingRowLength ? rowPrefix + "<" + type + " " + properties.join(" ") + ">\n" : rowPrefix + "<" + type + "\n" + rowPrefix + "  " + properties.join("\n" + rowPrefix + "  ") + "\n" + rowPrefix + ">\n";
        }
        function describePropertiesDiff(clientObject, serverObject, indent) {
          var properties = "", remainingServerProperties = assign({}, serverObject), propName;
          for (propName in clientObject)
            if (clientObject.hasOwnProperty(propName)) {
              delete remainingServerProperties[propName];
              var maxLength = 120 - 2 * indent - propName.length - 2, clientPropValue = describeValue(clientObject[propName], maxLength);
              serverObject.hasOwnProperty(propName) ? (maxLength = describeValue(serverObject[propName], maxLength), properties += added(indent) + propName + ": " + clientPropValue + "\n", properties += removed(indent) + propName + ": " + maxLength + "\n") : properties += added(indent) + propName + ": " + clientPropValue + "\n";
            }
          for (var _propName in remainingServerProperties)
            remainingServerProperties.hasOwnProperty(_propName) && (clientObject = describeValue(
              remainingServerProperties[_propName],
              120 - 2 * indent - _propName.length - 2
            ), properties += removed(indent) + _propName + ": " + clientObject + "\n");
          return properties;
        }
        function describeElementDiff(type, clientProps, serverProps, indent) {
          var content = "", serverPropNames = /* @__PURE__ */ new Map();
          for (propName$jscomp$0 in serverProps)
            serverProps.hasOwnProperty(propName$jscomp$0) && serverPropNames.set(
              propName$jscomp$0.toLowerCase(),
              propName$jscomp$0
            );
          if (1 === serverPropNames.size && serverPropNames.has("children"))
            content += describeExpandedElement(
              type,
              clientProps,
              indentation(indent)
            );
          else {
            for (var _propName2 in clientProps)
              if (clientProps.hasOwnProperty(_propName2) && "children" !== _propName2) {
                var maxLength$jscomp$0 = 120 - 2 * (indent + 1) - _propName2.length - 1, serverPropName = serverPropNames.get(_propName2.toLowerCase());
                if (void 0 !== serverPropName) {
                  serverPropNames.delete(_propName2.toLowerCase());
                  var propName$jscomp$0 = clientProps[_propName2];
                  serverPropName = serverProps[serverPropName];
                  var clientPropValue = describePropValue(
                    propName$jscomp$0,
                    maxLength$jscomp$0
                  );
                  maxLength$jscomp$0 = describePropValue(
                    serverPropName,
                    maxLength$jscomp$0
                  );
                  "object" === typeof propName$jscomp$0 && null !== propName$jscomp$0 && "object" === typeof serverPropName && null !== serverPropName && "Object" === objectName(propName$jscomp$0) && "Object" === objectName(serverPropName) && (2 < Object.keys(propName$jscomp$0).length || 2 < Object.keys(serverPropName).length || -1 < clientPropValue.indexOf("...") || -1 < maxLength$jscomp$0.indexOf("...")) ? content += indentation(indent + 1) + _propName2 + "={{\n" + describePropertiesDiff(
                    propName$jscomp$0,
                    serverPropName,
                    indent + 2
                  ) + indentation(indent + 1) + "}}\n" : (content += added(indent + 1) + _propName2 + "=" + clientPropValue + "\n", content += removed(indent + 1) + _propName2 + "=" + maxLength$jscomp$0 + "\n");
                } else
                  content += indentation(indent + 1) + _propName2 + "=" + describePropValue(clientProps[_propName2], maxLength$jscomp$0) + "\n";
              }
            serverPropNames.forEach(function(propName) {
              if ("children" !== propName) {
                var maxLength = 120 - 2 * (indent + 1) - propName.length - 1;
                content += removed(indent + 1) + propName + "=" + describePropValue(serverProps[propName], maxLength) + "\n";
              }
            });
            content = "" === content ? indentation(indent) + "<" + type + ">\n" : indentation(indent) + "<" + type + "\n" + content + indentation(indent) + ">\n";
          }
          type = serverProps.children;
          clientProps = clientProps.children;
          if ("string" === typeof type || "number" === typeof type || "bigint" === typeof type) {
            serverPropNames = "";
            if ("string" === typeof clientProps || "number" === typeof clientProps || "bigint" === typeof clientProps)
              serverPropNames = "" + clientProps;
            content += describeTextDiff(serverPropNames, "" + type, indent + 1);
          } else if ("string" === typeof clientProps || "number" === typeof clientProps || "bigint" === typeof clientProps)
            content = null == type ? content + describeTextDiff("" + clientProps, null, indent + 1) : content + describeTextDiff("" + clientProps, void 0, indent + 1);
          return content;
        }
        function describeSiblingFiber(fiber, indent) {
          var type = describeFiberType(fiber);
          if (null === type) {
            type = "";
            for (fiber = fiber.child; fiber; )
              type += describeSiblingFiber(fiber, indent), fiber = fiber.sibling;
            return type;
          }
          return indentation(indent) + "<" + type + ">\n";
        }
        function describeNode(node, indent) {
          var skipToNode = findNotableNode(node, indent);
          if (skipToNode !== node && (1 !== node.children.length || node.children[0] !== skipToNode))
            return indentation(indent) + "...\n" + describeNode(skipToNode, indent + 1);
          skipToNode = "";
          var debugInfo = node.fiber._debugInfo;
          if (debugInfo)
            for (var i8 = 0; i8 < debugInfo.length; i8++) {
              var serverComponentName = debugInfo[i8].name;
              "string" === typeof serverComponentName && (skipToNode += indentation(indent) + "<" + serverComponentName + ">\n", indent++);
            }
          debugInfo = "";
          i8 = node.fiber.pendingProps;
          if (6 === node.fiber.tag)
            debugInfo = describeTextDiff(i8, node.serverProps, indent), indent++;
          else if (serverComponentName = describeFiberType(node.fiber), null !== serverComponentName)
            if (void 0 === node.serverProps) {
              debugInfo = indent;
              var maxLength = 120 - 2 * debugInfo - serverComponentName.length - 2, content = "";
              for (propName in i8)
                if (i8.hasOwnProperty(propName) && "children" !== propName) {
                  var propValue = describePropValue(i8[propName], 15);
                  maxLength -= propName.length + propValue.length + 2;
                  if (0 > maxLength) {
                    content += " ...";
                    break;
                  }
                  content += " " + propName + "=" + propValue;
                }
              debugInfo = indentation(debugInfo) + "<" + serverComponentName + content + ">\n";
              indent++;
            } else
              null === node.serverProps ? (debugInfo = describeExpandedElement(
                serverComponentName,
                i8,
                added(indent)
              ), indent++) : "string" === typeof node.serverProps ? console.error(
                "Should not have matched a non HostText fiber to a Text node. This is a bug in React."
              ) : (debugInfo = describeElementDiff(
                serverComponentName,
                i8,
                node.serverProps,
                indent
              ), indent++);
          var propName = "";
          i8 = node.fiber.child;
          for (serverComponentName = 0; i8 && serverComponentName < node.children.length; )
            maxLength = node.children[serverComponentName], maxLength.fiber === i8 ? (propName += describeNode(maxLength, indent), serverComponentName++) : propName += describeSiblingFiber(i8, indent), i8 = i8.sibling;
          i8 && 0 < node.children.length && (propName += indentation(indent) + "...\n");
          i8 = node.serverTail;
          null === node.serverProps && indent--;
          for (node = 0; node < i8.length; node++)
            serverComponentName = i8[node], propName = "string" === typeof serverComponentName ? propName + (removed(indent) + describeTextNode(serverComponentName, 120 - 2 * indent) + "\n") : propName + describeExpandedElement(
              serverComponentName.type,
              serverComponentName.props,
              removed(indent)
            );
          return skipToNode + debugInfo + propName;
        }
        function describeDiff(rootNode) {
          try {
            return "\n\n" + describeNode(rootNode, 0);
          } catch (x6) {
            return "";
          }
        }
        function describeAncestors(ancestor, child, props) {
          for (var fiber = child, node = null, distanceFromLeaf = 0; fiber; )
            fiber === ancestor && (distanceFromLeaf = 0), node = {
              fiber,
              children: null !== node ? [node] : [],
              serverProps: fiber === child ? props : fiber === ancestor ? null : void 0,
              serverTail: [],
              distanceFromLeaf
            }, distanceFromLeaf++, fiber = fiber.return;
          return null !== node ? describeDiff(node).replaceAll(/^[+-]/gm, ">") : "";
        }
        function updatedAncestorInfoDev(oldInfo, tag) {
          var ancestorInfo = assign({}, oldInfo || emptyAncestorInfoDev), info = { tag };
          -1 !== inScopeTags.indexOf(tag) && (ancestorInfo.aTagInScope = null, ancestorInfo.buttonTagInScope = null, ancestorInfo.nobrTagInScope = null);
          -1 !== buttonScopeTags.indexOf(tag) && (ancestorInfo.pTagInButtonScope = null);
          -1 !== specialTags.indexOf(tag) && "address" !== tag && "div" !== tag && "p" !== tag && (ancestorInfo.listItemTagAutoclosing = null, ancestorInfo.dlItemTagAutoclosing = null);
          ancestorInfo.current = info;
          "form" === tag && (ancestorInfo.formTag = info);
          "a" === tag && (ancestorInfo.aTagInScope = info);
          "button" === tag && (ancestorInfo.buttonTagInScope = info);
          "nobr" === tag && (ancestorInfo.nobrTagInScope = info);
          "p" === tag && (ancestorInfo.pTagInButtonScope = info);
          "li" === tag && (ancestorInfo.listItemTagAutoclosing = info);
          if ("dd" === tag || "dt" === tag)
            ancestorInfo.dlItemTagAutoclosing = info;
          "#document" === tag || "html" === tag ? ancestorInfo.containerTagInScope = null : ancestorInfo.containerTagInScope || (ancestorInfo.containerTagInScope = info);
          null !== oldInfo || "#document" !== tag && "html" !== tag && "body" !== tag ? true === ancestorInfo.implicitRootScope && (ancestorInfo.implicitRootScope = false) : ancestorInfo.implicitRootScope = true;
          return ancestorInfo;
        }
        function isTagValidWithParent(tag, parentTag, implicitRootScope) {
          switch (parentTag) {
            case "select":
              return "hr" === tag || "option" === tag || "optgroup" === tag || "script" === tag || "template" === tag || "#text" === tag;
            case "optgroup":
              return "option" === tag || "#text" === tag;
            case "option":
              return "#text" === tag;
            case "tr":
              return "th" === tag || "td" === tag || "style" === tag || "script" === tag || "template" === tag;
            case "tbody":
            case "thead":
            case "tfoot":
              return "tr" === tag || "style" === tag || "script" === tag || "template" === tag;
            case "colgroup":
              return "col" === tag || "template" === tag;
            case "table":
              return "caption" === tag || "colgroup" === tag || "tbody" === tag || "tfoot" === tag || "thead" === tag || "style" === tag || "script" === tag || "template" === tag;
            case "head":
              return "base" === tag || "basefont" === tag || "bgsound" === tag || "link" === tag || "meta" === tag || "title" === tag || "noscript" === tag || "noframes" === tag || "style" === tag || "script" === tag || "template" === tag;
            case "html":
              if (implicitRootScope) break;
              return "head" === tag || "body" === tag || "frameset" === tag;
            case "frameset":
              return "frame" === tag;
            case "#document":
              if (!implicitRootScope) return "html" === tag;
          }
          switch (tag) {
            case "h1":
            case "h2":
            case "h3":
            case "h4":
            case "h5":
            case "h6":
              return "h1" !== parentTag && "h2" !== parentTag && "h3" !== parentTag && "h4" !== parentTag && "h5" !== parentTag && "h6" !== parentTag;
            case "rp":
            case "rt":
              return -1 === impliedEndTags.indexOf(parentTag);
            case "caption":
            case "col":
            case "colgroup":
            case "frameset":
            case "frame":
            case "tbody":
            case "td":
            case "tfoot":
            case "th":
            case "thead":
            case "tr":
              return null == parentTag;
            case "head":
              return implicitRootScope || null === parentTag;
            case "html":
              return implicitRootScope && "#document" === parentTag || null === parentTag;
            case "body":
              return implicitRootScope && ("#document" === parentTag || "html" === parentTag) || null === parentTag;
          }
          return true;
        }
        function findInvalidAncestorForTag(tag, ancestorInfo) {
          switch (tag) {
            case "address":
            case "article":
            case "aside":
            case "blockquote":
            case "center":
            case "details":
            case "dialog":
            case "dir":
            case "div":
            case "dl":
            case "fieldset":
            case "figcaption":
            case "figure":
            case "footer":
            case "header":
            case "hgroup":
            case "main":
            case "menu":
            case "nav":
            case "ol":
            case "p":
            case "section":
            case "summary":
            case "ul":
            case "pre":
            case "listing":
            case "table":
            case "hr":
            case "xmp":
            case "h1":
            case "h2":
            case "h3":
            case "h4":
            case "h5":
            case "h6":
              return ancestorInfo.pTagInButtonScope;
            case "form":
              return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
            case "li":
              return ancestorInfo.listItemTagAutoclosing;
            case "dd":
            case "dt":
              return ancestorInfo.dlItemTagAutoclosing;
            case "button":
              return ancestorInfo.buttonTagInScope;
            case "a":
              return ancestorInfo.aTagInScope;
            case "nobr":
              return ancestorInfo.nobrTagInScope;
          }
          return null;
        }
        function findAncestor(parent, tagName) {
          for (; parent; ) {
            switch (parent.tag) {
              case 5:
              case 26:
              case 27:
                if (parent.type === tagName) return parent;
            }
            parent = parent.return;
          }
          return null;
        }
        function validateDOMNesting(childTag, ancestorInfo) {
          ancestorInfo = ancestorInfo || emptyAncestorInfoDev;
          var parentInfo = ancestorInfo.current;
          ancestorInfo = (parentInfo = isTagValidWithParent(
            childTag,
            parentInfo && parentInfo.tag,
            ancestorInfo.implicitRootScope
          ) ? null : parentInfo) ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
          ancestorInfo = parentInfo || ancestorInfo;
          if (!ancestorInfo) return true;
          var ancestorTag = ancestorInfo.tag;
          ancestorInfo = String(!!parentInfo) + "|" + childTag + "|" + ancestorTag;
          if (didWarn[ancestorInfo]) return false;
          didWarn[ancestorInfo] = true;
          var ancestor = (ancestorInfo = current) ? findAncestor(ancestorInfo.return, ancestorTag) : null, ancestorDescription = null !== ancestorInfo && null !== ancestor ? describeAncestors(ancestor, ancestorInfo, null) : "", tagDisplayName = "<" + childTag + ">";
          parentInfo ? (parentInfo = "", "table" === ancestorTag && "tr" === childTag && (parentInfo += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), console.error(
            "In HTML, %s cannot be a child of <%s>.%s\nThis will cause a hydration error.%s",
            tagDisplayName,
            ancestorTag,
            parentInfo,
            ancestorDescription
          )) : console.error(
            "In HTML, %s cannot be a descendant of <%s>.\nThis will cause a hydration error.%s",
            tagDisplayName,
            ancestorTag,
            ancestorDescription
          );
          ancestorInfo && (childTag = ancestorInfo.return, null === ancestor || null === childTag || ancestor === childTag && childTag._debugOwner === ancestorInfo._debugOwner || runWithFiberInDEV(ancestor, function() {
            console.error(
              "<%s> cannot contain a nested %s.\nSee this log for the ancestor stack trace.",
              ancestorTag,
              tagDisplayName
            );
          }));
          return false;
        }
        function validateTextNesting(childText, parentTag, implicitRootScope) {
          if (implicitRootScope || isTagValidWithParent("#text", parentTag, false))
            return true;
          implicitRootScope = "#text|" + parentTag;
          if (didWarn[implicitRootScope]) return false;
          didWarn[implicitRootScope] = true;
          var ancestor = (implicitRootScope = current) ? findAncestor(implicitRootScope, parentTag) : null;
          implicitRootScope = null !== implicitRootScope && null !== ancestor ? describeAncestors(
            ancestor,
            implicitRootScope,
            6 !== implicitRootScope.tag ? { children: null } : null
          ) : "";
          /\S/.test(childText) ? console.error(
            "In HTML, text nodes cannot be a child of <%s>.\nThis will cause a hydration error.%s",
            parentTag,
            implicitRootScope
          ) : console.error(
            "In HTML, whitespace text nodes cannot be a child of <%s>. Make sure you don't have any extra whitespace between tags on each line of your source code.\nThis will cause a hydration error.%s",
            parentTag,
            implicitRootScope
          );
          return false;
        }
        function setTextContent(node, text) {
          if (text) {
            var firstChild = node.firstChild;
            if (firstChild && firstChild === node.lastChild && 3 === firstChild.nodeType) {
              firstChild.nodeValue = text;
              return;
            }
          }
          node.textContent = text;
        }
        function camelize(string) {
          return string.replace(hyphenPattern, function(_4, character) {
            return character.toUpperCase();
          });
        }
        function setValueForStyle(style2, styleName, value) {
          var isCustomProperty = 0 === styleName.indexOf("--");
          isCustomProperty || (-1 < styleName.indexOf("-") ? warnedStyleNames.hasOwnProperty(styleName) && warnedStyleNames[styleName] || (warnedStyleNames[styleName] = true, console.error(
            "Unsupported style property %s. Did you mean %s?",
            styleName,
            camelize(styleName.replace(msPattern, "ms-"))
          )) : badVendoredStyleNamePattern.test(styleName) ? warnedStyleNames.hasOwnProperty(styleName) && warnedStyleNames[styleName] || (warnedStyleNames[styleName] = true, console.error(
            "Unsupported vendor-prefixed style property %s. Did you mean %s?",
            styleName,
            styleName.charAt(0).toUpperCase() + styleName.slice(1)
          )) : !badStyleValueWithSemicolonPattern.test(value) || warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value] || (warnedStyleValues[value] = true, console.error(
            `Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`,
            styleName,
            value.replace(badStyleValueWithSemicolonPattern, "")
          )), "number" === typeof value && (isNaN(value) ? warnedForNaNValue || (warnedForNaNValue = true, console.error(
            "`NaN` is an invalid value for the `%s` css style property.",
            styleName
          )) : isFinite(value) || warnedForInfinityValue || (warnedForInfinityValue = true, console.error(
            "`Infinity` is an invalid value for the `%s` css style property.",
            styleName
          ))));
          null == value || "boolean" === typeof value || "" === value ? isCustomProperty ? style2.setProperty(styleName, "") : "float" === styleName ? style2.cssFloat = "" : style2[styleName] = "" : isCustomProperty ? style2.setProperty(styleName, value) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? "float" === styleName ? style2.cssFloat = value : (checkCSSPropertyStringCoercion(value, styleName), style2[styleName] = ("" + value).trim()) : style2[styleName] = value + "px";
        }
        function setValueForStyles(node, styles, prevStyles) {
          if (null != styles && "object" !== typeof styles)
            throw Error(
              "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
            );
          styles && Object.freeze(styles);
          node = node.style;
          if (null != prevStyles) {
            if (styles) {
              var expandedUpdates = {};
              if (prevStyles) {
                for (var key in prevStyles)
                  if (prevStyles.hasOwnProperty(key) && !styles.hasOwnProperty(key))
                    for (var longhands = shorthandToLonghand[key] || [key], i8 = 0; i8 < longhands.length; i8++)
                      expandedUpdates[longhands[i8]] = key;
              }
              for (var _key in styles)
                if (styles.hasOwnProperty(_key) && (!prevStyles || prevStyles[_key] !== styles[_key]))
                  for (key = shorthandToLonghand[_key] || [_key], longhands = 0; longhands < key.length; longhands++)
                    expandedUpdates[key[longhands]] = _key;
              _key = {};
              for (var key$jscomp$0 in styles)
                for (key = shorthandToLonghand[key$jscomp$0] || [key$jscomp$0], longhands = 0; longhands < key.length; longhands++)
                  _key[key[longhands]] = key$jscomp$0;
              key$jscomp$0 = {};
              for (var _key2 in expandedUpdates)
                if (key = expandedUpdates[_key2], (longhands = _key[_key2]) && key !== longhands && (i8 = key + "," + longhands, !key$jscomp$0[i8])) {
                  key$jscomp$0[i8] = true;
                  i8 = console;
                  var value = styles[key];
                  i8.error.call(
                    i8,
                    "%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.",
                    null == value || "boolean" === typeof value || "" === value ? "Removing" : "Updating",
                    key,
                    longhands
                  );
                }
            }
            for (var styleName in prevStyles)
              !prevStyles.hasOwnProperty(styleName) || null != styles && styles.hasOwnProperty(styleName) || (0 === styleName.indexOf("--") ? node.setProperty(styleName, "") : "float" === styleName ? node.cssFloat = "" : node[styleName] = "");
            for (var _styleName in styles)
              _key2 = styles[_styleName], styles.hasOwnProperty(_styleName) && prevStyles[_styleName] !== _key2 && setValueForStyle(node, _styleName, _key2);
          } else
            for (expandedUpdates in styles)
              styles.hasOwnProperty(expandedUpdates) && setValueForStyle(node, expandedUpdates, styles[expandedUpdates]);
        }
        function isCustomElement(tagName) {
          if (-1 === tagName.indexOf("-")) return false;
          switch (tagName) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              return false;
            default:
              return true;
          }
        }
        function getAttributeAlias(name) {
          return aliases.get(name) || name;
        }
        function validateProperty$1(tagName, name) {
          if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name])
            return true;
          if (rARIACamel$1.test(name)) {
            tagName = "aria-" + name.slice(4).toLowerCase();
            tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
            if (null == tagName)
              return console.error(
                "Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.",
                name
              ), warnedProperties$1[name] = true;
            if (name !== tagName)
              return console.error(
                "Invalid ARIA attribute `%s`. Did you mean `%s`?",
                name,
                tagName
              ), warnedProperties$1[name] = true;
          }
          if (rARIA$1.test(name)) {
            tagName = name.toLowerCase();
            tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
            if (null == tagName) return warnedProperties$1[name] = true, false;
            name !== tagName && (console.error(
              "Unknown ARIA attribute `%s`. Did you mean `%s`?",
              name,
              tagName
            ), warnedProperties$1[name] = true);
          }
          return true;
        }
        function validateProperties$2(type, props) {
          var invalidProps = [], key;
          for (key in props)
            validateProperty$1(type, key) || invalidProps.push(key);
          props = invalidProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          1 === invalidProps.length ? console.error(
            "Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
            props,
            type
          ) : 1 < invalidProps.length && console.error(
            "Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
            props,
            type
          );
        }
        function validateProperty(tagName, name, value, eventRegistry) {
          if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name])
            return true;
          var lowerCasedName = name.toLowerCase();
          if ("onfocusin" === lowerCasedName || "onfocusout" === lowerCasedName)
            return console.error(
              "React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."
            ), warnedProperties[name] = true;
          if ("function" === typeof value && ("form" === tagName && "action" === name || "input" === tagName && "formAction" === name || "button" === tagName && "formAction" === name))
            return true;
          if (null != eventRegistry) {
            tagName = eventRegistry.possibleRegistrationNames;
            if (eventRegistry.registrationNameDependencies.hasOwnProperty(name))
              return true;
            eventRegistry = tagName.hasOwnProperty(lowerCasedName) ? tagName[lowerCasedName] : null;
            if (null != eventRegistry)
              return console.error(
                "Invalid event handler property `%s`. Did you mean `%s`?",
                name,
                eventRegistry
              ), warnedProperties[name] = true;
            if (EVENT_NAME_REGEX.test(name))
              return console.error(
                "Unknown event handler property `%s`. It will be ignored.",
                name
              ), warnedProperties[name] = true;
          } else if (EVENT_NAME_REGEX.test(name))
            return INVALID_EVENT_NAME_REGEX.test(name) && console.error(
              "Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.",
              name
            ), warnedProperties[name] = true;
          if (rARIA.test(name) || rARIACamel.test(name)) return true;
          if ("innerhtml" === lowerCasedName)
            return console.error(
              "Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."
            ), warnedProperties[name] = true;
          if ("aria" === lowerCasedName)
            return console.error(
              "The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."
            ), warnedProperties[name] = true;
          if ("is" === lowerCasedName && null !== value && void 0 !== value && "string" !== typeof value)
            return console.error(
              "Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.",
              typeof value
            ), warnedProperties[name] = true;
          if ("number" === typeof value && isNaN(value))
            return console.error(
              "Received NaN for the `%s` attribute. If this is expected, cast the value to a string.",
              name
            ), warnedProperties[name] = true;
          if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
            if (lowerCasedName = possibleStandardNames[lowerCasedName], lowerCasedName !== name)
              return console.error(
                "Invalid DOM property `%s`. Did you mean `%s`?",
                name,
                lowerCasedName
              ), warnedProperties[name] = true;
          } else if (name !== lowerCasedName)
            return console.error(
              "React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.",
              name,
              lowerCasedName
            ), warnedProperties[name] = true;
          switch (name) {
            case "dangerouslySetInnerHTML":
            case "children":
            case "style":
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
            case "defaultValue":
            case "defaultChecked":
            case "innerHTML":
            case "ref":
              return true;
            case "innerText":
            case "textContent":
              return true;
          }
          switch (typeof value) {
            case "boolean":
              switch (name) {
                case "autoFocus":
                case "checked":
                case "multiple":
                case "muted":
                case "selected":
                case "contentEditable":
                case "spellCheck":
                case "draggable":
                case "value":
                case "autoReverse":
                case "externalResourcesRequired":
                case "focusable":
                case "preserveAlpha":
                case "allowFullScreen":
                case "async":
                case "autoPlay":
                case "controls":
                case "default":
                case "defer":
                case "disabled":
                case "disablePictureInPicture":
                case "disableRemotePlayback":
                case "formNoValidate":
                case "hidden":
                case "loop":
                case "noModule":
                case "noValidate":
                case "open":
                case "playsInline":
                case "readOnly":
                case "required":
                case "reversed":
                case "scoped":
                case "seamless":
                case "itemScope":
                case "capture":
                case "download":
                case "inert":
                  return true;
                default:
                  lowerCasedName = name.toLowerCase().slice(0, 5);
                  if ("data-" === lowerCasedName || "aria-" === lowerCasedName)
                    return true;
                  value ? console.error(
                    'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.',
                    value,
                    name,
                    name,
                    value,
                    name
                  ) : console.error(
                    'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',
                    value,
                    name,
                    name,
                    value,
                    name,
                    name,
                    name
                  );
                  return warnedProperties[name] = true;
              }
            case "function":
            case "symbol":
              return warnedProperties[name] = true, false;
            case "string":
              if ("false" === value || "true" === value) {
                switch (name) {
                  case "checked":
                  case "selected":
                  case "multiple":
                  case "muted":
                  case "allowFullScreen":
                  case "async":
                  case "autoPlay":
                  case "controls":
                  case "default":
                  case "defer":
                  case "disabled":
                  case "disablePictureInPicture":
                  case "disableRemotePlayback":
                  case "formNoValidate":
                  case "hidden":
                  case "loop":
                  case "noModule":
                  case "noValidate":
                  case "open":
                  case "playsInline":
                  case "readOnly":
                  case "required":
                  case "reversed":
                  case "scoped":
                  case "seamless":
                  case "itemScope":
                  case "inert":
                    break;
                  default:
                    return true;
                }
                console.error(
                  "Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?",
                  value,
                  name,
                  "false" === value ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".',
                  name,
                  value
                );
                warnedProperties[name] = true;
              }
          }
          return true;
        }
        function warnUnknownProperties(type, props, eventRegistry) {
          var unknownProps = [], key;
          for (key in props)
            validateProperty(type, key, props[key], eventRegistry) || unknownProps.push(key);
          props = unknownProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          1 === unknownProps.length ? console.error(
            "Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior ",
            props,
            type
          ) : 1 < unknownProps.length && console.error(
            "Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior ",
            props,
            type
          );
        }
        function sanitizeURL(url) {
          return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
        }
        function noop$1() {
        }
        function getEventTarget(nativeEvent) {
          nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
          nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
          return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
        }
        function restoreStateOfTarget(target) {
          var internalInstance = getInstanceFromNode(target);
          if (internalInstance && (target = internalInstance.stateNode)) {
            var props = target[internalPropsKey] || null;
            a: switch (target = internalInstance.stateNode, internalInstance.type) {
              case "input":
                updateInput(
                  target,
                  props.value,
                  props.defaultValue,
                  props.defaultValue,
                  props.checked,
                  props.defaultChecked,
                  props.type,
                  props.name
                );
                internalInstance = props.name;
                if ("radio" === props.type && null != internalInstance) {
                  for (props = target; props.parentNode; ) props = props.parentNode;
                  checkAttributeStringCoercion(internalInstance, "name");
                  props = props.querySelectorAll(
                    'input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                      "" + internalInstance
                    ) + '"][type="radio"]'
                  );
                  for (internalInstance = 0; internalInstance < props.length; internalInstance++) {
                    var otherNode = props[internalInstance];
                    if (otherNode !== target && otherNode.form === target.form) {
                      var otherProps = otherNode[internalPropsKey] || null;
                      if (!otherProps)
                        throw Error(
                          "ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported."
                        );
                      updateInput(
                        otherNode,
                        otherProps.value,
                        otherProps.defaultValue,
                        otherProps.defaultValue,
                        otherProps.checked,
                        otherProps.defaultChecked,
                        otherProps.type,
                        otherProps.name
                      );
                    }
                  }
                  for (internalInstance = 0; internalInstance < props.length; internalInstance++)
                    otherNode = props[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode);
                }
                break a;
              case "textarea":
                updateTextarea(target, props.value, props.defaultValue);
                break a;
              case "select":
                internalInstance = props.value, null != internalInstance && updateOptions(target, !!props.multiple, internalInstance, false);
            }
          }
        }
        function batchedUpdates$1(fn, a5, b3) {
          if (isInsideEventHandler) return fn(a5, b3);
          isInsideEventHandler = true;
          try {
            var JSCompiler_inline_result = fn(a5);
            return JSCompiler_inline_result;
          } finally {
            if (isInsideEventHandler = false, null !== restoreTarget || null !== restoreQueue) {
              if (flushSyncWork$1(), restoreTarget && (a5 = restoreTarget, fn = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(a5), fn))
                for (a5 = 0; a5 < fn.length; a5++) restoreStateOfTarget(fn[a5]);
            }
          }
        }
        function getListener(inst, registrationName) {
          var stateNode = inst.stateNode;
          if (null === stateNode) return null;
          var props = stateNode[internalPropsKey] || null;
          if (null === props) return null;
          stateNode = props[registrationName];
          a: switch (registrationName) {
            case "onClick":
            case "onClickCapture":
            case "onDoubleClick":
            case "onDoubleClickCapture":
            case "onMouseDown":
            case "onMouseDownCapture":
            case "onMouseMove":
            case "onMouseMoveCapture":
            case "onMouseUp":
            case "onMouseUpCapture":
            case "onMouseEnter":
              (props = !props.disabled) || (inst = inst.type, props = !("button" === inst || "input" === inst || "select" === inst || "textarea" === inst));
              inst = !props;
              break a;
            default:
              inst = false;
          }
          if (inst) return null;
          if (stateNode && "function" !== typeof stateNode)
            throw Error(
              "Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof stateNode + "` type."
            );
          return stateNode;
        }
        function getData() {
          if (fallbackText) return fallbackText;
          var start2, startValue = startText, startLength = startValue.length, end, endValue = "value" in root ? root.value : root.textContent, endLength = endValue.length;
          for (start2 = 0; start2 < startLength && startValue[start2] === endValue[start2]; start2++) ;
          var minEnd = startLength - start2;
          for (end = 1; end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++) ;
          return fallbackText = endValue.slice(start2, 1 < end ? 1 - end : void 0);
        }
        function getEventCharCode(nativeEvent) {
          var keyCode = nativeEvent.keyCode;
          "charCode" in nativeEvent ? (nativeEvent = nativeEvent.charCode, 0 === nativeEvent && 13 === keyCode && (nativeEvent = 13)) : nativeEvent = keyCode;
          10 === nativeEvent && (nativeEvent = 13);
          return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
        }
        function functionThatReturnsTrue() {
          return true;
        }
        function functionThatReturnsFalse() {
          return false;
        }
        function createSyntheticEvent(Interface) {
          function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
            this._reactName = reactName;
            this._targetInst = targetInst;
            this.type = reactEventType;
            this.nativeEvent = nativeEvent;
            this.target = nativeEventTarget;
            this.currentTarget = null;
            for (var propName in Interface)
              Interface.hasOwnProperty(propName) && (reactName = Interface[propName], this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]);
            this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : false === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
            this.isPropagationStopped = functionThatReturnsFalse;
            return this;
          }
          assign(SyntheticBaseEvent.prototype, {
            preventDefault: function() {
              this.defaultPrevented = true;
              var event = this.nativeEvent;
              event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = false), this.isDefaultPrevented = functionThatReturnsTrue);
            },
            stopPropagation: function() {
              var event = this.nativeEvent;
              event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = true), this.isPropagationStopped = functionThatReturnsTrue);
            },
            persist: function() {
            },
            isPersistent: functionThatReturnsTrue
          });
          return SyntheticBaseEvent;
        }
        function modifierStateGetter(keyArg) {
          var nativeEvent = this.nativeEvent;
          return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArg) : (keyArg = modifierKeyToProp[keyArg]) ? !!nativeEvent[keyArg] : false;
        }
        function getEventModifierState() {
          return modifierStateGetter;
        }
        function isFallbackCompositionEnd(domEventName, nativeEvent) {
          switch (domEventName) {
            case "keyup":
              return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
            case "keydown":
              return nativeEvent.keyCode !== START_KEYCODE;
            case "keypress":
            case "mousedown":
            case "focusout":
              return true;
            default:
              return false;
          }
        }
        function getDataFromCustomEvent(nativeEvent) {
          nativeEvent = nativeEvent.detail;
          return "object" === typeof nativeEvent && "data" in nativeEvent ? nativeEvent.data : null;
        }
        function getNativeBeforeInputChars(domEventName, nativeEvent) {
          switch (domEventName) {
            case "compositionend":
              return getDataFromCustomEvent(nativeEvent);
            case "keypress":
              if (nativeEvent.which !== SPACEBAR_CODE) return null;
              hasSpaceKeypress = true;
              return SPACEBAR_CHAR;
            case "textInput":
              return domEventName = nativeEvent.data, domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName;
            default:
              return null;
          }
        }
        function getFallbackBeforeInputChars(domEventName, nativeEvent) {
          if (isComposing)
            return "compositionend" === domEventName || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent) ? (domEventName = getData(), fallbackText = startText = root = null, isComposing = false, domEventName) : null;
          switch (domEventName) {
            case "paste":
              return null;
            case "keypress":
              if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || nativeEvent.ctrlKey && nativeEvent.altKey) {
                if (nativeEvent.char && 1 < nativeEvent.char.length)
                  return nativeEvent.char;
                if (nativeEvent.which)
                  return String.fromCharCode(nativeEvent.which);
              }
              return null;
            case "compositionend":
              return useFallbackCompositionData && "ko" !== nativeEvent.locale ? null : nativeEvent.data;
            default:
              return null;
          }
        }
        function isTextInputElement(elem) {
          var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
          return "input" === nodeName ? !!supportedInputTypes[elem.type] : "textarea" === nodeName ? true : false;
        }
        function isEventSupported(eventNameSuffix) {
          if (!canUseDOM) return false;
          eventNameSuffix = "on" + eventNameSuffix;
          var isSupported = eventNameSuffix in document;
          isSupported || (isSupported = document.createElement("div"), isSupported.setAttribute(eventNameSuffix, "return;"), isSupported = "function" === typeof isSupported[eventNameSuffix]);
          return isSupported;
        }
        function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
          restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [target] : restoreTarget = target;
          inst = accumulateTwoPhaseListeners(inst, "onChange");
          0 < inst.length && (nativeEvent = new SyntheticEvent(
            "onChange",
            "change",
            null,
            nativeEvent,
            target
          ), dispatchQueue.push({ event: nativeEvent, listeners: inst }));
        }
        function runEventInBatch(dispatchQueue) {
          processDispatchQueue(dispatchQueue, 0);
        }
        function getInstIfValueChanged(targetInst) {
          var targetNode = getNodeFromInstance(targetInst);
          if (updateValueIfChanged(targetNode)) return targetInst;
        }
        function getTargetInstForChangeEvent(domEventName, targetInst) {
          if ("change" === domEventName) return targetInst;
        }
        function stopWatchingForValueChange() {
          activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), activeElementInst$1 = activeElement$1 = null);
        }
        function handlePropertyChange(nativeEvent) {
          if ("value" === nativeEvent.propertyName && getInstIfValueChanged(activeElementInst$1)) {
            var dispatchQueue = [];
            createAndAccumulateChangeEvent(
              dispatchQueue,
              activeElementInst$1,
              nativeEvent,
              getEventTarget(nativeEvent)
            );
            batchedUpdates$1(runEventInBatch, dispatchQueue);
          }
        }
        function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
          "focusin" === domEventName ? (stopWatchingForValueChange(), activeElement$1 = target, activeElementInst$1 = targetInst, activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : "focusout" === domEventName && stopWatchingForValueChange();
        }
        function getTargetInstForInputEventPolyfill(domEventName) {
          if ("selectionchange" === domEventName || "keyup" === domEventName || "keydown" === domEventName)
            return getInstIfValueChanged(activeElementInst$1);
        }
        function getTargetInstForClickEvent(domEventName, targetInst) {
          if ("click" === domEventName) return getInstIfValueChanged(targetInst);
        }
        function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
          if ("input" === domEventName || "change" === domEventName)
            return getInstIfValueChanged(targetInst);
        }
        function is(x6, y5) {
          return x6 === y5 && (0 !== x6 || 1 / x6 === 1 / y5) || x6 !== x6 && y5 !== y5;
        }
        function shallowEqual(objA, objB) {
          if (objectIs(objA, objB)) return true;
          if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB)
            return false;
          var keysA = Object.keys(objA), keysB = Object.keys(objB);
          if (keysA.length !== keysB.length) return false;
          for (keysB = 0; keysB < keysA.length; keysB++) {
            var currentKey = keysA[keysB];
            if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey]))
              return false;
          }
          return true;
        }
        function getLeafNode(node) {
          for (; node && node.firstChild; ) node = node.firstChild;
          return node;
        }
        function getNodeForCharacterOffset(root2, offset) {
          var node = getLeafNode(root2);
          root2 = 0;
          for (var nodeEnd; node; ) {
            if (3 === node.nodeType) {
              nodeEnd = root2 + node.textContent.length;
              if (root2 <= offset && nodeEnd >= offset)
                return { node, offset: offset - root2 };
              root2 = nodeEnd;
            }
            a: {
              for (; node; ) {
                if (node.nextSibling) {
                  node = node.nextSibling;
                  break a;
                }
                node = node.parentNode;
              }
              node = void 0;
            }
            node = getLeafNode(node);
          }
        }
        function containsNode(outerNode, innerNode) {
          return outerNode && innerNode ? outerNode === innerNode ? true : outerNode && 3 === outerNode.nodeType ? false : innerNode && 3 === innerNode.nodeType ? containsNode(outerNode, innerNode.parentNode) : "contains" in outerNode ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : false : false;
        }
        function getActiveElementDeep(containerInfo) {
          containerInfo = null != containerInfo && null != containerInfo.ownerDocument && null != containerInfo.ownerDocument.defaultView ? containerInfo.ownerDocument.defaultView : window;
          for (var element = getActiveElement(containerInfo.document); element instanceof containerInfo.HTMLIFrameElement; ) {
            try {
              var JSCompiler_inline_result = "string" === typeof element.contentWindow.location.href;
            } catch (err) {
              JSCompiler_inline_result = false;
            }
            if (JSCompiler_inline_result) containerInfo = element.contentWindow;
            else break;
            element = getActiveElement(containerInfo.document);
          }
          return element;
        }
        function hasSelectionCapabilities(elem) {
          var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
          return nodeName && ("input" === nodeName && ("text" === elem.type || "search" === elem.type || "tel" === elem.type || "url" === elem.type || "password" === elem.type) || "textarea" === nodeName || "true" === elem.contentEditable);
        }
        function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
          var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : 9 === nativeEventTarget.nodeType ? nativeEventTarget : nativeEventTarget.ownerDocument;
          mouseDown || null == activeElement || activeElement !== getActiveElement(doc) || (doc = activeElement, "selectionStart" in doc && hasSelectionCapabilities(doc) ? doc = { start: doc.selectionStart, end: doc.selectionEnd } : (doc = (doc.ownerDocument && doc.ownerDocument.defaultView || window).getSelection(), doc = {
            anchorNode: doc.anchorNode,
            anchorOffset: doc.anchorOffset,
            focusNode: doc.focusNode,
            focusOffset: doc.focusOffset
          }), lastSelection && shallowEqual(lastSelection, doc) || (lastSelection = doc, doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect"), 0 < doc.length && (nativeEvent = new SyntheticEvent(
            "onSelect",
            "select",
            null,
            nativeEvent,
            nativeEventTarget
          ), dispatchQueue.push({ event: nativeEvent, listeners: doc }), nativeEvent.target = activeElement)));
        }
        function makePrefixMap(styleProp, eventName) {
          var prefixes = {};
          prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
          prefixes["Webkit" + styleProp] = "webkit" + eventName;
          prefixes["Moz" + styleProp] = "moz" + eventName;
          return prefixes;
        }
        function getVendorPrefixedEventName(eventName) {
          if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
          if (!vendorPrefixes[eventName]) return eventName;
          var prefixMap = vendorPrefixes[eventName], styleProp;
          for (styleProp in prefixMap)
            if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
              return prefixedEventNames[eventName] = prefixMap[styleProp];
          return eventName;
        }
        function registerSimpleEvent(domEventName, reactName) {
          topLevelEventsToReactNames.set(domEventName, reactName);
          registerTwoPhaseEvent(reactName, [domEventName]);
        }
        function getArrayKind(array) {
          for (var kind = EMPTY_ARRAY, i8 = 0; i8 < array.length; i8++) {
            var value = array[i8];
            if ("object" === typeof value && null !== value)
              if (isArrayImpl(value) && 2 === value.length && "string" === typeof value[0]) {
                if (kind !== EMPTY_ARRAY && kind !== ENTRIES_ARRAY)
                  return COMPLEX_ARRAY;
                kind = ENTRIES_ARRAY;
              } else return COMPLEX_ARRAY;
            else {
              if ("function" === typeof value || "string" === typeof value && 50 < value.length || kind !== EMPTY_ARRAY && kind !== PRIMITIVE_ARRAY)
                return COMPLEX_ARRAY;
              kind = PRIMITIVE_ARRAY;
            }
          }
          return kind;
        }
        function addObjectToProperties(object, properties, indent, prefix2) {
          for (var key in object)
            hasOwnProperty.call(object, key) && "_" !== key[0] && addValueToProperties(key, object[key], properties, indent, prefix2);
        }
        function addValueToProperties(propertyName, value, properties, indent, prefix2) {
          switch (typeof value) {
            case "object":
              if (null === value) {
                value = "null";
                break;
              } else {
                if (value.$$typeof === REACT_ELEMENT_TYPE) {
                  var typeName2 = getComponentNameFromType(value.type) || "\u2026", key = value.key;
                  value = value.props;
                  var propsKeys = Object.keys(value), propsLength = propsKeys.length;
                  if (null == key && 0 === propsLength) {
                    value = "<" + typeName2 + " />";
                    break;
                  }
                  if (3 > indent || 1 === propsLength && "children" === propsKeys[0] && null == key) {
                    value = "<" + typeName2 + " \u2026 />";
                    break;
                  }
                  properties.push([
                    prefix2 + "\xA0\xA0".repeat(indent) + propertyName,
                    "<" + typeName2
                  ]);
                  null !== key && addValueToProperties(
                    "key",
                    key,
                    properties,
                    indent + 1,
                    prefix2
                  );
                  propertyName = false;
                  for (var propKey in value)
                    "children" === propKey ? null != value.children && (!isArrayImpl(value.children) || 0 < value.children.length) && (propertyName = true) : hasOwnProperty.call(value, propKey) && "_" !== propKey[0] && addValueToProperties(
                      propKey,
                      value[propKey],
                      properties,
                      indent + 1,
                      prefix2
                    );
                  properties.push([
                    "",
                    propertyName ? ">\u2026</" + typeName2 + ">" : "/>"
                  ]);
                  return;
                }
                typeName2 = Object.prototype.toString.call(value);
                typeName2 = typeName2.slice(8, typeName2.length - 1);
                if ("Array" === typeName2) {
                  if (propKey = getArrayKind(value), propKey === PRIMITIVE_ARRAY || propKey === EMPTY_ARRAY) {
                    value = JSON.stringify(value);
                    break;
                  } else if (propKey === ENTRIES_ARRAY) {
                    properties.push([
                      prefix2 + "\xA0\xA0".repeat(indent) + propertyName,
                      ""
                    ]);
                    for (propertyName = 0; propertyName < value.length; propertyName++)
                      typeName2 = value[propertyName], addValueToProperties(
                        typeName2[0],
                        typeName2[1],
                        properties,
                        indent + 1,
                        prefix2
                      );
                    return;
                  }
                }
                if ("Promise" === typeName2) {
                  if ("fulfilled" === value.status) {
                    if (typeName2 = properties.length, addValueToProperties(
                      propertyName,
                      value.value,
                      properties,
                      indent,
                      prefix2
                    ), properties.length > typeName2) {
                      properties = properties[typeName2];
                      properties[1] = "Promise<" + (properties[1] || "Object") + ">";
                      return;
                    }
                  } else if ("rejected" === value.status && (typeName2 = properties.length, addValueToProperties(
                    propertyName,
                    value.reason,
                    properties,
                    indent,
                    prefix2
                  ), properties.length > typeName2)) {
                    properties = properties[typeName2];
                    properties[1] = "Rejected Promise<" + properties[1] + ">";
                    return;
                  }
                  properties.push([
                    "\xA0\xA0".repeat(indent) + propertyName,
                    "Promise"
                  ]);
                  return;
                }
                "Object" === typeName2 && (propKey = Object.getPrototypeOf(value)) && "function" === typeof propKey.constructor && (typeName2 = propKey.constructor.name);
                properties.push([
                  prefix2 + "\xA0\xA0".repeat(indent) + propertyName,
                  "Object" === typeName2 ? 3 > indent ? "" : "\u2026" : typeName2
                ]);
                3 > indent && addObjectToProperties(value, properties, indent + 1, prefix2);
                return;
              }
            case "function":
              value = "" === value.name ? "() => {}" : value.name + "() {}";
              break;
            case "string":
              value = value === OMITTED_PROP_ERROR ? "\u2026" : JSON.stringify(value);
              break;
            case "undefined":
              value = "undefined";
              break;
            case "boolean":
              value = value ? "true" : "false";
              break;
            default:
              value = String(value);
          }
          properties.push([
            prefix2 + "\xA0\xA0".repeat(indent) + propertyName,
            value
          ]);
        }
        function addObjectDiffToProperties(prev, next, properties, indent) {
          var isDeeplyEqual = true;
          for (key in prev)
            key in next || (properties.push([
              REMOVED + "\xA0\xA0".repeat(indent) + key,
              "\u2026"
            ]), isDeeplyEqual = false);
          for (var _key in next)
            if (_key in prev) {
              var key = prev[_key];
              var nextValue = next[_key];
              if (key !== nextValue) {
                if (0 === indent && "children" === _key)
                  isDeeplyEqual = "\xA0\xA0".repeat(indent) + _key, properties.push(
                    [REMOVED + isDeeplyEqual, "\u2026"],
                    [ADDED + isDeeplyEqual, "\u2026"]
                  );
                else {
                  if (!(3 <= indent)) {
                    if ("object" === typeof key && "object" === typeof nextValue && null !== key && null !== nextValue && key.$$typeof === nextValue.$$typeof)
                      if (nextValue.$$typeof === REACT_ELEMENT_TYPE) {
                        if (key.type === nextValue.type && key.key === nextValue.key) {
                          key = getComponentNameFromType(nextValue.type) || "\u2026";
                          isDeeplyEqual = "\xA0\xA0".repeat(indent) + _key;
                          key = "<" + key + " \u2026 />";
                          properties.push(
                            [REMOVED + isDeeplyEqual, key],
                            [ADDED + isDeeplyEqual, key]
                          );
                          isDeeplyEqual = false;
                          continue;
                        }
                      } else {
                        var prevKind = Object.prototype.toString.call(key), nextKind = Object.prototype.toString.call(nextValue);
                        if (prevKind === nextKind && ("[object Object]" === nextKind || "[object Array]" === nextKind)) {
                          prevKind = [
                            UNCHANGED + "\xA0\xA0".repeat(indent) + _key,
                            "[object Array]" === nextKind ? "Array" : ""
                          ];
                          properties.push(prevKind);
                          nextKind = properties.length;
                          addObjectDiffToProperties(
                            key,
                            nextValue,
                            properties,
                            indent + 1
                          ) ? nextKind === properties.length && (prevKind[1] = "Referentially unequal but deeply equal objects. Consider memoization.") : isDeeplyEqual = false;
                          continue;
                        }
                      }
                    else if ("function" === typeof key && "function" === typeof nextValue && key.name === nextValue.name && key.length === nextValue.length && (prevKind = Function.prototype.toString.call(key), nextKind = Function.prototype.toString.call(nextValue), prevKind === nextKind)) {
                      key = "" === nextValue.name ? "() => {}" : nextValue.name + "() {}";
                      properties.push([
                        UNCHANGED + "\xA0\xA0".repeat(indent) + _key,
                        key + " Referentially unequal function closure. Consider memoization."
                      ]);
                      continue;
                    }
                  }
                  addValueToProperties(_key, key, properties, indent, REMOVED);
                  addValueToProperties(_key, nextValue, properties, indent, ADDED);
                }
                isDeeplyEqual = false;
              }
            } else
              properties.push([
                ADDED + "\xA0\xA0".repeat(indent) + _key,
                "\u2026"
              ]), isDeeplyEqual = false;
          return isDeeplyEqual;
        }
        function setCurrentTrackFromLanes(lanes) {
          currentTrack = lanes & 63 ? "Blocking" : lanes & 64 ? "Gesture" : lanes & 4194176 ? "Transition" : lanes & 62914560 ? "Suspense" : lanes & 2080374784 ? "Idle" : "Other";
        }
        function logComponentTrigger(fiber, startTime, endTime, trigger) {
          supportsUserTiming && (reusableComponentOptions.start = startTime, reusableComponentOptions.end = endTime, reusableComponentDevToolDetails.color = "warning", reusableComponentDevToolDetails.tooltipText = trigger, reusableComponentDevToolDetails.properties = null, (fiber = fiber._debugTask) ? fiber.run(
            performance.measure.bind(
              performance,
              trigger,
              reusableComponentOptions
            )
          ) : performance.measure(trigger, reusableComponentOptions));
        }
        function logComponentReappeared(fiber, startTime, endTime) {
          logComponentTrigger(fiber, startTime, endTime, "Reconnect");
        }
        function logComponentRender(fiber, startTime, endTime, wasHydrated, committedLanes) {
          var name = getComponentNameFromFiber(fiber);
          if (null !== name && supportsUserTiming) {
            var alternate = fiber.alternate, selfTime = fiber.actualDuration;
            if (null === alternate || alternate.child !== fiber.child)
              for (var child = fiber.child; null !== child; child = child.sibling)
                selfTime -= child.actualDuration;
            wasHydrated = 0.5 > selfTime ? wasHydrated ? "tertiary-light" : "primary-light" : 10 > selfTime ? wasHydrated ? "tertiary" : "primary" : 100 > selfTime ? wasHydrated ? "tertiary-dark" : "primary-dark" : "error";
            var props = fiber.memoizedProps;
            selfTime = fiber._debugTask;
            null !== props && null !== alternate && alternate.memoizedProps !== props ? (child = [resuableChangedPropsEntry], props = addObjectDiffToProperties(
              alternate.memoizedProps,
              props,
              child,
              0
            ), 1 < child.length && (props && !alreadyWarnedForDeepEquality && 0 === (alternate.lanes & committedLanes) && 100 < fiber.actualDuration ? (alreadyWarnedForDeepEquality = true, child[0] = reusableDeeplyEqualPropsEntry, reusableComponentDevToolDetails.color = "warning", reusableComponentDevToolDetails.tooltipText = DEEP_EQUALITY_WARNING) : (reusableComponentDevToolDetails.color = wasHydrated, reusableComponentDevToolDetails.tooltipText = name), reusableComponentDevToolDetails.properties = child, reusableComponentOptions.start = startTime, reusableComponentOptions.end = endTime, null != selfTime ? selfTime.run(
              performance.measure.bind(
                performance,
                "\u200B" + name,
                reusableComponentOptions
              )
            ) : performance.measure(
              "\u200B" + name,
              reusableComponentOptions
            ))) : null != selfTime ? selfTime.run(
              console.timeStamp.bind(
                console,
                name,
                startTime,
                endTime,
                COMPONENTS_TRACK,
                void 0,
                wasHydrated
              )
            ) : console.timeStamp(
              name,
              startTime,
              endTime,
              COMPONENTS_TRACK,
              void 0,
              wasHydrated
            );
          }
        }
        function logComponentErrored(fiber, startTime, endTime, errors) {
          if (supportsUserTiming) {
            var name = getComponentNameFromFiber(fiber);
            if (null !== name) {
              for (var debugTask = null, properties = [], i8 = 0; i8 < errors.length; i8++) {
                var capturedValue = errors[i8];
                null == debugTask && null !== capturedValue.source && (debugTask = capturedValue.source._debugTask);
                capturedValue = capturedValue.value;
                properties.push([
                  "Error",
                  "object" === typeof capturedValue && null !== capturedValue && "string" === typeof capturedValue.message ? String(capturedValue.message) : String(capturedValue)
                ]);
              }
              null !== fiber.key && addValueToProperties("key", fiber.key, properties, 0, "");
              null !== fiber.memoizedProps && addObjectToProperties(fiber.memoizedProps, properties, 0, "");
              null == debugTask && (debugTask = fiber._debugTask);
              fiber = {
                start: startTime,
                end: endTime,
                detail: {
                  devtools: {
                    color: "error",
                    track: COMPONENTS_TRACK,
                    tooltipText: 13 === fiber.tag ? "Hydration failed" : "Error boundary caught an error",
                    properties
                  }
                }
              };
              debugTask ? debugTask.run(
                performance.measure.bind(performance, "\u200B" + name, fiber)
              ) : performance.measure("\u200B" + name, fiber);
            }
          }
        }
        function logComponentEffect(fiber, startTime, endTime, selfTime, errors) {
          if (null !== errors) {
            if (supportsUserTiming) {
              var name = getComponentNameFromFiber(fiber);
              if (null !== name) {
                selfTime = [];
                for (var i8 = 0; i8 < errors.length; i8++) {
                  var error = errors[i8].value;
                  selfTime.push([
                    "Error",
                    "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error)
                  ]);
                }
                null !== fiber.key && addValueToProperties("key", fiber.key, selfTime, 0, "");
                null !== fiber.memoizedProps && addObjectToProperties(fiber.memoizedProps, selfTime, 0, "");
                startTime = {
                  start: startTime,
                  end: endTime,
                  detail: {
                    devtools: {
                      color: "error",
                      track: COMPONENTS_TRACK,
                      tooltipText: "A lifecycle or effect errored",
                      properties: selfTime
                    }
                  }
                };
                (fiber = fiber._debugTask) ? fiber.run(
                  performance.measure.bind(
                    performance,
                    "\u200B" + name,
                    startTime
                  )
                ) : performance.measure("\u200B" + name, startTime);
              }
            }
          } else
            name = getComponentNameFromFiber(fiber), null !== name && supportsUserTiming && (errors = 1 > selfTime ? "secondary-light" : 100 > selfTime ? "secondary" : 500 > selfTime ? "secondary-dark" : "error", (fiber = fiber._debugTask) ? fiber.run(
              console.timeStamp.bind(
                console,
                name,
                startTime,
                endTime,
                COMPONENTS_TRACK,
                void 0,
                errors
              )
            ) : console.timeStamp(
              name,
              startTime,
              endTime,
              COMPONENTS_TRACK,
              void 0,
              errors
            ));
        }
        function logRenderPhase(startTime, endTime, lanes, debugTask) {
          if (supportsUserTiming && !(endTime <= startTime)) {
            var color = (lanes & 738197653) === lanes ? "tertiary-dark" : "primary-dark";
            lanes = (lanes & 536870912) === lanes ? "Prepared" : (lanes & 201326741) === lanes ? "Hydrated" : "Render";
            debugTask ? debugTask.run(
              console.timeStamp.bind(
                console,
                lanes,
                startTime,
                endTime,
                currentTrack,
                LANES_TRACK_GROUP,
                color
              )
            ) : console.timeStamp(
              lanes,
              startTime,
              endTime,
              currentTrack,
              LANES_TRACK_GROUP,
              color
            );
          }
        }
        function logSuspendedRenderPhase(startTime, endTime, lanes, debugTask) {
          !supportsUserTiming || endTime <= startTime || (lanes = (lanes & 738197653) === lanes ? "tertiary-dark" : "primary-dark", debugTask ? debugTask.run(
            console.timeStamp.bind(
              console,
              "Prewarm",
              startTime,
              endTime,
              currentTrack,
              LANES_TRACK_GROUP,
              lanes
            )
          ) : console.timeStamp(
            "Prewarm",
            startTime,
            endTime,
            currentTrack,
            LANES_TRACK_GROUP,
            lanes
          ));
        }
        function logSuspendedWithDelayPhase(startTime, endTime, lanes, debugTask) {
          !supportsUserTiming || endTime <= startTime || (lanes = (lanes & 738197653) === lanes ? "tertiary-dark" : "primary-dark", debugTask ? debugTask.run(
            console.timeStamp.bind(
              console,
              "Suspended",
              startTime,
              endTime,
              currentTrack,
              LANES_TRACK_GROUP,
              lanes
            )
          ) : console.timeStamp(
            "Suspended",
            startTime,
            endTime,
            currentTrack,
            LANES_TRACK_GROUP,
            lanes
          ));
        }
        function logRecoveredRenderPhase(startTime, endTime, lanes, recoverableErrors, hydrationFailed, debugTask) {
          if (supportsUserTiming && !(endTime <= startTime)) {
            lanes = [];
            for (var i8 = 0; i8 < recoverableErrors.length; i8++) {
              var error = recoverableErrors[i8].value;
              lanes.push([
                "Recoverable Error",
                "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error)
              ]);
            }
            startTime = {
              start: startTime,
              end: endTime,
              detail: {
                devtools: {
                  color: "primary-dark",
                  track: currentTrack,
                  trackGroup: LANES_TRACK_GROUP,
                  tooltipText: hydrationFailed ? "Hydration Failed" : "Recovered after Error",
                  properties: lanes
                }
              }
            };
            debugTask ? debugTask.run(
              performance.measure.bind(performance, "Recovered", startTime)
            ) : performance.measure("Recovered", startTime);
          }
        }
        function logErroredRenderPhase(startTime, endTime, lanes, debugTask) {
          !supportsUserTiming || endTime <= startTime || (debugTask ? debugTask.run(
            console.timeStamp.bind(
              console,
              "Errored",
              startTime,
              endTime,
              currentTrack,
              LANES_TRACK_GROUP,
              "error"
            )
          ) : console.timeStamp(
            "Errored",
            startTime,
            endTime,
            currentTrack,
            LANES_TRACK_GROUP,
            "error"
          ));
        }
        function logSuspendedCommitPhase(startTime, endTime, reason, debugTask) {
          !supportsUserTiming || endTime <= startTime || (debugTask ? debugTask.run(
            console.timeStamp.bind(
              console,
              reason,
              startTime,
              endTime,
              currentTrack,
              LANES_TRACK_GROUP,
              "secondary-light"
            )
          ) : console.timeStamp(
            reason,
            startTime,
            endTime,
            currentTrack,
            LANES_TRACK_GROUP,
            "secondary-light"
          ));
        }
        function logCommitErrored(startTime, endTime, errors, passive, debugTask) {
          if (supportsUserTiming && !(endTime <= startTime)) {
            for (var properties = [], i8 = 0; i8 < errors.length; i8++) {
              var error = errors[i8].value;
              properties.push([
                "Error",
                "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error)
              ]);
            }
            startTime = {
              start: startTime,
              end: endTime,
              detail: {
                devtools: {
                  color: "error",
                  track: currentTrack,
                  trackGroup: LANES_TRACK_GROUP,
                  tooltipText: passive ? "Remaining Effects Errored" : "Commit Errored",
                  properties
                }
              }
            };
            debugTask ? debugTask.run(
              performance.measure.bind(performance, "Errored", startTime)
            ) : performance.measure("Errored", startTime);
          }
        }
        function logAnimatingPhase(startTime, endTime, debugTask) {
          !supportsUserTiming || endTime <= startTime || (debugTask ? debugTask.run(
            console.timeStamp.bind(
              console,
              "Animating",
              startTime,
              endTime,
              currentTrack,
              LANES_TRACK_GROUP,
              "secondary-dark"
            )
          ) : console.timeStamp(
            "Animating",
            startTime,
            endTime,
            currentTrack,
            LANES_TRACK_GROUP,
            "secondary-dark"
          ));
        }
        function finishQueueingConcurrentUpdates() {
          for (var endIndex = concurrentQueuesIndex, i8 = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i8 < endIndex; ) {
            var fiber = concurrentQueues[i8];
            concurrentQueues[i8++] = null;
            var queue = concurrentQueues[i8];
            concurrentQueues[i8++] = null;
            var update = concurrentQueues[i8];
            concurrentQueues[i8++] = null;
            var lane = concurrentQueues[i8];
            concurrentQueues[i8++] = null;
            if (null !== queue && null !== update) {
              var pending = queue.pending;
              null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
              queue.pending = update;
            }
            0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
          }
        }
        function enqueueUpdate$1(fiber, queue, update, lane) {
          concurrentQueues[concurrentQueuesIndex++] = fiber;
          concurrentQueues[concurrentQueuesIndex++] = queue;
          concurrentQueues[concurrentQueuesIndex++] = update;
          concurrentQueues[concurrentQueuesIndex++] = lane;
          concurrentlyUpdatedLanes |= lane;
          fiber.lanes |= lane;
          fiber = fiber.alternate;
          null !== fiber && (fiber.lanes |= lane);
        }
        function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
          enqueueUpdate$1(fiber, queue, update, lane);
          return getRootForUpdatedFiber(fiber);
        }
        function enqueueConcurrentRenderForLane(fiber, lane) {
          enqueueUpdate$1(fiber, null, null, lane);
          return getRootForUpdatedFiber(fiber);
        }
        function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
          sourceFiber.lanes |= lane;
          var alternate = sourceFiber.alternate;
          null !== alternate && (alternate.lanes |= lane);
          for (var isHidden = false, parent = sourceFiber.return; null !== parent; )
            parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & OffscreenVisible || (isHidden = true)), sourceFiber = parent, parent = parent.return;
          return 3 === sourceFiber.tag ? (parent = sourceFiber.stateNode, isHidden && null !== update && (isHidden = 31 - clz32(lane), sourceFiber = parent.hiddenUpdates, alternate = sourceFiber[isHidden], null === alternate ? sourceFiber[isHidden] = [update] : alternate.push(update), update.lane = lane | 536870912), parent) : null;
        }
        function getRootForUpdatedFiber(sourceFiber) {
          if (nestedUpdateCount > NESTED_UPDATE_LIMIT)
            throw nestedPassiveUpdateCount = nestedUpdateCount = 0, rootWithPassiveNestedUpdates = rootWithNestedUpdates = null, Error(
              "Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops."
            );
          nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT && (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, console.error(
            "Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."
          ));
          null === sourceFiber.alternate && 0 !== (sourceFiber.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
          for (var node = sourceFiber, parent = node.return; null !== parent; )
            null === node.alternate && 0 !== (node.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber), node = parent, parent = node.return;
          return 3 === node.tag ? node.stateNode : null;
        }
        function resolveFunctionForHotReloading(type) {
          if (null === resolveFamily) return type;
          var family = resolveFamily(type);
          return void 0 === family ? type : family.current;
        }
        function resolveForwardRefForHotReloading(type) {
          if (null === resolveFamily) return type;
          var family = resolveFamily(type);
          return void 0 === family ? null !== type && void 0 !== type && "function" === typeof type.render && (family = resolveFunctionForHotReloading(type.render), type.render !== family) ? (family = { $$typeof: REACT_FORWARD_REF_TYPE, render: family }, void 0 !== type.displayName && (family.displayName = type.displayName), family) : type : family.current;
        }
        function isCompatibleFamilyForHotReloading(fiber, element) {
          if (null === resolveFamily) return false;
          var prevType = fiber.elementType;
          element = element.type;
          var needsCompareFamilies = false, $$typeofNextType = "object" === typeof element && null !== element ? element.$$typeof : null;
          switch (fiber.tag) {
            case 1:
              "function" === typeof element && (needsCompareFamilies = true);
              break;
            case 0:
              "function" === typeof element ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
              break;
            case 11:
              $$typeofNextType === REACT_FORWARD_REF_TYPE ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
              break;
            case 14:
            case 15:
              $$typeofNextType === REACT_MEMO_TYPE ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
              break;
            default:
              return false;
          }
          return needsCompareFamilies && (fiber = resolveFamily(prevType), void 0 !== fiber && fiber === resolveFamily(element)) ? true : false;
        }
        function markFailedErrorBoundaryForHotReloading(fiber) {
          null !== resolveFamily && "function" === typeof WeakSet && (null === failedBoundaries && (failedBoundaries = /* @__PURE__ */ new WeakSet()), failedBoundaries.add(fiber));
        }
        function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
          do {
            var _fiber = fiber, alternate = _fiber.alternate, child = _fiber.child, sibling = _fiber.sibling, tag = _fiber.tag;
            _fiber = _fiber.type;
            var candidateType = null;
            switch (tag) {
              case 0:
              case 15:
              case 1:
                candidateType = _fiber;
                break;
              case 11:
                candidateType = _fiber.render;
            }
            if (null === resolveFamily)
              throw Error("Expected resolveFamily to be set during hot reload.");
            var needsRender = false;
            _fiber = false;
            null !== candidateType && (candidateType = resolveFamily(candidateType), void 0 !== candidateType && (staleFamilies.has(candidateType) ? _fiber = true : updatedFamilies.has(candidateType) && (1 === tag ? _fiber = true : needsRender = true)));
            null !== failedBoundaries && (failedBoundaries.has(fiber) || null !== alternate && failedBoundaries.has(alternate)) && (_fiber = true);
            _fiber && (fiber._debugNeedsRemount = true);
            if (_fiber || needsRender)
              alternate = enqueueConcurrentRenderForLane(fiber, 2), null !== alternate && scheduleUpdateOnFiber(alternate, fiber, 2);
            null === child || _fiber || scheduleFibersWithFamiliesRecursively(
              child,
              updatedFamilies,
              staleFamilies
            );
            if (null === sibling) break;
            fiber = sibling;
          } while (1);
        }
        function FiberNode(tag, pendingProps, key, mode) {
          this.tag = tag;
          this.key = key;
          this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
          this.index = 0;
          this.refCleanup = this.ref = null;
          this.pendingProps = pendingProps;
          this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
          this.mode = mode;
          this.subtreeFlags = this.flags = 0;
          this.deletions = null;
          this.childLanes = this.lanes = 0;
          this.alternate = null;
          this.actualDuration = -0;
          this.actualStartTime = -1.1;
          this.treeBaseDuration = this.selfBaseDuration = -0;
          this._debugTask = this._debugStack = this._debugOwner = this._debugInfo = null;
          this._debugNeedsRemount = false;
          this._debugHookTypes = null;
          hasBadMapPolyfill || "function" !== typeof Object.preventExtensions || Object.preventExtensions(this);
        }
        function shouldConstruct(Component) {
          Component = Component.prototype;
          return !(!Component || !Component.isReactComponent);
        }
        function createWorkInProgress(current2, pendingProps) {
          var workInProgress2 = current2.alternate;
          null === workInProgress2 ? (workInProgress2 = createFiber(
            current2.tag,
            pendingProps,
            current2.key,
            current2.mode
          ), workInProgress2.elementType = current2.elementType, workInProgress2.type = current2.type, workInProgress2.stateNode = current2.stateNode, workInProgress2._debugOwner = current2._debugOwner, workInProgress2._debugStack = current2._debugStack, workInProgress2._debugTask = current2._debugTask, workInProgress2._debugHookTypes = current2._debugHookTypes, workInProgress2.alternate = current2, current2.alternate = workInProgress2) : (workInProgress2.pendingProps = pendingProps, workInProgress2.type = current2.type, workInProgress2.flags = 0, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.actualDuration = -0, workInProgress2.actualStartTime = -1.1);
          workInProgress2.flags = current2.flags & 65011712;
          workInProgress2.childLanes = current2.childLanes;
          workInProgress2.lanes = current2.lanes;
          workInProgress2.child = current2.child;
          workInProgress2.memoizedProps = current2.memoizedProps;
          workInProgress2.memoizedState = current2.memoizedState;
          workInProgress2.updateQueue = current2.updateQueue;
          pendingProps = current2.dependencies;
          workInProgress2.dependencies = null === pendingProps ? null : {
            lanes: pendingProps.lanes,
            firstContext: pendingProps.firstContext,
            _debugThenableState: pendingProps._debugThenableState
          };
          workInProgress2.sibling = current2.sibling;
          workInProgress2.index = current2.index;
          workInProgress2.ref = current2.ref;
          workInProgress2.refCleanup = current2.refCleanup;
          workInProgress2.selfBaseDuration = current2.selfBaseDuration;
          workInProgress2.treeBaseDuration = current2.treeBaseDuration;
          workInProgress2._debugInfo = current2._debugInfo;
          workInProgress2._debugNeedsRemount = current2._debugNeedsRemount;
          switch (workInProgress2.tag) {
            case 0:
            case 15:
              workInProgress2.type = resolveFunctionForHotReloading(current2.type);
              break;
            case 1:
              workInProgress2.type = resolveFunctionForHotReloading(current2.type);
              break;
            case 11:
              workInProgress2.type = resolveForwardRefForHotReloading(current2.type);
          }
          return workInProgress2;
        }
        function resetWorkInProgress(workInProgress2, renderLanes2) {
          workInProgress2.flags &= 65011714;
          var current2 = workInProgress2.alternate;
          null === current2 ? (workInProgress2.childLanes = 0, workInProgress2.lanes = renderLanes2, workInProgress2.child = null, workInProgress2.subtreeFlags = 0, workInProgress2.memoizedProps = null, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null, workInProgress2.dependencies = null, workInProgress2.stateNode = null, workInProgress2.selfBaseDuration = 0, workInProgress2.treeBaseDuration = 0) : (workInProgress2.childLanes = current2.childLanes, workInProgress2.lanes = current2.lanes, workInProgress2.child = current2.child, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.memoizedProps = current2.memoizedProps, workInProgress2.memoizedState = current2.memoizedState, workInProgress2.updateQueue = current2.updateQueue, workInProgress2.type = current2.type, renderLanes2 = current2.dependencies, workInProgress2.dependencies = null === renderLanes2 ? null : {
            lanes: renderLanes2.lanes,
            firstContext: renderLanes2.firstContext,
            _debugThenableState: renderLanes2._debugThenableState
          }, workInProgress2.selfBaseDuration = current2.selfBaseDuration, workInProgress2.treeBaseDuration = current2.treeBaseDuration);
          return workInProgress2;
        }
        function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
          var fiberTag = 0, resolvedType = type;
          if ("function" === typeof type)
            shouldConstruct(type) && (fiberTag = 1), resolvedType = resolveFunctionForHotReloading(resolvedType);
          else if ("string" === typeof type)
            fiberTag = getHostContext(), fiberTag = isHostHoistableType(type, pendingProps, fiberTag) ? 26 : "html" === type || "head" === type || "body" === type ? 27 : 5;
          else
            a: switch (type) {
              case REACT_ACTIVITY_TYPE:
                return key = createFiber(31, pendingProps, key, mode), key.elementType = REACT_ACTIVITY_TYPE, key.lanes = lanes, key;
              case REACT_FRAGMENT_TYPE:
                return createFiberFromFragment(
                  pendingProps.children,
                  mode,
                  lanes,
                  key
                );
              case REACT_STRICT_MODE_TYPE:
                fiberTag = 8;
                mode |= StrictLegacyMode;
                mode |= StrictEffectsMode;
                break;
              case REACT_PROFILER_TYPE:
                return type = pendingProps, owner = mode, "string" !== typeof type.id && console.error(
                  'Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.',
                  typeof type.id
                ), key = createFiber(12, type, key, owner | ProfileMode), key.elementType = REACT_PROFILER_TYPE, key.lanes = lanes, key.stateNode = { effectDuration: 0, passiveEffectDuration: 0 }, key;
              case REACT_SUSPENSE_TYPE:
                return key = createFiber(13, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_TYPE, key.lanes = lanes, key;
              case REACT_SUSPENSE_LIST_TYPE:
                return key = createFiber(19, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_LIST_TYPE, key.lanes = lanes, key;
              default:
                if ("object" === typeof type && null !== type)
                  switch (type.$$typeof) {
                    case REACT_CONTEXT_TYPE:
                      fiberTag = 10;
                      break a;
                    case REACT_CONSUMER_TYPE:
                      fiberTag = 9;
                      break a;
                    case REACT_FORWARD_REF_TYPE:
                      fiberTag = 11;
                      resolvedType = resolveForwardRefForHotReloading(resolvedType);
                      break a;
                    case REACT_MEMO_TYPE:
                      fiberTag = 14;
                      break a;
                    case REACT_LAZY_TYPE:
                      fiberTag = 16;
                      resolvedType = null;
                      break a;
                  }
                resolvedType = "";
                if (void 0 === type || "object" === typeof type && null !== type && 0 === Object.keys(type).length)
                  resolvedType += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                null === type ? pendingProps = "null" : isArrayImpl(type) ? pendingProps = "array" : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE ? (pendingProps = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />", resolvedType = " Did you accidentally export a JSX literal instead of a component?") : pendingProps = typeof type;
                (fiberTag = owner ? getComponentNameFromOwner(owner) : null) && (resolvedType += "\n\nCheck the render method of `" + fiberTag + "`.");
                fiberTag = 29;
                pendingProps = Error(
                  "Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (pendingProps + "." + resolvedType)
                );
                resolvedType = null;
            }
          key = createFiber(fiberTag, pendingProps, key, mode);
          key.elementType = type;
          key.type = resolvedType;
          key.lanes = lanes;
          key._debugOwner = owner;
          return key;
        }
        function createFiberFromElement(element, mode, lanes) {
          mode = createFiberFromTypeAndProps(
            element.type,
            element.key,
            element.props,
            element._owner,
            mode,
            lanes
          );
          mode._debugOwner = element._owner;
          mode._debugStack = element._debugStack;
          mode._debugTask = element._debugTask;
          return mode;
        }
        function createFiberFromFragment(elements, mode, lanes, key) {
          elements = createFiber(7, elements, key, mode);
          elements.lanes = lanes;
          return elements;
        }
        function createFiberFromText(content, mode, lanes) {
          content = createFiber(6, content, null, mode);
          content.lanes = lanes;
          return content;
        }
        function createFiberFromDehydratedFragment(dehydratedNode) {
          var fiber = createFiber(18, null, null, NoMode);
          fiber.stateNode = dehydratedNode;
          return fiber;
        }
        function createFiberFromPortal(portal, mode, lanes) {
          mode = createFiber(
            4,
            null !== portal.children ? portal.children : [],
            portal.key,
            mode
          );
          mode.lanes = lanes;
          mode.stateNode = {
            containerInfo: portal.containerInfo,
            pendingChildren: null,
            implementation: portal.implementation
          };
          return mode;
        }
        function createCapturedValueAtFiber(value, source) {
          if ("object" === typeof value && null !== value) {
            var existing = CapturedStacks.get(value);
            if (void 0 !== existing) return existing;
            source = {
              value,
              source,
              stack: getStackByFiberInDevAndProd(source)
            };
            CapturedStacks.set(value, source);
            return source;
          }
          return {
            value,
            source,
            stack: getStackByFiberInDevAndProd(source)
          };
        }
        function pushTreeFork(workInProgress2, totalChildren) {
          warnIfNotHydrating();
          forkStack[forkStackIndex++] = treeForkCount;
          forkStack[forkStackIndex++] = treeForkProvider;
          treeForkProvider = workInProgress2;
          treeForkCount = totalChildren;
        }
        function pushTreeId(workInProgress2, totalChildren, index) {
          warnIfNotHydrating();
          idStack[idStackIndex++] = treeContextId;
          idStack[idStackIndex++] = treeContextOverflow;
          idStack[idStackIndex++] = treeContextProvider;
          treeContextProvider = workInProgress2;
          var baseIdWithLeadingBit = treeContextId;
          workInProgress2 = treeContextOverflow;
          var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
          baseIdWithLeadingBit &= ~(1 << baseLength);
          index += 1;
          var length = 32 - clz32(totalChildren) + baseLength;
          if (30 < length) {
            var numberOfOverflowBits = baseLength - baseLength % 5;
            length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
            baseIdWithLeadingBit >>= numberOfOverflowBits;
            baseLength -= numberOfOverflowBits;
            treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit;
            treeContextOverflow = length + workInProgress2;
          } else
            treeContextId = 1 << length | index << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress2;
        }
        function pushMaterializedTreeId(workInProgress2) {
          warnIfNotHydrating();
          null !== workInProgress2.return && (pushTreeFork(workInProgress2, 1), pushTreeId(workInProgress2, 1, 0));
        }
        function popTreeContext(workInProgress2) {
          for (; workInProgress2 === treeForkProvider; )
            treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
          for (; workInProgress2 === treeContextProvider; )
            treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
        }
        function getSuspendedTreeContext() {
          warnIfNotHydrating();
          return null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null;
        }
        function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {
          warnIfNotHydrating();
          idStack[idStackIndex++] = treeContextId;
          idStack[idStackIndex++] = treeContextOverflow;
          idStack[idStackIndex++] = treeContextProvider;
          treeContextId = suspendedContext.id;
          treeContextOverflow = suspendedContext.overflow;
          treeContextProvider = workInProgress2;
        }
        function warnIfNotHydrating() {
          isHydrating || console.error(
            "Expected to be hydrating. This is a bug in React. Please file an issue."
          );
        }
        function buildHydrationDiffNode(fiber, distanceFromLeaf) {
          if (null === fiber.return) {
            if (null === hydrationDiffRootDEV)
              hydrationDiffRootDEV = {
                fiber,
                children: [],
                serverProps: void 0,
                serverTail: [],
                distanceFromLeaf
              };
            else {
              if (hydrationDiffRootDEV.fiber !== fiber)
                throw Error(
                  "Saw multiple hydration diff roots in a pass. This is a bug in React."
                );
              hydrationDiffRootDEV.distanceFromLeaf > distanceFromLeaf && (hydrationDiffRootDEV.distanceFromLeaf = distanceFromLeaf);
            }
            return hydrationDiffRootDEV;
          }
          var siblings = buildHydrationDiffNode(
            fiber.return,
            distanceFromLeaf + 1
          ).children;
          if (0 < siblings.length && siblings[siblings.length - 1].fiber === fiber)
            return siblings = siblings[siblings.length - 1], siblings.distanceFromLeaf > distanceFromLeaf && (siblings.distanceFromLeaf = distanceFromLeaf), siblings;
          distanceFromLeaf = {
            fiber,
            children: [],
            serverProps: void 0,
            serverTail: [],
            distanceFromLeaf
          };
          siblings.push(distanceFromLeaf);
          return distanceFromLeaf;
        }
        function warnIfHydrating() {
          isHydrating && console.error(
            "We should not be hydrating here. This is a bug in React. Please file a bug."
          );
        }
        function warnNonHydratedInstance(fiber, rejectedCandidate) {
          didSuspendOrErrorDEV || (fiber = buildHydrationDiffNode(fiber, 0), fiber.serverProps = null, null !== rejectedCandidate && (rejectedCandidate = describeHydratableInstanceForDevWarnings(rejectedCandidate), fiber.serverTail.push(rejectedCandidate)));
        }
        function throwOnHydrationMismatch(fiber) {
          var fromText = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : false, diff = "", diffRoot = hydrationDiffRootDEV;
          null !== diffRoot && (hydrationDiffRootDEV = null, diff = describeDiff(diffRoot));
          queueHydrationError(
            createCapturedValueAtFiber(
              Error(
                "Hydration failed because the server rendered " + (fromText ? "text" : "HTML") + " didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\nhttps://react.dev/link/hydration-mismatch" + diff
              ),
              fiber
            )
          );
          throw HydrationMismatchException;
        }
        function prepareToHydrateHostInstance(fiber) {
          var didHydrate = fiber.stateNode;
          var type = fiber.type, props = fiber.memoizedProps;
          didHydrate[internalInstanceKey] = fiber;
          didHydrate[internalPropsKey] = props;
          validatePropertiesInDevelopment(type, props);
          switch (type) {
            case "dialog":
              listenToNonDelegatedEvent("cancel", didHydrate);
              listenToNonDelegatedEvent("close", didHydrate);
              break;
            case "iframe":
            case "object":
            case "embed":
              listenToNonDelegatedEvent("load", didHydrate);
              break;
            case "video":
            case "audio":
              for (type = 0; type < mediaEventTypes.length; type++)
                listenToNonDelegatedEvent(mediaEventTypes[type], didHydrate);
              break;
            case "source":
              listenToNonDelegatedEvent("error", didHydrate);
              break;
            case "img":
            case "image":
            case "link":
              listenToNonDelegatedEvent("error", didHydrate);
              listenToNonDelegatedEvent("load", didHydrate);
              break;
            case "details":
              listenToNonDelegatedEvent("toggle", didHydrate);
              break;
            case "input":
              checkControlledValueProps("input", props);
              listenToNonDelegatedEvent("invalid", didHydrate);
              validateInputProps(didHydrate, props);
              initInput(
                didHydrate,
                props.value,
                props.defaultValue,
                props.checked,
                props.defaultChecked,
                props.type,
                props.name,
                true
              );
              break;
            case "option":
              validateOptionProps(didHydrate, props);
              break;
            case "select":
              checkControlledValueProps("select", props);
              listenToNonDelegatedEvent("invalid", didHydrate);
              validateSelectProps(didHydrate, props);
              break;
            case "textarea":
              checkControlledValueProps("textarea", props), listenToNonDelegatedEvent("invalid", didHydrate), validateTextareaProps(didHydrate, props), initTextarea(
                didHydrate,
                props.value,
                props.defaultValue,
                props.children
              );
          }
          type = props.children;
          "string" !== typeof type && "number" !== typeof type && "bigint" !== typeof type || didHydrate.textContent === "" + type || true === props.suppressHydrationWarning || checkForUnmatchedText(didHydrate.textContent, type) ? (null != props.popover && (listenToNonDelegatedEvent("beforetoggle", didHydrate), listenToNonDelegatedEvent("toggle", didHydrate)), null != props.onScroll && listenToNonDelegatedEvent("scroll", didHydrate), null != props.onScrollEnd && listenToNonDelegatedEvent("scrollend", didHydrate), null != props.onClick && (didHydrate.onclick = noop$1), didHydrate = true) : didHydrate = false;
          didHydrate || throwOnHydrationMismatch(fiber, true);
        }
        function popToNextHostParent(fiber) {
          for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
            switch (hydrationParentFiber.tag) {
              case 5:
              case 31:
              case 13:
                rootOrSingletonContext = false;
                return;
              case 27:
              case 3:
                rootOrSingletonContext = true;
                return;
              default:
                hydrationParentFiber = hydrationParentFiber.return;
            }
        }
        function popHydrationState(fiber) {
          if (fiber !== hydrationParentFiber) return false;
          if (!isHydrating)
            return popToNextHostParent(fiber), isHydrating = true, false;
          var tag = fiber.tag, JSCompiler_temp;
          if (JSCompiler_temp = 3 !== tag && 27 !== tag) {
            if (JSCompiler_temp = 5 === tag)
              JSCompiler_temp = fiber.type, JSCompiler_temp = !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) || shouldSetTextContent(fiber.type, fiber.memoizedProps);
            JSCompiler_temp = !JSCompiler_temp;
          }
          if (JSCompiler_temp && nextHydratableInstance) {
            for (JSCompiler_temp = nextHydratableInstance; JSCompiler_temp; ) {
              var diffNode = buildHydrationDiffNode(fiber, 0), description = describeHydratableInstanceForDevWarnings(JSCompiler_temp);
              diffNode.serverTail.push(description);
              JSCompiler_temp = "Suspense" === description.type ? getNextHydratableInstanceAfterHydrationBoundary(JSCompiler_temp) : getNextHydratable(JSCompiler_temp.nextSibling);
            }
            throwOnHydrationMismatch(fiber);
          }
          popToNextHostParent(fiber);
          if (13 === tag) {
            fiber = fiber.memoizedState;
            fiber = null !== fiber ? fiber.dehydrated : null;
            if (!fiber)
              throw Error(
                "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
              );
            nextHydratableInstance = getNextHydratableInstanceAfterHydrationBoundary(fiber);
          } else if (31 === tag) {
            fiber = fiber.memoizedState;
            fiber = null !== fiber ? fiber.dehydrated : null;
            if (!fiber)
              throw Error(
                "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
              );
            nextHydratableInstance = getNextHydratableInstanceAfterHydrationBoundary(fiber);
          } else
            27 === tag ? (tag = nextHydratableInstance, isSingletonScope(fiber.type) ? (fiber = previousHydratableOnEnteringScopedSingleton, previousHydratableOnEnteringScopedSingleton = null, nextHydratableInstance = fiber) : nextHydratableInstance = tag) : nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null;
          return true;
        }
        function resetHydrationState() {
          nextHydratableInstance = hydrationParentFiber = null;
          didSuspendOrErrorDEV = isHydrating = false;
        }
        function upgradeHydrationErrorsToRecoverable() {
          var queuedErrors = hydrationErrors;
          null !== queuedErrors && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = queuedErrors : workInProgressRootRecoverableErrors.push.apply(
            workInProgressRootRecoverableErrors,
            queuedErrors
          ), hydrationErrors = null);
          return queuedErrors;
        }
        function queueHydrationError(error) {
          null === hydrationErrors ? hydrationErrors = [error] : hydrationErrors.push(error);
        }
        function emitPendingHydrationWarnings() {
          var diffRoot = hydrationDiffRootDEV;
          if (null !== diffRoot) {
            hydrationDiffRootDEV = null;
            for (var diff = describeDiff(diffRoot); 0 < diffRoot.children.length; )
              diffRoot = diffRoot.children[0];
            runWithFiberInDEV(diffRoot.fiber, function() {
              console.error(
                "A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\n%s%s",
                "https://react.dev/link/hydration-mismatch",
                diff
              );
            });
          }
        }
        function resetContextDependencies() {
          lastContextDependency = currentlyRenderingFiber$1 = null;
          isDisallowedContextReadInDEV = false;
        }
        function pushProvider(providerFiber, context, nextValue) {
          push(valueCursor, context._currentValue, providerFiber);
          context._currentValue = nextValue;
          push(rendererCursorDEV, context._currentRenderer, providerFiber);
          void 0 !== context._currentRenderer && null !== context._currentRenderer && context._currentRenderer !== rendererSigil && console.error(
            "Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."
          );
          context._currentRenderer = rendererSigil;
        }
        function popProvider(context, providerFiber) {
          context._currentValue = valueCursor.current;
          var currentRenderer = rendererCursorDEV.current;
          pop(rendererCursorDEV, providerFiber);
          context._currentRenderer = currentRenderer;
          pop(valueCursor, providerFiber);
        }
        function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
          for (; null !== parent; ) {
            var alternate = parent.alternate;
            (parent.childLanes & renderLanes2) !== renderLanes2 ? (parent.childLanes |= renderLanes2, null !== alternate && (alternate.childLanes |= renderLanes2)) : null !== alternate && (alternate.childLanes & renderLanes2) !== renderLanes2 && (alternate.childLanes |= renderLanes2);
            if (parent === propagationRoot) break;
            parent = parent.return;
          }
          parent !== propagationRoot && console.error(
            "Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue."
          );
        }
        function propagateContextChanges(workInProgress2, contexts, renderLanes2, forcePropagateEntireTree) {
          var fiber = workInProgress2.child;
          null !== fiber && (fiber.return = workInProgress2);
          for (; null !== fiber; ) {
            var list = fiber.dependencies;
            if (null !== list) {
              var nextFiber = fiber.child;
              list = list.firstContext;
              a: for (; null !== list; ) {
                var dependency = list;
                list = fiber;
                for (var i8 = 0; i8 < contexts.length; i8++)
                  if (dependency.context === contexts[i8]) {
                    list.lanes |= renderLanes2;
                    dependency = list.alternate;
                    null !== dependency && (dependency.lanes |= renderLanes2);
                    scheduleContextWorkOnParentPath(
                      list.return,
                      renderLanes2,
                      workInProgress2
                    );
                    forcePropagateEntireTree || (nextFiber = null);
                    break a;
                  }
                list = dependency.next;
              }
            } else if (18 === fiber.tag) {
              nextFiber = fiber.return;
              if (null === nextFiber)
                throw Error(
                  "We just came from a parent so we must have had a parent. This is a bug in React."
                );
              nextFiber.lanes |= renderLanes2;
              list = nextFiber.alternate;
              null !== list && (list.lanes |= renderLanes2);
              scheduleContextWorkOnParentPath(
                nextFiber,
                renderLanes2,
                workInProgress2
              );
              nextFiber = null;
            } else nextFiber = fiber.child;
            if (null !== nextFiber) nextFiber.return = fiber;
            else
              for (nextFiber = fiber; null !== nextFiber; ) {
                if (nextFiber === workInProgress2) {
                  nextFiber = null;
                  break;
                }
                fiber = nextFiber.sibling;
                if (null !== fiber) {
                  fiber.return = nextFiber.return;
                  nextFiber = fiber;
                  break;
                }
                nextFiber = nextFiber.return;
              }
            fiber = nextFiber;
          }
        }
        function propagateParentContextChanges(current2, workInProgress2, renderLanes2, forcePropagateEntireTree) {
          current2 = null;
          for (var parent = workInProgress2, isInsidePropagationBailout = false; null !== parent; ) {
            if (!isInsidePropagationBailout) {
              if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = true;
              else if (0 !== (parent.flags & 262144)) break;
            }
            if (10 === parent.tag) {
              var currentParent = parent.alternate;
              if (null === currentParent)
                throw Error("Should have a current fiber. This is a bug in React.");
              currentParent = currentParent.memoizedProps;
              if (null !== currentParent) {
                var context = parent.type;
                objectIs(parent.pendingProps.value, currentParent.value) || (null !== current2 ? current2.push(context) : current2 = [context]);
              }
            } else if (parent === hostTransitionProviderCursor.current) {
              currentParent = parent.alternate;
              if (null === currentParent)
                throw Error("Should have a current fiber. This is a bug in React.");
              currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current2 ? current2.push(HostTransitionContext) : current2 = [HostTransitionContext]);
            }
            parent = parent.return;
          }
          null !== current2 && propagateContextChanges(
            workInProgress2,
            current2,
            renderLanes2,
            forcePropagateEntireTree
          );
          workInProgress2.flags |= 262144;
        }
        function checkIfContextChanged(currentDependencies) {
          for (currentDependencies = currentDependencies.firstContext; null !== currentDependencies; ) {
            if (!objectIs(
              currentDependencies.context._currentValue,
              currentDependencies.memoizedValue
            ))
              return true;
            currentDependencies = currentDependencies.next;
          }
          return false;
        }
        function prepareToReadContext(workInProgress2) {
          currentlyRenderingFiber$1 = workInProgress2;
          lastContextDependency = null;
          workInProgress2 = workInProgress2.dependencies;
          null !== workInProgress2 && (workInProgress2.firstContext = null);
        }
        function readContext(context) {
          isDisallowedContextReadInDEV && console.error(
            "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
          );
          return readContextForConsumer(currentlyRenderingFiber$1, context);
        }
        function readContextDuringReconciliation(consumer, context) {
          null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
          return readContextForConsumer(consumer, context);
        }
        function readContextForConsumer(consumer, context) {
          var value = context._currentValue;
          context = { context, memoizedValue: value, next: null };
          if (null === lastContextDependency) {
            if (null === consumer)
              throw Error(
                "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
              );
            lastContextDependency = context;
            consumer.dependencies = {
              lanes: 0,
              firstContext: context,
              _debugThenableState: null
            };
            consumer.flags |= 524288;
          } else lastContextDependency = lastContextDependency.next = context;
          return value;
        }
        function createCache() {
          return {
            controller: new AbortControllerLocal(),
            data: /* @__PURE__ */ new Map(),
            refCount: 0
          };
        }
        function retainCache(cache) {
          cache.controller.signal.aborted && console.warn(
            "A cache instance was retained after it was already freed. This likely indicates a bug in React."
          );
          cache.refCount++;
        }
        function releaseCache(cache) {
          cache.refCount--;
          0 > cache.refCount && console.warn(
            "A cache instance was released after it was already freed. This likely indicates a bug in React."
          );
          0 === cache.refCount && scheduleCallback$2(NormalPriority, function() {
            cache.controller.abort();
          });
        }
        function startUpdateTimerByLane(lane, method, fiber) {
          if (0 !== (lane & 127))
            0 > blockingUpdateTime && (blockingUpdateTime = now(), blockingUpdateTask = createTask(method), blockingUpdateMethodName = method, null != fiber && (blockingUpdateComponentName = getComponentNameFromFiber(fiber)), (executionContext & (RenderContext | CommitContext)) !== NoContext && (componentEffectSpawnedUpdate = true, blockingUpdateType = SPAWNED_UPDATE), lane = resolveEventTimeStamp(), method = resolveEventType(), lane !== blockingEventRepeatTime || method !== blockingEventType ? blockingEventRepeatTime = -1.1 : null !== method && (blockingUpdateType = SPAWNED_UPDATE), blockingEventTime = lane, blockingEventType = method);
          else if (0 !== (lane & 4194048) && 0 > transitionUpdateTime && (transitionUpdateTime = now(), transitionUpdateTask = createTask(method), transitionUpdateMethodName = method, null != fiber && (transitionUpdateComponentName = getComponentNameFromFiber(fiber)), 0 > transitionStartTime)) {
            lane = resolveEventTimeStamp();
            method = resolveEventType();
            if (lane !== transitionEventRepeatTime || method !== transitionEventType)
              transitionEventRepeatTime = -1.1;
            transitionEventTime = lane;
            transitionEventType = method;
          }
        }
        function startHostActionTimer(fiber) {
          if (0 > blockingUpdateTime) {
            blockingUpdateTime = now();
            blockingUpdateTask = null != fiber._debugTask ? fiber._debugTask : null;
            (executionContext & (RenderContext | CommitContext)) !== NoContext && (blockingUpdateType = SPAWNED_UPDATE);
            var newEventTime = resolveEventTimeStamp(), newEventType = resolveEventType();
            newEventTime !== blockingEventRepeatTime || newEventType !== blockingEventType ? blockingEventRepeatTime = -1.1 : null !== newEventType && (blockingUpdateType = SPAWNED_UPDATE);
            blockingEventTime = newEventTime;
            blockingEventType = newEventType;
          }
          if (0 > transitionUpdateTime && (transitionUpdateTime = now(), transitionUpdateTask = null != fiber._debugTask ? fiber._debugTask : null, 0 > transitionStartTime)) {
            fiber = resolveEventTimeStamp();
            newEventTime = resolveEventType();
            if (fiber !== transitionEventRepeatTime || newEventTime !== transitionEventType)
              transitionEventRepeatTime = -1.1;
            transitionEventTime = fiber;
            transitionEventType = newEventTime;
          }
        }
        function pushNestedEffectDurations() {
          var prevEffectDuration = profilerEffectDuration;
          profilerEffectDuration = 0;
          return prevEffectDuration;
        }
        function popNestedEffectDurations(prevEffectDuration) {
          var elapsedTime = profilerEffectDuration;
          profilerEffectDuration = prevEffectDuration;
          return elapsedTime;
        }
        function bubbleNestedEffectDurations(prevEffectDuration) {
          var elapsedTime = profilerEffectDuration;
          profilerEffectDuration += prevEffectDuration;
          return elapsedTime;
        }
        function resetComponentEffectTimers() {
          componentEffectEndTime = componentEffectStartTime = -1.1;
        }
        function pushComponentEffectStart() {
          var prevEffectStart = componentEffectStartTime;
          componentEffectStartTime = -1.1;
          return prevEffectStart;
        }
        function popComponentEffectStart(prevEffectStart) {
          0 <= prevEffectStart && (componentEffectStartTime = prevEffectStart);
        }
        function pushComponentEffectDuration() {
          var prevEffectDuration = componentEffectDuration;
          componentEffectDuration = -0;
          return prevEffectDuration;
        }
        function popComponentEffectDuration(prevEffectDuration) {
          0 <= prevEffectDuration && (componentEffectDuration = prevEffectDuration);
        }
        function pushComponentEffectErrors() {
          var prevErrors = componentEffectErrors;
          componentEffectErrors = null;
          return prevErrors;
        }
        function pushComponentEffectDidSpawnUpdate() {
          var prev = componentEffectSpawnedUpdate;
          componentEffectSpawnedUpdate = false;
          return prev;
        }
        function startProfilerTimer(fiber) {
          profilerStartTime = now();
          0 > fiber.actualStartTime && (fiber.actualStartTime = profilerStartTime);
        }
        function stopProfilerTimerIfRunningAndRecordDuration(fiber) {
          if (0 <= profilerStartTime) {
            var elapsedTime = now() - profilerStartTime;
            fiber.actualDuration += elapsedTime;
            fiber.selfBaseDuration = elapsedTime;
            profilerStartTime = -1;
          }
        }
        function stopProfilerTimerIfRunningAndRecordIncompleteDuration(fiber) {
          if (0 <= profilerStartTime) {
            var elapsedTime = now() - profilerStartTime;
            fiber.actualDuration += elapsedTime;
            profilerStartTime = -1;
          }
        }
        function recordEffectDuration() {
          if (0 <= profilerStartTime) {
            var endTime = now(), elapsedTime = endTime - profilerStartTime;
            profilerStartTime = -1;
            profilerEffectDuration += elapsedTime;
            componentEffectDuration += elapsedTime;
            componentEffectEndTime = endTime;
          }
        }
        function recordEffectError(errorInfo) {
          null === componentEffectErrors && (componentEffectErrors = []);
          componentEffectErrors.push(errorInfo);
          null === commitErrors && (commitErrors = []);
          commitErrors.push(errorInfo);
        }
        function startEffectTimer() {
          profilerStartTime = now();
          0 > componentEffectStartTime && (componentEffectStartTime = profilerStartTime);
        }
        function transferActualDuration(fiber) {
          for (var child = fiber.child; child; )
            fiber.actualDuration += child.actualDuration, child = child.sibling;
        }
        function entangleAsyncAction(transition, thenable) {
          if (null === currentEntangledListeners) {
            var entangledListeners = currentEntangledListeners = [];
            currentEntangledPendingCount = 0;
            currentEntangledLane = requestTransitionLane();
            currentEntangledActionThenable = {
              status: "pending",
              value: void 0,
              then: function(resolve) {
                entangledListeners.push(resolve);
              }
            };
          }
          currentEntangledPendingCount++;
          thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
          return thenable;
        }
        function pingEngtangledActionScope() {
          if (0 === --currentEntangledPendingCount && (-1 < transitionUpdateTime || (transitionStartTime = -1.1), null !== currentEntangledListeners)) {
            null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = "fulfilled");
            var listeners = currentEntangledListeners;
            currentEntangledListeners = null;
            currentEntangledLane = 0;
            currentEntangledActionThenable = null;
            for (var i8 = 0; i8 < listeners.length; i8++) (0, listeners[i8])();
          }
        }
        function chainThenableValue(thenable, result) {
          var listeners = [], thenableWithOverride = {
            status: "pending",
            value: null,
            reason: null,
            then: function(resolve) {
              listeners.push(resolve);
            }
          };
          thenable.then(
            function() {
              thenableWithOverride.status = "fulfilled";
              thenableWithOverride.value = result;
              for (var i8 = 0; i8 < listeners.length; i8++) (0, listeners[i8])(result);
            },
            function(error) {
              thenableWithOverride.status = "rejected";
              thenableWithOverride.reason = error;
              for (error = 0; error < listeners.length; error++)
                (0, listeners[error])(void 0);
            }
          );
          return thenableWithOverride;
        }
        function peekCacheFromPool() {
          var cacheResumedFromPreviousRender = resumedCache.current;
          return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
        }
        function pushTransition(offscreenWorkInProgress, prevCachePool) {
          null === prevCachePool ? push(resumedCache, resumedCache.current, offscreenWorkInProgress) : push(resumedCache, prevCachePool.pool, offscreenWorkInProgress);
        }
        function getSuspendedCache() {
          var cacheFromPool = peekCacheFromPool();
          return null === cacheFromPool ? null : { parent: CacheContext._currentValue, pool: cacheFromPool };
        }
        function createThenableState() {
          return { didWarnAboutUncachedPromise: false, thenables: [] };
        }
        function isThenableResolved(thenable) {
          thenable = thenable.status;
          return "fulfilled" === thenable || "rejected" === thenable;
        }
        function trackUsedThenable(thenableState2, thenable, index) {
          null !== ReactSharedInternals.actQueue && (ReactSharedInternals.didUsePromise = true);
          var trackedThenables = thenableState2.thenables;
          index = trackedThenables[index];
          void 0 === index ? trackedThenables.push(thenable) : index !== thenable && (thenableState2.didWarnAboutUncachedPromise || (thenableState2.didWarnAboutUncachedPromise = true, console.error(
            "A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework."
          )), thenable.then(noop$1, noop$1), thenable = index);
          if (void 0 === thenable._debugInfo) {
            thenableState2 = performance.now();
            trackedThenables = thenable.displayName;
            var ioInfo = {
              name: "string" === typeof trackedThenables ? trackedThenables : "Promise",
              start: thenableState2,
              end: thenableState2,
              value: thenable
            };
            thenable._debugInfo = [{ awaited: ioInfo }];
            "fulfilled" !== thenable.status && "rejected" !== thenable.status && (thenableState2 = function() {
              ioInfo.end = performance.now();
            }, thenable.then(thenableState2, thenableState2));
          }
          switch (thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
            default:
              if ("string" === typeof thenable.status)
                thenable.then(noop$1, noop$1);
              else {
                thenableState2 = workInProgressRoot;
                if (null !== thenableState2 && 100 < thenableState2.shellSuspendCounter)
                  throw Error(
                    "An unknown Component is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
                  );
                thenableState2 = thenable;
                thenableState2.status = "pending";
                thenableState2.then(
                  function(fulfilledValue) {
                    if ("pending" === thenable.status) {
                      var fulfilledThenable = thenable;
                      fulfilledThenable.status = "fulfilled";
                      fulfilledThenable.value = fulfilledValue;
                    }
                  },
                  function(error) {
                    if ("pending" === thenable.status) {
                      var rejectedThenable = thenable;
                      rejectedThenable.status = "rejected";
                      rejectedThenable.reason = error;
                    }
                  }
                );
              }
              switch (thenable.status) {
                case "fulfilled":
                  return thenable.value;
                case "rejected":
                  throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
              }
              suspendedThenable = thenable;
              needsToResetSuspendedThenableDEV = true;
              throw SuspenseException;
          }
        }
        function resolveLazy(lazyType) {
          try {
            return callLazyInitInDEV(lazyType);
          } catch (x6) {
            if (null !== x6 && "object" === typeof x6 && "function" === typeof x6.then)
              throw suspendedThenable = x6, needsToResetSuspendedThenableDEV = true, SuspenseException;
            throw x6;
          }
        }
        function getSuspendedThenable() {
          if (null === suspendedThenable)
            throw Error(
              "Expected a suspended thenable. This is a bug in React. Please file an issue."
            );
          var thenable = suspendedThenable;
          suspendedThenable = null;
          needsToResetSuspendedThenableDEV = false;
          return thenable;
        }
        function checkIfUseWrappedInAsyncCatch(rejectedReason) {
          if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException)
            throw Error(
              "Hooks are not supported inside an async component. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
            );
        }
        function pushDebugInfo(debugInfo) {
          var previousDebugInfo = currentDebugInfo;
          null != debugInfo && (currentDebugInfo = null === previousDebugInfo ? debugInfo : previousDebugInfo.concat(debugInfo));
          return previousDebugInfo;
        }
        function getCurrentDebugTask() {
          var debugInfo = currentDebugInfo;
          if (null != debugInfo) {
            for (var i8 = debugInfo.length - 1; 0 <= i8; i8--)
              if (null != debugInfo[i8].name) {
                var debugTask = debugInfo[i8].debugTask;
                if (null != debugTask) return debugTask;
              }
          }
          return null;
        }
        function validateFragmentProps(element, fiber, returnFiber) {
          for (var keys = Object.keys(element.props), i8 = 0; i8 < keys.length; i8++) {
            var key = keys[i8];
            if ("children" !== key && "key" !== key) {
              null === fiber && (fiber = createFiberFromElement(element, returnFiber.mode, 0), fiber._debugInfo = currentDebugInfo, fiber.return = returnFiber);
              runWithFiberInDEV(
                fiber,
                function(erroredKey) {
                  console.error(
                    "Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.",
                    erroredKey
                  );
                },
                key
              );
              break;
            }
          }
        }
        function unwrapThenable(thenable) {
          var index = thenableIndexCounter$1;
          thenableIndexCounter$1 += 1;
          null === thenableState$1 && (thenableState$1 = createThenableState());
          return trackUsedThenable(thenableState$1, thenable, index);
        }
        function coerceRef(workInProgress2, element) {
          element = element.props.ref;
          workInProgress2.ref = void 0 !== element ? element : null;
        }
        function throwOnInvalidObjectTypeImpl(returnFiber, newChild) {
          if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
            throw Error(
              'A React Element from an older version of React was rendered. This is not supported. It can happen if:\n- Multiple copies of the "react" package is used.\n- A library pre-bundled an old copy of "react" or "react/jsx-runtime".\n- A compiler tries to "inline" JSX instead of using the runtime.'
            );
          returnFiber = Object.prototype.toString.call(newChild);
          throw Error(
            "Objects are not valid as a React child (found: " + ("[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber) + "). If you meant to render a collection of children, use an array instead."
          );
        }
        function throwOnInvalidObjectType(returnFiber, newChild) {
          var debugTask = getCurrentDebugTask();
          null !== debugTask ? debugTask.run(
            throwOnInvalidObjectTypeImpl.bind(null, returnFiber, newChild)
          ) : throwOnInvalidObjectTypeImpl(returnFiber, newChild);
        }
        function warnOnFunctionTypeImpl(returnFiber, invalidChild) {
          var parentName = getComponentNameFromFiber(returnFiber) || "Component";
          ownerHasFunctionTypeWarning[parentName] || (ownerHasFunctionTypeWarning[parentName] = true, invalidChild = invalidChild.displayName || invalidChild.name || "Component", 3 === returnFiber.tag ? console.error(
            "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  root.render(%s)",
            invalidChild,
            invalidChild,
            invalidChild
          ) : console.error(
            "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  <%s>{%s}</%s>",
            invalidChild,
            invalidChild,
            parentName,
            invalidChild,
            parentName
          ));
        }
        function warnOnFunctionType(returnFiber, invalidChild) {
          var debugTask = getCurrentDebugTask();
          null !== debugTask ? debugTask.run(
            warnOnFunctionTypeImpl.bind(null, returnFiber, invalidChild)
          ) : warnOnFunctionTypeImpl(returnFiber, invalidChild);
        }
        function warnOnSymbolTypeImpl(returnFiber, invalidChild) {
          var parentName = getComponentNameFromFiber(returnFiber) || "Component";
          ownerHasSymbolTypeWarning[parentName] || (ownerHasSymbolTypeWarning[parentName] = true, invalidChild = String(invalidChild), 3 === returnFiber.tag ? console.error(
            "Symbols are not valid as a React child.\n  root.render(%s)",
            invalidChild
          ) : console.error(
            "Symbols are not valid as a React child.\n  <%s>%s</%s>",
            parentName,
            invalidChild,
            parentName
          ));
        }
        function warnOnSymbolType(returnFiber, invalidChild) {
          var debugTask = getCurrentDebugTask();
          null !== debugTask ? debugTask.run(
            warnOnSymbolTypeImpl.bind(null, returnFiber, invalidChild)
          ) : warnOnSymbolTypeImpl(returnFiber, invalidChild);
        }
        function createChildReconciler(shouldTrackSideEffects) {
          function deleteChild(returnFiber, childToDelete) {
            if (shouldTrackSideEffects) {
              var deletions = returnFiber.deletions;
              null === deletions ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
            }
          }
          function deleteRemainingChildren(returnFiber, currentFirstChild) {
            if (!shouldTrackSideEffects) return null;
            for (; null !== currentFirstChild; )
              deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
            return null;
          }
          function mapRemainingChildren(currentFirstChild) {
            for (var existingChildren = /* @__PURE__ */ new Map(); null !== currentFirstChild; )
              null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
            return existingChildren;
          }
          function useFiber(fiber, pendingProps) {
            fiber = createWorkInProgress(fiber, pendingProps);
            fiber.index = 0;
            fiber.sibling = null;
            return fiber;
          }
          function placeChild(newFiber, lastPlacedIndex, newIndex) {
            newFiber.index = newIndex;
            if (!shouldTrackSideEffects)
              return newFiber.flags |= 1048576, lastPlacedIndex;
            newIndex = newFiber.alternate;
            if (null !== newIndex)
              return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 67108866, lastPlacedIndex) : newIndex;
            newFiber.flags |= 67108866;
            return lastPlacedIndex;
          }
          function placeSingleChild(newFiber) {
            shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 67108866);
            return newFiber;
          }
          function updateTextNode(returnFiber, current2, textContent, lanes) {
            if (null === current2 || 6 !== current2.tag)
              return current2 = createFiberFromText(
                textContent,
                returnFiber.mode,
                lanes
              ), current2.return = returnFiber, current2._debugOwner = returnFiber, current2._debugTask = returnFiber._debugTask, current2._debugInfo = currentDebugInfo, current2;
            current2 = useFiber(current2, textContent);
            current2.return = returnFiber;
            current2._debugInfo = currentDebugInfo;
            return current2;
          }
          function updateElement(returnFiber, current2, element, lanes) {
            var elementType = element.type;
            if (elementType === REACT_FRAGMENT_TYPE)
              return current2 = updateFragment(
                returnFiber,
                current2,
                element.props.children,
                lanes,
                element.key
              ), validateFragmentProps(element, current2, returnFiber), current2;
            if (null !== current2 && (current2.elementType === elementType || isCompatibleFamilyForHotReloading(current2, element) || "object" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current2.type))
              return current2 = useFiber(current2, element.props), coerceRef(current2, element), current2.return = returnFiber, current2._debugOwner = element._owner, current2._debugInfo = currentDebugInfo, current2;
            current2 = createFiberFromElement(element, returnFiber.mode, lanes);
            coerceRef(current2, element);
            current2.return = returnFiber;
            current2._debugInfo = currentDebugInfo;
            return current2;
          }
          function updatePortal(returnFiber, current2, portal, lanes) {
            if (null === current2 || 4 !== current2.tag || current2.stateNode.containerInfo !== portal.containerInfo || current2.stateNode.implementation !== portal.implementation)
              return current2 = createFiberFromPortal(portal, returnFiber.mode, lanes), current2.return = returnFiber, current2._debugInfo = currentDebugInfo, current2;
            current2 = useFiber(current2, portal.children || []);
            current2.return = returnFiber;
            current2._debugInfo = currentDebugInfo;
            return current2;
          }
          function updateFragment(returnFiber, current2, fragment, lanes, key) {
            if (null === current2 || 7 !== current2.tag)
              return current2 = createFiberFromFragment(
                fragment,
                returnFiber.mode,
                lanes,
                key
              ), current2.return = returnFiber, current2._debugOwner = returnFiber, current2._debugTask = returnFiber._debugTask, current2._debugInfo = currentDebugInfo, current2;
            current2 = useFiber(current2, fragment);
            current2.return = returnFiber;
            current2._debugInfo = currentDebugInfo;
            return current2;
          }
          function createChild(returnFiber, newChild, lanes) {
            if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
              return newChild = createFiberFromText(
                "" + newChild,
                returnFiber.mode,
                lanes
              ), newChild.return = returnFiber, newChild._debugOwner = returnFiber, newChild._debugTask = returnFiber._debugTask, newChild._debugInfo = currentDebugInfo, newChild;
            if ("object" === typeof newChild && null !== newChild) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  return lanes = createFiberFromElement(
                    newChild,
                    returnFiber.mode,
                    lanes
                  ), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;
                case REACT_PORTAL_TYPE:
                  return newChild = createFiberFromPortal(
                    newChild,
                    returnFiber.mode,
                    lanes
                  ), newChild.return = returnFiber, newChild._debugInfo = currentDebugInfo, newChild;
                case REACT_LAZY_TYPE:
                  var _prevDebugInfo = pushDebugInfo(newChild._debugInfo);
                  newChild = resolveLazy(newChild);
                  returnFiber = createChild(returnFiber, newChild, lanes);
                  currentDebugInfo = _prevDebugInfo;
                  return returnFiber;
              }
              if (isArrayImpl(newChild) || getIteratorFn(newChild))
                return lanes = createFiberFromFragment(
                  newChild,
                  returnFiber.mode,
                  lanes,
                  null
                ), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;
              if ("function" === typeof newChild.then)
                return _prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = createChild(
                  returnFiber,
                  unwrapThenable(newChild),
                  lanes
                ), currentDebugInfo = _prevDebugInfo, returnFiber;
              if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                return createChild(
                  returnFiber,
                  readContextDuringReconciliation(returnFiber, newChild),
                  lanes
                );
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
            "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
            return null;
          }
          function updateSlot(returnFiber, oldFiber, newChild, lanes) {
            var key = null !== oldFiber ? oldFiber.key : null;
            if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
              return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
            if ("object" === typeof newChild && null !== newChild) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  return newChild.key === key ? (key = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(
                    returnFiber,
                    oldFiber,
                    newChild,
                    lanes
                  ), currentDebugInfo = key, returnFiber) : null;
                case REACT_PORTAL_TYPE:
                  return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
                case REACT_LAZY_TYPE:
                  return key = pushDebugInfo(newChild._debugInfo), newChild = resolveLazy(newChild), returnFiber = updateSlot(
                    returnFiber,
                    oldFiber,
                    newChild,
                    lanes
                  ), currentDebugInfo = key, returnFiber;
              }
              if (isArrayImpl(newChild) || getIteratorFn(newChild)) {
                if (null !== key) return null;
                key = pushDebugInfo(newChild._debugInfo);
                returnFiber = updateFragment(
                  returnFiber,
                  oldFiber,
                  newChild,
                  lanes,
                  null
                );
                currentDebugInfo = key;
                return returnFiber;
              }
              if ("function" === typeof newChild.then)
                return key = pushDebugInfo(newChild._debugInfo), returnFiber = updateSlot(
                  returnFiber,
                  oldFiber,
                  unwrapThenable(newChild),
                  lanes
                ), currentDebugInfo = key, returnFiber;
              if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                return updateSlot(
                  returnFiber,
                  oldFiber,
                  readContextDuringReconciliation(returnFiber, newChild),
                  lanes
                );
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
            "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
            return null;
          }
          function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
            if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
              return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
            if ("object" === typeof newChild && null !== newChild) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  return newIdx = existingChildren.get(
                    null === newChild.key ? newIdx : newChild.key
                  ) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(
                    returnFiber,
                    newIdx,
                    newChild,
                    lanes
                  ), currentDebugInfo = existingChildren, returnFiber;
                case REACT_PORTAL_TYPE:
                  return existingChildren = existingChildren.get(
                    null === newChild.key ? newIdx : newChild.key
                  ) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
                case REACT_LAZY_TYPE:
                  var _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo);
                  newChild = resolveLazy(newChild);
                  returnFiber = updateFromMap(
                    existingChildren,
                    returnFiber,
                    newIdx,
                    newChild,
                    lanes
                  );
                  currentDebugInfo = _prevDebugInfo7;
                  return returnFiber;
              }
              if (isArrayImpl(newChild) || getIteratorFn(newChild))
                return newIdx = existingChildren.get(newIdx) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateFragment(
                  returnFiber,
                  newIdx,
                  newChild,
                  lanes,
                  null
                ), currentDebugInfo = existingChildren, returnFiber;
              if ("function" === typeof newChild.then)
                return _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo), returnFiber = updateFromMap(
                  existingChildren,
                  returnFiber,
                  newIdx,
                  unwrapThenable(newChild),
                  lanes
                ), currentDebugInfo = _prevDebugInfo7, returnFiber;
              if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                return updateFromMap(
                  existingChildren,
                  returnFiber,
                  newIdx,
                  readContextDuringReconciliation(returnFiber, newChild),
                  lanes
                );
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
            "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
            return null;
          }
          function warnOnInvalidKey(returnFiber, workInProgress2, child, knownKeys) {
            if ("object" !== typeof child || null === child) return knownKeys;
            switch (child.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_PORTAL_TYPE:
                warnForMissingKey(returnFiber, workInProgress2, child);
                var key = child.key;
                if ("string" !== typeof key) break;
                if (null === knownKeys) {
                  knownKeys = /* @__PURE__ */ new Set();
                  knownKeys.add(key);
                  break;
                }
                if (!knownKeys.has(key)) {
                  knownKeys.add(key);
                  break;
                }
                runWithFiberInDEV(workInProgress2, function() {
                  console.error(
                    "Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.",
                    key
                  );
                });
                break;
              case REACT_LAZY_TYPE:
                child = resolveLazy(child), warnOnInvalidKey(returnFiber, workInProgress2, child, knownKeys);
            }
            return knownKeys;
          }
          function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
            for (var knownKeys = null, resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
              oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
              var newFiber = updateSlot(
                returnFiber,
                oldFiber,
                newChildren[newIdx],
                lanes
              );
              if (null === newFiber) {
                null === oldFiber && (oldFiber = nextOldFiber);
                break;
              }
              knownKeys = warnOnInvalidKey(
                returnFiber,
                newFiber,
                newChildren[newIdx],
                knownKeys
              );
              shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
              currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
              null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
              previousNewFiber = newFiber;
              oldFiber = nextOldFiber;
            }
            if (newIdx === newChildren.length)
              return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
            if (null === oldFiber) {
              for (; newIdx < newChildren.length; newIdx++)
                oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(
                  returnFiber,
                  oldFiber,
                  newChildren[newIdx],
                  knownKeys
                ), currentFirstChild = placeChild(
                  oldFiber,
                  currentFirstChild,
                  newIdx
                ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
              isHydrating && pushTreeFork(returnFiber, newIdx);
              return resultingFirstChild;
            }
            for (oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)
              nextOldFiber = updateFromMap(
                oldFiber,
                returnFiber,
                newIdx,
                newChildren[newIdx],
                lanes
              ), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(
                returnFiber,
                nextOldFiber,
                newChildren[newIdx],
                knownKeys
              ), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
                null === nextOldFiber.key ? newIdx : nextOldFiber.key
              ), currentFirstChild = placeChild(
                nextOldFiber,
                currentFirstChild,
                newIdx
              ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
            shouldTrackSideEffects && oldFiber.forEach(function(child) {
              return deleteChild(returnFiber, child);
            });
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
            if (null == newChildren)
              throw Error("An iterable object provided no iterator.");
            for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, knownKeys = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()) {
              oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
              var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
              if (null === newFiber) {
                null === oldFiber && (oldFiber = nextOldFiber);
                break;
              }
              knownKeys = warnOnInvalidKey(
                returnFiber,
                newFiber,
                step.value,
                knownKeys
              );
              shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
              currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
              null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
              previousNewFiber = newFiber;
              oldFiber = nextOldFiber;
            }
            if (step.done)
              return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
            if (null === oldFiber) {
              for (; !step.done; newIdx++, step = newChildren.next())
                oldFiber = createChild(returnFiber, step.value, lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(
                  returnFiber,
                  oldFiber,
                  step.value,
                  knownKeys
                ), currentFirstChild = placeChild(
                  oldFiber,
                  currentFirstChild,
                  newIdx
                ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
              isHydrating && pushTreeFork(returnFiber, newIdx);
              return resultingFirstChild;
            }
            for (oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next())
              nextOldFiber = updateFromMap(
                oldFiber,
                returnFiber,
                newIdx,
                step.value,
                lanes
              ), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(
                returnFiber,
                nextOldFiber,
                step.value,
                knownKeys
              ), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
                null === nextOldFiber.key ? newIdx : nextOldFiber.key
              ), currentFirstChild = placeChild(
                nextOldFiber,
                currentFirstChild,
                newIdx
              ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
            shouldTrackSideEffects && oldFiber.forEach(function(child) {
              return deleteChild(returnFiber, child);
            });
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
            "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (validateFragmentProps(newChild, null, returnFiber), newChild = newChild.props.children);
            if ("object" === typeof newChild && null !== newChild) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  var prevDebugInfo = pushDebugInfo(newChild._debugInfo);
                  a: {
                    for (var key = newChild.key; null !== currentFirstChild; ) {
                      if (currentFirstChild.key === key) {
                        key = newChild.type;
                        if (key === REACT_FRAGMENT_TYPE) {
                          if (7 === currentFirstChild.tag) {
                            deleteRemainingChildren(
                              returnFiber,
                              currentFirstChild.sibling
                            );
                            lanes = useFiber(
                              currentFirstChild,
                              newChild.props.children
                            );
                            lanes.return = returnFiber;
                            lanes._debugOwner = newChild._owner;
                            lanes._debugInfo = currentDebugInfo;
                            validateFragmentProps(newChild, lanes, returnFiber);
                            returnFiber = lanes;
                            break a;
                          }
                        } else if (currentFirstChild.elementType === key || isCompatibleFamilyForHotReloading(
                          currentFirstChild,
                          newChild
                        ) || "object" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && resolveLazy(key) === currentFirstChild.type) {
                          deleteRemainingChildren(
                            returnFiber,
                            currentFirstChild.sibling
                          );
                          lanes = useFiber(currentFirstChild, newChild.props);
                          coerceRef(lanes, newChild);
                          lanes.return = returnFiber;
                          lanes._debugOwner = newChild._owner;
                          lanes._debugInfo = currentDebugInfo;
                          returnFiber = lanes;
                          break a;
                        }
                        deleteRemainingChildren(returnFiber, currentFirstChild);
                        break;
                      } else deleteChild(returnFiber, currentFirstChild);
                      currentFirstChild = currentFirstChild.sibling;
                    }
                    newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(
                      newChild.props.children,
                      returnFiber.mode,
                      lanes,
                      newChild.key
                    ), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, lanes._debugInfo = currentDebugInfo, validateFragmentProps(newChild, lanes, returnFiber), returnFiber = lanes) : (lanes = createFiberFromElement(
                      newChild,
                      returnFiber.mode,
                      lanes
                    ), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes._debugInfo = currentDebugInfo, returnFiber = lanes);
                  }
                  returnFiber = placeSingleChild(returnFiber);
                  currentDebugInfo = prevDebugInfo;
                  return returnFiber;
                case REACT_PORTAL_TYPE:
                  a: {
                    prevDebugInfo = newChild;
                    for (newChild = prevDebugInfo.key; null !== currentFirstChild; ) {
                      if (currentFirstChild.key === newChild)
                        if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === prevDebugInfo.containerInfo && currentFirstChild.stateNode.implementation === prevDebugInfo.implementation) {
                          deleteRemainingChildren(
                            returnFiber,
                            currentFirstChild.sibling
                          );
                          lanes = useFiber(
                            currentFirstChild,
                            prevDebugInfo.children || []
                          );
                          lanes.return = returnFiber;
                          returnFiber = lanes;
                          break a;
                        } else {
                          deleteRemainingChildren(returnFiber, currentFirstChild);
                          break;
                        }
                      else deleteChild(returnFiber, currentFirstChild);
                      currentFirstChild = currentFirstChild.sibling;
                    }
                    lanes = createFiberFromPortal(
                      prevDebugInfo,
                      returnFiber.mode,
                      lanes
                    );
                    lanes.return = returnFiber;
                    returnFiber = lanes;
                  }
                  return placeSingleChild(returnFiber);
                case REACT_LAZY_TYPE:
                  return prevDebugInfo = pushDebugInfo(newChild._debugInfo), newChild = resolveLazy(newChild), returnFiber = reconcileChildFibersImpl(
                    returnFiber,
                    currentFirstChild,
                    newChild,
                    lanes
                  ), currentDebugInfo = prevDebugInfo, returnFiber;
              }
              if (isArrayImpl(newChild))
                return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildrenArray(
                  returnFiber,
                  currentFirstChild,
                  newChild,
                  lanes
                ), currentDebugInfo = prevDebugInfo, returnFiber;
              if (getIteratorFn(newChild)) {
                prevDebugInfo = pushDebugInfo(newChild._debugInfo);
                key = getIteratorFn(newChild);
                if ("function" !== typeof key)
                  throw Error(
                    "An object is not an iterable. This error is likely caused by a bug in React. Please file an issue."
                  );
                var newChildren = key.call(newChild);
                if (newChildren === newChild) {
                  if (0 !== returnFiber.tag || "[object GeneratorFunction]" !== Object.prototype.toString.call(returnFiber.type) || "[object Generator]" !== Object.prototype.toString.call(newChildren))
                    didWarnAboutGenerators || console.error(
                      "Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."
                    ), didWarnAboutGenerators = true;
                } else
                  newChild.entries !== key || didWarnAboutMaps || (console.error(
                    "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
                  ), didWarnAboutMaps = true);
                returnFiber = reconcileChildrenIterator(
                  returnFiber,
                  currentFirstChild,
                  newChildren,
                  lanes
                );
                currentDebugInfo = prevDebugInfo;
                return returnFiber;
              }
              if ("function" === typeof newChild.then)
                return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildFibersImpl(
                  returnFiber,
                  currentFirstChild,
                  unwrapThenable(newChild),
                  lanes
                ), currentDebugInfo = prevDebugInfo, returnFiber;
              if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                return reconcileChildFibersImpl(
                  returnFiber,
                  currentFirstChild,
                  readContextDuringReconciliation(returnFiber, newChild),
                  lanes
                );
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
              return prevDebugInfo = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(
                returnFiber,
                currentFirstChild.sibling
              ), lanes = useFiber(currentFirstChild, prevDebugInfo), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(
                prevDebugInfo,
                returnFiber.mode,
                lanes
              ), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, lanes._debugInfo = currentDebugInfo, returnFiber = lanes), placeSingleChild(returnFiber);
            "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
            "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
            return deleteRemainingChildren(returnFiber, currentFirstChild);
          }
          return function(returnFiber, currentFirstChild, newChild, lanes) {
            var prevDebugInfo = currentDebugInfo;
            currentDebugInfo = null;
            try {
              thenableIndexCounter$1 = 0;
              var firstChildFiber = reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                newChild,
                lanes
              );
              thenableState$1 = null;
              return firstChildFiber;
            } catch (x6) {
              if (x6 === SuspenseException || x6 === SuspenseActionException) throw x6;
              var fiber = createFiber(29, x6, null, returnFiber.mode);
              fiber.lanes = lanes;
              fiber.return = returnFiber;
              var debugInfo = fiber._debugInfo = currentDebugInfo;
              fiber._debugOwner = returnFiber._debugOwner;
              fiber._debugTask = returnFiber._debugTask;
              if (null != debugInfo) {
                for (var i8 = debugInfo.length - 1; 0 <= i8; i8--)
                  if ("string" === typeof debugInfo[i8].stack) {
                    fiber._debugOwner = debugInfo[i8];
                    fiber._debugTask = debugInfo[i8].debugTask;
                    break;
                  }
              }
              return fiber;
            } finally {
              currentDebugInfo = prevDebugInfo;
            }
          };
        }
        function validateSuspenseListNestedChild(childSlot, index) {
          var isAnArray = isArrayImpl(childSlot);
          childSlot = !isAnArray && "function" === typeof getIteratorFn(childSlot);
          return isAnArray || childSlot ? (isAnArray = isAnArray ? "array" : "iterable", console.error(
            "A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>",
            isAnArray,
            index,
            isAnArray
          ), false) : true;
        }
        function initializeUpdateQueue(fiber) {
          fiber.updateQueue = {
            baseState: fiber.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: { pending: null, lanes: 0, hiddenCallbacks: null },
            callbacks: null
          };
        }
        function cloneUpdateQueue(current2, workInProgress2) {
          current2 = current2.updateQueue;
          workInProgress2.updateQueue === current2 && (workInProgress2.updateQueue = {
            baseState: current2.baseState,
            firstBaseUpdate: current2.firstBaseUpdate,
            lastBaseUpdate: current2.lastBaseUpdate,
            shared: current2.shared,
            callbacks: null
          });
        }
        function createUpdate(lane) {
          return {
            lane,
            tag: UpdateState,
            payload: null,
            callback: null,
            next: null
          };
        }
        function enqueueUpdate(fiber, update, lane) {
          var updateQueue = fiber.updateQueue;
          if (null === updateQueue) return null;
          updateQueue = updateQueue.shared;
          if (currentlyProcessingQueue === updateQueue && !didWarnUpdateInsideUpdate) {
            var componentName2 = getComponentNameFromFiber(fiber);
            console.error(
              "An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.\n\nPlease update the following component: %s",
              componentName2
            );
            didWarnUpdateInsideUpdate = true;
          }
          if ((executionContext & RenderContext) !== NoContext)
            return componentName2 = updateQueue.pending, null === componentName2 ? update.next = update : (update.next = componentName2.next, componentName2.next = update), updateQueue.pending = update, update = getRootForUpdatedFiber(fiber), markUpdateLaneFromFiberToRoot(fiber, null, lane), update;
          enqueueUpdate$1(fiber, updateQueue, update, lane);
          return getRootForUpdatedFiber(fiber);
        }
        function entangleTransitions(root2, fiber, lane) {
          fiber = fiber.updateQueue;
          if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194048))) {
            var queueLanes = fiber.lanes;
            queueLanes &= root2.pendingLanes;
            lane |= queueLanes;
            fiber.lanes = lane;
            markRootEntangled(root2, lane);
          }
        }
        function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
          var queue = workInProgress2.updateQueue, current2 = workInProgress2.alternate;
          if (null !== current2 && (current2 = current2.updateQueue, queue === current2)) {
            var newFirst = null, newLast = null;
            queue = queue.firstBaseUpdate;
            if (null !== queue) {
              do {
                var clone = {
                  lane: queue.lane,
                  tag: queue.tag,
                  payload: queue.payload,
                  callback: null,
                  next: null
                };
                null === newLast ? newFirst = newLast = clone : newLast = newLast.next = clone;
                queue = queue.next;
              } while (null !== queue);
              null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
            } else newFirst = newLast = capturedUpdate;
            queue = {
              baseState: current2.baseState,
              firstBaseUpdate: newFirst,
              lastBaseUpdate: newLast,
              shared: current2.shared,
              callbacks: current2.callbacks
            };
            workInProgress2.updateQueue = queue;
            return;
          }
          workInProgress2 = queue.lastBaseUpdate;
          null === workInProgress2 ? queue.firstBaseUpdate = capturedUpdate : workInProgress2.next = capturedUpdate;
          queue.lastBaseUpdate = capturedUpdate;
        }
        function suspendIfUpdateReadFromEntangledAsyncAction() {
          if (didReadFromEntangledAsyncAction) {
            var entangledActionThenable = currentEntangledActionThenable;
            if (null !== entangledActionThenable) throw entangledActionThenable;
          }
        }
        function processUpdateQueue(workInProgress2, props, instance$jscomp$0, renderLanes2) {
          didReadFromEntangledAsyncAction = false;
          var queue = workInProgress2.updateQueue;
          hasForceUpdate = false;
          currentlyProcessingQueue = queue.shared;
          var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;
          if (null !== pendingQueue) {
            queue.shared.pending = null;
            var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
            lastPendingUpdate.next = null;
            null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
            lastBaseUpdate = lastPendingUpdate;
            var current2 = workInProgress2.alternate;
            null !== current2 && (current2 = current2.updateQueue, pendingQueue = current2.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current2.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current2.lastBaseUpdate = lastPendingUpdate));
          }
          if (null !== firstBaseUpdate) {
            var newState = queue.baseState;
            lastBaseUpdate = 0;
            current2 = firstPendingUpdate = lastPendingUpdate = null;
            pendingQueue = firstBaseUpdate;
            do {
              var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;
              if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes2 & updateLane) === updateLane) {
                0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = true);
                null !== current2 && (current2 = current2.next = {
                  lane: 0,
                  tag: pendingQueue.tag,
                  payload: pendingQueue.payload,
                  callback: null,
                  next: null
                });
                a: {
                  updateLane = workInProgress2;
                  var partialState = pendingQueue;
                  var nextProps = props, instance = instance$jscomp$0;
                  switch (partialState.tag) {
                    case ReplaceState:
                      partialState = partialState.payload;
                      if ("function" === typeof partialState) {
                        isDisallowedContextReadInDEV = true;
                        var nextState = partialState.call(
                          instance,
                          newState,
                          nextProps
                        );
                        if (updateLane.mode & StrictLegacyMode) {
                          setIsStrictModeForDevtools(true);
                          try {
                            partialState.call(instance, newState, nextProps);
                          } finally {
                            setIsStrictModeForDevtools(false);
                          }
                        }
                        isDisallowedContextReadInDEV = false;
                        newState = nextState;
                        break a;
                      }
                      newState = partialState;
                      break a;
                    case CaptureUpdate:
                      updateLane.flags = updateLane.flags & -65537 | 128;
                    case UpdateState:
                      nextState = partialState.payload;
                      if ("function" === typeof nextState) {
                        isDisallowedContextReadInDEV = true;
                        partialState = nextState.call(
                          instance,
                          newState,
                          nextProps
                        );
                        if (updateLane.mode & StrictLegacyMode) {
                          setIsStrictModeForDevtools(true);
                          try {
                            nextState.call(instance, newState, nextProps);
                          } finally {
                            setIsStrictModeForDevtools(false);
                          }
                        }
                        isDisallowedContextReadInDEV = false;
                      } else partialState = nextState;
                      if (null === partialState || void 0 === partialState) break a;
                      newState = assign({}, newState, partialState);
                      break a;
                    case ForceUpdate:
                      hasForceUpdate = true;
                  }
                }
                updateLane = pendingQueue.callback;
                null !== updateLane && (workInProgress2.flags |= 64, isHiddenUpdate && (workInProgress2.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
              } else
                isHiddenUpdate = {
                  lane: updateLane,
                  tag: pendingQueue.tag,
                  payload: pendingQueue.payload,
                  callback: pendingQueue.callback,
                  next: null
                }, null === current2 ? (firstPendingUpdate = current2 = isHiddenUpdate, lastPendingUpdate = newState) : current2 = current2.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
              pendingQueue = pendingQueue.next;
              if (null === pendingQueue)
                if (pendingQueue = queue.shared.pending, null === pendingQueue)
                  break;
                else
                  isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
            } while (1);
            null === current2 && (lastPendingUpdate = newState);
            queue.baseState = lastPendingUpdate;
            queue.firstBaseUpdate = firstPendingUpdate;
            queue.lastBaseUpdate = current2;
            null === firstBaseUpdate && (queue.shared.lanes = 0);
            workInProgressRootSkippedLanes |= lastBaseUpdate;
            workInProgress2.lanes = lastBaseUpdate;
            workInProgress2.memoizedState = newState;
          }
          currentlyProcessingQueue = null;
        }
        function callCallback(callback, context) {
          if ("function" !== typeof callback)
            throw Error(
              "Invalid argument passed as callback. Expected a function. Instead received: " + callback
            );
          callback.call(context);
        }
        function commitHiddenCallbacks(updateQueue, context) {
          var hiddenCallbacks = updateQueue.shared.hiddenCallbacks;
          if (null !== hiddenCallbacks)
            for (updateQueue.shared.hiddenCallbacks = null, updateQueue = 0; updateQueue < hiddenCallbacks.length; updateQueue++)
              callCallback(hiddenCallbacks[updateQueue], context);
        }
        function commitCallbacks(updateQueue, context) {
          var callbacks = updateQueue.callbacks;
          if (null !== callbacks)
            for (updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++)
              callCallback(callbacks[updateQueue], context);
        }
        function pushHiddenContext(fiber, context) {
          var prevEntangledRenderLanes = entangledRenderLanes;
          push(prevEntangledRenderLanesCursor, prevEntangledRenderLanes, fiber);
          push(currentTreeHiddenStackCursor, context, fiber);
          entangledRenderLanes = prevEntangledRenderLanes | context.baseLanes;
        }
        function reuseHiddenContextOnStack(fiber) {
          push(prevEntangledRenderLanesCursor, entangledRenderLanes, fiber);
          push(
            currentTreeHiddenStackCursor,
            currentTreeHiddenStackCursor.current,
            fiber
          );
        }
        function popHiddenContext(fiber) {
          entangledRenderLanes = prevEntangledRenderLanesCursor.current;
          pop(currentTreeHiddenStackCursor, fiber);
          pop(prevEntangledRenderLanesCursor, fiber);
        }
        function pushPrimaryTreeSuspenseHandler(handler) {
          var current2 = handler.alternate;
          push(
            suspenseStackCursor,
            suspenseStackCursor.current & SubtreeSuspenseContextMask,
            handler
          );
          push(suspenseHandlerStackCursor, handler, handler);
          null === shellBoundary && (null === current2 || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current2.memoizedState && (shellBoundary = handler));
        }
        function pushDehydratedActivitySuspenseHandler(fiber) {
          push(suspenseStackCursor, suspenseStackCursor.current, fiber);
          push(suspenseHandlerStackCursor, fiber, fiber);
          null === shellBoundary && (shellBoundary = fiber);
        }
        function pushOffscreenSuspenseHandler(fiber) {
          22 === fiber.tag ? (push(suspenseStackCursor, suspenseStackCursor.current, fiber), push(suspenseHandlerStackCursor, fiber, fiber), null === shellBoundary && (shellBoundary = fiber)) : reuseSuspenseHandlerOnStack(fiber);
        }
        function reuseSuspenseHandlerOnStack(fiber) {
          push(suspenseStackCursor, suspenseStackCursor.current, fiber);
          push(
            suspenseHandlerStackCursor,
            suspenseHandlerStackCursor.current,
            fiber
          );
        }
        function popSuspenseHandler(fiber) {
          pop(suspenseHandlerStackCursor, fiber);
          shellBoundary === fiber && (shellBoundary = null);
          pop(suspenseStackCursor, fiber);
        }
        function findFirstSuspended(row) {
          for (var node = row; null !== node; ) {
            if (13 === node.tag) {
              var state = node.memoizedState;
              if (null !== state && (state = state.dehydrated, null === state || isSuspenseInstancePending(state) || isSuspenseInstanceFallback(state)))
                return node;
            } else if (19 === node.tag && ("forwards" === node.memoizedProps.revealOrder || "backwards" === node.memoizedProps.revealOrder || "unstable_legacy-backwards" === node.memoizedProps.revealOrder || "together" === node.memoizedProps.revealOrder)) {
              if (0 !== (node.flags & 128)) return node;
            } else if (null !== node.child) {
              node.child.return = node;
              node = node.child;
              continue;
            }
            if (node === row) break;
            for (; null === node.sibling; ) {
              if (null === node.return || node.return === row) return null;
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
          return null;
        }
        function mountHookTypesDev() {
          var hookName = currentHookNameInDev;
          null === hookTypesDev ? hookTypesDev = [hookName] : hookTypesDev.push(hookName);
        }
        function updateHookTypesDev() {
          var hookName = currentHookNameInDev;
          if (null !== hookTypesDev && (hookTypesUpdateIndexDev++, hookTypesDev[hookTypesUpdateIndexDev] !== hookName)) {
            var componentName2 = getComponentNameFromFiber(currentlyRenderingFiber);
            if (!didWarnAboutMismatchedHooksForComponent.has(componentName2) && (didWarnAboutMismatchedHooksForComponent.add(componentName2), null !== hookTypesDev)) {
              for (var table = "", i8 = 0; i8 <= hookTypesUpdateIndexDev; i8++) {
                var oldHookName = hookTypesDev[i8], newHookName = i8 === hookTypesUpdateIndexDev ? hookName : oldHookName;
                for (oldHookName = i8 + 1 + ". " + oldHookName; 30 > oldHookName.length; )
                  oldHookName += " ";
                oldHookName += newHookName + "\n";
                table += oldHookName;
              }
              console.error(
                "React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n",
                componentName2,
                table
              );
            }
          }
        }
        function checkDepsAreArrayDev(deps) {
          void 0 === deps || null === deps || isArrayImpl(deps) || console.error(
            "%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.",
            currentHookNameInDev,
            typeof deps
          );
        }
        function warnOnUseFormStateInDev() {
          var componentName2 = getComponentNameFromFiber(currentlyRenderingFiber);
          didWarnAboutUseFormState.has(componentName2) || (didWarnAboutUseFormState.add(componentName2), console.error(
            "ReactDOM.useFormState has been renamed to React.useActionState. Please update %s to use React.useActionState.",
            componentName2
          ));
        }
        function throwInvalidHookError() {
          throw Error(
            "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
          );
        }
        function areHookInputsEqual(nextDeps, prevDeps) {
          if (ignorePreviousDependencies) return false;
          if (null === prevDeps)
            return console.error(
              "%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.",
              currentHookNameInDev
            ), false;
          nextDeps.length !== prevDeps.length && console.error(
            "The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s",
            currentHookNameInDev,
            "[" + prevDeps.join(", ") + "]",
            "[" + nextDeps.join(", ") + "]"
          );
          for (var i8 = 0; i8 < prevDeps.length && i8 < nextDeps.length; i8++)
            if (!objectIs(nextDeps[i8], prevDeps[i8])) return false;
          return true;
        }
        function renderWithHooks(current2, workInProgress2, Component, props, secondArg, nextRenderLanes) {
          renderLanes = nextRenderLanes;
          currentlyRenderingFiber = workInProgress2;
          hookTypesDev = null !== current2 ? current2._debugHookTypes : null;
          hookTypesUpdateIndexDev = -1;
          ignorePreviousDependencies = null !== current2 && current2.type !== workInProgress2.type;
          if ("[object AsyncFunction]" === Object.prototype.toString.call(Component) || "[object AsyncGeneratorFunction]" === Object.prototype.toString.call(Component))
            nextRenderLanes = getComponentNameFromFiber(currentlyRenderingFiber), didWarnAboutAsyncClientComponent.has(nextRenderLanes) || (didWarnAboutAsyncClientComponent.add(nextRenderLanes), console.error(
              "%s is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.",
              null === nextRenderLanes ? "An unknown Component" : "<" + nextRenderLanes + ">"
            ));
          workInProgress2.memoizedState = null;
          workInProgress2.updateQueue = null;
          workInProgress2.lanes = 0;
          ReactSharedInternals.H = null !== current2 && null !== current2.memoizedState ? HooksDispatcherOnUpdateInDEV : null !== hookTypesDev ? HooksDispatcherOnMountWithHookTypesInDEV : HooksDispatcherOnMountInDEV;
          shouldDoubleInvokeUserFnsInHooksDEV = nextRenderLanes = (workInProgress2.mode & StrictLegacyMode) !== NoMode;
          var children = callComponentInDEV(Component, props, secondArg);
          shouldDoubleInvokeUserFnsInHooksDEV = false;
          didScheduleRenderPhaseUpdateDuringThisPass && (children = renderWithHooksAgain(
            workInProgress2,
            Component,
            props,
            secondArg
          ));
          if (nextRenderLanes) {
            setIsStrictModeForDevtools(true);
            try {
              children = renderWithHooksAgain(
                workInProgress2,
                Component,
                props,
                secondArg
              );
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          finishRenderingHooks(current2, workInProgress2);
          return children;
        }
        function finishRenderingHooks(current2, workInProgress2) {
          workInProgress2._debugHookTypes = hookTypesDev;
          null === workInProgress2.dependencies ? null !== thenableState && (workInProgress2.dependencies = {
            lanes: 0,
            firstContext: null,
            _debugThenableState: thenableState
          }) : workInProgress2.dependencies._debugThenableState = thenableState;
          ReactSharedInternals.H = ContextOnlyDispatcher;
          var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
          renderLanes = 0;
          hookTypesDev = currentHookNameInDev = workInProgressHook = currentHook = currentlyRenderingFiber = null;
          hookTypesUpdateIndexDev = -1;
          null !== current2 && (current2.flags & 65011712) !== (workInProgress2.flags & 65011712) && console.error(
            "Internal React error: Expected static flag was missing. Please notify the React team."
          );
          didScheduleRenderPhaseUpdate = false;
          thenableIndexCounter = 0;
          thenableState = null;
          if (didRenderTooFewHooks)
            throw Error(
              "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
            );
          null === current2 || didReceiveUpdate || (current2 = current2.dependencies, null !== current2 && checkIfContextChanged(current2) && (didReceiveUpdate = true));
          needsToResetSuspendedThenableDEV ? (needsToResetSuspendedThenableDEV = false, current2 = true) : current2 = false;
          current2 && (workInProgress2 = getComponentNameFromFiber(workInProgress2) || "Unknown", didWarnAboutUseWrappedInTryCatch.has(workInProgress2) || didWarnAboutAsyncClientComponent.has(workInProgress2) || (didWarnAboutUseWrappedInTryCatch.add(workInProgress2), console.error(
            "`use` was called from inside a try/catch block. This is not allowed and can lead to unexpected behavior. To handle errors triggered by `use`, wrap your component in a error boundary."
          )));
        }
        function renderWithHooksAgain(workInProgress2, Component, props, secondArg) {
          currentlyRenderingFiber = workInProgress2;
          var numberOfReRenders = 0;
          do {
            didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);
            thenableIndexCounter = 0;
            didScheduleRenderPhaseUpdateDuringThisPass = false;
            if (numberOfReRenders >= RE_RENDER_LIMIT)
              throw Error(
                "Too many re-renders. React limits the number of renders to prevent an infinite loop."
              );
            numberOfReRenders += 1;
            ignorePreviousDependencies = false;
            workInProgressHook = currentHook = null;
            if (null != workInProgress2.updateQueue) {
              var children = workInProgress2.updateQueue;
              children.lastEffect = null;
              children.events = null;
              children.stores = null;
              null != children.memoCache && (children.memoCache.index = 0);
            }
            hookTypesUpdateIndexDev = -1;
            ReactSharedInternals.H = HooksDispatcherOnRerenderInDEV;
            children = callComponentInDEV(Component, props, secondArg);
          } while (didScheduleRenderPhaseUpdateDuringThisPass);
          return children;
        }
        function TransitionAwareHostComponent() {
          var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];
          maybeThenable = "function" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
          dispatcher = dispatcher.useState()[0];
          (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber.flags |= 1024);
          return maybeThenable;
        }
        function checkDidRenderIdHook() {
          var didRenderIdHook = 0 !== localIdCounter;
          localIdCounter = 0;
          return didRenderIdHook;
        }
        function bailoutHooks(current2, workInProgress2, lanes) {
          workInProgress2.updateQueue = current2.updateQueue;
          workInProgress2.flags = (workInProgress2.mode & StrictEffectsMode) !== NoMode ? workInProgress2.flags & -402655237 : workInProgress2.flags & -2053;
          current2.lanes &= ~lanes;
        }
        function resetHooksOnUnwind(workInProgress2) {
          if (didScheduleRenderPhaseUpdate) {
            for (workInProgress2 = workInProgress2.memoizedState; null !== workInProgress2; ) {
              var queue = workInProgress2.queue;
              null !== queue && (queue.pending = null);
              workInProgress2 = workInProgress2.next;
            }
            didScheduleRenderPhaseUpdate = false;
          }
          renderLanes = 0;
          hookTypesDev = workInProgressHook = currentHook = currentlyRenderingFiber = null;
          hookTypesUpdateIndexDev = -1;
          currentHookNameInDev = null;
          didScheduleRenderPhaseUpdateDuringThisPass = false;
          thenableIndexCounter = localIdCounter = 0;
          thenableState = null;
        }
        function mountWorkInProgressHook() {
          var hook = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
          };
          null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
          return workInProgressHook;
        }
        function updateWorkInProgressHook() {
          if (null === currentHook) {
            var nextCurrentHook = currentlyRenderingFiber.alternate;
            nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
          } else nextCurrentHook = currentHook.next;
          var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;
          if (null !== nextWorkInProgressHook)
            workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;
          else {
            if (null === nextCurrentHook) {
              if (null === currentlyRenderingFiber.alternate)
                throw Error(
                  "Update hook called on initial render. This is likely a bug in React. Please file an issue."
                );
              throw Error("Rendered more hooks than during the previous render.");
            }
            currentHook = nextCurrentHook;
            nextCurrentHook = {
              memoizedState: currentHook.memoizedState,
              baseState: currentHook.baseState,
              baseQueue: currentHook.baseQueue,
              queue: currentHook.queue,
              next: null
            };
            null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
          }
          return workInProgressHook;
        }
        function createFunctionComponentUpdateQueue() {
          return { lastEffect: null, events: null, stores: null, memoCache: null };
        }
        function useThenable(thenable) {
          var index = thenableIndexCounter;
          thenableIndexCounter += 1;
          null === thenableState && (thenableState = createThenableState());
          thenable = trackUsedThenable(thenableState, thenable, index);
          index = currentlyRenderingFiber;
          null === (null === workInProgressHook ? index.memoizedState : workInProgressHook.next) && (index = index.alternate, ReactSharedInternals.H = null !== index && null !== index.memoizedState ? HooksDispatcherOnUpdateInDEV : HooksDispatcherOnMountInDEV);
          return thenable;
        }
        function use(usable) {
          if (null !== usable && "object" === typeof usable) {
            if ("function" === typeof usable.then) return useThenable(usable);
            if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
          }
          throw Error("An unsupported type was passed to use(): " + String(usable));
        }
        function useMemoCache(size) {
          var memoCache = null, updateQueue = currentlyRenderingFiber.updateQueue;
          null !== updateQueue && (memoCache = updateQueue.memoCache);
          if (null == memoCache) {
            var current2 = currentlyRenderingFiber.alternate;
            null !== current2 && (current2 = current2.updateQueue, null !== current2 && (current2 = current2.memoCache, null != current2 && (memoCache = {
              data: current2.data.map(function(array) {
                return array.slice();
              }),
              index: 0
            })));
          }
          null == memoCache && (memoCache = { data: [], index: 0 });
          null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = updateQueue);
          updateQueue.memoCache = memoCache;
          updateQueue = memoCache.data[memoCache.index];
          if (void 0 === updateQueue || ignorePreviousDependencies)
            for (updateQueue = memoCache.data[memoCache.index] = Array(size), current2 = 0; current2 < size; current2++)
              updateQueue[current2] = REACT_MEMO_CACHE_SENTINEL;
          else
            updateQueue.length !== size && console.error(
              "Expected a constant size argument for each invocation of useMemoCache. The previous cache was allocated with size %s but size %s was requested.",
              updateQueue.length,
              size
            );
          memoCache.index++;
          return updateQueue;
        }
        function basicStateReducer(state, action) {
          return "function" === typeof action ? action(state) : action;
        }
        function mountReducer(reducer, initialArg, init) {
          var hook = mountWorkInProgressHook();
          if (void 0 !== init) {
            var initialState = init(initialArg);
            if (shouldDoubleInvokeUserFnsInHooksDEV) {
              setIsStrictModeForDevtools(true);
              try {
                init(initialArg);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
          } else initialState = initialArg;
          hook.memoizedState = hook.baseState = initialState;
          reducer = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: reducer,
            lastRenderedState: initialState
          };
          hook.queue = reducer;
          reducer = reducer.dispatch = dispatchReducerAction.bind(
            null,
            currentlyRenderingFiber,
            reducer
          );
          return [hook.memoizedState, reducer];
        }
        function updateReducer(reducer) {
          var hook = updateWorkInProgressHook();
          return updateReducerImpl(hook, currentHook, reducer);
        }
        function updateReducerImpl(hook, current2, reducer) {
          var queue = hook.queue;
          if (null === queue)
            throw Error(
              "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
            );
          queue.lastRenderedReducer = reducer;
          var baseQueue = hook.baseQueue, pendingQueue = queue.pending;
          if (null !== pendingQueue) {
            if (null !== baseQueue) {
              var baseFirst = baseQueue.next;
              baseQueue.next = pendingQueue.next;
              pendingQueue.next = baseFirst;
            }
            current2.baseQueue !== baseQueue && console.error(
              "Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."
            );
            current2.baseQueue = baseQueue = pendingQueue;
            queue.pending = null;
          }
          pendingQueue = hook.baseState;
          if (null === baseQueue) hook.memoizedState = pendingQueue;
          else {
            current2 = baseQueue.next;
            var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current2, didReadFromEntangledAsyncAction2 = false;
            do {
              var updateLane = update.lane & -536870913;
              if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
                var revertLane = update.revertLane;
                if (0 === revertLane)
                  null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
                    lane: 0,
                    revertLane: 0,
                    gesture: null,
                    action: update.action,
                    hasEagerState: update.hasEagerState,
                    eagerState: update.eagerState,
                    next: null
                  }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction2 = true);
                else if ((renderLanes & revertLane) === revertLane) {
                  update = update.next;
                  revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction2 = true);
                  continue;
                } else
                  updateLane = {
                    lane: 0,
                    revertLane: update.revertLane,
                    gesture: null,
                    action: update.action,
                    hasEagerState: update.hasEagerState,
                    eagerState: update.eagerState,
                    next: null
                  }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
                updateLane = update.action;
                shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
                pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
              } else
                revertLane = {
                  lane: updateLane,
                  revertLane: update.revertLane,
                  gesture: update.gesture,
                  action: update.action,
                  hasEagerState: update.hasEagerState,
                  eagerState: update.eagerState,
                  next: null
                }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
              update = update.next;
            } while (null !== update && update !== current2);
            null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
            if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = true, didReadFromEntangledAsyncAction2 && (reducer = currentEntangledActionThenable, null !== reducer)))
              throw reducer;
            hook.memoizedState = pendingQueue;
            hook.baseState = baseFirst;
            hook.baseQueue = newBaseQueueLast;
            queue.lastRenderedState = pendingQueue;
          }
          null === baseQueue && (queue.lanes = 0);
          return [hook.memoizedState, queue.dispatch];
        }
        function rerenderReducer(reducer) {
          var hook = updateWorkInProgressHook(), queue = hook.queue;
          if (null === queue)
            throw Error(
              "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
            );
          queue.lastRenderedReducer = reducer;
          var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;
          if (null !== lastRenderPhaseUpdate) {
            queue.pending = null;
            var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
            do
              newState = reducer(newState, update.action), update = update.next;
            while (update !== lastRenderPhaseUpdate);
            objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
            hook.memoizedState = newState;
            null === hook.baseQueue && (hook.baseState = newState);
            queue.lastRenderedState = newState;
          }
          return [newState, dispatch];
        }
        function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          var fiber = currentlyRenderingFiber, hook = mountWorkInProgressHook();
          if (isHydrating) {
            if (void 0 === getServerSnapshot)
              throw Error(
                "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
              );
            var nextSnapshot = getServerSnapshot();
            didWarnUncachedGetSnapshot || nextSnapshot === getServerSnapshot() || (console.error(
              "The result of getServerSnapshot should be cached to avoid an infinite loop"
            ), didWarnUncachedGetSnapshot = true);
          } else {
            nextSnapshot = getSnapshot();
            didWarnUncachedGetSnapshot || (getServerSnapshot = getSnapshot(), objectIs(nextSnapshot, getServerSnapshot) || (console.error(
              "The result of getSnapshot should be cached to avoid an infinite loop"
            ), didWarnUncachedGetSnapshot = true));
            if (null === workInProgressRoot)
              throw Error(
                "Expected a work-in-progress root. This is a bug in React. Please file an issue."
              );
            0 !== (workInProgressRootRenderLanes & 127) || pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
          }
          hook.memoizedState = nextSnapshot;
          getServerSnapshot = { value: nextSnapshot, getSnapshot };
          hook.queue = getServerSnapshot;
          mountEffect(
            subscribeToStore.bind(null, fiber, getServerSnapshot, subscribe),
            [subscribe]
          );
          fiber.flags |= 2048;
          pushSimpleEffect(
            HasEffect | Passive,
            { destroy: void 0 },
            updateStoreInstance.bind(
              null,
              fiber,
              getServerSnapshot,
              nextSnapshot,
              getSnapshot
            ),
            null
          );
          return nextSnapshot;
        }
        function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          var fiber = currentlyRenderingFiber, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;
          if (isHydrating$jscomp$0) {
            if (void 0 === getServerSnapshot)
              throw Error(
                "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
              );
            getServerSnapshot = getServerSnapshot();
          } else if (getServerSnapshot = getSnapshot(), !didWarnUncachedGetSnapshot) {
            var cachedSnapshot = getSnapshot();
            objectIs(getServerSnapshot, cachedSnapshot) || (console.error(
              "The result of getSnapshot should be cached to avoid an infinite loop"
            ), didWarnUncachedGetSnapshot = true);
          }
          if (cachedSnapshot = !objectIs(
            (currentHook || hook).memoizedState,
            getServerSnapshot
          ))
            hook.memoizedState = getServerSnapshot, didReceiveUpdate = true;
          hook = hook.queue;
          var create2 = subscribeToStore.bind(null, fiber, hook, subscribe);
          updateEffectImpl(2048, Passive, create2, [subscribe]);
          if (hook.getSnapshot !== getSnapshot || cachedSnapshot || null !== workInProgressHook && workInProgressHook.memoizedState.tag & HasEffect) {
            fiber.flags |= 2048;
            pushSimpleEffect(
              HasEffect | Passive,
              { destroy: void 0 },
              updateStoreInstance.bind(
                null,
                fiber,
                hook,
                getServerSnapshot,
                getSnapshot
              ),
              null
            );
            if (null === workInProgressRoot)
              throw Error(
                "Expected a work-in-progress root. This is a bug in React. Please file an issue."
              );
            isHydrating$jscomp$0 || 0 !== (renderLanes & 127) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
          }
          return getServerSnapshot;
        }
        function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
          fiber.flags |= 16384;
          fiber = { getSnapshot, value: renderedSnapshot };
          getSnapshot = currentlyRenderingFiber.updateQueue;
          null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
        }
        function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
          inst.value = nextSnapshot;
          inst.getSnapshot = getSnapshot;
          checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
        }
        function subscribeToStore(fiber, inst, subscribe) {
          return subscribe(function() {
            checkIfSnapshotChanged(inst) && (startUpdateTimerByLane(2, "updateSyncExternalStore()", fiber), forceStoreRerender(fiber));
          });
        }
        function checkIfSnapshotChanged(inst) {
          var latestGetSnapshot = inst.getSnapshot;
          inst = inst.value;
          try {
            var nextValue = latestGetSnapshot();
            return !objectIs(inst, nextValue);
          } catch (error) {
            return true;
          }
        }
        function forceStoreRerender(fiber) {
          var root2 = enqueueConcurrentRenderForLane(fiber, 2);
          null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2);
        }
        function mountStateImpl(initialState) {
          var hook = mountWorkInProgressHook();
          if ("function" === typeof initialState) {
            var initialStateInitializer = initialState;
            initialState = initialStateInitializer();
            if (shouldDoubleInvokeUserFnsInHooksDEV) {
              setIsStrictModeForDevtools(true);
              try {
                initialStateInitializer();
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
          }
          hook.memoizedState = hook.baseState = initialState;
          hook.queue = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: initialState
          };
          return hook;
        }
        function mountState(initialState) {
          initialState = mountStateImpl(initialState);
          var queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
          queue.dispatch = dispatch;
          return [initialState.memoizedState, dispatch];
        }
        function mountOptimistic(passthrough) {
          var hook = mountWorkInProgressHook();
          hook.memoizedState = hook.baseState = passthrough;
          var queue = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: null,
            lastRenderedState: null
          };
          hook.queue = queue;
          hook = dispatchOptimisticSetState.bind(
            null,
            currentlyRenderingFiber,
            true,
            queue
          );
          queue.dispatch = hook;
          return [passthrough, hook];
        }
        function updateOptimistic(passthrough, reducer) {
          var hook = updateWorkInProgressHook();
          return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
        }
        function updateOptimisticImpl(hook, current2, passthrough, reducer) {
          hook.baseState = passthrough;
          return updateReducerImpl(
            hook,
            currentHook,
            "function" === typeof reducer ? reducer : basicStateReducer
          );
        }
        function rerenderOptimistic(passthrough, reducer) {
          var hook = updateWorkInProgressHook();
          if (null !== currentHook)
            return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
          hook.baseState = passthrough;
          return [passthrough, hook.queue.dispatch];
        }
        function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
          if (isRenderPhaseUpdate(fiber))
            throw Error("Cannot update form state while rendering.");
          fiber = actionQueue.action;
          if (null !== fiber) {
            var actionNode = {
              payload,
              action: fiber,
              next: null,
              isTransition: true,
              status: "pending",
              value: null,
              reason: null,
              listeners: [],
              then: function(listener) {
                actionNode.listeners.push(listener);
              }
            };
            null !== ReactSharedInternals.T ? setPendingState(true) : actionNode.isTransition = false;
            setState(actionNode);
            setPendingState = actionQueue.pending;
            null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
          }
        }
        function runActionStateAction(actionQueue, node) {
          var action = node.action, payload = node.payload, prevState = actionQueue.state;
          if (node.isTransition) {
            var prevTransition = ReactSharedInternals.T, currentTransition = {};
            currentTransition._updatedFibers = /* @__PURE__ */ new Set();
            ReactSharedInternals.T = currentTransition;
            try {
              var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;
              null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
              handleActionReturnValue(actionQueue, node, returnValue);
            } catch (error) {
              onActionError(actionQueue, node, error);
            } finally {
              null !== prevTransition && null !== currentTransition.types && (null !== prevTransition.types && prevTransition.types !== currentTransition.types && console.error(
                "We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React."
              ), prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (actionQueue = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < actionQueue && console.warn(
                "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
              ));
            }
          } else
            try {
              currentTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, currentTransition);
            } catch (error$4) {
              onActionError(actionQueue, node, error$4);
            }
        }
        function handleActionReturnValue(actionQueue, node, returnValue) {
          null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then ? (ReactSharedInternals.asyncTransitions++, returnValue.then(releaseAsyncTransition, releaseAsyncTransition), returnValue.then(
            function(nextState) {
              onActionSuccess(actionQueue, node, nextState);
            },
            function(error) {
              return onActionError(actionQueue, node, error);
            }
          ), node.isTransition || console.error(
            "An async function with useActionState was called outside of a transition. This is likely not what you intended (for example, isPending will not update correctly). Either call the returned function inside startTransition, or pass it to an `action` or `formAction` prop."
          )) : onActionSuccess(actionQueue, node, returnValue);
        }
        function onActionSuccess(actionQueue, actionNode, nextState) {
          actionNode.status = "fulfilled";
          actionNode.value = nextState;
          notifyActionListeners(actionNode);
          actionQueue.state = nextState;
          actionNode = actionQueue.pending;
          null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
        }
        function onActionError(actionQueue, actionNode, error) {
          var last = actionQueue.pending;
          actionQueue.pending = null;
          if (null !== last) {
            last = last.next;
            do
              actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;
            while (actionNode !== last);
          }
          actionQueue.action = null;
        }
        function notifyActionListeners(actionNode) {
          actionNode = actionNode.listeners;
          for (var i8 = 0; i8 < actionNode.length; i8++) (0, actionNode[i8])();
        }
        function actionStateReducer(oldState, newState) {
          return newState;
        }
        function mountActionState(action, initialStateProp) {
          if (isHydrating) {
            var ssrFormState = workInProgressRoot.formState;
            if (null !== ssrFormState) {
              a: {
                var isMatching = currentlyRenderingFiber;
                if (isHydrating) {
                  if (nextHydratableInstance) {
                    b: {
                      var markerInstance = nextHydratableInstance;
                      for (var inRootOrSingleton = rootOrSingletonContext; 8 !== markerInstance.nodeType; ) {
                        if (!inRootOrSingleton) {
                          markerInstance = null;
                          break b;
                        }
                        markerInstance = getNextHydratable(
                          markerInstance.nextSibling
                        );
                        if (null === markerInstance) {
                          markerInstance = null;
                          break b;
                        }
                      }
                      inRootOrSingleton = markerInstance.data;
                      markerInstance = inRootOrSingleton === FORM_STATE_IS_MATCHING || inRootOrSingleton === FORM_STATE_IS_NOT_MATCHING ? markerInstance : null;
                    }
                    if (markerInstance) {
                      nextHydratableInstance = getNextHydratable(
                        markerInstance.nextSibling
                      );
                      isMatching = markerInstance.data === FORM_STATE_IS_MATCHING;
                      break a;
                    }
                  }
                  throwOnHydrationMismatch(isMatching);
                }
                isMatching = false;
              }
              isMatching && (initialStateProp = ssrFormState[0]);
            }
          }
          ssrFormState = mountWorkInProgressHook();
          ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
          isMatching = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: actionStateReducer,
            lastRenderedState: initialStateProp
          };
          ssrFormState.queue = isMatching;
          ssrFormState = dispatchSetState.bind(
            null,
            currentlyRenderingFiber,
            isMatching
          );
          isMatching.dispatch = ssrFormState;
          isMatching = mountStateImpl(false);
          inRootOrSingleton = dispatchOptimisticSetState.bind(
            null,
            currentlyRenderingFiber,
            false,
            isMatching.queue
          );
          isMatching = mountWorkInProgressHook();
          markerInstance = {
            state: initialStateProp,
            dispatch: null,
            action,
            pending: null
          };
          isMatching.queue = markerInstance;
          ssrFormState = dispatchActionState.bind(
            null,
            currentlyRenderingFiber,
            markerInstance,
            inRootOrSingleton,
            ssrFormState
          );
          markerInstance.dispatch = ssrFormState;
          isMatching.memoizedState = action;
          return [initialStateProp, ssrFormState, false];
        }
        function updateActionState(action) {
          var stateHook = updateWorkInProgressHook();
          return updateActionStateImpl(stateHook, currentHook, action);
        }
        function updateActionStateImpl(stateHook, currentStateHook, action) {
          currentStateHook = updateReducerImpl(
            stateHook,
            currentStateHook,
            actionStateReducer
          )[0];
          stateHook = updateReducer(basicStateReducer)[0];
          if ("object" === typeof currentStateHook && null !== currentStateHook && "function" === typeof currentStateHook.then)
            try {
              var state = useThenable(currentStateHook);
            } catch (x6) {
              if (x6 === SuspenseException) throw SuspenseActionException;
              throw x6;
            }
          else state = currentStateHook;
          currentStateHook = updateWorkInProgressHook();
          var actionQueue = currentStateHook.queue, dispatch = actionQueue.dispatch;
          action !== currentStateHook.memoizedState && (currentlyRenderingFiber.flags |= 2048, pushSimpleEffect(
            HasEffect | Passive,
            { destroy: void 0 },
            actionStateActionEffect.bind(null, actionQueue, action),
            null
          ));
          return [state, dispatch, stateHook];
        }
        function actionStateActionEffect(actionQueue, action) {
          actionQueue.action = action;
        }
        function rerenderActionState(action) {
          var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;
          if (null !== currentStateHook)
            return updateActionStateImpl(stateHook, currentStateHook, action);
          updateWorkInProgressHook();
          stateHook = stateHook.memoizedState;
          currentStateHook = updateWorkInProgressHook();
          var dispatch = currentStateHook.queue.dispatch;
          currentStateHook.memoizedState = action;
          return [stateHook, dispatch, false];
        }
        function pushSimpleEffect(tag, inst, create2, deps) {
          tag = { tag, create: create2, deps, inst, next: null };
          inst = currentlyRenderingFiber.updateQueue;
          null === inst && (inst = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = inst);
          create2 = inst.lastEffect;
          null === create2 ? inst.lastEffect = tag.next = tag : (deps = create2.next, create2.next = tag, tag.next = deps, inst.lastEffect = tag);
          return tag;
        }
        function mountRef(initialValue) {
          var hook = mountWorkInProgressHook();
          initialValue = { current: initialValue };
          return hook.memoizedState = initialValue;
        }
        function mountEffectImpl(fiberFlags, hookFlags, create2, deps) {
          var hook = mountWorkInProgressHook();
          currentlyRenderingFiber.flags |= fiberFlags;
          hook.memoizedState = pushSimpleEffect(
            HasEffect | hookFlags,
            { destroy: void 0 },
            create2,
            void 0 === deps ? null : deps
          );
        }
        function updateEffectImpl(fiberFlags, hookFlags, create2, deps) {
          var hook = updateWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var inst = hook.memoizedState.inst;
          null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushSimpleEffect(hookFlags, inst, create2, deps) : (currentlyRenderingFiber.flags |= fiberFlags, hook.memoizedState = pushSimpleEffect(
            HasEffect | hookFlags,
            inst,
            create2,
            deps
          ));
        }
        function mountEffect(create2, deps) {
          (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode ? mountEffectImpl(276826112, Passive, create2, deps) : mountEffectImpl(8390656, Passive, create2, deps);
        }
        function useEffectEventImpl(payload) {
          currentlyRenderingFiber.flags |= 4;
          var componentUpdateQueue = currentlyRenderingFiber.updateQueue;
          if (null === componentUpdateQueue)
            componentUpdateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = componentUpdateQueue, componentUpdateQueue.events = [payload];
          else {
            var events = componentUpdateQueue.events;
            null === events ? componentUpdateQueue.events = [payload] : events.push(payload);
          }
        }
        function mountEvent(callback) {
          var hook = mountWorkInProgressHook(), ref = { impl: callback };
          hook.memoizedState = ref;
          return function() {
            if ((executionContext & RenderContext) !== NoContext)
              throw Error(
                "A function wrapped in useEffectEvent can't be called during rendering."
              );
            return ref.impl.apply(void 0, arguments);
          };
        }
        function updateEvent(callback) {
          var ref = updateWorkInProgressHook().memoizedState;
          useEffectEventImpl({ ref, nextImpl: callback });
          return function() {
            if ((executionContext & RenderContext) !== NoContext)
              throw Error(
                "A function wrapped in useEffectEvent can't be called during rendering."
              );
            return ref.impl.apply(void 0, arguments);
          };
        }
        function mountLayoutEffect(create2, deps) {
          var fiberFlags = 4194308;
          (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode && (fiberFlags |= 134217728);
          return mountEffectImpl(fiberFlags, Layout, create2, deps);
        }
        function imperativeHandleEffect(create2, ref) {
          if ("function" === typeof ref) {
            create2 = create2();
            var refCleanup = ref(create2);
            return function() {
              "function" === typeof refCleanup ? refCleanup() : ref(null);
            };
          }
          if (null !== ref && void 0 !== ref)
            return ref.hasOwnProperty("current") || console.error(
              "Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.",
              "an object with keys {" + Object.keys(ref).join(", ") + "}"
            ), create2 = create2(), ref.current = create2, function() {
              ref.current = null;
            };
        }
        function mountImperativeHandle(ref, create2, deps) {
          "function" !== typeof create2 && console.error(
            "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
            null !== create2 ? typeof create2 : "null"
          );
          deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
          var fiberFlags = 4194308;
          (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode && (fiberFlags |= 134217728);
          mountEffectImpl(
            fiberFlags,
            Layout,
            imperativeHandleEffect.bind(null, create2, ref),
            deps
          );
        }
        function updateImperativeHandle(ref, create2, deps) {
          "function" !== typeof create2 && console.error(
            "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
            null !== create2 ? typeof create2 : "null"
          );
          deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
          updateEffectImpl(
            4,
            Layout,
            imperativeHandleEffect.bind(null, create2, ref),
            deps
          );
        }
        function mountCallback(callback, deps) {
          mountWorkInProgressHook().memoizedState = [
            callback,
            void 0 === deps ? null : deps
          ];
          return callback;
        }
        function updateCallback(callback, deps) {
          var hook = updateWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var prevState = hook.memoizedState;
          if (null !== deps && areHookInputsEqual(deps, prevState[1]))
            return prevState[0];
          hook.memoizedState = [callback, deps];
          return callback;
        }
        function mountMemo(nextCreate, deps) {
          var hook = mountWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var nextValue = nextCreate();
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              nextCreate();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          hook.memoizedState = [nextValue, deps];
          return nextValue;
        }
        function updateMemo(nextCreate, deps) {
          var hook = updateWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var prevState = hook.memoizedState;
          if (null !== deps && areHookInputsEqual(deps, prevState[1]))
            return prevState[0];
          prevState = nextCreate();
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              nextCreate();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          hook.memoizedState = [prevState, deps];
          return prevState;
        }
        function mountDeferredValue(value, initialValue) {
          var hook = mountWorkInProgressHook();
          return mountDeferredValueImpl(hook, value, initialValue);
        }
        function updateDeferredValue(value, initialValue) {
          var hook = updateWorkInProgressHook();
          return updateDeferredValueImpl(
            hook,
            currentHook.memoizedState,
            value,
            initialValue
          );
        }
        function rerenderDeferredValue(value, initialValue) {
          var hook = updateWorkInProgressHook();
          return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(
            hook,
            currentHook.memoizedState,
            value,
            initialValue
          );
        }
        function mountDeferredValueImpl(hook, value, initialValue) {
          if (void 0 === initialValue || 0 !== (renderLanes & 1073741824) && 0 === (workInProgressRootRenderLanes & 261930))
            return hook.memoizedState = value;
          hook.memoizedState = initialValue;
          hook = requestDeferredLane();
          currentlyRenderingFiber.lanes |= hook;
          workInProgressRootSkippedLanes |= hook;
          return initialValue;
        }
        function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
          if (objectIs(value, prevValue)) return value;
          if (null !== currentTreeHiddenStackCursor.current)
            return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = true), hook;
          if (0 === (renderLanes & 42) || 0 !== (renderLanes & 1073741824) && 0 === (workInProgressRootRenderLanes & 261930))
            return didReceiveUpdate = true, hook.memoizedState = value;
          hook = requestDeferredLane();
          currentlyRenderingFiber.lanes |= hook;
          workInProgressRootSkippedLanes |= hook;
          return prevValue;
        }
        function releaseAsyncTransition() {
          ReactSharedInternals.asyncTransitions--;
        }
        function startTransition(fiber, queue, pendingState, finishedState, callback) {
          var previousPriority = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = 0 !== previousPriority && previousPriority < ContinuousEventPriority ? previousPriority : ContinuousEventPriority;
          var prevTransition = ReactSharedInternals.T, currentTransition = {};
          currentTransition._updatedFibers = /* @__PURE__ */ new Set();
          ReactSharedInternals.T = currentTransition;
          dispatchOptimisticSetState(fiber, false, queue, pendingState);
          try {
            var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;
            null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
            if (null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then) {
              ReactSharedInternals.asyncTransitions++;
              returnValue.then(releaseAsyncTransition, releaseAsyncTransition);
              var thenableForFinishedState = chainThenableValue(
                returnValue,
                finishedState
              );
              dispatchSetStateInternal(
                fiber,
                queue,
                thenableForFinishedState,
                requestUpdateLane(fiber)
              );
            } else
              dispatchSetStateInternal(
                fiber,
                queue,
                finishedState,
                requestUpdateLane(fiber)
              );
          } catch (error) {
            dispatchSetStateInternal(
              fiber,
              queue,
              { then: function() {
              }, status: "rejected", reason: error },
              requestUpdateLane(fiber)
            );
          } finally {
            ReactDOMSharedInternals.p = previousPriority, null !== prevTransition && null !== currentTransition.types && (null !== prevTransition.types && prevTransition.types !== currentTransition.types && console.error(
              "We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React."
            ), prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (fiber = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < fiber && console.warn(
              "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
            ));
          }
        }
        function startHostTransition(formFiber, pendingState, action, formData) {
          if (5 !== formFiber.tag)
            throw Error(
              "Expected the form instance to be a HostComponent. This is a bug in React."
            );
          var queue = ensureFormComponentIsStateful(formFiber).queue;
          startHostActionTimer(formFiber);
          startTransition(
            formFiber,
            queue,
            pendingState,
            NotPendingTransition,
            null === action ? noop : function() {
              requestFormReset$1(formFiber);
              return action(formData);
            }
          );
        }
        function ensureFormComponentIsStateful(formFiber) {
          var existingStateHook = formFiber.memoizedState;
          if (null !== existingStateHook) return existingStateHook;
          existingStateHook = {
            memoizedState: NotPendingTransition,
            baseState: NotPendingTransition,
            baseQueue: null,
            queue: {
              pending: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: basicStateReducer,
              lastRenderedState: NotPendingTransition
            },
            next: null
          };
          var initialResetState = {};
          existingStateHook.next = {
            memoizedState: initialResetState,
            baseState: initialResetState,
            baseQueue: null,
            queue: {
              pending: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: basicStateReducer,
              lastRenderedState: initialResetState
            },
            next: null
          };
          formFiber.memoizedState = existingStateHook;
          formFiber = formFiber.alternate;
          null !== formFiber && (formFiber.memoizedState = existingStateHook);
          return existingStateHook;
        }
        function requestFormReset$1(formFiber) {
          null === ReactSharedInternals.T && console.error(
            "requestFormReset was called outside a transition or action. To fix, move to an action, or wrap with startTransition."
          );
          var stateHook = ensureFormComponentIsStateful(formFiber);
          null === stateHook.next && (stateHook = formFiber.alternate.memoizedState);
          dispatchSetStateInternal(
            formFiber,
            stateHook.next.queue,
            {},
            requestUpdateLane(formFiber)
          );
        }
        function mountTransition() {
          var stateHook = mountStateImpl(false);
          stateHook = startTransition.bind(
            null,
            currentlyRenderingFiber,
            stateHook.queue,
            true,
            false
          );
          mountWorkInProgressHook().memoizedState = stateHook;
          return [false, stateHook];
        }
        function updateTransition() {
          var booleanOrThenable = updateReducer(basicStateReducer)[0], start2 = updateWorkInProgressHook().memoizedState;
          return [
            "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
            start2
          ];
        }
        function rerenderTransition() {
          var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start2 = updateWorkInProgressHook().memoizedState;
          return [
            "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
            start2
          ];
        }
        function useHostTransitionStatus() {
          return readContext(HostTransitionContext);
        }
        function mountId() {
          var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;
          if (isHydrating) {
            var treeId = treeContextOverflow;
            var idWithLeadingBit = treeContextId;
            treeId = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + treeId;
            identifierPrefix = "_" + identifierPrefix + "R_" + treeId;
            treeId = localIdCounter++;
            0 < treeId && (identifierPrefix += "H" + treeId.toString(32));
            identifierPrefix += "_";
          } else
            treeId = globalClientIdCounter++, identifierPrefix = "_" + identifierPrefix + "r_" + treeId.toString(32) + "_";
          return hook.memoizedState = identifierPrefix;
        }
        function mountRefresh() {
          return mountWorkInProgressHook().memoizedState = refreshCache.bind(
            null,
            currentlyRenderingFiber
          );
        }
        function refreshCache(fiber, seedKey) {
          for (var provider = fiber.return; null !== provider; ) {
            switch (provider.tag) {
              case 24:
              case 3:
                var lane = requestUpdateLane(provider), refreshUpdate = createUpdate(lane), root2 = enqueueUpdate(provider, refreshUpdate, lane);
                null !== root2 && (startUpdateTimerByLane(lane, "refresh()", fiber), scheduleUpdateOnFiber(root2, provider, lane), entangleTransitions(root2, provider, lane));
                fiber = createCache();
                null !== seedKey && void 0 !== seedKey && null !== root2 && console.error(
                  "The seed argument is not enabled outside experimental channels."
                );
                refreshUpdate.payload = { cache: fiber };
                return;
            }
            provider = provider.return;
          }
        }
        function dispatchReducerAction(fiber, queue, action) {
          var args = arguments;
          "function" === typeof args[3] && console.error(
            "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
          );
          args = requestUpdateLane(fiber);
          var update = {
            lane: args,
            revertLane: 0,
            gesture: null,
            action,
            hasEagerState: false,
            eagerState: null,
            next: null
          };
          isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, update) : (update = enqueueConcurrentHookUpdate(fiber, queue, update, args), null !== update && (startUpdateTimerByLane(args, "dispatch()", fiber), scheduleUpdateOnFiber(update, fiber, args), entangleTransitionUpdate(update, queue, args)));
        }
        function dispatchSetState(fiber, queue, action) {
          var args = arguments;
          "function" === typeof args[3] && console.error(
            "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
          );
          args = requestUpdateLane(fiber);
          dispatchSetStateInternal(fiber, queue, action, args) && startUpdateTimerByLane(args, "setState()", fiber);
        }
        function dispatchSetStateInternal(fiber, queue, action, lane) {
          var update = {
            lane,
            revertLane: 0,
            gesture: null,
            action,
            hasEagerState: false,
            eagerState: null,
            next: null
          };
          if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
          else {
            var alternate = fiber.alternate;
            if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate)) {
              var prevDispatcher = ReactSharedInternals.H;
              ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);
                update.hasEagerState = true;
                update.eagerState = eagerState;
                if (objectIs(eagerState, currentState))
                  return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), false;
              } catch (error) {
              } finally {
                ReactSharedInternals.H = prevDispatcher;
              }
            }
            action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
            if (null !== action)
              return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), true;
          }
          return false;
        }
        function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
          null === ReactSharedInternals.T && 0 === currentEntangledLane && console.error(
            "An optimistic state update occurred outside a transition or action. To fix, move the update to an action, or wrap with startTransition."
          );
          action = {
            lane: 2,
            revertLane: requestTransitionLane(),
            gesture: null,
            action,
            hasEagerState: false,
            eagerState: null,
            next: null
          };
          if (isRenderPhaseUpdate(fiber)) {
            if (throwIfDuringRender)
              throw Error("Cannot update optimistic state while rendering.");
            console.error("Cannot call startTransition while rendering.");
          } else
            throwIfDuringRender = enqueueConcurrentHookUpdate(
              fiber,
              queue,
              action,
              2
            ), null !== throwIfDuringRender && (startUpdateTimerByLane(2, "setOptimistic()", fiber), scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2));
        }
        function isRenderPhaseUpdate(fiber) {
          var alternate = fiber.alternate;
          return fiber === currentlyRenderingFiber || null !== alternate && alternate === currentlyRenderingFiber;
        }
        function enqueueRenderPhaseUpdate(queue, update) {
          didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
          var pending = queue.pending;
          null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
          queue.pending = update;
        }
        function entangleTransitionUpdate(root2, queue, lane) {
          if (0 !== (lane & 4194048)) {
            var queueLanes = queue.lanes;
            queueLanes &= root2.pendingLanes;
            lane |= queueLanes;
            queue.lanes = lane;
            markRootEntangled(root2, lane);
          }
        }
        function warnOnInvalidCallback(callback) {
          if (null !== callback && "function" !== typeof callback) {
            var key = String(callback);
            didWarnOnInvalidCallback.has(key) || (didWarnOnInvalidCallback.add(key), console.error(
              "Expected the last optional `callback` argument to be a function. Instead received: %s.",
              callback
            ));
          }
        }
        function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
          var prevState = workInProgress2.memoizedState, partialState = getDerivedStateFromProps(nextProps, prevState);
          if (workInProgress2.mode & StrictLegacyMode) {
            setIsStrictModeForDevtools(true);
            try {
              partialState = getDerivedStateFromProps(nextProps, prevState);
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          void 0 === partialState && (ctor = getComponentNameFromType(ctor) || "Component", didWarnAboutUndefinedDerivedState.has(ctor) || (didWarnAboutUndefinedDerivedState.add(ctor), console.error(
            "%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.",
            ctor
          )));
          prevState = null === partialState || void 0 === partialState ? prevState : assign({}, prevState, partialState);
          workInProgress2.memoizedState = prevState;
          0 === workInProgress2.lanes && (workInProgress2.updateQueue.baseState = prevState);
        }
        function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
          var instance = workInProgress2.stateNode;
          if ("function" === typeof instance.shouldComponentUpdate) {
            oldProps = instance.shouldComponentUpdate(
              newProps,
              newState,
              nextContext
            );
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                oldProps = instance.shouldComponentUpdate(
                  newProps,
                  newState,
                  nextContext
                );
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            void 0 === oldProps && console.error(
              "%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.",
              getComponentNameFromType(ctor) || "Component"
            );
            return oldProps;
          }
          return ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : true;
        }
        function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
          var oldState = instance.state;
          "function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
          "function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
          instance.state !== oldState && (workInProgress2 = getComponentNameFromFiber(workInProgress2) || "Component", didWarnAboutStateAssignmentForComponent.has(workInProgress2) || (didWarnAboutStateAssignmentForComponent.add(workInProgress2), console.error(
            "%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
            workInProgress2
          )), classComponentUpdater.enqueueReplaceState(
            instance,
            instance.state,
            null
          ));
        }
        function resolveClassComponentProps(Component, baseProps) {
          var newProps = baseProps;
          if ("ref" in baseProps) {
            newProps = {};
            for (var propName in baseProps)
              "ref" !== propName && (newProps[propName] = baseProps[propName]);
          }
          if (Component = Component.defaultProps) {
            newProps === baseProps && (newProps = assign({}, newProps));
            for (var _propName in Component)
              void 0 === newProps[_propName] && (newProps[_propName] = Component[_propName]);
          }
          return newProps;
        }
        function defaultOnUncaughtError(error) {
          reportGlobalError(error);
          console.warn(
            "%s\n\n%s\n",
            componentName ? "An error occurred in the <" + componentName + "> component." : "An error occurred in one of your React components.",
            "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://react.dev/link/error-boundaries to learn more about error boundaries."
          );
        }
        function defaultOnCaughtError(error) {
          var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component." : "The above error occurred in one of your React components.", recreateMessage = "React will try to recreate this component tree from scratch using the error boundary you provided, " + ((errorBoundaryName || "Anonymous") + ".");
          if ("object" === typeof error && null !== error && "string" === typeof error.environmentName) {
            var JSCompiler_inline_result = error.environmentName;
            error = [
              "%o\n\n%s\n\n%s\n",
              error,
              componentNameMessage,
              recreateMessage
            ].slice(0);
            "string" === typeof error[0] ? error.splice(
              0,
              1,
              badgeFormat + " " + error[0],
              badgeStyle,
              pad + JSCompiler_inline_result + pad,
              resetStyle
            ) : error.splice(
              0,
              0,
              badgeFormat,
              badgeStyle,
              pad + JSCompiler_inline_result + pad,
              resetStyle
            );
            error.unshift(console);
            JSCompiler_inline_result = bind.apply(console.error, error);
            JSCompiler_inline_result();
          } else
            console.error(
              "%o\n\n%s\n\n%s\n",
              error,
              componentNameMessage,
              recreateMessage
            );
        }
        function defaultOnRecoverableError(error) {
          reportGlobalError(error);
        }
        function logUncaughtError(root2, errorInfo) {
          try {
            componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;
            errorBoundaryName = null;
            var error = errorInfo.value;
            if (null !== ReactSharedInternals.actQueue)
              ReactSharedInternals.thrownErrors.push(error);
            else {
              var onUncaughtError = root2.onUncaughtError;
              onUncaughtError(error, { componentStack: errorInfo.stack });
            }
          } catch (e$5) {
            setTimeout(function() {
              throw e$5;
            });
          }
        }
        function logCaughtError(root2, boundary, errorInfo) {
          try {
            componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;
            errorBoundaryName = getComponentNameFromFiber(boundary);
            var onCaughtError = root2.onCaughtError;
            onCaughtError(errorInfo.value, {
              componentStack: errorInfo.stack,
              errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
            });
          } catch (e$6) {
            setTimeout(function() {
              throw e$6;
            });
          }
        }
        function createRootErrorUpdate(root2, errorInfo, lane) {
          lane = createUpdate(lane);
          lane.tag = CaptureUpdate;
          lane.payload = { element: null };
          lane.callback = function() {
            runWithFiberInDEV(errorInfo.source, logUncaughtError, root2, errorInfo);
          };
          return lane;
        }
        function createClassErrorUpdate(lane) {
          lane = createUpdate(lane);
          lane.tag = CaptureUpdate;
          return lane;
        }
        function initializeClassErrorUpdate(update, root2, fiber, errorInfo) {
          var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
          if ("function" === typeof getDerivedStateFromError) {
            var error = errorInfo.value;
            update.payload = function() {
              return getDerivedStateFromError(error);
            };
            update.callback = function() {
              markFailedErrorBoundaryForHotReloading(fiber);
              runWithFiberInDEV(
                errorInfo.source,
                logCaughtError,
                root2,
                fiber,
                errorInfo
              );
            };
          }
          var inst = fiber.stateNode;
          null !== inst && "function" === typeof inst.componentDidCatch && (update.callback = function() {
            markFailedErrorBoundaryForHotReloading(fiber);
            runWithFiberInDEV(
              errorInfo.source,
              logCaughtError,
              root2,
              fiber,
              errorInfo
            );
            "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
            callComponentDidCatchInDEV(this, errorInfo);
            "function" === typeof getDerivedStateFromError || 0 === (fiber.lanes & 2) && console.error(
              "%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.",
              getComponentNameFromFiber(fiber) || "Unknown"
            );
          });
        }
        function throwException(root2, returnFiber, sourceFiber, value, rootRenderLanes) {
          sourceFiber.flags |= 32768;
          isDevToolsPresent && restorePendingUpdaters(root2, rootRenderLanes);
          if (null !== value && "object" === typeof value && "function" === typeof value.then) {
            returnFiber = sourceFiber.alternate;
            null !== returnFiber && propagateParentContextChanges(
              returnFiber,
              sourceFiber,
              rootRenderLanes,
              true
            );
            isHydrating && (didSuspendOrErrorDEV = true);
            sourceFiber = suspenseHandlerStackCursor.current;
            if (null !== sourceFiber) {
              switch (sourceFiber.tag) {
                case 31:
                case 13:
                  return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootSuspended), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = /* @__PURE__ */ new Set([value]) : returnFiber.add(value), attachPingListener(root2, value, rootRenderLanes)), false;
                case 22:
                  return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {
                    transitions: null,
                    markerInstances: null,
                    retryQueue: /* @__PURE__ */ new Set([value])
                  }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = /* @__PURE__ */ new Set([value]) : sourceFiber.add(value)), attachPingListener(root2, value, rootRenderLanes)), false;
              }
              throw Error(
                "Unexpected Suspense handler tag (" + sourceFiber.tag + "). This is a bug in React."
              );
            }
            attachPingListener(root2, value, rootRenderLanes);
            renderDidSuspendDelayIfPossible();
            return false;
          }
          if (isHydrating)
            return didSuspendOrErrorDEV = true, returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && queueHydrationError(
              createCapturedValueAtFiber(
                Error(
                  "There was an error while hydrating but React was able to recover by instead client rendering from the nearest Suspense boundary.",
                  { cause: value }
                ),
                sourceFiber
              )
            )) : (value !== HydrationMismatchException && queueHydrationError(
              createCapturedValueAtFiber(
                Error(
                  "There was an error while hydrating but React was able to recover by instead client rendering the entire root.",
                  { cause: value }
                ),
                sourceFiber
              )
            ), root2 = root2.current.alternate, root2.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root2.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(
              root2.stateNode,
              value,
              rootRenderLanes
            ), enqueueCapturedUpdate(root2, rootRenderLanes), workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored)), false;
          var error = createCapturedValueAtFiber(
            Error(
              "There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.",
              { cause: value }
            ),
            sourceFiber
          );
          null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [error] : workInProgressRootConcurrentErrors.push(error);
          workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored);
          if (null === returnFiber) return true;
          value = createCapturedValueAtFiber(value, sourceFiber);
          sourceFiber = returnFiber;
          do {
            switch (sourceFiber.tag) {
              case 3:
                return sourceFiber.flags |= 65536, root2 = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root2, root2 = createRootErrorUpdate(
                  sourceFiber.stateNode,
                  value,
                  root2
                ), enqueueCapturedUpdate(sourceFiber, root2), false;
              case 1:
                if (returnFiber = sourceFiber.type, error = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && ("function" === typeof returnFiber.getDerivedStateFromError || null !== error && "function" === typeof error.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(error))))
                  return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(
                    rootRenderLanes,
                    root2,
                    sourceFiber,
                    value
                  ), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), false;
            }
            sourceFiber = sourceFiber.return;
          } while (null !== sourceFiber);
          return false;
        }
        function reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2) {
          workInProgress2.child = null === current2 ? mountChildFibers(workInProgress2, null, nextChildren, renderLanes2) : reconcileChildFibers(
            workInProgress2,
            current2.child,
            nextChildren,
            renderLanes2
          );
        }
        function updateForwardRef(current2, workInProgress2, Component, nextProps, renderLanes2) {
          Component = Component.render;
          var ref = workInProgress2.ref;
          if ("ref" in nextProps) {
            var propsWithoutRef = {};
            for (var key in nextProps)
              "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
          } else propsWithoutRef = nextProps;
          prepareToReadContext(workInProgress2);
          nextProps = renderWithHooks(
            current2,
            workInProgress2,
            Component,
            propsWithoutRef,
            ref,
            renderLanes2
          );
          key = checkDidRenderIdHook();
          if (null !== current2 && !didReceiveUpdate)
            return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          isHydrating && key && pushMaterializedTreeId(workInProgress2);
          workInProgress2.flags |= 1;
          reconcileChildren(current2, workInProgress2, nextProps, renderLanes2);
          return workInProgress2.child;
        }
        function updateMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
          if (null === current2) {
            var type = Component.type;
            if ("function" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component.compare)
              return Component = resolveFunctionForHotReloading(type), workInProgress2.tag = 15, workInProgress2.type = Component, validateFunctionComponentInDev(workInProgress2, type), updateSimpleMemoComponent(
                current2,
                workInProgress2,
                Component,
                nextProps,
                renderLanes2
              );
            current2 = createFiberFromTypeAndProps(
              Component.type,
              null,
              nextProps,
              workInProgress2,
              workInProgress2.mode,
              renderLanes2
            );
            current2.ref = workInProgress2.ref;
            current2.return = workInProgress2;
            return workInProgress2.child = current2;
          }
          type = current2.child;
          if (!checkScheduledUpdateOrContext(current2, renderLanes2)) {
            var prevProps = type.memoizedProps;
            Component = Component.compare;
            Component = null !== Component ? Component : shallowEqual;
            if (Component(prevProps, nextProps) && current2.ref === workInProgress2.ref)
              return bailoutOnAlreadyFinishedWork(
                current2,
                workInProgress2,
                renderLanes2
              );
          }
          workInProgress2.flags |= 1;
          current2 = createWorkInProgress(type, nextProps);
          current2.ref = workInProgress2.ref;
          current2.return = workInProgress2;
          return workInProgress2.child = current2;
        }
        function updateSimpleMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
          if (null !== current2) {
            var prevProps = current2.memoizedProps;
            if (shallowEqual(prevProps, nextProps) && current2.ref === workInProgress2.ref && workInProgress2.type === current2.type)
              if (didReceiveUpdate = false, workInProgress2.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current2, renderLanes2))
                0 !== (current2.flags & 131072) && (didReceiveUpdate = true);
              else
                return workInProgress2.lanes = current2.lanes, bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          }
          return updateFunctionComponent(
            current2,
            workInProgress2,
            Component,
            nextProps,
            renderLanes2
          );
        }
        function updateOffscreenComponent(current2, workInProgress2, renderLanes2, nextProps) {
          var nextChildren = nextProps.children, prevState = null !== current2 ? current2.memoizedState : null;
          null === current2 && null === workInProgress2.stateNode && (workInProgress2.stateNode = {
            _visibility: OffscreenVisible,
            _pendingMarkers: null,
            _retryCache: null,
            _transitions: null
          });
          if ("hidden" === nextProps.mode) {
            if (0 !== (workInProgress2.flags & 128)) {
              prevState = null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2;
              if (null !== current2) {
                nextProps = workInProgress2.child = current2.child;
                for (nextChildren = 0; null !== nextProps; )
                  nextChildren = nextChildren | nextProps.lanes | nextProps.childLanes, nextProps = nextProps.sibling;
                nextProps = nextChildren & ~prevState;
              } else nextProps = 0, workInProgress2.child = null;
              return deferHiddenOffscreenComponent(
                current2,
                workInProgress2,
                prevState,
                renderLanes2,
                nextProps
              );
            }
            if (0 !== (renderLanes2 & 536870912))
              workInProgress2.memoizedState = { baseLanes: 0, cachePool: null }, null !== current2 && pushTransition(
                workInProgress2,
                null !== prevState ? prevState.cachePool : null
              ), null !== prevState ? pushHiddenContext(workInProgress2, prevState) : reuseHiddenContextOnStack(workInProgress2), pushOffscreenSuspenseHandler(workInProgress2);
            else
              return nextProps = workInProgress2.lanes = 536870912, deferHiddenOffscreenComponent(
                current2,
                workInProgress2,
                null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2,
                renderLanes2,
                nextProps
              );
          } else
            null !== prevState ? (pushTransition(workInProgress2, prevState.cachePool), pushHiddenContext(workInProgress2, prevState), reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.memoizedState = null) : (null !== current2 && pushTransition(workInProgress2, null), reuseHiddenContextOnStack(workInProgress2), reuseSuspenseHandlerOnStack(workInProgress2));
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function bailoutOffscreenComponent(current2, workInProgress2) {
          null !== current2 && 22 === current2.tag || null !== workInProgress2.stateNode || (workInProgress2.stateNode = {
            _visibility: OffscreenVisible,
            _pendingMarkers: null,
            _retryCache: null,
            _transitions: null
          });
          return workInProgress2.sibling;
        }
        function deferHiddenOffscreenComponent(current2, workInProgress2, nextBaseLanes, renderLanes2, remainingChildLanes) {
          var JSCompiler_inline_result = peekCacheFromPool();
          JSCompiler_inline_result = null === JSCompiler_inline_result ? null : {
            parent: CacheContext._currentValue,
            pool: JSCompiler_inline_result
          };
          workInProgress2.memoizedState = {
            baseLanes: nextBaseLanes,
            cachePool: JSCompiler_inline_result
          };
          null !== current2 && pushTransition(workInProgress2, null);
          reuseHiddenContextOnStack(workInProgress2);
          pushOffscreenSuspenseHandler(workInProgress2);
          null !== current2 && propagateParentContextChanges(current2, workInProgress2, renderLanes2, true);
          workInProgress2.childLanes = remainingChildLanes;
          return null;
        }
        function mountActivityChildren(workInProgress2, nextProps) {
          var hiddenProp = nextProps.hidden;
          void 0 !== hiddenProp && console.error(
            `<Activity> doesn't accept a hidden prop. Use mode="hidden" instead.
- <Activity %s>
+ <Activity %s>`,
            true === hiddenProp ? "hidden" : false === hiddenProp ? "hidden={false}" : "hidden={...}",
            hiddenProp ? 'mode="hidden"' : 'mode="visible"'
          );
          nextProps = mountWorkInProgressOffscreenFiber(
            { mode: nextProps.mode, children: nextProps.children },
            workInProgress2.mode
          );
          nextProps.ref = workInProgress2.ref;
          workInProgress2.child = nextProps;
          nextProps.return = workInProgress2;
          return nextProps;
        }
        function retryActivityComponentWithoutHydrating(current2, workInProgress2, renderLanes2) {
          reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
          current2 = mountActivityChildren(
            workInProgress2,
            workInProgress2.pendingProps
          );
          current2.flags |= 2;
          popSuspenseHandler(workInProgress2);
          workInProgress2.memoizedState = null;
          return current2;
        }
        function updateActivityComponent(current2, workInProgress2, renderLanes2) {
          var nextProps = workInProgress2.pendingProps, didSuspend = 0 !== (workInProgress2.flags & 128);
          workInProgress2.flags &= -129;
          if (null === current2) {
            if (isHydrating) {
              if ("hidden" === nextProps.mode)
                return current2 = mountActivityChildren(workInProgress2, nextProps), workInProgress2.lanes = 536870912, bailoutOffscreenComponent(null, current2);
              pushDehydratedActivitySuspenseHandler(workInProgress2);
              (current2 = nextHydratableInstance) ? (renderLanes2 = canHydrateHydrationBoundary(
                current2,
                rootOrSingletonContext
              ), renderLanes2 = null !== renderLanes2 && renderLanes2.data === ACTIVITY_START_DATA ? renderLanes2 : null, null !== renderLanes2 && (nextProps = {
                dehydrated: renderLanes2,
                treeContext: getSuspendedTreeContext(),
                retryLane: 536870912,
                hydrationErrors: null
              }, workInProgress2.memoizedState = nextProps, nextProps = createFiberFromDehydratedFragment(renderLanes2), nextProps.return = workInProgress2, workInProgress2.child = nextProps, hydrationParentFiber = workInProgress2, nextHydratableInstance = null)) : renderLanes2 = null;
              if (null === renderLanes2)
                throw warnNonHydratedInstance(workInProgress2, current2), throwOnHydrationMismatch(workInProgress2);
              workInProgress2.lanes = 536870912;
              return null;
            }
            return mountActivityChildren(workInProgress2, nextProps);
          }
          var prevState = current2.memoizedState;
          if (null !== prevState) {
            var activityInstance = prevState.dehydrated;
            pushDehydratedActivitySuspenseHandler(workInProgress2);
            if (didSuspend)
              if (workInProgress2.flags & 256)
                workInProgress2.flags &= -257, workInProgress2 = retryActivityComponentWithoutHydrating(
                  current2,
                  workInProgress2,
                  renderLanes2
                );
              else if (null !== workInProgress2.memoizedState)
                workInProgress2.child = current2.child, workInProgress2.flags |= 128, workInProgress2 = null;
              else
                throw Error(
                  "Client rendering an Activity suspended it again. This is a bug in React."
                );
            else if (warnIfHydrating(), 0 !== (renderLanes2 & 536870912) && markRenderDerivedCause(workInProgress2), didReceiveUpdate || propagateParentContextChanges(
              current2,
              workInProgress2,
              renderLanes2,
              false
            ), didSuspend = 0 !== (renderLanes2 & current2.childLanes), didReceiveUpdate || didSuspend) {
              nextProps = workInProgressRoot;
              if (null !== nextProps && (activityInstance = getBumpedLaneForHydration(
                nextProps,
                renderLanes2
              ), 0 !== activityInstance && activityInstance !== prevState.retryLane))
                throw prevState.retryLane = activityInstance, enqueueConcurrentRenderForLane(current2, activityInstance), scheduleUpdateOnFiber(nextProps, current2, activityInstance), SelectiveHydrationException;
              renderDidSuspendDelayIfPossible();
              workInProgress2 = retryActivityComponentWithoutHydrating(
                current2,
                workInProgress2,
                renderLanes2
              );
            } else
              current2 = prevState.treeContext, nextHydratableInstance = getNextHydratable(
                activityInstance.nextSibling
              ), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, didSuspendOrErrorDEV = false, hydrationDiffRootDEV = null, rootOrSingletonContext = false, null !== current2 && restoreSuspendedTreeContext(workInProgress2, current2), workInProgress2 = mountActivityChildren(workInProgress2, nextProps), workInProgress2.flags |= 4096;
            return workInProgress2;
          }
          prevState = current2.child;
          nextProps = { mode: nextProps.mode, children: nextProps.children };
          0 !== (renderLanes2 & 536870912) && 0 !== (renderLanes2 & current2.lanes) && markRenderDerivedCause(workInProgress2);
          current2 = createWorkInProgress(prevState, nextProps);
          current2.ref = workInProgress2.ref;
          workInProgress2.child = current2;
          current2.return = workInProgress2;
          return current2;
        }
        function markRef(current2, workInProgress2) {
          var ref = workInProgress2.ref;
          if (null === ref)
            null !== current2 && null !== current2.ref && (workInProgress2.flags |= 4194816);
          else {
            if ("function" !== typeof ref && "object" !== typeof ref)
              throw Error(
                "Expected ref to be a function, an object returned by React.createRef(), or undefined/null."
              );
            if (null === current2 || current2.ref !== ref)
              workInProgress2.flags |= 4194816;
          }
        }
        function updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
          if (Component.prototype && "function" === typeof Component.prototype.render) {
            var componentName2 = getComponentNameFromType(Component) || "Unknown";
            didWarnAboutBadClass[componentName2] || (console.error(
              "The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.",
              componentName2,
              componentName2
            ), didWarnAboutBadClass[componentName2] = true);
          }
          workInProgress2.mode & StrictLegacyMode && ReactStrictModeWarnings.recordLegacyContextWarning(
            workInProgress2,
            null
          );
          null === current2 && (validateFunctionComponentInDev(workInProgress2, workInProgress2.type), Component.contextTypes && (componentName2 = getComponentNameFromType(Component) || "Unknown", didWarnAboutContextTypes[componentName2] || (didWarnAboutContextTypes[componentName2] = true, console.error(
            "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)",
            componentName2
          ))));
          prepareToReadContext(workInProgress2);
          Component = renderWithHooks(
            current2,
            workInProgress2,
            Component,
            nextProps,
            void 0,
            renderLanes2
          );
          nextProps = checkDidRenderIdHook();
          if (null !== current2 && !didReceiveUpdate)
            return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          isHydrating && nextProps && pushMaterializedTreeId(workInProgress2);
          workInProgress2.flags |= 1;
          reconcileChildren(current2, workInProgress2, Component, renderLanes2);
          return workInProgress2.child;
        }
        function replayFunctionComponent(current2, workInProgress2, nextProps, Component, secondArg, renderLanes2) {
          prepareToReadContext(workInProgress2);
          hookTypesUpdateIndexDev = -1;
          ignorePreviousDependencies = null !== current2 && current2.type !== workInProgress2.type;
          workInProgress2.updateQueue = null;
          nextProps = renderWithHooksAgain(
            workInProgress2,
            Component,
            nextProps,
            secondArg
          );
          finishRenderingHooks(current2, workInProgress2);
          Component = checkDidRenderIdHook();
          if (null !== current2 && !didReceiveUpdate)
            return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          isHydrating && Component && pushMaterializedTreeId(workInProgress2);
          workInProgress2.flags |= 1;
          reconcileChildren(current2, workInProgress2, nextProps, renderLanes2);
          return workInProgress2.child;
        }
        function updateClassComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
          switch (shouldErrorImpl(workInProgress2)) {
            case false:
              var _instance = workInProgress2.stateNode, state = new workInProgress2.type(
                workInProgress2.memoizedProps,
                _instance.context
              ).state;
              _instance.updater.enqueueSetState(_instance, state, null);
              break;
            case true:
              workInProgress2.flags |= 128;
              workInProgress2.flags |= 65536;
              _instance = Error("Simulated error coming from DevTools");
              var lane = renderLanes2 & -renderLanes2;
              workInProgress2.lanes |= lane;
              state = workInProgressRoot;
              if (null === state)
                throw Error(
                  "Expected a work-in-progress root. This is a bug in React. Please file an issue."
                );
              lane = createClassErrorUpdate(lane);
              initializeClassErrorUpdate(
                lane,
                state,
                workInProgress2,
                createCapturedValueAtFiber(_instance, workInProgress2)
              );
              enqueueCapturedUpdate(workInProgress2, lane);
          }
          prepareToReadContext(workInProgress2);
          if (null === workInProgress2.stateNode) {
            state = emptyContextObject;
            _instance = Component.contextType;
            "contextType" in Component && null !== _instance && (void 0 === _instance || _instance.$$typeof !== REACT_CONTEXT_TYPE) && !didWarnAboutInvalidateContextType.has(Component) && (didWarnAboutInvalidateContextType.add(Component), lane = void 0 === _instance ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : "object" !== typeof _instance ? " However, it is set to a " + typeof _instance + "." : _instance.$$typeof === REACT_CONSUMER_TYPE ? " Did you accidentally pass the Context.Consumer instead?" : " However, it is set to an object with keys {" + Object.keys(_instance).join(", ") + "}.", console.error(
              "%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s",
              getComponentNameFromType(Component) || "Component",
              lane
            ));
            "object" === typeof _instance && null !== _instance && (state = readContext(_instance));
            _instance = new Component(nextProps, state);
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                _instance = new Component(nextProps, state);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            state = workInProgress2.memoizedState = null !== _instance.state && void 0 !== _instance.state ? _instance.state : null;
            _instance.updater = classComponentUpdater;
            workInProgress2.stateNode = _instance;
            _instance._reactInternals = workInProgress2;
            _instance._reactInternalInstance = fakeInternalInstance;
            "function" === typeof Component.getDerivedStateFromProps && null === state && (state = getComponentNameFromType(Component) || "Component", didWarnAboutUninitializedState.has(state) || (didWarnAboutUninitializedState.add(state), console.error(
              "`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.",
              state,
              null === _instance.state ? "null" : "undefined",
              state
            )));
            if ("function" === typeof Component.getDerivedStateFromProps || "function" === typeof _instance.getSnapshotBeforeUpdate) {
              var foundWillUpdateName = lane = state = null;
              "function" === typeof _instance.componentWillMount && true !== _instance.componentWillMount.__suppressDeprecationWarning ? state = "componentWillMount" : "function" === typeof _instance.UNSAFE_componentWillMount && (state = "UNSAFE_componentWillMount");
              "function" === typeof _instance.componentWillReceiveProps && true !== _instance.componentWillReceiveProps.__suppressDeprecationWarning ? lane = "componentWillReceiveProps" : "function" === typeof _instance.UNSAFE_componentWillReceiveProps && (lane = "UNSAFE_componentWillReceiveProps");
              "function" === typeof _instance.componentWillUpdate && true !== _instance.componentWillUpdate.__suppressDeprecationWarning ? foundWillUpdateName = "componentWillUpdate" : "function" === typeof _instance.UNSAFE_componentWillUpdate && (foundWillUpdateName = "UNSAFE_componentWillUpdate");
              if (null !== state || null !== lane || null !== foundWillUpdateName) {
                _instance = getComponentNameFromType(Component) || "Component";
                var newApiName = "function" === typeof Component.getDerivedStateFromProps ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                didWarnAboutLegacyLifecyclesAndDerivedState.has(_instance) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(_instance), console.error(
                  "Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://react.dev/link/unsafe-component-lifecycles",
                  _instance,
                  newApiName,
                  null !== state ? "\n  " + state : "",
                  null !== lane ? "\n  " + lane : "",
                  null !== foundWillUpdateName ? "\n  " + foundWillUpdateName : ""
                ));
              }
            }
            _instance = workInProgress2.stateNode;
            state = getComponentNameFromType(Component) || "Component";
            _instance.render || (Component.prototype && "function" === typeof Component.prototype.render ? console.error(
              "No `render` method found on the %s instance: did you accidentally return an object from the constructor?",
              state
            ) : console.error(
              "No `render` method found on the %s instance: you may have forgotten to define `render`.",
              state
            ));
            !_instance.getInitialState || _instance.getInitialState.isReactClassApproved || _instance.state || console.error(
              "getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?",
              state
            );
            _instance.getDefaultProps && !_instance.getDefaultProps.isReactClassApproved && console.error(
              "getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.",
              state
            );
            _instance.contextType && console.error(
              "contextType was defined as an instance property on %s. Use a static property to define contextType instead.",
              state
            );
            Component.childContextTypes && !didWarnAboutChildContextTypes.has(Component) && (didWarnAboutChildContextTypes.add(Component), console.error(
              "%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)",
              state
            ));
            Component.contextTypes && !didWarnAboutContextTypes$1.has(Component) && (didWarnAboutContextTypes$1.add(Component), console.error(
              "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)",
              state
            ));
            "function" === typeof _instance.componentShouldUpdate && console.error(
              "%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.",
              state
            );
            Component.prototype && Component.prototype.isPureReactComponent && "undefined" !== typeof _instance.shouldComponentUpdate && console.error(
              "%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.",
              getComponentNameFromType(Component) || "A pure component"
            );
            "function" === typeof _instance.componentDidUnmount && console.error(
              "%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?",
              state
            );
            "function" === typeof _instance.componentDidReceiveProps && console.error(
              "%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().",
              state
            );
            "function" === typeof _instance.componentWillRecieveProps && console.error(
              "%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",
              state
            );
            "function" === typeof _instance.UNSAFE_componentWillRecieveProps && console.error(
              "%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?",
              state
            );
            lane = _instance.props !== nextProps;
            void 0 !== _instance.props && lane && console.error(
              "When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.",
              state
            );
            _instance.defaultProps && console.error(
              "Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.",
              state,
              state
            );
            "function" !== typeof _instance.getSnapshotBeforeUpdate || "function" === typeof _instance.componentDidUpdate || didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(Component) || (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(Component), console.error(
              "%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.",
              getComponentNameFromType(Component)
            ));
            "function" === typeof _instance.getDerivedStateFromProps && console.error(
              "%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
              state
            );
            "function" === typeof _instance.getDerivedStateFromError && console.error(
              "%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
              state
            );
            "function" === typeof Component.getSnapshotBeforeUpdate && console.error(
              "%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.",
              state
            );
            (lane = _instance.state) && ("object" !== typeof lane || isArrayImpl(lane)) && console.error("%s.state: must be set to an object or null", state);
            "function" === typeof _instance.getChildContext && "object" !== typeof Component.childContextTypes && console.error(
              "%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().",
              state
            );
            _instance = workInProgress2.stateNode;
            _instance.props = nextProps;
            _instance.state = workInProgress2.memoizedState;
            _instance.refs = {};
            initializeUpdateQueue(workInProgress2);
            state = Component.contextType;
            _instance.context = "object" === typeof state && null !== state ? readContext(state) : emptyContextObject;
            _instance.state === nextProps && (state = getComponentNameFromType(Component) || "Component", didWarnAboutDirectlyAssigningPropsToState.has(state) || (didWarnAboutDirectlyAssigningPropsToState.add(state), console.error(
              "%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.",
              state
            )));
            workInProgress2.mode & StrictLegacyMode && ReactStrictModeWarnings.recordLegacyContextWarning(
              workInProgress2,
              _instance
            );
            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(
              workInProgress2,
              _instance
            );
            _instance.state = workInProgress2.memoizedState;
            state = Component.getDerivedStateFromProps;
            "function" === typeof state && (applyDerivedStateFromProps(
              workInProgress2,
              Component,
              state,
              nextProps
            ), _instance.state = workInProgress2.memoizedState);
            "function" === typeof Component.getDerivedStateFromProps || "function" === typeof _instance.getSnapshotBeforeUpdate || "function" !== typeof _instance.UNSAFE_componentWillMount && "function" !== typeof _instance.componentWillMount || (state = _instance.state, "function" === typeof _instance.componentWillMount && _instance.componentWillMount(), "function" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount(), state !== _instance.state && (console.error(
              "%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
              getComponentNameFromFiber(workInProgress2) || "Component"
            ), classComponentUpdater.enqueueReplaceState(
              _instance,
              _instance.state,
              null
            )), processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction(), _instance.state = workInProgress2.memoizedState);
            "function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308);
            (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728);
            _instance = true;
          } else if (null === current2) {
            _instance = workInProgress2.stateNode;
            var unresolvedOldProps = workInProgress2.memoizedProps;
            lane = resolveClassComponentProps(Component, unresolvedOldProps);
            _instance.props = lane;
            var oldContext = _instance.context;
            foundWillUpdateName = Component.contextType;
            state = emptyContextObject;
            "object" === typeof foundWillUpdateName && null !== foundWillUpdateName && (state = readContext(foundWillUpdateName));
            newApiName = Component.getDerivedStateFromProps;
            foundWillUpdateName = "function" === typeof newApiName || "function" === typeof _instance.getSnapshotBeforeUpdate;
            unresolvedOldProps = workInProgress2.pendingProps !== unresolvedOldProps;
            foundWillUpdateName || "function" !== typeof _instance.UNSAFE_componentWillReceiveProps && "function" !== typeof _instance.componentWillReceiveProps || (unresolvedOldProps || oldContext !== state) && callComponentWillReceiveProps(
              workInProgress2,
              _instance,
              nextProps,
              state
            );
            hasForceUpdate = false;
            var oldState = workInProgress2.memoizedState;
            _instance.state = oldState;
            processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2);
            suspendIfUpdateReadFromEntangledAsyncAction();
            oldContext = workInProgress2.memoizedState;
            unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? ("function" === typeof newApiName && (applyDerivedStateFromProps(
              workInProgress2,
              Component,
              newApiName,
              nextProps
            ), oldContext = workInProgress2.memoizedState), (lane = hasForceUpdate || checkShouldComponentUpdate(
              workInProgress2,
              Component,
              lane,
              nextProps,
              oldState,
              oldContext,
              state
            )) ? (foundWillUpdateName || "function" !== typeof _instance.UNSAFE_componentWillMount && "function" !== typeof _instance.componentWillMount || ("function" === typeof _instance.componentWillMount && _instance.componentWillMount(), "function" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount()), "function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308), (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728)) : ("function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308), (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = oldContext), _instance.props = nextProps, _instance.state = oldContext, _instance.context = state, _instance = lane) : ("function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308), (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728), _instance = false);
          } else {
            _instance = workInProgress2.stateNode;
            cloneUpdateQueue(current2, workInProgress2);
            state = workInProgress2.memoizedProps;
            foundWillUpdateName = resolveClassComponentProps(Component, state);
            _instance.props = foundWillUpdateName;
            newApiName = workInProgress2.pendingProps;
            oldState = _instance.context;
            oldContext = Component.contextType;
            lane = emptyContextObject;
            "object" === typeof oldContext && null !== oldContext && (lane = readContext(oldContext));
            unresolvedOldProps = Component.getDerivedStateFromProps;
            (oldContext = "function" === typeof unresolvedOldProps || "function" === typeof _instance.getSnapshotBeforeUpdate) || "function" !== typeof _instance.UNSAFE_componentWillReceiveProps && "function" !== typeof _instance.componentWillReceiveProps || (state !== newApiName || oldState !== lane) && callComponentWillReceiveProps(
              workInProgress2,
              _instance,
              nextProps,
              lane
            );
            hasForceUpdate = false;
            oldState = workInProgress2.memoizedState;
            _instance.state = oldState;
            processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2);
            suspendIfUpdateReadFromEntangledAsyncAction();
            var newState = workInProgress2.memoizedState;
            state !== newApiName || oldState !== newState || hasForceUpdate || null !== current2 && null !== current2.dependencies && checkIfContextChanged(current2.dependencies) ? ("function" === typeof unresolvedOldProps && (applyDerivedStateFromProps(
              workInProgress2,
              Component,
              unresolvedOldProps,
              nextProps
            ), newState = workInProgress2.memoizedState), (foundWillUpdateName = hasForceUpdate || checkShouldComponentUpdate(
              workInProgress2,
              Component,
              foundWillUpdateName,
              nextProps,
              oldState,
              newState,
              lane
            ) || null !== current2 && null !== current2.dependencies && checkIfContextChanged(current2.dependencies)) ? (oldContext || "function" !== typeof _instance.UNSAFE_componentWillUpdate && "function" !== typeof _instance.componentWillUpdate || ("function" === typeof _instance.componentWillUpdate && _instance.componentWillUpdate(nextProps, newState, lane), "function" === typeof _instance.UNSAFE_componentWillUpdate && _instance.UNSAFE_componentWillUpdate(
              nextProps,
              newState,
              lane
            )), "function" === typeof _instance.componentDidUpdate && (workInProgress2.flags |= 4), "function" === typeof _instance.getSnapshotBeforeUpdate && (workInProgress2.flags |= 1024)) : ("function" !== typeof _instance.componentDidUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof _instance.getSnapshotBeforeUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 1024), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = newState), _instance.props = nextProps, _instance.state = newState, _instance.context = lane, _instance = foundWillUpdateName) : ("function" !== typeof _instance.componentDidUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof _instance.getSnapshotBeforeUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 1024), _instance = false);
          }
          lane = _instance;
          markRef(current2, workInProgress2);
          state = 0 !== (workInProgress2.flags & 128);
          if (lane || state) {
            lane = workInProgress2.stateNode;
            setCurrentFiber(workInProgress2);
            if (state && "function" !== typeof Component.getDerivedStateFromError)
              Component = null, profilerStartTime = -1;
            else if (Component = callRenderInDEV(lane), workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                callRenderInDEV(lane);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            workInProgress2.flags |= 1;
            null !== current2 && state ? (workInProgress2.child = reconcileChildFibers(
              workInProgress2,
              current2.child,
              null,
              renderLanes2
            ), workInProgress2.child = reconcileChildFibers(
              workInProgress2,
              null,
              Component,
              renderLanes2
            )) : reconcileChildren(current2, workInProgress2, Component, renderLanes2);
            workInProgress2.memoizedState = lane.state;
            current2 = workInProgress2.child;
          } else
            current2 = bailoutOnAlreadyFinishedWork(
              current2,
              workInProgress2,
              renderLanes2
            );
          renderLanes2 = workInProgress2.stateNode;
          _instance && renderLanes2.props !== nextProps && (didWarnAboutReassigningProps || console.error(
            "It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.",
            getComponentNameFromFiber(workInProgress2) || "a component"
          ), didWarnAboutReassigningProps = true);
          return current2;
        }
        function mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2) {
          resetHydrationState();
          workInProgress2.flags |= 256;
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function validateFunctionComponentInDev(workInProgress2, Component) {
          Component && Component.childContextTypes && console.error(
            "childContextTypes cannot be defined on a function component.\n  %s.childContextTypes = ...",
            Component.displayName || Component.name || "Component"
          );
          "function" === typeof Component.getDerivedStateFromProps && (workInProgress2 = getComponentNameFromType(Component) || "Unknown", didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress2] || (console.error(
            "%s: Function components do not support getDerivedStateFromProps.",
            workInProgress2
          ), didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress2] = true));
          "object" === typeof Component.contextType && null !== Component.contextType && (Component = getComponentNameFromType(Component) || "Unknown", didWarnAboutContextTypeOnFunctionComponent[Component] || (console.error(
            "%s: Function components do not support contextType.",
            Component
          ), didWarnAboutContextTypeOnFunctionComponent[Component] = true));
        }
        function mountSuspenseOffscreenState(renderLanes2) {
          return { baseLanes: renderLanes2, cachePool: getSuspendedCache() };
        }
        function getRemainingWorkInPrimaryTree(current2, primaryTreeDidDefer, renderLanes2) {
          current2 = null !== current2 ? current2.childLanes & ~renderLanes2 : 0;
          primaryTreeDidDefer && (current2 |= workInProgressDeferredLane);
          return current2;
        }
        function updateSuspenseComponent(current2, workInProgress2, renderLanes2) {
          var JSCompiler_object_inline_digest_2724;
          var JSCompiler_object_inline_stack_2725 = workInProgress2.pendingProps;
          shouldSuspendImpl(workInProgress2) && (workInProgress2.flags |= 128);
          var JSCompiler_object_inline_message_2723 = false;
          var didSuspend = 0 !== (workInProgress2.flags & 128);
          (JSCompiler_object_inline_digest_2724 = didSuspend) || (JSCompiler_object_inline_digest_2724 = null !== current2 && null === current2.memoizedState ? false : 0 !== (suspenseStackCursor.current & ForceSuspenseFallback));
          JSCompiler_object_inline_digest_2724 && (JSCompiler_object_inline_message_2723 = true, workInProgress2.flags &= -129);
          JSCompiler_object_inline_digest_2724 = 0 !== (workInProgress2.flags & 32);
          workInProgress2.flags &= -33;
          if (null === current2) {
            if (isHydrating) {
              JSCompiler_object_inline_message_2723 ? pushPrimaryTreeSuspenseHandler(workInProgress2) : reuseSuspenseHandlerOnStack(workInProgress2);
              (current2 = nextHydratableInstance) ? (renderLanes2 = canHydrateHydrationBoundary(
                current2,
                rootOrSingletonContext
              ), renderLanes2 = null !== renderLanes2 && renderLanes2.data !== ACTIVITY_START_DATA ? renderLanes2 : null, null !== renderLanes2 && (JSCompiler_object_inline_digest_2724 = {
                dehydrated: renderLanes2,
                treeContext: getSuspendedTreeContext(),
                retryLane: 536870912,
                hydrationErrors: null
              }, workInProgress2.memoizedState = JSCompiler_object_inline_digest_2724, JSCompiler_object_inline_digest_2724 = createFiberFromDehydratedFragment(renderLanes2), JSCompiler_object_inline_digest_2724.return = workInProgress2, workInProgress2.child = JSCompiler_object_inline_digest_2724, hydrationParentFiber = workInProgress2, nextHydratableInstance = null)) : renderLanes2 = null;
              if (null === renderLanes2)
                throw warnNonHydratedInstance(workInProgress2, current2), throwOnHydrationMismatch(workInProgress2);
              isSuspenseInstanceFallback(renderLanes2) ? workInProgress2.lanes = 32 : workInProgress2.lanes = 536870912;
              return null;
            }
            var nextPrimaryChildren = JSCompiler_object_inline_stack_2725.children;
            JSCompiler_object_inline_stack_2725 = JSCompiler_object_inline_stack_2725.fallback;
            if (JSCompiler_object_inline_message_2723) {
              reuseSuspenseHandlerOnStack(workInProgress2);
              var mode = workInProgress2.mode;
              nextPrimaryChildren = mountWorkInProgressOffscreenFiber(
                { mode: "hidden", children: nextPrimaryChildren },
                mode
              );
              JSCompiler_object_inline_stack_2725 = createFiberFromFragment(
                JSCompiler_object_inline_stack_2725,
                mode,
                renderLanes2,
                null
              );
              nextPrimaryChildren.return = workInProgress2;
              JSCompiler_object_inline_stack_2725.return = workInProgress2;
              nextPrimaryChildren.sibling = JSCompiler_object_inline_stack_2725;
              workInProgress2.child = nextPrimaryChildren;
              JSCompiler_object_inline_stack_2725 = workInProgress2.child;
              JSCompiler_object_inline_stack_2725.memoizedState = mountSuspenseOffscreenState(renderLanes2);
              JSCompiler_object_inline_stack_2725.childLanes = getRemainingWorkInPrimaryTree(
                current2,
                JSCompiler_object_inline_digest_2724,
                renderLanes2
              );
              workInProgress2.memoizedState = SUSPENDED_MARKER;
              return bailoutOffscreenComponent(
                null,
                JSCompiler_object_inline_stack_2725
              );
            }
            pushPrimaryTreeSuspenseHandler(workInProgress2);
            return mountSuspensePrimaryChildren(
              workInProgress2,
              nextPrimaryChildren
            );
          }
          var prevState = current2.memoizedState;
          if (null !== prevState) {
            var JSCompiler_object_inline_componentStack_2726 = prevState.dehydrated;
            if (null !== JSCompiler_object_inline_componentStack_2726) {
              if (didSuspend)
                workInProgress2.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags &= -257, workInProgress2 = retrySuspenseComponentWithoutHydrating(
                  current2,
                  workInProgress2,
                  renderLanes2
                )) : null !== workInProgress2.memoizedState ? (reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.child = current2.child, workInProgress2.flags |= 128, workInProgress2 = null) : (reuseSuspenseHandlerOnStack(workInProgress2), nextPrimaryChildren = JSCompiler_object_inline_stack_2725.fallback, mode = workInProgress2.mode, JSCompiler_object_inline_stack_2725 = mountWorkInProgressOffscreenFiber(
                  {
                    mode: "visible",
                    children: JSCompiler_object_inline_stack_2725.children
                  },
                  mode
                ), nextPrimaryChildren = createFiberFromFragment(
                  nextPrimaryChildren,
                  mode,
                  renderLanes2,
                  null
                ), nextPrimaryChildren.flags |= 2, JSCompiler_object_inline_stack_2725.return = workInProgress2, nextPrimaryChildren.return = workInProgress2, JSCompiler_object_inline_stack_2725.sibling = nextPrimaryChildren, workInProgress2.child = JSCompiler_object_inline_stack_2725, reconcileChildFibers(
                  workInProgress2,
                  current2.child,
                  null,
                  renderLanes2
                ), JSCompiler_object_inline_stack_2725 = workInProgress2.child, JSCompiler_object_inline_stack_2725.memoizedState = mountSuspenseOffscreenState(renderLanes2), JSCompiler_object_inline_stack_2725.childLanes = getRemainingWorkInPrimaryTree(
                  current2,
                  JSCompiler_object_inline_digest_2724,
                  renderLanes2
                ), workInProgress2.memoizedState = SUSPENDED_MARKER, workInProgress2 = bailoutOffscreenComponent(
                  null,
                  JSCompiler_object_inline_stack_2725
                ));
              else if (pushPrimaryTreeSuspenseHandler(workInProgress2), warnIfHydrating(), 0 !== (renderLanes2 & 536870912) && markRenderDerivedCause(workInProgress2), isSuspenseInstanceFallback(
                JSCompiler_object_inline_componentStack_2726
              )) {
                JSCompiler_object_inline_digest_2724 = JSCompiler_object_inline_componentStack_2726.nextSibling && JSCompiler_object_inline_componentStack_2726.nextSibling.dataset;
                if (JSCompiler_object_inline_digest_2724) {
                  nextPrimaryChildren = JSCompiler_object_inline_digest_2724.dgst;
                  var message = JSCompiler_object_inline_digest_2724.msg;
                  mode = JSCompiler_object_inline_digest_2724.stck;
                  var componentStack = JSCompiler_object_inline_digest_2724.cstck;
                }
                JSCompiler_object_inline_message_2723 = message;
                JSCompiler_object_inline_digest_2724 = nextPrimaryChildren;
                JSCompiler_object_inline_stack_2725 = mode;
                JSCompiler_object_inline_componentStack_2726 = componentStack;
                nextPrimaryChildren = JSCompiler_object_inline_message_2723;
                mode = JSCompiler_object_inline_componentStack_2726;
                nextPrimaryChildren = nextPrimaryChildren ? Error(nextPrimaryChildren) : Error(
                  "The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering."
                );
                nextPrimaryChildren.stack = JSCompiler_object_inline_stack_2725 || "";
                nextPrimaryChildren.digest = JSCompiler_object_inline_digest_2724;
                JSCompiler_object_inline_digest_2724 = void 0 === mode ? null : mode;
                JSCompiler_object_inline_stack_2725 = {
                  value: nextPrimaryChildren,
                  source: null,
                  stack: JSCompiler_object_inline_digest_2724
                };
                "string" === typeof JSCompiler_object_inline_digest_2724 && CapturedStacks.set(
                  nextPrimaryChildren,
                  JSCompiler_object_inline_stack_2725
                );
                queueHydrationError(JSCompiler_object_inline_stack_2725);
                workInProgress2 = retrySuspenseComponentWithoutHydrating(
                  current2,
                  workInProgress2,
                  renderLanes2
                );
              } else if (didReceiveUpdate || propagateParentContextChanges(
                current2,
                workInProgress2,
                renderLanes2,
                false
              ), JSCompiler_object_inline_digest_2724 = 0 !== (renderLanes2 & current2.childLanes), didReceiveUpdate || JSCompiler_object_inline_digest_2724) {
                JSCompiler_object_inline_digest_2724 = workInProgressRoot;
                if (null !== JSCompiler_object_inline_digest_2724 && (JSCompiler_object_inline_stack_2725 = getBumpedLaneForHydration(
                  JSCompiler_object_inline_digest_2724,
                  renderLanes2
                ), 0 !== JSCompiler_object_inline_stack_2725 && JSCompiler_object_inline_stack_2725 !== prevState.retryLane))
                  throw prevState.retryLane = JSCompiler_object_inline_stack_2725, enqueueConcurrentRenderForLane(
                    current2,
                    JSCompiler_object_inline_stack_2725
                  ), scheduleUpdateOnFiber(
                    JSCompiler_object_inline_digest_2724,
                    current2,
                    JSCompiler_object_inline_stack_2725
                  ), SelectiveHydrationException;
                isSuspenseInstancePending(
                  JSCompiler_object_inline_componentStack_2726
                ) || renderDidSuspendDelayIfPossible();
                workInProgress2 = retrySuspenseComponentWithoutHydrating(
                  current2,
                  workInProgress2,
                  renderLanes2
                );
              } else
                isSuspenseInstancePending(
                  JSCompiler_object_inline_componentStack_2726
                ) ? (workInProgress2.flags |= 192, workInProgress2.child = current2.child, workInProgress2 = null) : (current2 = prevState.treeContext, nextHydratableInstance = getNextHydratable(
                  JSCompiler_object_inline_componentStack_2726.nextSibling
                ), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, didSuspendOrErrorDEV = false, hydrationDiffRootDEV = null, rootOrSingletonContext = false, null !== current2 && restoreSuspendedTreeContext(workInProgress2, current2), workInProgress2 = mountSuspensePrimaryChildren(
                  workInProgress2,
                  JSCompiler_object_inline_stack_2725.children
                ), workInProgress2.flags |= 4096);
              return workInProgress2;
            }
          }
          if (JSCompiler_object_inline_message_2723)
            return reuseSuspenseHandlerOnStack(workInProgress2), nextPrimaryChildren = JSCompiler_object_inline_stack_2725.fallback, mode = workInProgress2.mode, componentStack = current2.child, JSCompiler_object_inline_componentStack_2726 = componentStack.sibling, JSCompiler_object_inline_stack_2725 = createWorkInProgress(
              componentStack,
              {
                mode: "hidden",
                children: JSCompiler_object_inline_stack_2725.children
              }
            ), JSCompiler_object_inline_stack_2725.subtreeFlags = componentStack.subtreeFlags & 65011712, null !== JSCompiler_object_inline_componentStack_2726 ? nextPrimaryChildren = createWorkInProgress(
              JSCompiler_object_inline_componentStack_2726,
              nextPrimaryChildren
            ) : (nextPrimaryChildren = createFiberFromFragment(
              nextPrimaryChildren,
              mode,
              renderLanes2,
              null
            ), nextPrimaryChildren.flags |= 2), nextPrimaryChildren.return = workInProgress2, JSCompiler_object_inline_stack_2725.return = workInProgress2, JSCompiler_object_inline_stack_2725.sibling = nextPrimaryChildren, workInProgress2.child = JSCompiler_object_inline_stack_2725, bailoutOffscreenComponent(null, JSCompiler_object_inline_stack_2725), JSCompiler_object_inline_stack_2725 = workInProgress2.child, nextPrimaryChildren = current2.child.memoizedState, null === nextPrimaryChildren ? nextPrimaryChildren = mountSuspenseOffscreenState(renderLanes2) : (mode = nextPrimaryChildren.cachePool, null !== mode ? (componentStack = CacheContext._currentValue, mode = mode.parent !== componentStack ? { parent: componentStack, pool: componentStack } : mode) : mode = getSuspendedCache(), nextPrimaryChildren = {
              baseLanes: nextPrimaryChildren.baseLanes | renderLanes2,
              cachePool: mode
            }), JSCompiler_object_inline_stack_2725.memoizedState = nextPrimaryChildren, JSCompiler_object_inline_stack_2725.childLanes = getRemainingWorkInPrimaryTree(
              current2,
              JSCompiler_object_inline_digest_2724,
              renderLanes2
            ), workInProgress2.memoizedState = SUSPENDED_MARKER, bailoutOffscreenComponent(
              current2.child,
              JSCompiler_object_inline_stack_2725
            );
          null !== prevState && (renderLanes2 & 62914560) === renderLanes2 && 0 !== (renderLanes2 & current2.lanes) && markRenderDerivedCause(workInProgress2);
          pushPrimaryTreeSuspenseHandler(workInProgress2);
          renderLanes2 = current2.child;
          current2 = renderLanes2.sibling;
          renderLanes2 = createWorkInProgress(renderLanes2, {
            mode: "visible",
            children: JSCompiler_object_inline_stack_2725.children
          });
          renderLanes2.return = workInProgress2;
          renderLanes2.sibling = null;
          null !== current2 && (JSCompiler_object_inline_digest_2724 = workInProgress2.deletions, null === JSCompiler_object_inline_digest_2724 ? (workInProgress2.deletions = [current2], workInProgress2.flags |= 16) : JSCompiler_object_inline_digest_2724.push(current2));
          workInProgress2.child = renderLanes2;
          workInProgress2.memoizedState = null;
          return renderLanes2;
        }
        function mountSuspensePrimaryChildren(workInProgress2, primaryChildren) {
          primaryChildren = mountWorkInProgressOffscreenFiber(
            { mode: "visible", children: primaryChildren },
            workInProgress2.mode
          );
          primaryChildren.return = workInProgress2;
          return workInProgress2.child = primaryChildren;
        }
        function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
          offscreenProps = createFiber(22, offscreenProps, null, mode);
          offscreenProps.lanes = 0;
          return offscreenProps;
        }
        function retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2) {
          reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
          current2 = mountSuspensePrimaryChildren(
            workInProgress2,
            workInProgress2.pendingProps.children
          );
          current2.flags |= 2;
          workInProgress2.memoizedState = null;
          return current2;
        }
        function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
          fiber.lanes |= renderLanes2;
          var alternate = fiber.alternate;
          null !== alternate && (alternate.lanes |= renderLanes2);
          scheduleContextWorkOnParentPath(
            fiber.return,
            renderLanes2,
            propagationRoot
          );
        }
        function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode, treeForkCount2) {
          var renderState = workInProgress2.memoizedState;
          null === renderState ? workInProgress2.memoizedState = {
            isBackwards,
            rendering: null,
            renderingStartTime: 0,
            last: lastContentRow,
            tail,
            tailMode,
            treeForkCount: treeForkCount2
          } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode, renderState.treeForkCount = treeForkCount2);
        }
        function updateSuspenseListComponent(current2, workInProgress2, renderLanes2) {
          var nextProps = workInProgress2.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail, newChildren = nextProps.children, suspenseContext = suspenseStackCursor.current;
          (nextProps = 0 !== (suspenseContext & ForceSuspenseFallback)) ? (suspenseContext = suspenseContext & SubtreeSuspenseContextMask | ForceSuspenseFallback, workInProgress2.flags |= 128) : suspenseContext &= SubtreeSuspenseContextMask;
          push(suspenseStackCursor, suspenseContext, workInProgress2);
          suspenseContext = null == revealOrder ? "null" : revealOrder;
          if ("forwards" !== revealOrder && "unstable_legacy-backwards" !== revealOrder && "together" !== revealOrder && "independent" !== revealOrder && !didWarnAboutRevealOrder[suspenseContext])
            if (didWarnAboutRevealOrder[suspenseContext] = true, null == revealOrder)
              console.error(
                'The default for the <SuspenseList revealOrder="..."> prop is changing. To be future compatible you must explictly specify either "independent" (the current default), "together", "forwards" or "legacy_unstable-backwards".'
              );
            else if ("backwards" === revealOrder)
              console.error(
                'The rendering order of <SuspenseList revealOrder="backwards"> is changing. To be future compatible you must specify revealOrder="legacy_unstable-backwards" instead.'
              );
            else if ("string" === typeof revealOrder)
              switch (revealOrder.toLowerCase()) {
                case "together":
                case "forwards":
                case "backwards":
                case "independent":
                  console.error(
                    '"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.',
                    revealOrder,
                    revealOrder.toLowerCase()
                  );
                  break;
                case "forward":
                case "backward":
                  console.error(
                    '"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.',
                    revealOrder,
                    revealOrder.toLowerCase()
                  );
                  break;
                default:
                  console.error(
                    '"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "independent", "together", "forwards" or "backwards"?',
                    revealOrder
                  );
              }
            else
              console.error(
                '%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "independent", "together", "forwards" or "backwards"?',
                revealOrder
              );
          suspenseContext = null == tailMode ? "null" : tailMode;
          if (!didWarnAboutTailOptions[suspenseContext])
            if (null == tailMode) {
              if ("forwards" === revealOrder || "backwards" === revealOrder || "unstable_legacy-backwards" === revealOrder)
                didWarnAboutTailOptions[suspenseContext] = true, console.error(
                  'The default for the <SuspenseList tail="..."> prop is changing. To be future compatible you must explictly specify either "visible" (the current default), "collapsed" or "hidden".'
                );
            } else
              "visible" !== tailMode && "collapsed" !== tailMode && "hidden" !== tailMode ? (didWarnAboutTailOptions[suspenseContext] = true, console.error(
                '"%s" is not a supported value for tail on <SuspenseList />. Did you mean "visible", "collapsed" or "hidden"?',
                tailMode
              )) : "forwards" !== revealOrder && "backwards" !== revealOrder && "unstable_legacy-backwards" !== revealOrder && (didWarnAboutTailOptions[suspenseContext] = true, console.error(
                '<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?',
                tailMode
              ));
          a: if (("forwards" === revealOrder || "backwards" === revealOrder || "unstable_legacy-backwards" === revealOrder) && void 0 !== newChildren && null !== newChildren && false !== newChildren)
            if (isArrayImpl(newChildren))
              for (suspenseContext = 0; suspenseContext < newChildren.length; suspenseContext++) {
                if (!validateSuspenseListNestedChild(
                  newChildren[suspenseContext],
                  suspenseContext
                ))
                  break a;
              }
            else if (suspenseContext = getIteratorFn(newChildren), "function" === typeof suspenseContext) {
              if (suspenseContext = suspenseContext.call(newChildren))
                for (var step = suspenseContext.next(), _i = 0; !step.done; step = suspenseContext.next()) {
                  if (!validateSuspenseListNestedChild(step.value, _i)) break a;
                  _i++;
                }
            } else
              console.error(
                'A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?',
                revealOrder
              );
          reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
          isHydrating ? (warnIfNotHydrating(), newChildren = treeForkCount) : newChildren = 0;
          if (!nextProps && null !== current2 && 0 !== (current2.flags & 128))
            a: for (current2 = workInProgress2.child; null !== current2; ) {
              if (13 === current2.tag)
                null !== current2.memoizedState && scheduleSuspenseWorkOnFiber(current2, renderLanes2, workInProgress2);
              else if (19 === current2.tag)
                scheduleSuspenseWorkOnFiber(current2, renderLanes2, workInProgress2);
              else if (null !== current2.child) {
                current2.child.return = current2;
                current2 = current2.child;
                continue;
              }
              if (current2 === workInProgress2) break a;
              for (; null === current2.sibling; ) {
                if (null === current2.return || current2.return === workInProgress2)
                  break a;
                current2 = current2.return;
              }
              current2.sibling.return = current2.return;
              current2 = current2.sibling;
            }
          switch (revealOrder) {
            case "forwards":
              renderLanes2 = workInProgress2.child;
              for (revealOrder = null; null !== renderLanes2; )
                current2 = renderLanes2.alternate, null !== current2 && null === findFirstSuspended(current2) && (revealOrder = renderLanes2), renderLanes2 = renderLanes2.sibling;
              renderLanes2 = revealOrder;
              null === renderLanes2 ? (revealOrder = workInProgress2.child, workInProgress2.child = null) : (revealOrder = renderLanes2.sibling, renderLanes2.sibling = null);
              initSuspenseListRenderState(
                workInProgress2,
                false,
                revealOrder,
                renderLanes2,
                tailMode,
                newChildren
              );
              break;
            case "backwards":
            case "unstable_legacy-backwards":
              renderLanes2 = null;
              revealOrder = workInProgress2.child;
              for (workInProgress2.child = null; null !== revealOrder; ) {
                current2 = revealOrder.alternate;
                if (null !== current2 && null === findFirstSuspended(current2)) {
                  workInProgress2.child = revealOrder;
                  break;
                }
                current2 = revealOrder.sibling;
                revealOrder.sibling = renderLanes2;
                renderLanes2 = revealOrder;
                revealOrder = current2;
              }
              initSuspenseListRenderState(
                workInProgress2,
                true,
                renderLanes2,
                null,
                tailMode,
                newChildren
              );
              break;
            case "together":
              initSuspenseListRenderState(
                workInProgress2,
                false,
                null,
                null,
                void 0,
                newChildren
              );
              break;
            default:
              workInProgress2.memoizedState = null;
          }
          return workInProgress2.child;
        }
        function bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2) {
          null !== current2 && (workInProgress2.dependencies = current2.dependencies);
          profilerStartTime = -1;
          workInProgressRootSkippedLanes |= workInProgress2.lanes;
          if (0 === (renderLanes2 & workInProgress2.childLanes))
            if (null !== current2) {
              if (propagateParentContextChanges(
                current2,
                workInProgress2,
                renderLanes2,
                false
              ), 0 === (renderLanes2 & workInProgress2.childLanes))
                return null;
            } else return null;
          if (null !== current2 && workInProgress2.child !== current2.child)
            throw Error("Resuming work not yet implemented.");
          if (null !== workInProgress2.child) {
            current2 = workInProgress2.child;
            renderLanes2 = createWorkInProgress(current2, current2.pendingProps);
            workInProgress2.child = renderLanes2;
            for (renderLanes2.return = workInProgress2; null !== current2.sibling; )
              current2 = current2.sibling, renderLanes2 = renderLanes2.sibling = createWorkInProgress(current2, current2.pendingProps), renderLanes2.return = workInProgress2;
            renderLanes2.sibling = null;
          }
          return workInProgress2.child;
        }
        function checkScheduledUpdateOrContext(current2, renderLanes2) {
          if (0 !== (current2.lanes & renderLanes2)) return true;
          current2 = current2.dependencies;
          return null !== current2 && checkIfContextChanged(current2) ? true : false;
        }
        function attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2) {
          switch (workInProgress2.tag) {
            case 3:
              pushHostContainer(
                workInProgress2,
                workInProgress2.stateNode.containerInfo
              );
              pushProvider(
                workInProgress2,
                CacheContext,
                current2.memoizedState.cache
              );
              resetHydrationState();
              break;
            case 27:
            case 5:
              pushHostContext(workInProgress2);
              break;
            case 4:
              pushHostContainer(
                workInProgress2,
                workInProgress2.stateNode.containerInfo
              );
              break;
            case 10:
              pushProvider(
                workInProgress2,
                workInProgress2.type,
                workInProgress2.memoizedProps.value
              );
              break;
            case 12:
              0 !== (renderLanes2 & workInProgress2.childLanes) && (workInProgress2.flags |= 4);
              workInProgress2.flags |= 2048;
              var stateNode = workInProgress2.stateNode;
              stateNode.effectDuration = -0;
              stateNode.passiveEffectDuration = -0;
              break;
            case 31:
              if (null !== workInProgress2.memoizedState)
                return workInProgress2.flags |= 128, pushDehydratedActivitySuspenseHandler(workInProgress2), null;
              break;
            case 13:
              stateNode = workInProgress2.memoizedState;
              if (null !== stateNode) {
                if (null !== stateNode.dehydrated)
                  return pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags |= 128, null;
                if (0 !== (renderLanes2 & workInProgress2.child.childLanes))
                  return updateSuspenseComponent(
                    current2,
                    workInProgress2,
                    renderLanes2
                  );
                pushPrimaryTreeSuspenseHandler(workInProgress2);
                current2 = bailoutOnAlreadyFinishedWork(
                  current2,
                  workInProgress2,
                  renderLanes2
                );
                return null !== current2 ? current2.sibling : null;
              }
              pushPrimaryTreeSuspenseHandler(workInProgress2);
              break;
            case 19:
              var didSuspendBefore = 0 !== (current2.flags & 128);
              stateNode = 0 !== (renderLanes2 & workInProgress2.childLanes);
              stateNode || (propagateParentContextChanges(
                current2,
                workInProgress2,
                renderLanes2,
                false
              ), stateNode = 0 !== (renderLanes2 & workInProgress2.childLanes));
              if (didSuspendBefore) {
                if (stateNode)
                  return updateSuspenseListComponent(
                    current2,
                    workInProgress2,
                    renderLanes2
                  );
                workInProgress2.flags |= 128;
              }
              didSuspendBefore = workInProgress2.memoizedState;
              null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
              push(
                suspenseStackCursor,
                suspenseStackCursor.current,
                workInProgress2
              );
              if (stateNode) break;
              else return null;
            case 22:
              return workInProgress2.lanes = 0, updateOffscreenComponent(
                current2,
                workInProgress2,
                renderLanes2,
                workInProgress2.pendingProps
              );
            case 24:
              pushProvider(
                workInProgress2,
                CacheContext,
                current2.memoizedState.cache
              );
          }
          return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
        }
        function beginWork(current2, workInProgress2, renderLanes2) {
          if (workInProgress2._debugNeedsRemount && null !== current2) {
            renderLanes2 = createFiberFromTypeAndProps(
              workInProgress2.type,
              workInProgress2.key,
              workInProgress2.pendingProps,
              workInProgress2._debugOwner || null,
              workInProgress2.mode,
              workInProgress2.lanes
            );
            renderLanes2._debugStack = workInProgress2._debugStack;
            renderLanes2._debugTask = workInProgress2._debugTask;
            var returnFiber = workInProgress2.return;
            if (null === returnFiber) throw Error("Cannot swap the root fiber.");
            current2.alternate = null;
            workInProgress2.alternate = null;
            renderLanes2.index = workInProgress2.index;
            renderLanes2.sibling = workInProgress2.sibling;
            renderLanes2.return = workInProgress2.return;
            renderLanes2.ref = workInProgress2.ref;
            renderLanes2._debugInfo = workInProgress2._debugInfo;
            if (workInProgress2 === returnFiber.child)
              returnFiber.child = renderLanes2;
            else {
              var prevSibling = returnFiber.child;
              if (null === prevSibling)
                throw Error("Expected parent to have a child.");
              for (; prevSibling.sibling !== workInProgress2; )
                if (prevSibling = prevSibling.sibling, null === prevSibling)
                  throw Error("Expected to find the previous sibling.");
              prevSibling.sibling = renderLanes2;
            }
            workInProgress2 = returnFiber.deletions;
            null === workInProgress2 ? (returnFiber.deletions = [current2], returnFiber.flags |= 16) : workInProgress2.push(current2);
            renderLanes2.flags |= 2;
            return renderLanes2;
          }
          if (null !== current2)
            if (current2.memoizedProps !== workInProgress2.pendingProps || workInProgress2.type !== current2.type)
              didReceiveUpdate = true;
            else {
              if (!checkScheduledUpdateOrContext(current2, renderLanes2) && 0 === (workInProgress2.flags & 128))
                return didReceiveUpdate = false, attemptEarlyBailoutIfNoScheduledUpdate(
                  current2,
                  workInProgress2,
                  renderLanes2
                );
              didReceiveUpdate = 0 !== (current2.flags & 131072) ? true : false;
            }
          else {
            didReceiveUpdate = false;
            if (returnFiber = isHydrating)
              warnIfNotHydrating(), returnFiber = 0 !== (workInProgress2.flags & 1048576);
            returnFiber && (returnFiber = workInProgress2.index, warnIfNotHydrating(), pushTreeId(workInProgress2, treeForkCount, returnFiber));
          }
          workInProgress2.lanes = 0;
          switch (workInProgress2.tag) {
            case 16:
              a: if (returnFiber = workInProgress2.pendingProps, current2 = resolveLazy(workInProgress2.elementType), workInProgress2.type = current2, "function" === typeof current2)
                shouldConstruct(current2) ? (returnFiber = resolveClassComponentProps(
                  current2,
                  returnFiber
                ), workInProgress2.tag = 1, workInProgress2.type = current2 = resolveFunctionForHotReloading(current2), workInProgress2 = updateClassComponent(
                  null,
                  workInProgress2,
                  current2,
                  returnFiber,
                  renderLanes2
                )) : (workInProgress2.tag = 0, validateFunctionComponentInDev(workInProgress2, current2), workInProgress2.type = current2 = resolveFunctionForHotReloading(current2), workInProgress2 = updateFunctionComponent(
                  null,
                  workInProgress2,
                  current2,
                  returnFiber,
                  renderLanes2
                ));
              else {
                if (void 0 !== current2 && null !== current2) {
                  if (prevSibling = current2.$$typeof, prevSibling === REACT_FORWARD_REF_TYPE) {
                    workInProgress2.tag = 11;
                    workInProgress2.type = current2 = resolveForwardRefForHotReloading(current2);
                    workInProgress2 = updateForwardRef(
                      null,
                      workInProgress2,
                      current2,
                      returnFiber,
                      renderLanes2
                    );
                    break a;
                  } else if (prevSibling === REACT_MEMO_TYPE) {
                    workInProgress2.tag = 14;
                    workInProgress2 = updateMemoComponent(
                      null,
                      workInProgress2,
                      current2,
                      returnFiber,
                      renderLanes2
                    );
                    break a;
                  }
                }
                workInProgress2 = "";
                null !== current2 && "object" === typeof current2 && current2.$$typeof === REACT_LAZY_TYPE && (workInProgress2 = " Did you wrap a component in React.lazy() more than once?");
                renderLanes2 = getComponentNameFromType(current2) || current2;
                throw Error(
                  "Element type is invalid. Received a promise that resolves to: " + renderLanes2 + ". Lazy element type must resolve to a class or function." + workInProgress2
                );
              }
              return workInProgress2;
            case 0:
              return updateFunctionComponent(
                current2,
                workInProgress2,
                workInProgress2.type,
                workInProgress2.pendingProps,
                renderLanes2
              );
            case 1:
              return returnFiber = workInProgress2.type, prevSibling = resolveClassComponentProps(
                returnFiber,
                workInProgress2.pendingProps
              ), updateClassComponent(
                current2,
                workInProgress2,
                returnFiber,
                prevSibling,
                renderLanes2
              );
            case 3:
              a: {
                pushHostContainer(
                  workInProgress2,
                  workInProgress2.stateNode.containerInfo
                );
                if (null === current2)
                  throw Error(
                    "Should have a current fiber. This is a bug in React."
                  );
                returnFiber = workInProgress2.pendingProps;
                var prevState = workInProgress2.memoizedState;
                prevSibling = prevState.element;
                cloneUpdateQueue(current2, workInProgress2);
                processUpdateQueue(workInProgress2, returnFiber, null, renderLanes2);
                var nextState = workInProgress2.memoizedState;
                returnFiber = nextState.cache;
                pushProvider(workInProgress2, CacheContext, returnFiber);
                returnFiber !== prevState.cache && propagateContextChanges(
                  workInProgress2,
                  [CacheContext],
                  renderLanes2,
                  true
                );
                suspendIfUpdateReadFromEntangledAsyncAction();
                returnFiber = nextState.element;
                if (prevState.isDehydrated)
                  if (prevState = {
                    element: returnFiber,
                    isDehydrated: false,
                    cache: nextState.cache
                  }, workInProgress2.updateQueue.baseState = prevState, workInProgress2.memoizedState = prevState, workInProgress2.flags & 256) {
                    workInProgress2 = mountHostRootWithoutHydrating(
                      current2,
                      workInProgress2,
                      returnFiber,
                      renderLanes2
                    );
                    break a;
                  } else if (returnFiber !== prevSibling) {
                    prevSibling = createCapturedValueAtFiber(
                      Error(
                        "This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."
                      ),
                      workInProgress2
                    );
                    queueHydrationError(prevSibling);
                    workInProgress2 = mountHostRootWithoutHydrating(
                      current2,
                      workInProgress2,
                      returnFiber,
                      renderLanes2
                    );
                    break a;
                  } else {
                    current2 = workInProgress2.stateNode.containerInfo;
                    switch (current2.nodeType) {
                      case 9:
                        current2 = current2.body;
                        break;
                      default:
                        current2 = "HTML" === current2.nodeName ? current2.ownerDocument.body : current2;
                    }
                    nextHydratableInstance = getNextHydratable(current2.firstChild);
                    hydrationParentFiber = workInProgress2;
                    isHydrating = true;
                    hydrationErrors = null;
                    didSuspendOrErrorDEV = false;
                    hydrationDiffRootDEV = null;
                    rootOrSingletonContext = true;
                    renderLanes2 = mountChildFibers(
                      workInProgress2,
                      null,
                      returnFiber,
                      renderLanes2
                    );
                    for (workInProgress2.child = renderLanes2; renderLanes2; )
                      renderLanes2.flags = renderLanes2.flags & -3 | 4096, renderLanes2 = renderLanes2.sibling;
                  }
                else {
                  resetHydrationState();
                  if (returnFiber === prevSibling) {
                    workInProgress2 = bailoutOnAlreadyFinishedWork(
                      current2,
                      workInProgress2,
                      renderLanes2
                    );
                    break a;
                  }
                  reconcileChildren(
                    current2,
                    workInProgress2,
                    returnFiber,
                    renderLanes2
                  );
                }
                workInProgress2 = workInProgress2.child;
              }
              return workInProgress2;
            case 26:
              return markRef(current2, workInProgress2), null === current2 ? (renderLanes2 = getResource(
                workInProgress2.type,
                null,
                workInProgress2.pendingProps,
                null
              )) ? workInProgress2.memoizedState = renderLanes2 : isHydrating || (renderLanes2 = workInProgress2.type, current2 = workInProgress2.pendingProps, returnFiber = requiredContext(
                rootInstanceStackCursor.current
              ), returnFiber = getOwnerDocumentFromRootContainer(
                returnFiber
              ).createElement(renderLanes2), returnFiber[internalInstanceKey] = workInProgress2, returnFiber[internalPropsKey] = current2, setInitialProperties(returnFiber, renderLanes2, current2), markNodeAsHoistable(returnFiber), workInProgress2.stateNode = returnFiber) : workInProgress2.memoizedState = getResource(
                workInProgress2.type,
                current2.memoizedProps,
                workInProgress2.pendingProps,
                current2.memoizedState
              ), null;
            case 27:
              return pushHostContext(workInProgress2), null === current2 && isHydrating && (returnFiber = requiredContext(rootInstanceStackCursor.current), prevSibling = getHostContext(), returnFiber = workInProgress2.stateNode = resolveSingletonInstance(
                workInProgress2.type,
                workInProgress2.pendingProps,
                returnFiber,
                prevSibling,
                false
              ), didSuspendOrErrorDEV || (prevSibling = diffHydratedProperties(
                returnFiber,
                workInProgress2.type,
                workInProgress2.pendingProps,
                prevSibling
              ), null !== prevSibling && (buildHydrationDiffNode(workInProgress2, 0).serverProps = prevSibling)), hydrationParentFiber = workInProgress2, rootOrSingletonContext = true, prevSibling = nextHydratableInstance, isSingletonScope(workInProgress2.type) ? (previousHydratableOnEnteringScopedSingleton = prevSibling, nextHydratableInstance = getNextHydratable(
                returnFiber.firstChild
              )) : nextHydratableInstance = prevSibling), reconcileChildren(
                current2,
                workInProgress2,
                workInProgress2.pendingProps.children,
                renderLanes2
              ), markRef(current2, workInProgress2), null === current2 && (workInProgress2.flags |= 4194304), workInProgress2.child;
            case 5:
              return null === current2 && isHydrating && (prevState = getHostContext(), returnFiber = validateDOMNesting(
                workInProgress2.type,
                prevState.ancestorInfo
              ), prevSibling = nextHydratableInstance, (nextState = !prevSibling) || (nextState = canHydrateInstance(
                prevSibling,
                workInProgress2.type,
                workInProgress2.pendingProps,
                rootOrSingletonContext
              ), null !== nextState ? (workInProgress2.stateNode = nextState, didSuspendOrErrorDEV || (prevState = diffHydratedProperties(
                nextState,
                workInProgress2.type,
                workInProgress2.pendingProps,
                prevState
              ), null !== prevState && (buildHydrationDiffNode(workInProgress2, 0).serverProps = prevState)), hydrationParentFiber = workInProgress2, nextHydratableInstance = getNextHydratable(
                nextState.firstChild
              ), rootOrSingletonContext = false, prevState = true) : prevState = false, nextState = !prevState), nextState && (returnFiber && warnNonHydratedInstance(workInProgress2, prevSibling), throwOnHydrationMismatch(workInProgress2))), pushHostContext(workInProgress2), prevSibling = workInProgress2.type, prevState = workInProgress2.pendingProps, nextState = null !== current2 ? current2.memoizedProps : null, returnFiber = prevState.children, shouldSetTextContent(prevSibling, prevState) ? returnFiber = null : null !== nextState && shouldSetTextContent(prevSibling, nextState) && (workInProgress2.flags |= 32), null !== workInProgress2.memoizedState && (prevSibling = renderWithHooks(
                current2,
                workInProgress2,
                TransitionAwareHostComponent,
                null,
                null,
                renderLanes2
              ), HostTransitionContext._currentValue = prevSibling), markRef(current2, workInProgress2), reconcileChildren(
                current2,
                workInProgress2,
                returnFiber,
                renderLanes2
              ), workInProgress2.child;
            case 6:
              return null === current2 && isHydrating && (renderLanes2 = workInProgress2.pendingProps, current2 = getHostContext(), returnFiber = current2.ancestorInfo.current, renderLanes2 = null != returnFiber ? validateTextNesting(
                renderLanes2,
                returnFiber.tag,
                current2.ancestorInfo.implicitRootScope
              ) : true, current2 = nextHydratableInstance, (returnFiber = !current2) || (returnFiber = canHydrateTextInstance(
                current2,
                workInProgress2.pendingProps,
                rootOrSingletonContext
              ), null !== returnFiber ? (workInProgress2.stateNode = returnFiber, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, returnFiber = true) : returnFiber = false, returnFiber = !returnFiber), returnFiber && (renderLanes2 && warnNonHydratedInstance(workInProgress2, current2), throwOnHydrationMismatch(workInProgress2))), null;
            case 13:
              return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
            case 4:
              return pushHostContainer(
                workInProgress2,
                workInProgress2.stateNode.containerInfo
              ), returnFiber = workInProgress2.pendingProps, null === current2 ? workInProgress2.child = reconcileChildFibers(
                workInProgress2,
                null,
                returnFiber,
                renderLanes2
              ) : reconcileChildren(
                current2,
                workInProgress2,
                returnFiber,
                renderLanes2
              ), workInProgress2.child;
            case 11:
              return updateForwardRef(
                current2,
                workInProgress2,
                workInProgress2.type,
                workInProgress2.pendingProps,
                renderLanes2
              );
            case 7:
              return reconcileChildren(
                current2,
                workInProgress2,
                workInProgress2.pendingProps,
                renderLanes2
              ), workInProgress2.child;
            case 8:
              return reconcileChildren(
                current2,
                workInProgress2,
                workInProgress2.pendingProps.children,
                renderLanes2
              ), workInProgress2.child;
            case 12:
              return workInProgress2.flags |= 4, workInProgress2.flags |= 2048, returnFiber = workInProgress2.stateNode, returnFiber.effectDuration = -0, returnFiber.passiveEffectDuration = -0, reconcileChildren(
                current2,
                workInProgress2,
                workInProgress2.pendingProps.children,
                renderLanes2
              ), workInProgress2.child;
            case 10:
              return returnFiber = workInProgress2.type, prevSibling = workInProgress2.pendingProps, prevState = prevSibling.value, "value" in prevSibling || hasWarnedAboutUsingNoValuePropOnContextProvider || (hasWarnedAboutUsingNoValuePropOnContextProvider = true, console.error(
                "The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"
              )), pushProvider(workInProgress2, returnFiber, prevState), reconcileChildren(
                current2,
                workInProgress2,
                prevSibling.children,
                renderLanes2
              ), workInProgress2.child;
            case 9:
              return prevSibling = workInProgress2.type._context, returnFiber = workInProgress2.pendingProps.children, "function" !== typeof returnFiber && console.error(
                "A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."
              ), prepareToReadContext(workInProgress2), prevSibling = readContext(prevSibling), returnFiber = callComponentInDEV(
                returnFiber,
                prevSibling,
                void 0
              ), workInProgress2.flags |= 1, reconcileChildren(
                current2,
                workInProgress2,
                returnFiber,
                renderLanes2
              ), workInProgress2.child;
            case 14:
              return updateMemoComponent(
                current2,
                workInProgress2,
                workInProgress2.type,
                workInProgress2.pendingProps,
                renderLanes2
              );
            case 15:
              return updateSimpleMemoComponent(
                current2,
                workInProgress2,
                workInProgress2.type,
                workInProgress2.pendingProps,
                renderLanes2
              );
            case 19:
              return updateSuspenseListComponent(
                current2,
                workInProgress2,
                renderLanes2
              );
            case 31:
              return updateActivityComponent(current2, workInProgress2, renderLanes2);
            case 22:
              return updateOffscreenComponent(
                current2,
                workInProgress2,
                renderLanes2,
                workInProgress2.pendingProps
              );
            case 24:
              return prepareToReadContext(workInProgress2), returnFiber = readContext(CacheContext), null === current2 ? (prevSibling = peekCacheFromPool(), null === prevSibling && (prevSibling = workInProgressRoot, prevState = createCache(), prevSibling.pooledCache = prevState, retainCache(prevState), null !== prevState && (prevSibling.pooledCacheLanes |= renderLanes2), prevSibling = prevState), workInProgress2.memoizedState = {
                parent: returnFiber,
                cache: prevSibling
              }, initializeUpdateQueue(workInProgress2), pushProvider(workInProgress2, CacheContext, prevSibling)) : (0 !== (current2.lanes & renderLanes2) && (cloneUpdateQueue(current2, workInProgress2), processUpdateQueue(workInProgress2, null, null, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction()), prevSibling = current2.memoizedState, prevState = workInProgress2.memoizedState, prevSibling.parent !== returnFiber ? (prevSibling = {
                parent: returnFiber,
                cache: returnFiber
              }, workInProgress2.memoizedState = prevSibling, 0 === workInProgress2.lanes && (workInProgress2.memoizedState = workInProgress2.updateQueue.baseState = prevSibling), pushProvider(workInProgress2, CacheContext, returnFiber)) : (returnFiber = prevState.cache, pushProvider(workInProgress2, CacheContext, returnFiber), returnFiber !== prevSibling.cache && propagateContextChanges(
                workInProgress2,
                [CacheContext],
                renderLanes2,
                true
              ))), reconcileChildren(
                current2,
                workInProgress2,
                workInProgress2.pendingProps.children,
                renderLanes2
              ), workInProgress2.child;
            case 29:
              throw workInProgress2.pendingProps;
          }
          throw Error(
            "Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue."
          );
        }
        function markUpdate(workInProgress2) {
          workInProgress2.flags |= 4;
        }
        function preloadInstanceAndSuspendIfNeeded(workInProgress2, type, oldProps, newProps, renderLanes2) {
          if (type = (workInProgress2.mode & SuspenseyImagesMode) !== NoMode)
            type = false;
          if (type) {
            if (workInProgress2.flags |= 16777216, (renderLanes2 & 335544128) === renderLanes2)
              if (workInProgress2.stateNode.complete) workInProgress2.flags |= 8192;
              else if (shouldRemainOnPreviousScreen()) workInProgress2.flags |= 8192;
              else
                throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
          } else workInProgress2.flags &= -16777217;
        }
        function preloadResourceAndSuspendIfNeeded(workInProgress2, resource) {
          if ("stylesheet" !== resource.type || (resource.state.loading & Inserted) !== NotLoaded)
            workInProgress2.flags &= -16777217;
          else if (workInProgress2.flags |= 16777216, !preloadResource(resource))
            if (shouldRemainOnPreviousScreen()) workInProgress2.flags |= 8192;
            else
              throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
        }
        function scheduleRetryEffect(workInProgress2, retryQueue) {
          null !== retryQueue && (workInProgress2.flags |= 4);
          workInProgress2.flags & 16384 && (retryQueue = 22 !== workInProgress2.tag ? claimNextRetryLane() : 536870912, workInProgress2.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
        }
        function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
          if (!isHydrating)
            switch (renderState.tailMode) {
              case "hidden":
                hasRenderedATailFallback = renderState.tail;
                for (var lastTailNode = null; null !== hasRenderedATailFallback; )
                  null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
                null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
                break;
              case "collapsed":
                lastTailNode = renderState.tail;
                for (var _lastTailNode = null; null !== lastTailNode; )
                  null !== lastTailNode.alternate && (_lastTailNode = lastTailNode), lastTailNode = lastTailNode.sibling;
                null === _lastTailNode ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : _lastTailNode.sibling = null;
            }
        }
        function bubbleProperties(completedWork) {
          var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;
          if (didBailout)
            if ((completedWork.mode & ProfileMode) !== NoMode) {
              for (var _treeBaseDuration = completedWork.selfBaseDuration, _child2 = completedWork.child; null !== _child2; )
                newChildLanes |= _child2.lanes | _child2.childLanes, subtreeFlags |= _child2.subtreeFlags & 65011712, subtreeFlags |= _child2.flags & 65011712, _treeBaseDuration += _child2.treeBaseDuration, _child2 = _child2.sibling;
              completedWork.treeBaseDuration = _treeBaseDuration;
            } else
              for (_treeBaseDuration = completedWork.child; null !== _treeBaseDuration; )
                newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags & 65011712, subtreeFlags |= _treeBaseDuration.flags & 65011712, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;
          else if ((completedWork.mode & ProfileMode) !== NoMode) {
            _treeBaseDuration = completedWork.actualDuration;
            _child2 = completedWork.selfBaseDuration;
            for (var child = completedWork.child; null !== child; )
              newChildLanes |= child.lanes | child.childLanes, subtreeFlags |= child.subtreeFlags, subtreeFlags |= child.flags, _treeBaseDuration += child.actualDuration, _child2 += child.treeBaseDuration, child = child.sibling;
            completedWork.actualDuration = _treeBaseDuration;
            completedWork.treeBaseDuration = _child2;
          } else
            for (_treeBaseDuration = completedWork.child; null !== _treeBaseDuration; )
              newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags, subtreeFlags |= _treeBaseDuration.flags, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;
          completedWork.subtreeFlags |= subtreeFlags;
          completedWork.childLanes = newChildLanes;
          return didBailout;
        }
        function completeWork(current2, workInProgress2, renderLanes2) {
          var newProps = workInProgress2.pendingProps;
          popTreeContext(workInProgress2);
          switch (workInProgress2.tag) {
            case 16:
            case 15:
            case 0:
            case 11:
            case 7:
            case 8:
            case 12:
            case 9:
            case 14:
              return bubbleProperties(workInProgress2), null;
            case 1:
              return bubbleProperties(workInProgress2), null;
            case 3:
              renderLanes2 = workInProgress2.stateNode;
              newProps = null;
              null !== current2 && (newProps = current2.memoizedState.cache);
              workInProgress2.memoizedState.cache !== newProps && (workInProgress2.flags |= 2048);
              popProvider(CacheContext, workInProgress2);
              popHostContainer(workInProgress2);
              renderLanes2.pendingContext && (renderLanes2.context = renderLanes2.pendingContext, renderLanes2.pendingContext = null);
              if (null === current2 || null === current2.child)
                popHydrationState(workInProgress2) ? (emitPendingHydrationWarnings(), markUpdate(workInProgress2)) : null === current2 || current2.memoizedState.isDehydrated && 0 === (workInProgress2.flags & 256) || (workInProgress2.flags |= 1024, upgradeHydrationErrorsToRecoverable());
              bubbleProperties(workInProgress2);
              return null;
            case 26:
              var type = workInProgress2.type, nextResource = workInProgress2.memoizedState;
              null === current2 ? (markUpdate(workInProgress2), null !== nextResource ? (bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(
                workInProgress2,
                nextResource
              )) : (bubbleProperties(workInProgress2), preloadInstanceAndSuspendIfNeeded(
                workInProgress2,
                type,
                null,
                newProps,
                renderLanes2
              ))) : nextResource ? nextResource !== current2.memoizedState ? (markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(
                workInProgress2,
                nextResource
              )) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217) : (current2 = current2.memoizedProps, current2 !== newProps && markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadInstanceAndSuspendIfNeeded(
                workInProgress2,
                type,
                current2,
                newProps,
                renderLanes2
              ));
              return null;
            case 27:
              popHostContext(workInProgress2);
              renderLanes2 = requiredContext(rootInstanceStackCursor.current);
              type = workInProgress2.type;
              if (null !== current2 && null != workInProgress2.stateNode)
                current2.memoizedProps !== newProps && markUpdate(workInProgress2);
              else {
                if (!newProps) {
                  if (null === workInProgress2.stateNode)
                    throw Error(
                      "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                    );
                  bubbleProperties(workInProgress2);
                  return null;
                }
                current2 = getHostContext();
                popHydrationState(workInProgress2) ? prepareToHydrateHostInstance(workInProgress2, current2) : (current2 = resolveSingletonInstance(
                  type,
                  newProps,
                  renderLanes2,
                  current2,
                  true
                ), workInProgress2.stateNode = current2, markUpdate(workInProgress2));
              }
              bubbleProperties(workInProgress2);
              return null;
            case 5:
              popHostContext(workInProgress2);
              type = workInProgress2.type;
              if (null !== current2 && null != workInProgress2.stateNode)
                current2.memoizedProps !== newProps && markUpdate(workInProgress2);
              else {
                if (!newProps) {
                  if (null === workInProgress2.stateNode)
                    throw Error(
                      "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                    );
                  bubbleProperties(workInProgress2);
                  return null;
                }
                var _currentHostContext = getHostContext();
                if (popHydrationState(workInProgress2))
                  prepareToHydrateHostInstance(workInProgress2, _currentHostContext);
                else {
                  nextResource = requiredContext(rootInstanceStackCursor.current);
                  validateDOMNesting(type, _currentHostContext.ancestorInfo);
                  _currentHostContext = _currentHostContext.context;
                  nextResource = getOwnerDocumentFromRootContainer(nextResource);
                  switch (_currentHostContext) {
                    case HostContextNamespaceSvg:
                      nextResource = nextResource.createElementNS(
                        SVG_NAMESPACE,
                        type
                      );
                      break;
                    case HostContextNamespaceMath:
                      nextResource = nextResource.createElementNS(
                        MATH_NAMESPACE,
                        type
                      );
                      break;
                    default:
                      switch (type) {
                        case "svg":
                          nextResource = nextResource.createElementNS(
                            SVG_NAMESPACE,
                            type
                          );
                          break;
                        case "math":
                          nextResource = nextResource.createElementNS(
                            MATH_NAMESPACE,
                            type
                          );
                          break;
                        case "script":
                          nextResource = nextResource.createElement("div");
                          nextResource.innerHTML = "<script><\/script>";
                          nextResource = nextResource.removeChild(
                            nextResource.firstChild
                          );
                          break;
                        case "select":
                          nextResource = "string" === typeof newProps.is ? nextResource.createElement("select", {
                            is: newProps.is
                          }) : nextResource.createElement("select");
                          newProps.multiple ? nextResource.multiple = true : newProps.size && (nextResource.size = newProps.size);
                          break;
                        default:
                          nextResource = "string" === typeof newProps.is ? nextResource.createElement(type, {
                            is: newProps.is
                          }) : nextResource.createElement(type), -1 === type.indexOf("-") && (type !== type.toLowerCase() && console.error(
                            "<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.",
                            type
                          ), "[object HTMLUnknownElement]" !== Object.prototype.toString.call(nextResource) || hasOwnProperty.call(warnedUnknownTags, type) || (warnedUnknownTags[type] = true, console.error(
                            "The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.",
                            type
                          )));
                      }
                  }
                  nextResource[internalInstanceKey] = workInProgress2;
                  nextResource[internalPropsKey] = newProps;
                  a: for (_currentHostContext = workInProgress2.child; null !== _currentHostContext; ) {
                    if (5 === _currentHostContext.tag || 6 === _currentHostContext.tag)
                      nextResource.appendChild(_currentHostContext.stateNode);
                    else if (4 !== _currentHostContext.tag && 27 !== _currentHostContext.tag && null !== _currentHostContext.child) {
                      _currentHostContext.child.return = _currentHostContext;
                      _currentHostContext = _currentHostContext.child;
                      continue;
                    }
                    if (_currentHostContext === workInProgress2) break a;
                    for (; null === _currentHostContext.sibling; ) {
                      if (null === _currentHostContext.return || _currentHostContext.return === workInProgress2)
                        break a;
                      _currentHostContext = _currentHostContext.return;
                    }
                    _currentHostContext.sibling.return = _currentHostContext.return;
                    _currentHostContext = _currentHostContext.sibling;
                  }
                  workInProgress2.stateNode = nextResource;
                  a: switch (setInitialProperties(nextResource, type, newProps), type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      newProps = !!newProps.autoFocus;
                      break a;
                    case "img":
                      newProps = true;
                      break a;
                    default:
                      newProps = false;
                  }
                  newProps && markUpdate(workInProgress2);
                }
              }
              bubbleProperties(workInProgress2);
              preloadInstanceAndSuspendIfNeeded(
                workInProgress2,
                workInProgress2.type,
                null === current2 ? null : current2.memoizedProps,
                workInProgress2.pendingProps,
                renderLanes2
              );
              return null;
            case 6:
              if (current2 && null != workInProgress2.stateNode)
                current2.memoizedProps !== newProps && markUpdate(workInProgress2);
              else {
                if ("string" !== typeof newProps && null === workInProgress2.stateNode)
                  throw Error(
                    "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                  );
                current2 = requiredContext(rootInstanceStackCursor.current);
                renderLanes2 = getHostContext();
                if (popHydrationState(workInProgress2)) {
                  current2 = workInProgress2.stateNode;
                  renderLanes2 = workInProgress2.memoizedProps;
                  type = !didSuspendOrErrorDEV;
                  newProps = null;
                  nextResource = hydrationParentFiber;
                  if (null !== nextResource)
                    switch (nextResource.tag) {
                      case 3:
                        type && (type = diffHydratedTextForDevWarnings(
                          current2,
                          renderLanes2,
                          newProps
                        ), null !== type && (buildHydrationDiffNode(workInProgress2, 0).serverProps = type));
                        break;
                      case 27:
                      case 5:
                        newProps = nextResource.memoizedProps, type && (type = diffHydratedTextForDevWarnings(
                          current2,
                          renderLanes2,
                          newProps
                        ), null !== type && (buildHydrationDiffNode(
                          workInProgress2,
                          0
                        ).serverProps = type));
                    }
                  current2[internalInstanceKey] = workInProgress2;
                  current2 = current2.nodeValue === renderLanes2 || null !== newProps && true === newProps.suppressHydrationWarning || checkForUnmatchedText(current2.nodeValue, renderLanes2) ? true : false;
                  current2 || throwOnHydrationMismatch(workInProgress2, true);
                } else
                  type = renderLanes2.ancestorInfo.current, null != type && validateTextNesting(
                    newProps,
                    type.tag,
                    renderLanes2.ancestorInfo.implicitRootScope
                  ), current2 = getOwnerDocumentFromRootContainer(current2).createTextNode(
                    newProps
                  ), current2[internalInstanceKey] = workInProgress2, workInProgress2.stateNode = current2;
              }
              bubbleProperties(workInProgress2);
              return null;
            case 31:
              renderLanes2 = workInProgress2.memoizedState;
              if (null === current2 || null !== current2.memoizedState) {
                newProps = popHydrationState(workInProgress2);
                if (null !== renderLanes2) {
                  if (null === current2) {
                    if (!newProps)
                      throw Error(
                        "A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React."
                      );
                    current2 = workInProgress2.memoizedState;
                    current2 = null !== current2 ? current2.dehydrated : null;
                    if (!current2)
                      throw Error(
                        "Expected to have a hydrated activity instance. This error is likely caused by a bug in React. Please file an issue."
                      );
                    current2[internalInstanceKey] = workInProgress2;
                    bubbleProperties(workInProgress2);
                    (workInProgress2.mode & ProfileMode) !== NoMode && null !== renderLanes2 && (current2 = workInProgress2.child, null !== current2 && (workInProgress2.treeBaseDuration -= current2.treeBaseDuration));
                  } else
                    emitPendingHydrationWarnings(), resetHydrationState(), 0 === (workInProgress2.flags & 128) && (renderLanes2 = workInProgress2.memoizedState = null), workInProgress2.flags |= 4, bubbleProperties(workInProgress2), (workInProgress2.mode & ProfileMode) !== NoMode && null !== renderLanes2 && (current2 = workInProgress2.child, null !== current2 && (workInProgress2.treeBaseDuration -= current2.treeBaseDuration));
                  current2 = false;
                } else
                  renderLanes2 = upgradeHydrationErrorsToRecoverable(), null !== current2 && null !== current2.memoizedState && (current2.memoizedState.hydrationErrors = renderLanes2), current2 = true;
                if (!current2) {
                  if (workInProgress2.flags & 256)
                    return popSuspenseHandler(workInProgress2), workInProgress2;
                  popSuspenseHandler(workInProgress2);
                  return null;
                }
                if (0 !== (workInProgress2.flags & 128))
                  throw Error(
                    "Client rendering an Activity suspended it again. This is a bug in React."
                  );
              }
              bubbleProperties(workInProgress2);
              return null;
            case 13:
              newProps = workInProgress2.memoizedState;
              if (null === current2 || null !== current2.memoizedState && null !== current2.memoizedState.dehydrated) {
                type = newProps;
                nextResource = popHydrationState(workInProgress2);
                if (null !== type && null !== type.dehydrated) {
                  if (null === current2) {
                    if (!nextResource)
                      throw Error(
                        "A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React."
                      );
                    nextResource = workInProgress2.memoizedState;
                    nextResource = null !== nextResource ? nextResource.dehydrated : null;
                    if (!nextResource)
                      throw Error(
                        "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
                      );
                    nextResource[internalInstanceKey] = workInProgress2;
                    bubbleProperties(workInProgress2);
                    (workInProgress2.mode & ProfileMode) !== NoMode && null !== type && (type = workInProgress2.child, null !== type && (workInProgress2.treeBaseDuration -= type.treeBaseDuration));
                  } else
                    emitPendingHydrationWarnings(), resetHydrationState(), 0 === (workInProgress2.flags & 128) && (type = workInProgress2.memoizedState = null), workInProgress2.flags |= 4, bubbleProperties(workInProgress2), (workInProgress2.mode & ProfileMode) !== NoMode && null !== type && (type = workInProgress2.child, null !== type && (workInProgress2.treeBaseDuration -= type.treeBaseDuration));
                  type = false;
                } else
                  type = upgradeHydrationErrorsToRecoverable(), null !== current2 && null !== current2.memoizedState && (current2.memoizedState.hydrationErrors = type), type = true;
                if (!type) {
                  if (workInProgress2.flags & 256)
                    return popSuspenseHandler(workInProgress2), workInProgress2;
                  popSuspenseHandler(workInProgress2);
                  return null;
                }
              }
              popSuspenseHandler(workInProgress2);
              if (0 !== (workInProgress2.flags & 128))
                return workInProgress2.lanes = renderLanes2, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2;
              renderLanes2 = null !== newProps;
              current2 = null !== current2 && null !== current2.memoizedState;
              renderLanes2 && (newProps = workInProgress2.child, type = null, null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (type = newProps.alternate.memoizedState.cachePool.pool), nextResource = null, null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (nextResource = newProps.memoizedState.cachePool.pool), nextResource !== type && (newProps.flags |= 2048));
              renderLanes2 !== current2 && renderLanes2 && (workInProgress2.child.flags |= 8192);
              scheduleRetryEffect(workInProgress2, workInProgress2.updateQueue);
              bubbleProperties(workInProgress2);
              (workInProgress2.mode & ProfileMode) !== NoMode && renderLanes2 && (current2 = workInProgress2.child, null !== current2 && (workInProgress2.treeBaseDuration -= current2.treeBaseDuration));
              return null;
            case 4:
              return popHostContainer(workInProgress2), null === current2 && listenToAllSupportedEvents(
                workInProgress2.stateNode.containerInfo
              ), bubbleProperties(workInProgress2), null;
            case 10:
              return popProvider(workInProgress2.type, workInProgress2), bubbleProperties(workInProgress2), null;
            case 19:
              pop(suspenseStackCursor, workInProgress2);
              newProps = workInProgress2.memoizedState;
              if (null === newProps) return bubbleProperties(workInProgress2), null;
              type = 0 !== (workInProgress2.flags & 128);
              nextResource = newProps.rendering;
              if (null === nextResource)
                if (type) cutOffTailIfNeeded(newProps, false);
                else {
                  if (workInProgressRootExitStatus !== RootInProgress || null !== current2 && 0 !== (current2.flags & 128))
                    for (current2 = workInProgress2.child; null !== current2; ) {
                      nextResource = findFirstSuspended(current2);
                      if (null !== nextResource) {
                        workInProgress2.flags |= 128;
                        cutOffTailIfNeeded(newProps, false);
                        current2 = nextResource.updateQueue;
                        workInProgress2.updateQueue = current2;
                        scheduleRetryEffect(workInProgress2, current2);
                        workInProgress2.subtreeFlags = 0;
                        current2 = renderLanes2;
                        for (renderLanes2 = workInProgress2.child; null !== renderLanes2; )
                          resetWorkInProgress(renderLanes2, current2), renderLanes2 = renderLanes2.sibling;
                        push(
                          suspenseStackCursor,
                          suspenseStackCursor.current & SubtreeSuspenseContextMask | ForceSuspenseFallback,
                          workInProgress2
                        );
                        isHydrating && pushTreeFork(workInProgress2, newProps.treeForkCount);
                        return workInProgress2.child;
                      }
                      current2 = current2.sibling;
                    }
                  null !== newProps.tail && now$1() > workInProgressRootRenderTargetTime && (workInProgress2.flags |= 128, type = true, cutOffTailIfNeeded(newProps, false), workInProgress2.lanes = 4194304);
                }
              else {
                if (!type)
                  if (current2 = findFirstSuspended(nextResource), null !== current2) {
                    if (workInProgress2.flags |= 128, type = true, current2 = current2.updateQueue, workInProgress2.updateQueue = current2, scheduleRetryEffect(workInProgress2, current2), cutOffTailIfNeeded(newProps, true), null === newProps.tail && "hidden" === newProps.tailMode && !nextResource.alternate && !isHydrating)
                      return bubbleProperties(workInProgress2), null;
                  } else
                    2 * now$1() - newProps.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes2 && (workInProgress2.flags |= 128, type = true, cutOffTailIfNeeded(newProps, false), workInProgress2.lanes = 4194304);
                newProps.isBackwards ? (nextResource.sibling = workInProgress2.child, workInProgress2.child = nextResource) : (current2 = newProps.last, null !== current2 ? current2.sibling = nextResource : workInProgress2.child = nextResource, newProps.last = nextResource);
              }
              if (null !== newProps.tail)
                return current2 = newProps.tail, newProps.rendering = current2, newProps.tail = current2.sibling, newProps.renderingStartTime = now$1(), current2.sibling = null, renderLanes2 = suspenseStackCursor.current, renderLanes2 = type ? renderLanes2 & SubtreeSuspenseContextMask | ForceSuspenseFallback : renderLanes2 & SubtreeSuspenseContextMask, push(suspenseStackCursor, renderLanes2, workInProgress2), isHydrating && pushTreeFork(workInProgress2, newProps.treeForkCount), current2;
              bubbleProperties(workInProgress2);
              return null;
            case 22:
            case 23:
              return popSuspenseHandler(workInProgress2), popHiddenContext(workInProgress2), newProps = null !== workInProgress2.memoizedState, null !== current2 ? null !== current2.memoizedState !== newProps && (workInProgress2.flags |= 8192) : newProps && (workInProgress2.flags |= 8192), newProps ? 0 !== (renderLanes2 & 536870912) && 0 === (workInProgress2.flags & 128) && (bubbleProperties(workInProgress2), workInProgress2.subtreeFlags & 6 && (workInProgress2.flags |= 8192)) : bubbleProperties(workInProgress2), renderLanes2 = workInProgress2.updateQueue, null !== renderLanes2 && scheduleRetryEffect(workInProgress2, renderLanes2.retryQueue), renderLanes2 = null, null !== current2 && null !== current2.memoizedState && null !== current2.memoizedState.cachePool && (renderLanes2 = current2.memoizedState.cachePool.pool), newProps = null, null !== workInProgress2.memoizedState && null !== workInProgress2.memoizedState.cachePool && (newProps = workInProgress2.memoizedState.cachePool.pool), newProps !== renderLanes2 && (workInProgress2.flags |= 2048), null !== current2 && pop(resumedCache, workInProgress2), null;
            case 24:
              return renderLanes2 = null, null !== current2 && (renderLanes2 = current2.memoizedState.cache), workInProgress2.memoizedState.cache !== renderLanes2 && (workInProgress2.flags |= 2048), popProvider(CacheContext, workInProgress2), bubbleProperties(workInProgress2), null;
            case 25:
              return null;
            case 30:
              return null;
          }
          throw Error(
            "Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue."
          );
        }
        function unwindWork(current2, workInProgress2) {
          popTreeContext(workInProgress2);
          switch (workInProgress2.tag) {
            case 1:
              return current2 = workInProgress2.flags, current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
            case 3:
              return popProvider(CacheContext, workInProgress2), popHostContainer(workInProgress2), current2 = workInProgress2.flags, 0 !== (current2 & 65536) && 0 === (current2 & 128) ? (workInProgress2.flags = current2 & -65537 | 128, workInProgress2) : null;
            case 26:
            case 27:
            case 5:
              return popHostContext(workInProgress2), null;
            case 31:
              if (null !== workInProgress2.memoizedState) {
                popSuspenseHandler(workInProgress2);
                if (null === workInProgress2.alternate)
                  throw Error(
                    "Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue."
                  );
                resetHydrationState();
              }
              current2 = workInProgress2.flags;
              return current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
            case 13:
              popSuspenseHandler(workInProgress2);
              current2 = workInProgress2.memoizedState;
              if (null !== current2 && null !== current2.dehydrated) {
                if (null === workInProgress2.alternate)
                  throw Error(
                    "Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue."
                  );
                resetHydrationState();
              }
              current2 = workInProgress2.flags;
              return current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
            case 19:
              return pop(suspenseStackCursor, workInProgress2), null;
            case 4:
              return popHostContainer(workInProgress2), null;
            case 10:
              return popProvider(workInProgress2.type, workInProgress2), null;
            case 22:
            case 23:
              return popSuspenseHandler(workInProgress2), popHiddenContext(workInProgress2), null !== current2 && pop(resumedCache, workInProgress2), current2 = workInProgress2.flags, current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
            case 24:
              return popProvider(CacheContext, workInProgress2), null;
            case 25:
              return null;
            default:
              return null;
          }
        }
        function unwindInterruptedWork(current2, interruptedWork) {
          popTreeContext(interruptedWork);
          switch (interruptedWork.tag) {
            case 3:
              popProvider(CacheContext, interruptedWork);
              popHostContainer(interruptedWork);
              break;
            case 26:
            case 27:
            case 5:
              popHostContext(interruptedWork);
              break;
            case 4:
              popHostContainer(interruptedWork);
              break;
            case 31:
              null !== interruptedWork.memoizedState && popSuspenseHandler(interruptedWork);
              break;
            case 13:
              popSuspenseHandler(interruptedWork);
              break;
            case 19:
              pop(suspenseStackCursor, interruptedWork);
              break;
            case 10:
              popProvider(interruptedWork.type, interruptedWork);
              break;
            case 22:
            case 23:
              popSuspenseHandler(interruptedWork);
              popHiddenContext(interruptedWork);
              null !== current2 && pop(resumedCache, interruptedWork);
              break;
            case 24:
              popProvider(CacheContext, interruptedWork);
          }
        }
        function shouldProfile(current2) {
          return (current2.mode & ProfileMode) !== NoMode;
        }
        function commitHookLayoutEffects(finishedWork, hookFlags) {
          shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);
        }
        function commitHookLayoutUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
          shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          ), recordEffectDuration()) : commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          );
        }
        function commitHookEffectListMount(flags, finishedWork) {
          try {
            var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
            if (null !== lastEffect) {
              var firstEffect = lastEffect.next;
              updateQueue = firstEffect;
              do {
                if ((updateQueue.tag & flags) === flags && (lastEffect = void 0, (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = true), lastEffect = runWithFiberInDEV(
                  finishedWork,
                  callCreateInDEV,
                  updateQueue
                ), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = false), void 0 !== lastEffect && "function" !== typeof lastEffect)) {
                  var hookName = void 0;
                  hookName = 0 !== (updateQueue.tag & Layout) ? "useLayoutEffect" : 0 !== (updateQueue.tag & Insertion) ? "useInsertionEffect" : "useEffect";
                  var addendum = void 0;
                  addendum = null === lastEffect ? " You returned null. If your effect does not require clean up, return undefined (or nothing)." : "function" === typeof lastEffect.then ? "\n\nIt looks like you wrote " + hookName + "(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n" + hookName + "(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching" : " You returned: " + lastEffect;
                  runWithFiberInDEV(
                    finishedWork,
                    function(n5, a5) {
                      console.error(
                        "%s must not return anything besides a function, which is used for clean-up.%s",
                        n5,
                        a5
                      );
                    },
                    hookName,
                    addendum
                  );
                }
                updateQueue = updateQueue.next;
              } while (updateQueue !== firstEffect);
            }
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {
          try {
            var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
            if (null !== lastEffect) {
              var firstEffect = lastEffect.next;
              updateQueue = firstEffect;
              do {
                if ((updateQueue.tag & flags) === flags) {
                  var inst = updateQueue.inst, destroy = inst.destroy;
                  void 0 !== destroy && (inst.destroy = void 0, (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = true), lastEffect = finishedWork, runWithFiberInDEV(
                    lastEffect,
                    callDestroyInDEV,
                    lastEffect,
                    nearestMountedAncestor,
                    destroy
                  ), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = false));
                }
                updateQueue = updateQueue.next;
              } while (updateQueue !== firstEffect);
            }
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function commitHookPassiveMountEffects(finishedWork, hookFlags) {
          shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);
        }
        function commitHookPassiveUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
          shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          ), recordEffectDuration()) : commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          );
        }
        function commitClassCallbacks(finishedWork) {
          var updateQueue = finishedWork.updateQueue;
          if (null !== updateQueue) {
            var instance = finishedWork.stateNode;
            finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (instance.props !== finishedWork.memoizedProps && console.error(
              "Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
              getComponentNameFromFiber(finishedWork) || "instance"
            ), instance.state !== finishedWork.memoizedState && console.error(
              "Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
              getComponentNameFromFiber(finishedWork) || "instance"
            ));
            try {
              runWithFiberInDEV(
                finishedWork,
                commitCallbacks,
                updateQueue,
                instance
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
        }
        function callGetSnapshotBeforeUpdates(instance, prevProps, prevState) {
          return instance.getSnapshotBeforeUpdate(prevProps, prevState);
        }
        function commitClassSnapshot(finishedWork, current2) {
          var prevProps = current2.memoizedProps, prevState = current2.memoizedState;
          current2 = finishedWork.stateNode;
          finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (current2.props !== finishedWork.memoizedProps && console.error(
            "Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
            getComponentNameFromFiber(finishedWork) || "instance"
          ), current2.state !== finishedWork.memoizedState && console.error(
            "Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
            getComponentNameFromFiber(finishedWork) || "instance"
          ));
          try {
            var resolvedPrevProps = resolveClassComponentProps(
              finishedWork.type,
              prevProps
            );
            var snapshot = runWithFiberInDEV(
              finishedWork,
              callGetSnapshotBeforeUpdates,
              current2,
              resolvedPrevProps,
              prevState
            );
            prevProps = didWarnAboutUndefinedSnapshotBeforeUpdate;
            void 0 !== snapshot || prevProps.has(finishedWork.type) || (prevProps.add(finishedWork.type), runWithFiberInDEV(finishedWork, function() {
              console.error(
                "%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.",
                getComponentNameFromFiber(finishedWork)
              );
            }));
            current2.__reactInternalSnapshotBeforeUpdate = snapshot;
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function safelyCallComponentWillUnmount(current2, nearestMountedAncestor, instance) {
          instance.props = resolveClassComponentProps(
            current2.type,
            current2.memoizedProps
          );
          instance.state = current2.memoizedState;
          shouldProfile(current2) ? (startEffectTimer(), runWithFiberInDEV(
            current2,
            callComponentWillUnmountInDEV,
            current2,
            nearestMountedAncestor,
            instance
          ), recordEffectDuration()) : runWithFiberInDEV(
            current2,
            callComponentWillUnmountInDEV,
            current2,
            nearestMountedAncestor,
            instance
          );
        }
        function commitAttachRef(finishedWork) {
          var ref = finishedWork.ref;
          if (null !== ref) {
            switch (finishedWork.tag) {
              case 26:
              case 27:
              case 5:
                var instanceToUse = finishedWork.stateNode;
                break;
              case 30:
                instanceToUse = finishedWork.stateNode;
                break;
              default:
                instanceToUse = finishedWork.stateNode;
            }
            if ("function" === typeof ref)
              if (shouldProfile(finishedWork))
                try {
                  startEffectTimer(), finishedWork.refCleanup = ref(instanceToUse);
                } finally {
                  recordEffectDuration();
                }
              else finishedWork.refCleanup = ref(instanceToUse);
            else
              "string" === typeof ref ? console.error("String refs are no longer supported.") : ref.hasOwnProperty("current") || console.error(
                "Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().",
                getComponentNameFromFiber(finishedWork)
              ), ref.current = instanceToUse;
          }
        }
        function safelyAttachRef(current2, nearestMountedAncestor) {
          try {
            runWithFiberInDEV(current2, commitAttachRef, current2);
          } catch (error) {
            captureCommitPhaseError(current2, nearestMountedAncestor, error);
          }
        }
        function safelyDetachRef(current2, nearestMountedAncestor) {
          var ref = current2.ref, refCleanup = current2.refCleanup;
          if (null !== ref)
            if ("function" === typeof refCleanup)
              try {
                if (shouldProfile(current2))
                  try {
                    startEffectTimer(), runWithFiberInDEV(current2, refCleanup);
                  } finally {
                    recordEffectDuration(current2);
                  }
                else runWithFiberInDEV(current2, refCleanup);
              } catch (error) {
                captureCommitPhaseError(current2, nearestMountedAncestor, error);
              } finally {
                current2.refCleanup = null, current2 = current2.alternate, null != current2 && (current2.refCleanup = null);
              }
            else if ("function" === typeof ref)
              try {
                if (shouldProfile(current2))
                  try {
                    startEffectTimer(), runWithFiberInDEV(current2, ref, null);
                  } finally {
                    recordEffectDuration(current2);
                  }
                else runWithFiberInDEV(current2, ref, null);
              } catch (error$7) {
                captureCommitPhaseError(current2, nearestMountedAncestor, error$7);
              }
            else ref.current = null;
        }
        function commitProfiler(finishedWork, current2, commitStartTime2, effectDuration) {
          var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onCommit = _finishedWork$memoize.onCommit;
          _finishedWork$memoize = _finishedWork$memoize.onRender;
          current2 = null === current2 ? "mount" : "update";
          currentUpdateIsNested && (current2 = "nested-update");
          "function" === typeof _finishedWork$memoize && _finishedWork$memoize(
            id,
            current2,
            finishedWork.actualDuration,
            finishedWork.treeBaseDuration,
            finishedWork.actualStartTime,
            commitStartTime2
          );
          "function" === typeof onCommit && onCommit(id, current2, effectDuration, commitStartTime2);
        }
        function commitProfilerPostCommitImpl(finishedWork, current2, commitStartTime2, passiveEffectDuration) {
          var _finishedWork$memoize2 = finishedWork.memoizedProps;
          finishedWork = _finishedWork$memoize2.id;
          _finishedWork$memoize2 = _finishedWork$memoize2.onPostCommit;
          current2 = null === current2 ? "mount" : "update";
          currentUpdateIsNested && (current2 = "nested-update");
          "function" === typeof _finishedWork$memoize2 && _finishedWork$memoize2(
            finishedWork,
            current2,
            passiveEffectDuration,
            commitStartTime2
          );
        }
        function commitHostMount(finishedWork) {
          var type = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;
          try {
            runWithFiberInDEV(
              finishedWork,
              commitMount,
              instance,
              type,
              props,
              finishedWork
            );
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function commitHostUpdate(finishedWork, newProps, oldProps) {
          try {
            runWithFiberInDEV(
              finishedWork,
              commitUpdate,
              finishedWork.stateNode,
              finishedWork.type,
              oldProps,
              newProps,
              finishedWork
            );
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function isHostParent(fiber) {
          return 5 === fiber.tag || 3 === fiber.tag || 26 === fiber.tag || 27 === fiber.tag && isSingletonScope(fiber.type) || 4 === fiber.tag;
        }
        function getHostSibling(fiber) {
          a: for (; ; ) {
            for (; null === fiber.sibling; ) {
              if (null === fiber.return || isHostParent(fiber.return)) return null;
              fiber = fiber.return;
            }
            fiber.sibling.return = fiber.return;
            for (fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag; ) {
              if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
              if (fiber.flags & 2) continue a;
              if (null === fiber.child || 4 === fiber.tag) continue a;
              else fiber.child.return = fiber, fiber = fiber.child;
            }
            if (!(fiber.flags & 2)) return fiber.stateNode;
          }
        }
        function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
          var tag = node.tag;
          if (5 === tag || 6 === tag)
            node = node.stateNode, before ? (warnForReactChildrenConflict(parent), (9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent).insertBefore(node, before)) : (warnForReactChildrenConflict(parent), before = 9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent, before.appendChild(node), parent = parent._reactRootContainer, null !== parent && void 0 !== parent || null !== before.onclick || (before.onclick = noop$1));
          else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode, before = null), node = node.child, null !== node))
            for (insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node; )
              insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;
        }
        function insertOrAppendPlacementNode(node, before, parent) {
          var tag = node.tag;
          if (5 === tag || 6 === tag)
            node = node.stateNode, before ? parent.insertBefore(node, before) : parent.appendChild(node);
          else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode), node = node.child, null !== node))
            for (insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node; )
              insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
        }
        function commitPlacement(finishedWork) {
          for (var hostParentFiber, parentFiber = finishedWork.return; null !== parentFiber; ) {
            if (isHostParent(parentFiber)) {
              hostParentFiber = parentFiber;
              break;
            }
            parentFiber = parentFiber.return;
          }
          if (null == hostParentFiber)
            throw Error(
              "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
            );
          switch (hostParentFiber.tag) {
            case 27:
              hostParentFiber = hostParentFiber.stateNode;
              parentFiber = getHostSibling(finishedWork);
              insertOrAppendPlacementNode(
                finishedWork,
                parentFiber,
                hostParentFiber
              );
              break;
            case 5:
              parentFiber = hostParentFiber.stateNode;
              hostParentFiber.flags & 32 && (resetTextContent(parentFiber), hostParentFiber.flags &= -33);
              hostParentFiber = getHostSibling(finishedWork);
              insertOrAppendPlacementNode(
                finishedWork,
                hostParentFiber,
                parentFiber
              );
              break;
            case 3:
            case 4:
              hostParentFiber = hostParentFiber.stateNode.containerInfo;
              parentFiber = getHostSibling(finishedWork);
              insertOrAppendPlacementNodeIntoContainer(
                finishedWork,
                parentFiber,
                hostParentFiber
              );
              break;
            default:
              throw Error(
                "Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue."
              );
          }
        }
        function commitHostSingletonAcquisition(finishedWork) {
          var singleton = finishedWork.stateNode, props = finishedWork.memoizedProps;
          try {
            runWithFiberInDEV(
              finishedWork,
              acquireSingletonInstance,
              finishedWork.type,
              props,
              singleton,
              finishedWork
            );
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function isHydratingParent(current2, finishedWork) {
          return 31 === finishedWork.tag ? (finishedWork = finishedWork.memoizedState, null !== current2.memoizedState && null === finishedWork) : 13 === finishedWork.tag ? (current2 = current2.memoizedState, finishedWork = finishedWork.memoizedState, null !== current2 && null !== current2.dehydrated && (null === finishedWork || null === finishedWork.dehydrated)) : 3 === finishedWork.tag ? current2.memoizedState.isDehydrated && 0 === (finishedWork.flags & 256) : false;
        }
        function commitBeforeMutationEffects(root2, firstChild) {
          root2 = root2.containerInfo;
          eventsEnabled = _enabled;
          root2 = getActiveElementDeep(root2);
          if (hasSelectionCapabilities(root2)) {
            if ("selectionStart" in root2)
              var JSCompiler_temp = {
                start: root2.selectionStart,
                end: root2.selectionEnd
              };
            else
              a: {
                JSCompiler_temp = (JSCompiler_temp = root2.ownerDocument) && JSCompiler_temp.defaultView || window;
                var selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
                if (selection && 0 !== selection.rangeCount) {
                  JSCompiler_temp = selection.anchorNode;
                  var anchorOffset = selection.anchorOffset, focusNode = selection.focusNode;
                  selection = selection.focusOffset;
                  try {
                    JSCompiler_temp.nodeType, focusNode.nodeType;
                  } catch (e$2) {
                    JSCompiler_temp = null;
                    break a;
                  }
                  var length = 0, start2 = -1, end = -1, indexWithinAnchor = 0, indexWithinFocus = 0, node = root2, parentNode = null;
                  b: for (; ; ) {
                    for (var next; ; ) {
                      node !== JSCompiler_temp || 0 !== anchorOffset && 3 !== node.nodeType || (start2 = length + anchorOffset);
                      node !== focusNode || 0 !== selection && 3 !== node.nodeType || (end = length + selection);
                      3 === node.nodeType && (length += node.nodeValue.length);
                      if (null === (next = node.firstChild)) break;
                      parentNode = node;
                      node = next;
                    }
                    for (; ; ) {
                      if (node === root2) break b;
                      parentNode === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start2 = length);
                      parentNode === focusNode && ++indexWithinFocus === selection && (end = length);
                      if (null !== (next = node.nextSibling)) break;
                      node = parentNode;
                      parentNode = node.parentNode;
                    }
                    node = next;
                  }
                  JSCompiler_temp = -1 === start2 || -1 === end ? null : { start: start2, end };
                } else JSCompiler_temp = null;
              }
            JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
          } else JSCompiler_temp = null;
          selectionInformation = {
            focusedElem: root2,
            selectionRange: JSCompiler_temp
          };
          _enabled = false;
          for (nextEffect = firstChild; null !== nextEffect; )
            if (firstChild = nextEffect, root2 = firstChild.child, 0 !== (firstChild.subtreeFlags & 1028) && null !== root2)
              root2.return = firstChild, nextEffect = root2;
            else
              for (; null !== nextEffect; ) {
                root2 = firstChild = nextEffect;
                JSCompiler_temp = root2.alternate;
                anchorOffset = root2.flags;
                switch (root2.tag) {
                  case 0:
                    if (0 !== (anchorOffset & 4) && (root2 = root2.updateQueue, root2 = null !== root2 ? root2.events : null, null !== root2))
                      for (JSCompiler_temp = 0; JSCompiler_temp < root2.length; JSCompiler_temp++)
                        anchorOffset = root2[JSCompiler_temp], anchorOffset.ref.impl = anchorOffset.nextImpl;
                    break;
                  case 11:
                  case 15:
                    break;
                  case 1:
                    0 !== (anchorOffset & 1024) && null !== JSCompiler_temp && commitClassSnapshot(root2, JSCompiler_temp);
                    break;
                  case 3:
                    if (0 !== (anchorOffset & 1024)) {
                      if (root2 = root2.stateNode.containerInfo, JSCompiler_temp = root2.nodeType, 9 === JSCompiler_temp)
                        clearContainerSparingly(root2);
                      else if (1 === JSCompiler_temp)
                        switch (root2.nodeName) {
                          case "HEAD":
                          case "HTML":
                          case "BODY":
                            clearContainerSparingly(root2);
                            break;
                          default:
                            root2.textContent = "";
                        }
                    }
                    break;
                  case 5:
                  case 26:
                  case 27:
                  case 6:
                  case 4:
                  case 17:
                    break;
                  default:
                    if (0 !== (anchorOffset & 1024))
                      throw Error(
                        "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."
                      );
                }
                root2 = firstChild.sibling;
                if (null !== root2) {
                  root2.return = firstChild.return;
                  nextEffect = root2;
                  break;
                }
                nextEffect = firstChild.return;
              }
        }
        function commitLayoutEffectOnFiber(finishedRoot, current2, finishedWork) {
          var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              flags & 4 && commitHookLayoutEffects(finishedWork, Layout | HasEffect);
              break;
            case 1:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              if (flags & 4)
                if (finishedRoot = finishedWork.stateNode, null === current2)
                  finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error(
                    "Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  ), finishedRoot.state !== finishedWork.memoizedState && console.error(
                    "Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  )), shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(
                    finishedWork,
                    callComponentDidMountInDEV,
                    finishedWork,
                    finishedRoot
                  ), recordEffectDuration()) : runWithFiberInDEV(
                    finishedWork,
                    callComponentDidMountInDEV,
                    finishedWork,
                    finishedRoot
                  );
                else {
                  var prevProps = resolveClassComponentProps(
                    finishedWork.type,
                    current2.memoizedProps
                  );
                  current2 = current2.memoizedState;
                  finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error(
                    "Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  ), finishedRoot.state !== finishedWork.memoizedState && console.error(
                    "Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  ));
                  shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(
                    finishedWork,
                    callComponentDidUpdateInDEV,
                    finishedWork,
                    finishedRoot,
                    prevProps,
                    current2,
                    finishedRoot.__reactInternalSnapshotBeforeUpdate
                  ), recordEffectDuration()) : runWithFiberInDEV(
                    finishedWork,
                    callComponentDidUpdateInDEV,
                    finishedWork,
                    finishedRoot,
                    prevProps,
                    current2,
                    finishedRoot.__reactInternalSnapshotBeforeUpdate
                  );
                }
              flags & 64 && commitClassCallbacks(finishedWork);
              flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 3:
              current2 = pushNestedEffectDurations();
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              if (flags & 64 && (flags = finishedWork.updateQueue, null !== flags)) {
                prevProps = null;
                if (null !== finishedWork.child)
                  switch (finishedWork.child.tag) {
                    case 27:
                    case 5:
                      prevProps = finishedWork.child.stateNode;
                      break;
                    case 1:
                      prevProps = finishedWork.child.stateNode;
                  }
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitCallbacks,
                    flags,
                    prevProps
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              }
              finishedRoot.effectDuration += popNestedEffectDurations(current2);
              break;
            case 27:
              null === current2 && flags & 4 && commitHostSingletonAcquisition(finishedWork);
            case 26:
            case 5:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              if (null === current2) {
                if (flags & 4) commitHostMount(finishedWork);
                else if (flags & 64) {
                  finishedRoot = finishedWork.type;
                  current2 = finishedWork.memoizedProps;
                  prevProps = finishedWork.stateNode;
                  try {
                    runWithFiberInDEV(
                      finishedWork,
                      commitHydratedInstance,
                      prevProps,
                      finishedRoot,
                      current2,
                      finishedWork
                    );
                  } catch (error) {
                    captureCommitPhaseError(
                      finishedWork,
                      finishedWork.return,
                      error
                    );
                  }
                }
              }
              flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 12:
              if (flags & 4) {
                flags = pushNestedEffectDurations();
                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                finishedRoot = finishedWork.stateNode;
                finishedRoot.effectDuration += bubbleNestedEffectDurations(flags);
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitProfiler,
                    finishedWork,
                    current2,
                    commitStartTime,
                    finishedRoot.effectDuration
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              } else recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              break;
            case 31:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
              break;
            case 13:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
              flags & 64 && (finishedRoot = finishedWork.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot && (flags = retryDehydratedSuspenseBoundary.bind(
                null,
                finishedWork
              ), registerSuspenseInstanceRetry(finishedRoot, flags))));
              break;
            case 22:
              flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
              if (!flags) {
                current2 = null !== current2 && null !== current2.memoizedState || offscreenSubtreeWasHidden;
                prevProps = offscreenSubtreeIsHidden;
                var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                offscreenSubtreeIsHidden = flags;
                (offscreenSubtreeWasHidden = current2) && !prevOffscreenSubtreeWasHidden ? (recursivelyTraverseReappearLayoutEffects(
                  finishedRoot,
                  finishedWork,
                  0 !== (finishedWork.subtreeFlags & 8772)
                ), (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentReappeared(
                  finishedWork,
                  componentEffectStartTime,
                  componentEffectEndTime
                )) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                offscreenSubtreeIsHidden = prevProps;
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
              }
              break;
            case 30:
              break;
            default:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          }
          (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && ((componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            componentEffectDuration,
            componentEffectErrors
          ), null === finishedWork.alternate && null !== finishedWork.return && null !== finishedWork.return.alternate && 0.05 < componentEffectEndTime - componentEffectStartTime && (isHydratingParent(
            finishedWork.return.alternate,
            finishedWork.return
          ) || logComponentTrigger(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            "Mount"
          )));
          popComponentEffectStart(prevEffectStart);
          popComponentEffectDuration(prevEffectDuration);
          componentEffectErrors = prevEffectErrors;
          componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
        }
        function detachFiberAfterEffects(fiber) {
          var alternate = fiber.alternate;
          null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
          fiber.child = null;
          fiber.deletions = null;
          fiber.sibling = null;
          5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));
          fiber.stateNode = null;
          fiber._debugOwner = null;
          fiber.return = null;
          fiber.dependencies = null;
          fiber.memoizedProps = null;
          fiber.memoizedState = null;
          fiber.pendingProps = null;
          fiber.stateNode = null;
          fiber.updateQueue = null;
        }
        function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
          for (parent = parent.child; null !== parent; )
            commitDeletionEffectsOnFiber(
              finishedRoot,
              nearestMountedAncestor,
              parent
            ), parent = parent.sibling;
        }
        function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
          if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
            try {
              injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
            } catch (err) {
              hasLoggedError || (hasLoggedError = true, console.error(
                "React instrumentation encountered an error: %o",
                err
              ));
            }
          var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
          switch (deletedFiber.tag) {
            case 26:
              offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && (finishedRoot = deletedFiber.stateNode, finishedRoot.parentNode.removeChild(finishedRoot));
              break;
            case 27:
              offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
              var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
              isSingletonScope(deletedFiber.type) && (hostParent = deletedFiber.stateNode, hostParentIsContainer = false);
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              runWithFiberInDEV(
                deletedFiber,
                releaseSingletonInstance,
                deletedFiber.stateNode
              );
              hostParent = prevHostParent;
              hostParentIsContainer = prevHostParentIsContainer;
              break;
            case 5:
              offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
            case 6:
              prevHostParent = hostParent;
              prevHostParentIsContainer = hostParentIsContainer;
              hostParent = null;
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              hostParent = prevHostParent;
              hostParentIsContainer = prevHostParentIsContainer;
              if (null !== hostParent)
                if (hostParentIsContainer)
                  try {
                    runWithFiberInDEV(
                      deletedFiber,
                      removeChildFromContainer,
                      hostParent,
                      deletedFiber.stateNode
                    );
                  } catch (error) {
                    captureCommitPhaseError(
                      deletedFiber,
                      nearestMountedAncestor,
                      error
                    );
                  }
                else
                  try {
                    runWithFiberInDEV(
                      deletedFiber,
                      removeChild,
                      hostParent,
                      deletedFiber.stateNode
                    );
                  } catch (error) {
                    captureCommitPhaseError(
                      deletedFiber,
                      nearestMountedAncestor,
                      error
                    );
                  }
              break;
            case 18:
              null !== hostParent && (hostParentIsContainer ? (finishedRoot = hostParent, clearHydrationBoundary(
                9 === finishedRoot.nodeType ? finishedRoot.body : "HTML" === finishedRoot.nodeName ? finishedRoot.ownerDocument.body : finishedRoot,
                deletedFiber.stateNode
              ), retryIfBlockedOn(finishedRoot)) : clearHydrationBoundary(hostParent, deletedFiber.stateNode));
              break;
            case 4:
              prevHostParent = hostParent;
              prevHostParentIsContainer = hostParentIsContainer;
              hostParent = deletedFiber.stateNode.containerInfo;
              hostParentIsContainer = true;
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              hostParent = prevHostParent;
              hostParentIsContainer = prevHostParentIsContainer;
              break;
            case 0:
            case 11:
            case 14:
            case 15:
              commitHookEffectListUnmount(
                Insertion,
                deletedFiber,
                nearestMountedAncestor
              );
              offscreenSubtreeWasHidden || commitHookLayoutUnmountEffects(
                deletedFiber,
                nearestMountedAncestor,
                Layout
              );
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              break;
            case 1:
              offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, "function" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(
                deletedFiber,
                nearestMountedAncestor,
                prevHostParent
              ));
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              break;
            case 21:
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              break;
            case 22:
              offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              offscreenSubtreeWasHidden = prevHostParent;
              break;
            default:
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
          }
          (deletedFiber.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
            deletedFiber,
            componentEffectStartTime,
            componentEffectEndTime,
            componentEffectDuration,
            componentEffectErrors
          );
          popComponentEffectStart(prevEffectStart);
          popComponentEffectDuration(prevEffectDuration);
          componentEffectErrors = prevEffectErrors;
          componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
        }
        function commitActivityHydrationCallbacks(finishedRoot, finishedWork) {
          if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot))) {
            finishedRoot = finishedRoot.dehydrated;
            try {
              runWithFiberInDEV(
                finishedWork,
                commitHydratedActivityInstance,
                finishedRoot
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
        }
        function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
          if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot))))
            try {
              runWithFiberInDEV(
                finishedWork,
                commitHydratedSuspenseInstance,
                finishedRoot
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
        }
        function getRetryCache(finishedWork) {
          switch (finishedWork.tag) {
            case 31:
            case 13:
            case 19:
              var retryCache = finishedWork.stateNode;
              null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
              return retryCache;
            case 22:
              return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;
            default:
              throw Error(
                "Unexpected Suspense handler tag (" + finishedWork.tag + "). This is a bug in React."
              );
          }
        }
        function attachSuspenseRetryListeners(finishedWork, wakeables) {
          var retryCache = getRetryCache(finishedWork);
          wakeables.forEach(function(wakeable) {
            if (!retryCache.has(wakeable)) {
              retryCache.add(wakeable);
              if (isDevToolsPresent)
                if (null !== inProgressLanes && null !== inProgressRoot)
                  restorePendingUpdaters(inProgressRoot, inProgressLanes);
                else
                  throw Error(
                    "Expected finished root and lanes to be set. This is a bug in React."
                  );
              var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
              wakeable.then(retry, retry);
            }
          });
        }
        function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
          var deletions = parentFiber.deletions;
          if (null !== deletions)
            for (var i8 = 0; i8 < deletions.length; i8++) {
              var root2 = root$jscomp$0, returnFiber = parentFiber, deletedFiber = deletions[i8], prevEffectStart = pushComponentEffectStart(), parent = returnFiber;
              a: for (; null !== parent; ) {
                switch (parent.tag) {
                  case 27:
                    if (isSingletonScope(parent.type)) {
                      hostParent = parent.stateNode;
                      hostParentIsContainer = false;
                      break a;
                    }
                    break;
                  case 5:
                    hostParent = parent.stateNode;
                    hostParentIsContainer = false;
                    break a;
                  case 3:
                  case 4:
                    hostParent = parent.stateNode.containerInfo;
                    hostParentIsContainer = true;
                    break a;
                }
                parent = parent.return;
              }
              if (null === hostParent)
                throw Error(
                  "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
                );
              commitDeletionEffectsOnFiber(root2, returnFiber, deletedFiber);
              hostParent = null;
              hostParentIsContainer = false;
              (deletedFiber.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(
                deletedFiber,
                componentEffectStartTime,
                componentEffectEndTime,
                "Unmount"
              );
              popComponentEffectStart(prevEffectStart);
              root2 = deletedFiber;
              returnFiber = root2.alternate;
              null !== returnFiber && (returnFiber.return = null);
              root2.return = null;
            }
          if (parentFiber.subtreeFlags & 13886)
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
        }
        function commitMutationEffectsOnFiber(finishedWork, root2) {
          var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), current2 = finishedWork.alternate, flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 4 && (commitHookEffectListUnmount(
                Insertion | HasEffect,
                finishedWork,
                finishedWork.return
              ), commitHookEffectListMount(Insertion | HasEffect, finishedWork), commitHookLayoutUnmountEffects(
                finishedWork,
                finishedWork.return,
                Layout | HasEffect
              ));
              break;
            case 1:
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
              if (flags & 64 && offscreenSubtreeIsHidden && (flags = finishedWork.updateQueue, null !== flags && (current2 = flags.callbacks, null !== current2))) {
                var existingHiddenCallbacks = flags.shared.hiddenCallbacks;
                flags.shared.hiddenCallbacks = null === existingHiddenCallbacks ? current2 : existingHiddenCallbacks.concat(current2);
              }
              break;
            case 26:
              existingHiddenCallbacks = currentHoistableRoot;
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
              if (flags & 4) {
                var currentResource = null !== current2 ? current2.memoizedState : null;
                flags = finishedWork.memoizedState;
                if (null === current2)
                  if (null === flags)
                    if (null === finishedWork.stateNode) {
                      a: {
                        flags = finishedWork.type;
                        current2 = finishedWork.memoizedProps;
                        existingHiddenCallbacks = existingHiddenCallbacks.ownerDocument || existingHiddenCallbacks;
                        b: switch (flags) {
                          case "title":
                            currentResource = existingHiddenCallbacks.getElementsByTagName(
                              "title"
                            )[0];
                            if (!currentResource || currentResource[internalHoistableMarker] || currentResource[internalInstanceKey] || currentResource.namespaceURI === SVG_NAMESPACE || currentResource.hasAttribute("itemprop"))
                              currentResource = existingHiddenCallbacks.createElement(flags), existingHiddenCallbacks.head.insertBefore(
                                currentResource,
                                existingHiddenCallbacks.querySelector(
                                  "head > title"
                                )
                              );
                            setInitialProperties(currentResource, flags, current2);
                            currentResource[internalInstanceKey] = finishedWork;
                            markNodeAsHoistable(currentResource);
                            flags = currentResource;
                            break a;
                          case "link":
                            var maybeNodes = getHydratableHoistableCache(
                              "link",
                              "href",
                              existingHiddenCallbacks
                            ).get(flags + (current2.href || ""));
                            if (maybeNodes) {
                              for (var i8 = 0; i8 < maybeNodes.length; i8++)
                                if (currentResource = maybeNodes[i8], currentResource.getAttribute("href") === (null == current2.href || "" === current2.href ? null : current2.href) && currentResource.getAttribute("rel") === (null == current2.rel ? null : current2.rel) && currentResource.getAttribute("title") === (null == current2.title ? null : current2.title) && currentResource.getAttribute("crossorigin") === (null == current2.crossOrigin ? null : current2.crossOrigin)) {
                                  maybeNodes.splice(i8, 1);
                                  break b;
                                }
                            }
                            currentResource = existingHiddenCallbacks.createElement(flags);
                            setInitialProperties(currentResource, flags, current2);
                            existingHiddenCallbacks.head.appendChild(
                              currentResource
                            );
                            break;
                          case "meta":
                            if (maybeNodes = getHydratableHoistableCache(
                              "meta",
                              "content",
                              existingHiddenCallbacks
                            ).get(flags + (current2.content || ""))) {
                              for (i8 = 0; i8 < maybeNodes.length; i8++)
                                if (currentResource = maybeNodes[i8], checkAttributeStringCoercion(
                                  current2.content,
                                  "content"
                                ), currentResource.getAttribute("content") === (null == current2.content ? null : "" + current2.content) && currentResource.getAttribute("name") === (null == current2.name ? null : current2.name) && currentResource.getAttribute("property") === (null == current2.property ? null : current2.property) && currentResource.getAttribute("http-equiv") === (null == current2.httpEquiv ? null : current2.httpEquiv) && currentResource.getAttribute("charset") === (null == current2.charSet ? null : current2.charSet)) {
                                  maybeNodes.splice(i8, 1);
                                  break b;
                                }
                            }
                            currentResource = existingHiddenCallbacks.createElement(flags);
                            setInitialProperties(currentResource, flags, current2);
                            existingHiddenCallbacks.head.appendChild(
                              currentResource
                            );
                            break;
                          default:
                            throw Error(
                              'getNodesForType encountered a type it did not expect: "' + flags + '". This is a bug in React.'
                            );
                        }
                        currentResource[internalInstanceKey] = finishedWork;
                        markNodeAsHoistable(currentResource);
                        flags = currentResource;
                      }
                      finishedWork.stateNode = flags;
                    } else
                      mountHoistable(
                        existingHiddenCallbacks,
                        finishedWork.type,
                        finishedWork.stateNode
                      );
                  else
                    finishedWork.stateNode = acquireResource(
                      existingHiddenCallbacks,
                      flags,
                      finishedWork.memoizedProps
                    );
                else
                  currentResource !== flags ? (null === currentResource ? null !== current2.stateNode && (current2 = current2.stateNode, current2.parentNode.removeChild(current2)) : currentResource.count--, null === flags ? mountHoistable(
                    existingHiddenCallbacks,
                    finishedWork.type,
                    finishedWork.stateNode
                  ) : acquireResource(
                    existingHiddenCallbacks,
                    flags,
                    finishedWork.memoizedProps
                  )) : null === flags && null !== finishedWork.stateNode && commitHostUpdate(
                    finishedWork,
                    finishedWork.memoizedProps,
                    current2.memoizedProps
                  );
              }
              break;
            case 27:
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
              null !== current2 && flags & 4 && commitHostUpdate(
                finishedWork,
                finishedWork.memoizedProps,
                current2.memoizedProps
              );
              break;
            case 5:
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
              if (finishedWork.flags & 32) {
                existingHiddenCallbacks = finishedWork.stateNode;
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    resetTextContent,
                    existingHiddenCallbacks
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              }
              flags & 4 && null != finishedWork.stateNode && (existingHiddenCallbacks = finishedWork.memoizedProps, commitHostUpdate(
                finishedWork,
                existingHiddenCallbacks,
                null !== current2 ? current2.memoizedProps : existingHiddenCallbacks
              ));
              flags & 1024 && (needsFormReset = true, "form" !== finishedWork.type && console.error(
                "Unexpected host component type. Expected a form. This is a bug in React."
              ));
              break;
            case 6:
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & 4) {
                if (null === finishedWork.stateNode)
                  throw Error(
                    "This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue."
                  );
                flags = finishedWork.memoizedProps;
                current2 = null !== current2 ? current2.memoizedProps : flags;
                existingHiddenCallbacks = finishedWork.stateNode;
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitTextUpdate,
                    existingHiddenCallbacks,
                    current2,
                    flags
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              }
              break;
            case 3:
              existingHiddenCallbacks = pushNestedEffectDurations();
              tagCaches = null;
              currentResource = currentHoistableRoot;
              currentHoistableRoot = getHoistableRoot(root2.containerInfo);
              recursivelyTraverseMutationEffects(root2, finishedWork);
              currentHoistableRoot = currentResource;
              commitReconciliationEffects(finishedWork);
              if (flags & 4 && null !== current2 && current2.memoizedState.isDehydrated)
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitHydratedContainer,
                    root2.containerInfo
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              needsFormReset && (needsFormReset = false, recursivelyResetForms(finishedWork));
              root2.effectDuration += popNestedEffectDurations(
                existingHiddenCallbacks
              );
              break;
            case 4:
              flags = currentHoistableRoot;
              currentHoistableRoot = getHoistableRoot(
                finishedWork.stateNode.containerInfo
              );
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              currentHoistableRoot = flags;
              break;
            case 12:
              flags = pushNestedEffectDurations();
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              finishedWork.stateNode.effectDuration += bubbleNestedEffectDurations(flags);
              break;
            case 31:
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
              break;
            case 13:
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current2 && null !== current2.memoizedState) && (globalMostRecentFallbackTime = now$1());
              flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
              break;
            case 22:
              existingHiddenCallbacks = null !== finishedWork.memoizedState;
              var wasHidden = null !== current2 && null !== current2.memoizedState, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
              offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || existingHiddenCallbacks;
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
              recursivelyTraverseMutationEffects(root2, finishedWork);
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
              offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
              wasHidden && !existingHiddenCallbacks && !prevOffscreenSubtreeIsHidden && !prevOffscreenSubtreeWasHidden && (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentReappeared(
                finishedWork,
                componentEffectStartTime,
                componentEffectEndTime
              );
              commitReconciliationEffects(finishedWork);
              if (flags & 8192)
                a: for (root2 = finishedWork.stateNode, root2._visibility = existingHiddenCallbacks ? root2._visibility & ~OffscreenVisible : root2._visibility | OffscreenVisible, !existingHiddenCallbacks || null === current2 || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || (recursivelyTraverseDisappearLayoutEffects(finishedWork), (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(
                  finishedWork,
                  componentEffectStartTime,
                  componentEffectEndTime,
                  "Disconnect"
                )), current2 = null, root2 = finishedWork; ; ) {
                  if (5 === root2.tag || 26 === root2.tag) {
                    if (null === current2) {
                      wasHidden = current2 = root2;
                      try {
                        currentResource = wasHidden.stateNode, existingHiddenCallbacks ? runWithFiberInDEV(
                          wasHidden,
                          hideInstance,
                          currentResource
                        ) : runWithFiberInDEV(
                          wasHidden,
                          unhideInstance,
                          wasHidden.stateNode,
                          wasHidden.memoizedProps
                        );
                      } catch (error) {
                        captureCommitPhaseError(wasHidden, wasHidden.return, error);
                      }
                    }
                  } else if (6 === root2.tag) {
                    if (null === current2) {
                      wasHidden = root2;
                      try {
                        maybeNodes = wasHidden.stateNode, existingHiddenCallbacks ? runWithFiberInDEV(
                          wasHidden,
                          hideTextInstance,
                          maybeNodes
                        ) : runWithFiberInDEV(
                          wasHidden,
                          unhideTextInstance,
                          maybeNodes,
                          wasHidden.memoizedProps
                        );
                      } catch (error) {
                        captureCommitPhaseError(wasHidden, wasHidden.return, error);
                      }
                    }
                  } else if (18 === root2.tag) {
                    if (null === current2) {
                      wasHidden = root2;
                      try {
                        i8 = wasHidden.stateNode, existingHiddenCallbacks ? runWithFiberInDEV(
                          wasHidden,
                          hideDehydratedBoundary,
                          i8
                        ) : runWithFiberInDEV(
                          wasHidden,
                          unhideDehydratedBoundary,
                          wasHidden.stateNode
                        );
                      } catch (error) {
                        captureCommitPhaseError(wasHidden, wasHidden.return, error);
                      }
                    }
                  } else if ((22 !== root2.tag && 23 !== root2.tag || null === root2.memoizedState || root2 === finishedWork) && null !== root2.child) {
                    root2.child.return = root2;
                    root2 = root2.child;
                    continue;
                  }
                  if (root2 === finishedWork) break a;
                  for (; null === root2.sibling; ) {
                    if (null === root2.return || root2.return === finishedWork)
                      break a;
                    current2 === root2 && (current2 = null);
                    root2 = root2.return;
                  }
                  current2 === root2 && (current2 = null);
                  root2.sibling.return = root2.return;
                  root2 = root2.sibling;
                }
              flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current2 = flags.retryQueue, null !== current2 && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current2))));
              break;
            case 19:
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
              break;
            case 30:
              break;
            case 21:
              break;
            default:
              recursivelyTraverseMutationEffects(root2, finishedWork), commitReconciliationEffects(finishedWork);
          }
          (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && ((componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            componentEffectDuration,
            componentEffectErrors
          ), null === finishedWork.alternate && null !== finishedWork.return && null !== finishedWork.return.alternate && 0.05 < componentEffectEndTime - componentEffectStartTime && (isHydratingParent(
            finishedWork.return.alternate,
            finishedWork.return
          ) || logComponentTrigger(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            "Mount"
          )));
          popComponentEffectStart(prevEffectStart);
          popComponentEffectDuration(prevEffectDuration);
          componentEffectErrors = prevEffectErrors;
          componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
        }
        function commitReconciliationEffects(finishedWork) {
          var flags = finishedWork.flags;
          if (flags & 2) {
            try {
              runWithFiberInDEV(finishedWork, commitPlacement, finishedWork);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
            finishedWork.flags &= -3;
          }
          flags & 4096 && (finishedWork.flags &= -4097);
        }
        function recursivelyResetForms(parentFiber) {
          if (parentFiber.subtreeFlags & 1024)
            for (parentFiber = parentFiber.child; null !== parentFiber; ) {
              var fiber = parentFiber;
              recursivelyResetForms(fiber);
              5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
              parentFiber = parentFiber.sibling;
            }
        }
        function recursivelyTraverseLayoutEffects(root2, parentFiber) {
          if (parentFiber.subtreeFlags & 8772)
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              commitLayoutEffectOnFiber(root2, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
        }
        function disappearLayoutEffects(finishedWork) {
          var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              commitHookLayoutUnmountEffects(
                finishedWork,
                finishedWork.return,
                Layout
              );
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 1:
              safelyDetachRef(finishedWork, finishedWork.return);
              var instance = finishedWork.stateNode;
              "function" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(
                finishedWork,
                finishedWork.return,
                instance
              );
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 27:
              runWithFiberInDEV(
                finishedWork,
                releaseSingletonInstance,
                finishedWork.stateNode
              );
            case 26:
            case 5:
              safelyDetachRef(finishedWork, finishedWork.return);
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 22:
              null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 30:
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            default:
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
          }
          (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            componentEffectDuration,
            componentEffectErrors
          );
          popComponentEffectStart(prevEffectStart);
          popComponentEffectDuration(prevEffectDuration);
          componentEffectErrors = prevEffectErrors;
          componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
        }
        function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            disappearLayoutEffects(parentFiber), parentFiber = parentFiber.sibling;
        }
        function reappearLayoutEffects(finishedRoot, current2, finishedWork, includeWorkInProgressEffects) {
          var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              commitHookLayoutEffects(finishedWork, Layout);
              break;
            case 1:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              current2 = finishedWork.stateNode;
              "function" === typeof current2.componentDidMount && runWithFiberInDEV(
                finishedWork,
                callComponentDidMountInDEV,
                finishedWork,
                current2
              );
              current2 = finishedWork.updateQueue;
              if (null !== current2) {
                finishedRoot = finishedWork.stateNode;
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitHiddenCallbacks,
                    current2,
                    finishedRoot
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              }
              includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 27:
              commitHostSingletonAcquisition(finishedWork);
            case 26:
            case 5:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && null === current2 && flags & 4 && commitHostMount(finishedWork);
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 12:
              if (includeWorkInProgressEffects && flags & 4) {
                flags = pushNestedEffectDurations();
                recursivelyTraverseReappearLayoutEffects(
                  finishedRoot,
                  finishedWork,
                  includeWorkInProgressEffects
                );
                includeWorkInProgressEffects = finishedWork.stateNode;
                includeWorkInProgressEffects.effectDuration += bubbleNestedEffectDurations(flags);
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitProfiler,
                    finishedWork,
                    current2,
                    commitStartTime,
                    includeWorkInProgressEffects.effectDuration
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              } else
                recursivelyTraverseReappearLayoutEffects(
                  finishedRoot,
                  finishedWork,
                  includeWorkInProgressEffects
                );
              break;
            case 31:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
              break;
            case 13:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
              break;
            case 22:
              null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 30:
              break;
            default:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
          }
          (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            componentEffectDuration,
            componentEffectErrors
          );
          popComponentEffectStart(prevEffectStart);
          popComponentEffectDuration(prevEffectDuration);
          componentEffectErrors = prevEffectErrors;
          componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
        }
        function recursivelyTraverseReappearLayoutEffects(finishedRoot, parentFiber, includeWorkInProgressEffects) {
          includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            reappearLayoutEffects(
              finishedRoot,
              parentFiber.alternate,
              parentFiber,
              includeWorkInProgressEffects
            ), parentFiber = parentFiber.sibling;
        }
        function commitOffscreenPassiveMountEffects(current2, finishedWork) {
          var previousCache = null;
          null !== current2 && null !== current2.memoizedState && null !== current2.memoizedState.cachePool && (previousCache = current2.memoizedState.cachePool.pool);
          current2 = null;
          null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current2 = finishedWork.memoizedState.cachePool.pool);
          current2 !== previousCache && (null != current2 && retainCache(current2), null != previousCache && releaseCache(previousCache));
        }
        function commitCachePassiveMountEffect(current2, finishedWork) {
          current2 = null;
          null !== finishedWork.alternate && (current2 = finishedWork.alternate.memoizedState.cache);
          finishedWork = finishedWork.memoizedState.cache;
          finishedWork !== current2 && (retainCache(finishedWork), null != current2 && releaseCache(current2));
        }
        function recursivelyTraversePassiveMountEffects(root2, parentFiber, committedLanes, committedTransitions, endTime) {
          if (parentFiber.subtreeFlags & 10256 || 0 !== parentFiber.actualDuration && (null === parentFiber.alternate || parentFiber.alternate.child !== parentFiber.child))
            for (parentFiber = parentFiber.child; null !== parentFiber; ) {
              var nextSibling = parentFiber.sibling;
              commitPassiveMountOnFiber(
                root2,
                parentFiber,
                committedLanes,
                committedTransitions,
                null !== nextSibling ? nextSibling.actualStartTime : endTime
              );
              parentFiber = nextSibling;
            }
        }
        function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime) {
          var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), prevDeepEquality = alreadyWarnedForDeepEquality, flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              (finishedWork.mode & ProfileMode) !== NoMode && 0 < finishedWork.actualStartTime && 0 !== (finishedWork.flags & 1) && logComponentRender(
                finishedWork,
                finishedWork.actualStartTime,
                endTime,
                inHydratedSubtree,
                committedLanes
              );
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              );
              flags & 2048 && commitHookPassiveMountEffects(finishedWork, Passive | HasEffect);
              break;
            case 1:
              (finishedWork.mode & ProfileMode) !== NoMode && 0 < finishedWork.actualStartTime && (0 !== (finishedWork.flags & 128) ? logComponentErrored(
                finishedWork,
                finishedWork.actualStartTime,
                endTime,
                []
              ) : 0 !== (finishedWork.flags & 1) && logComponentRender(
                finishedWork,
                finishedWork.actualStartTime,
                endTime,
                inHydratedSubtree,
                committedLanes
              ));
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              );
              break;
            case 3:
              var prevProfilerEffectDuration = pushNestedEffectDurations(), wasInHydratedSubtree = inHydratedSubtree;
              inHydratedSubtree = null !== finishedWork.alternate && finishedWork.alternate.memoizedState.isDehydrated && 0 === (finishedWork.flags & 256);
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              );
              inHydratedSubtree = wasInHydratedSubtree;
              flags & 2048 && (committedLanes = null, null !== finishedWork.alternate && (committedLanes = finishedWork.alternate.memoizedState.cache), committedTransitions = finishedWork.memoizedState.cache, committedTransitions !== committedLanes && (retainCache(committedTransitions), null != committedLanes && releaseCache(committedLanes)));
              finishedRoot.passiveEffectDuration += popNestedEffectDurations(
                prevProfilerEffectDuration
              );
              break;
            case 12:
              if (flags & 2048) {
                flags = pushNestedEffectDurations();
                recursivelyTraversePassiveMountEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions,
                  endTime
                );
                finishedRoot = finishedWork.stateNode;
                finishedRoot.passiveEffectDuration += bubbleNestedEffectDurations(flags);
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitProfilerPostCommitImpl,
                    finishedWork,
                    finishedWork.alternate,
                    commitStartTime,
                    finishedRoot.passiveEffectDuration
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              } else
                recursivelyTraversePassiveMountEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions,
                  endTime
                );
              break;
            case 31:
              flags = inHydratedSubtree;
              prevProfilerEffectDuration = null !== finishedWork.alternate ? finishedWork.alternate.memoizedState : null;
              wasInHydratedSubtree = finishedWork.memoizedState;
              null !== prevProfilerEffectDuration && null === wasInHydratedSubtree ? (wasInHydratedSubtree = finishedWork.deletions, null !== wasInHydratedSubtree && 0 < wasInHydratedSubtree.length && 18 === wasInHydratedSubtree[0].tag ? (inHydratedSubtree = false, prevProfilerEffectDuration = prevProfilerEffectDuration.hydrationErrors, null !== prevProfilerEffectDuration && logComponentErrored(
                finishedWork,
                finishedWork.actualStartTime,
                endTime,
                prevProfilerEffectDuration
              )) : inHydratedSubtree = true) : inHydratedSubtree = false;
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              );
              inHydratedSubtree = flags;
              break;
            case 13:
              flags = inHydratedSubtree;
              prevProfilerEffectDuration = null !== finishedWork.alternate ? finishedWork.alternate.memoizedState : null;
              wasInHydratedSubtree = finishedWork.memoizedState;
              null === prevProfilerEffectDuration || null === prevProfilerEffectDuration.dehydrated || null !== wasInHydratedSubtree && null !== wasInHydratedSubtree.dehydrated ? inHydratedSubtree = false : (wasInHydratedSubtree = finishedWork.deletions, null !== wasInHydratedSubtree && 0 < wasInHydratedSubtree.length && 18 === wasInHydratedSubtree[0].tag ? (inHydratedSubtree = false, prevProfilerEffectDuration = prevProfilerEffectDuration.hydrationErrors, null !== prevProfilerEffectDuration && logComponentErrored(
                finishedWork,
                finishedWork.actualStartTime,
                endTime,
                prevProfilerEffectDuration
              )) : inHydratedSubtree = true);
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              );
              inHydratedSubtree = flags;
              break;
            case 23:
              break;
            case 22:
              wasInHydratedSubtree = finishedWork.stateNode;
              prevProfilerEffectDuration = finishedWork.alternate;
              null !== finishedWork.memoizedState ? wasInHydratedSubtree._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              ) : recursivelyTraverseAtomicPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              ) : wasInHydratedSubtree._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              ) : (wasInHydratedSubtree._visibility |= OffscreenPassiveEffectsConnected, recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                0 !== (finishedWork.subtreeFlags & 10256) || 0 !== finishedWork.actualDuration && (null === finishedWork.alternate || finishedWork.alternate.child !== finishedWork.child),
                endTime
              ), (finishedWork.mode & ProfileMode) === NoMode || inHydratedSubtree || (finishedRoot = finishedWork.actualStartTime, 0 <= finishedRoot && 0.05 < endTime - finishedRoot && logComponentReappeared(finishedWork, finishedRoot, endTime), 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentReappeared(
                finishedWork,
                componentEffectStartTime,
                componentEffectEndTime
              )));
              flags & 2048 && commitOffscreenPassiveMountEffects(
                prevProfilerEffectDuration,
                finishedWork
              );
              break;
            case 24:
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              );
              flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
              break;
            default:
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              );
          }
          if ((finishedWork.mode & ProfileMode) !== NoMode) {
            if (finishedRoot = !inHydratedSubtree && null === finishedWork.alternate && null !== finishedWork.return && null !== finishedWork.return.alternate)
              committedLanes = finishedWork.actualStartTime, 0 <= committedLanes && 0.05 < endTime - committedLanes && logComponentTrigger(
                finishedWork,
                committedLanes,
                endTime,
                "Mount"
              );
            0 <= componentEffectStartTime && 0 <= componentEffectEndTime && ((componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
              finishedWork,
              componentEffectStartTime,
              componentEffectEndTime,
              componentEffectDuration,
              componentEffectErrors
            ), finishedRoot && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(
              finishedWork,
              componentEffectStartTime,
              componentEffectEndTime,
              "Mount"
            ));
          }
          popComponentEffectStart(prevEffectStart);
          popComponentEffectDuration(prevEffectDuration);
          componentEffectErrors = prevEffectErrors;
          componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
          alreadyWarnedForDeepEquality = prevDeepEquality;
        }
        function recursivelyTraverseReconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects, endTime) {
          includeWorkInProgressEffects = includeWorkInProgressEffects && (0 !== (parentFiber.subtreeFlags & 10256) || 0 !== parentFiber.actualDuration && (null === parentFiber.alternate || parentFiber.alternate.child !== parentFiber.child));
          for (parentFiber = parentFiber.child; null !== parentFiber; ) {
            var nextSibling = parentFiber.sibling;
            reconnectPassiveEffects(
              finishedRoot,
              parentFiber,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects,
              null !== nextSibling ? nextSibling.actualStartTime : endTime
            );
            parentFiber = nextSibling;
          }
        }
        function reconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects, endTime) {
          var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), prevDeepEquality = alreadyWarnedForDeepEquality;
          includeWorkInProgressEffects && (finishedWork.mode & ProfileMode) !== NoMode && 0 < finishedWork.actualStartTime && 0 !== (finishedWork.flags & 1) && logComponentRender(
            finishedWork,
            finishedWork.actualStartTime,
            endTime,
            inHydratedSubtree,
            committedLanes
          );
          var flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects,
                endTime
              );
              commitHookPassiveMountEffects(finishedWork, Passive);
              break;
            case 23:
              break;
            case 22:
              var _instance2 = finishedWork.stateNode;
              null !== finishedWork.memoizedState ? _instance2._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects,
                endTime
              ) : recursivelyTraverseAtomicPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                endTime
              ) : (_instance2._visibility |= OffscreenPassiveEffectsConnected, recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects,
                endTime
              ));
              includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(
                finishedWork.alternate,
                finishedWork
              );
              break;
            case 24:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects,
                endTime
              );
              includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
              break;
            default:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects,
                endTime
              );
          }
          (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            componentEffectDuration,
            componentEffectErrors
          );
          popComponentEffectStart(prevEffectStart);
          popComponentEffectDuration(prevEffectDuration);
          componentEffectErrors = prevEffectErrors;
          componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
          alreadyWarnedForDeepEquality = prevDeepEquality;
        }
        function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber, committedLanes$jscomp$0, committedTransitions$jscomp$0, endTime$jscomp$0) {
          if (parentFiber.subtreeFlags & 10256 || 0 !== parentFiber.actualDuration && (null === parentFiber.alternate || parentFiber.alternate.child !== parentFiber.child))
            for (var child = parentFiber.child; null !== child; ) {
              parentFiber = child.sibling;
              var finishedRoot = finishedRoot$jscomp$0, committedLanes = committedLanes$jscomp$0, committedTransitions = committedTransitions$jscomp$0, endTime = null !== parentFiber ? parentFiber.actualStartTime : endTime$jscomp$0, prevDeepEquality = alreadyWarnedForDeepEquality;
              (child.mode & ProfileMode) !== NoMode && 0 < child.actualStartTime && 0 !== (child.flags & 1) && logComponentRender(
                child,
                child.actualStartTime,
                endTime,
                inHydratedSubtree,
                committedLanes
              );
              var flags = child.flags;
              switch (child.tag) {
                case 22:
                  recursivelyTraverseAtomicPassiveEffects(
                    finishedRoot,
                    child,
                    committedLanes,
                    committedTransitions,
                    endTime
                  );
                  flags & 2048 && commitOffscreenPassiveMountEffects(child.alternate, child);
                  break;
                case 24:
                  recursivelyTraverseAtomicPassiveEffects(
                    finishedRoot,
                    child,
                    committedLanes,
                    committedTransitions,
                    endTime
                  );
                  flags & 2048 && commitCachePassiveMountEffect(child.alternate, child);
                  break;
                default:
                  recursivelyTraverseAtomicPassiveEffects(
                    finishedRoot,
                    child,
                    committedLanes,
                    committedTransitions,
                    endTime
                  );
              }
              alreadyWarnedForDeepEquality = prevDeepEquality;
              child = parentFiber;
            }
        }
        function recursivelyAccumulateSuspenseyCommit(parentFiber, committedLanes, suspendedState) {
          if (parentFiber.subtreeFlags & suspenseyCommitFlag)
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              accumulateSuspenseyCommitOnFiber(
                parentFiber,
                committedLanes,
                suspendedState
              ), parentFiber = parentFiber.sibling;
        }
        function accumulateSuspenseyCommitOnFiber(fiber, committedLanes, suspendedState) {
          switch (fiber.tag) {
            case 26:
              recursivelyAccumulateSuspenseyCommit(
                fiber,
                committedLanes,
                suspendedState
              );
              fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState && suspendResource(
                suspendedState,
                currentHoistableRoot,
                fiber.memoizedState,
                fiber.memoizedProps
              );
              break;
            case 5:
              recursivelyAccumulateSuspenseyCommit(
                fiber,
                committedLanes,
                suspendedState
              );
              break;
            case 3:
            case 4:
              var previousHoistableRoot = currentHoistableRoot;
              currentHoistableRoot = getHoistableRoot(
                fiber.stateNode.containerInfo
              );
              recursivelyAccumulateSuspenseyCommit(
                fiber,
                committedLanes,
                suspendedState
              );
              currentHoistableRoot = previousHoistableRoot;
              break;
            case 22:
              null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(
                fiber,
                committedLanes,
                suspendedState
              ), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(
                fiber,
                committedLanes,
                suspendedState
              ));
              break;
            default:
              recursivelyAccumulateSuspenseyCommit(
                fiber,
                committedLanes,
                suspendedState
              );
          }
        }
        function detachAlternateSiblings(parentFiber) {
          var previousFiber = parentFiber.alternate;
          if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {
            previousFiber.child = null;
            do
              previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;
            while (null !== parentFiber);
          }
        }
        function recursivelyTraversePassiveUnmountEffects(parentFiber) {
          var deletions = parentFiber.deletions;
          if (0 !== (parentFiber.flags & 16)) {
            if (null !== deletions)
              for (var i8 = 0; i8 < deletions.length; i8++) {
                var childToDelete = deletions[i8], prevEffectStart = pushComponentEffectStart();
                nextEffect = childToDelete;
                commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                  childToDelete,
                  parentFiber
                );
                (childToDelete.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(
                  childToDelete,
                  componentEffectStartTime,
                  componentEffectEndTime,
                  "Unmount"
                );
                popComponentEffectStart(prevEffectStart);
              }
            detachAlternateSiblings(parentFiber);
          }
          if (parentFiber.subtreeFlags & 10256)
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
        }
        function commitPassiveUnmountOnFiber(finishedWork) {
          var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraversePassiveUnmountEffects(finishedWork);
              finishedWork.flags & 2048 && commitHookPassiveUnmountEffects(
                finishedWork,
                finishedWork.return,
                Passive | HasEffect
              );
              break;
            case 3:
              var prevProfilerEffectDuration = pushNestedEffectDurations();
              recursivelyTraversePassiveUnmountEffects(finishedWork);
              finishedWork.stateNode.passiveEffectDuration += popNestedEffectDurations(prevProfilerEffectDuration);
              break;
            case 12:
              prevProfilerEffectDuration = pushNestedEffectDurations();
              recursivelyTraversePassiveUnmountEffects(finishedWork);
              finishedWork.stateNode.passiveEffectDuration += bubbleNestedEffectDurations(prevProfilerEffectDuration);
              break;
            case 22:
              prevProfilerEffectDuration = finishedWork.stateNode;
              null !== finishedWork.memoizedState && prevProfilerEffectDuration._visibility & OffscreenPassiveEffectsConnected && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (prevProfilerEffectDuration._visibility &= ~OffscreenPassiveEffectsConnected, recursivelyTraverseDisconnectPassiveEffects(finishedWork), (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(
                finishedWork,
                componentEffectStartTime,
                componentEffectEndTime,
                "Disconnect"
              )) : recursivelyTraversePassiveUnmountEffects(finishedWork);
              break;
            default:
              recursivelyTraversePassiveUnmountEffects(finishedWork);
          }
          (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            componentEffectDuration,
            componentEffectErrors
          );
          popComponentEffectStart(prevEffectStart);
          popComponentEffectDuration(prevEffectDuration);
          componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
          componentEffectErrors = prevEffectErrors;
        }
        function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
          var deletions = parentFiber.deletions;
          if (0 !== (parentFiber.flags & 16)) {
            if (null !== deletions)
              for (var i8 = 0; i8 < deletions.length; i8++) {
                var childToDelete = deletions[i8], prevEffectStart = pushComponentEffectStart();
                nextEffect = childToDelete;
                commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                  childToDelete,
                  parentFiber
                );
                (childToDelete.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(
                  childToDelete,
                  componentEffectStartTime,
                  componentEffectEndTime,
                  "Unmount"
                );
                popComponentEffectStart(prevEffectStart);
              }
            detachAlternateSiblings(parentFiber);
          }
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            disconnectPassiveEffect(parentFiber), parentFiber = parentFiber.sibling;
        }
        function disconnectPassiveEffect(finishedWork) {
          var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              commitHookPassiveUnmountEffects(
                finishedWork,
                finishedWork.return,
                Passive
              );
              recursivelyTraverseDisconnectPassiveEffects(finishedWork);
              break;
            case 22:
              var instance = finishedWork.stateNode;
              instance._visibility & OffscreenPassiveEffectsConnected && (instance._visibility &= ~OffscreenPassiveEffectsConnected, recursivelyTraverseDisconnectPassiveEffects(finishedWork));
              break;
            default:
              recursivelyTraverseDisconnectPassiveEffects(finishedWork);
          }
          (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            componentEffectDuration,
            componentEffectErrors
          );
          popComponentEffectStart(prevEffectStart);
          popComponentEffectDuration(prevEffectDuration);
          componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
          componentEffectErrors = prevEffectErrors;
        }
        function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor$jscomp$0) {
          for (; null !== nextEffect; ) {
            var fiber = nextEffect, current2 = fiber, nearestMountedAncestor = nearestMountedAncestor$jscomp$0, prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
            switch (current2.tag) {
              case 0:
              case 11:
              case 15:
                commitHookPassiveUnmountEffects(
                  current2,
                  nearestMountedAncestor,
                  Passive
                );
                break;
              case 23:
              case 22:
                null !== current2.memoizedState && null !== current2.memoizedState.cachePool && (nearestMountedAncestor = current2.memoizedState.cachePool.pool, null != nearestMountedAncestor && retainCache(nearestMountedAncestor));
                break;
              case 24:
                releaseCache(current2.memoizedState.cache);
            }
            (current2.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(
              current2,
              componentEffectStartTime,
              componentEffectEndTime,
              componentEffectDuration,
              componentEffectErrors
            );
            popComponentEffectStart(prevEffectStart);
            popComponentEffectDuration(prevEffectDuration);
            componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
            componentEffectErrors = prevEffectErrors;
            current2 = fiber.child;
            if (null !== current2) current2.return = fiber, nextEffect = current2;
            else
              a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
                current2 = nextEffect;
                prevEffectStart = current2.sibling;
                prevEffectDuration = current2.return;
                detachFiberAfterEffects(current2);
                if (current2 === fiber) {
                  nextEffect = null;
                  break a;
                }
                if (null !== prevEffectStart) {
                  prevEffectStart.return = prevEffectDuration;
                  nextEffect = prevEffectStart;
                  break a;
                }
                nextEffect = prevEffectDuration;
              }
          }
        }
        function onCommitRoot() {
          commitHooks.forEach(function(commitHook) {
            return commitHook();
          });
        }
        function isConcurrentActEnvironment() {
          var isReactActEnvironmentGlobal = "undefined" !== typeof IS_REACT_ACT_ENVIRONMENT ? IS_REACT_ACT_ENVIRONMENT : void 0;
          isReactActEnvironmentGlobal || null === ReactSharedInternals.actQueue || console.error(
            "The current testing environment is not configured to support act(...)"
          );
          return isReactActEnvironmentGlobal;
        }
        function requestUpdateLane(fiber) {
          if ((executionContext & RenderContext) !== NoContext && 0 !== workInProgressRootRenderLanes)
            return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
          var transition = ReactSharedInternals.T;
          return null !== transition ? (transition._updatedFibers || (transition._updatedFibers = /* @__PURE__ */ new Set()), transition._updatedFibers.add(fiber), requestTransitionLane()) : resolveUpdatePriority();
        }
        function requestDeferredLane() {
          if (0 === workInProgressDeferredLane)
            if (0 === (workInProgressRootRenderLanes & 536870912) || isHydrating) {
              var lane = nextTransitionDeferredLane;
              nextTransitionDeferredLane <<= 1;
              0 === (nextTransitionDeferredLane & 3932160) && (nextTransitionDeferredLane = 262144);
              workInProgressDeferredLane = lane;
            } else workInProgressDeferredLane = 536870912;
          lane = suspenseHandlerStackCursor.current;
          null !== lane && (lane.flags |= 32);
          return workInProgressDeferredLane;
        }
        function scheduleUpdateOnFiber(root2, fiber, lane) {
          isRunningInsertionEffect && console.error("useInsertionEffect must not schedule updates.");
          isFlushingPassiveEffects && (didScheduleUpdateDuringPassiveEffects = true);
          if (root2 === workInProgressRoot && (workInProgressSuspendedReason === SuspendedOnData || workInProgressSuspendedReason === SuspendedOnAction) || null !== root2.cancelPendingCommit)
            prepareFreshStack(root2, 0), markRootSuspended(
              root2,
              workInProgressRootRenderLanes,
              workInProgressDeferredLane,
              false
            );
          markRootUpdated$1(root2, lane);
          if ((executionContext & RenderContext) !== NoContext && root2 === workInProgressRoot) {
            if (isRendering)
              switch (fiber.tag) {
                case 0:
                case 11:
                case 15:
                  root2 = workInProgress && getComponentNameFromFiber(workInProgress) || "Unknown";
                  didWarnAboutUpdateInRenderForAnotherComponent.has(root2) || (didWarnAboutUpdateInRenderForAnotherComponent.add(root2), fiber = getComponentNameFromFiber(fiber) || "Unknown", console.error(
                    "Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://react.dev/link/setstate-in-render",
                    fiber,
                    root2,
                    root2
                  ));
                  break;
                case 1:
                  didWarnAboutUpdateInRender || (console.error(
                    "Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."
                  ), didWarnAboutUpdateInRender = true);
              }
          } else
            isDevToolsPresent && addFiberToLanesMap(root2, fiber, lane), warnIfUpdatesNotWrappedWithActDEV(fiber), root2 === workInProgressRoot && ((executionContext & RenderContext) === NoContext && (workInProgressRootInterleavedUpdatedLanes |= lane), workInProgressRootExitStatus === RootSuspendedWithDelay && markRootSuspended(
              root2,
              workInProgressRootRenderLanes,
              workInProgressDeferredLane,
              false
            )), ensureRootIsScheduled(root2);
        }
        function performWorkOnRoot(root2, lanes, forceSync) {
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
            throw Error("Should not already be working.");
          if (0 !== workInProgressRootRenderLanes && null !== workInProgress) {
            var yieldedFiber = workInProgress, yieldEndTime = now$1();
            switch (yieldReason) {
              case SuspendedOnImmediate:
              case SuspendedOnData:
                var startTime = yieldStartTime;
                supportsUserTiming && ((yieldedFiber = yieldedFiber._debugTask) ? yieldedFiber.run(
                  console.timeStamp.bind(
                    console,
                    "Suspended",
                    startTime,
                    yieldEndTime,
                    COMPONENTS_TRACK,
                    void 0,
                    "primary-light"
                  )
                ) : console.timeStamp(
                  "Suspended",
                  startTime,
                  yieldEndTime,
                  COMPONENTS_TRACK,
                  void 0,
                  "primary-light"
                ));
                break;
              case SuspendedOnAction:
                startTime = yieldStartTime;
                supportsUserTiming && ((yieldedFiber = yieldedFiber._debugTask) ? yieldedFiber.run(
                  console.timeStamp.bind(
                    console,
                    "Action",
                    startTime,
                    yieldEndTime,
                    COMPONENTS_TRACK,
                    void 0,
                    "primary-light"
                  )
                ) : console.timeStamp(
                  "Action",
                  startTime,
                  yieldEndTime,
                  COMPONENTS_TRACK,
                  void 0,
                  "primary-light"
                ));
                break;
              default:
                supportsUserTiming && (yieldedFiber = yieldEndTime - yieldStartTime, 3 > yieldedFiber || console.timeStamp(
                  "Blocked",
                  yieldStartTime,
                  yieldEndTime,
                  COMPONENTS_TRACK,
                  void 0,
                  5 > yieldedFiber ? "primary-light" : 10 > yieldedFiber ? "primary" : 100 > yieldedFiber ? "primary-dark" : "error"
                ));
            }
          }
          startTime = (forceSync = !forceSync && 0 === (lanes & 127) && 0 === (lanes & root2.expiredLanes) || checkIfRootIsPrerendering(root2, lanes)) ? renderRootConcurrent(root2, lanes) : renderRootSync(root2, lanes, true);
          var renderWasConcurrent = forceSync;
          do {
            if (startTime === RootInProgress) {
              workInProgressRootIsPrerendering && !forceSync && markRootSuspended(root2, lanes, 0, false);
              lanes = workInProgressSuspendedReason;
              yieldStartTime = now();
              yieldReason = lanes;
              break;
            } else {
              yieldedFiber = now$1();
              yieldEndTime = root2.current.alternate;
              if (renderWasConcurrent && !isRenderConsistentWithExternalStores(yieldEndTime)) {
                setCurrentTrackFromLanes(lanes);
                yieldEndTime = renderStartTime;
                startTime = yieldedFiber;
                !supportsUserTiming || startTime <= yieldEndTime || (workInProgressUpdateTask ? workInProgressUpdateTask.run(
                  console.timeStamp.bind(
                    console,
                    "Teared Render",
                    yieldEndTime,
                    startTime,
                    currentTrack,
                    LANES_TRACK_GROUP,
                    "error"
                  )
                ) : console.timeStamp(
                  "Teared Render",
                  yieldEndTime,
                  startTime,
                  currentTrack,
                  LANES_TRACK_GROUP,
                  "error"
                ));
                finalizeRender(lanes, yieldedFiber);
                startTime = renderRootSync(root2, lanes, false);
                renderWasConcurrent = false;
                continue;
              }
              if (startTime === RootErrored) {
                renderWasConcurrent = lanes;
                if (root2.errorRecoveryDisabledLanes & renderWasConcurrent)
                  var errorRetryLanes = 0;
                else
                  errorRetryLanes = root2.pendingLanes & -536870913, errorRetryLanes = 0 !== errorRetryLanes ? errorRetryLanes : errorRetryLanes & 536870912 ? 536870912 : 0;
                if (0 !== errorRetryLanes) {
                  setCurrentTrackFromLanes(lanes);
                  logErroredRenderPhase(
                    renderStartTime,
                    yieldedFiber,
                    lanes,
                    workInProgressUpdateTask
                  );
                  finalizeRender(lanes, yieldedFiber);
                  lanes = errorRetryLanes;
                  a: {
                    yieldedFiber = root2;
                    startTime = renderWasConcurrent;
                    renderWasConcurrent = workInProgressRootConcurrentErrors;
                    var wasRootDehydrated = yieldedFiber.current.memoizedState.isDehydrated;
                    wasRootDehydrated && (prepareFreshStack(yieldedFiber, errorRetryLanes).flags |= 256);
                    errorRetryLanes = renderRootSync(
                      yieldedFiber,
                      errorRetryLanes,
                      false
                    );
                    if (errorRetryLanes !== RootErrored) {
                      if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                        yieldedFiber.errorRecoveryDisabledLanes |= startTime;
                        workInProgressRootInterleavedUpdatedLanes |= startTime;
                        startTime = RootSuspendedWithDelay;
                        break a;
                      }
                      yieldedFiber = workInProgressRootRecoverableErrors;
                      workInProgressRootRecoverableErrors = renderWasConcurrent;
                      null !== yieldedFiber && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = yieldedFiber : workInProgressRootRecoverableErrors.push.apply(
                        workInProgressRootRecoverableErrors,
                        yieldedFiber
                      ));
                    }
                    startTime = errorRetryLanes;
                  }
                  renderWasConcurrent = false;
                  if (startTime !== RootErrored) continue;
                  else yieldedFiber = now$1();
                }
              }
              if (startTime === RootFatalErrored) {
                setCurrentTrackFromLanes(lanes);
                logErroredRenderPhase(
                  renderStartTime,
                  yieldedFiber,
                  lanes,
                  workInProgressUpdateTask
                );
                finalizeRender(lanes, yieldedFiber);
                prepareFreshStack(root2, 0);
                markRootSuspended(root2, lanes, 0, true);
                break;
              }
              a: {
                forceSync = root2;
                switch (startTime) {
                  case RootInProgress:
                  case RootFatalErrored:
                    throw Error("Root did not complete. This is a bug in React.");
                  case RootSuspendedWithDelay:
                    if ((lanes & 4194048) !== lanes) break;
                  case RootSuspendedAtTheShell:
                    setCurrentTrackFromLanes(lanes);
                    logSuspendedRenderPhase(
                      renderStartTime,
                      yieldedFiber,
                      lanes,
                      workInProgressUpdateTask
                    );
                    finalizeRender(lanes, yieldedFiber);
                    yieldEndTime = lanes;
                    0 !== (yieldEndTime & 127) ? blockingSuspendedTime = yieldedFiber : 0 !== (yieldEndTime & 4194048) && (transitionSuspendedTime = yieldedFiber);
                    markRootSuspended(
                      forceSync,
                      lanes,
                      workInProgressDeferredLane,
                      !workInProgressRootDidSkipSuspendedSiblings
                    );
                    break a;
                  case RootErrored:
                    workInProgressRootRecoverableErrors = null;
                    break;
                  case RootSuspended:
                  case RootCompleted:
                    break;
                  default:
                    throw Error("Unknown root exit status.");
                }
                if (null !== ReactSharedInternals.actQueue)
                  commitRoot(
                    forceSync,
                    yieldEndTime,
                    lanes,
                    workInProgressRootRecoverableErrors,
                    workInProgressTransitions,
                    workInProgressRootDidIncludeRecursiveRenderUpdate,
                    workInProgressDeferredLane,
                    workInProgressRootInterleavedUpdatedLanes,
                    workInProgressSuspendedRetryLanes,
                    startTime,
                    null,
                    null,
                    renderStartTime,
                    yieldedFiber
                  );
                else {
                  if ((lanes & 62914560) === lanes && (renderWasConcurrent = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now$1(), 10 < renderWasConcurrent)) {
                    markRootSuspended(
                      forceSync,
                      lanes,
                      workInProgressDeferredLane,
                      !workInProgressRootDidSkipSuspendedSiblings
                    );
                    if (0 !== getNextLanes(forceSync, 0, true)) break a;
                    pendingEffectsLanes = lanes;
                    forceSync.timeoutHandle = scheduleTimeout(
                      commitRootWhenReady.bind(
                        null,
                        forceSync,
                        yieldEndTime,
                        workInProgressRootRecoverableErrors,
                        workInProgressTransitions,
                        workInProgressRootDidIncludeRecursiveRenderUpdate,
                        lanes,
                        workInProgressDeferredLane,
                        workInProgressRootInterleavedUpdatedLanes,
                        workInProgressSuspendedRetryLanes,
                        workInProgressRootDidSkipSuspendedSiblings,
                        startTime,
                        "Throttled",
                        renderStartTime,
                        yieldedFiber
                      ),
                      renderWasConcurrent
                    );
                    break a;
                  }
                  commitRootWhenReady(
                    forceSync,
                    yieldEndTime,
                    workInProgressRootRecoverableErrors,
                    workInProgressTransitions,
                    workInProgressRootDidIncludeRecursiveRenderUpdate,
                    lanes,
                    workInProgressDeferredLane,
                    workInProgressRootInterleavedUpdatedLanes,
                    workInProgressSuspendedRetryLanes,
                    workInProgressRootDidSkipSuspendedSiblings,
                    startTime,
                    null,
                    renderStartTime,
                    yieldedFiber
                  );
                }
              }
            }
            break;
          } while (1);
          ensureRootIsScheduled(root2);
        }
        function commitRootWhenReady(root2, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
          root2.timeoutHandle = noTimeout;
          var subtreeFlags = finishedWork.subtreeFlags, suspendedState = null;
          if (subtreeFlags & 8192 || 16785408 === (subtreeFlags & 16785408)) {
            if (suspendedState = {
              stylesheets: null,
              count: 0,
              imgCount: 0,
              imgBytes: 0,
              suspenseyImages: [],
              waitingForImages: true,
              waitingForViewTransition: false,
              unsuspend: noop$1
            }, accumulateSuspenseyCommitOnFiber(finishedWork, lanes, suspendedState), subtreeFlags = (lanes & 62914560) === lanes ? globalMostRecentFallbackTime - now$1() : (lanes & 4194048) === lanes ? globalMostRecentTransitionTime - now$1() : 0, subtreeFlags = waitForCommitToBeReady(suspendedState, subtreeFlags), null !== subtreeFlags) {
              pendingEffectsLanes = lanes;
              root2.cancelPendingCommit = subtreeFlags(
                commitRoot.bind(
                  null,
                  root2,
                  finishedWork,
                  lanes,
                  recoverableErrors,
                  transitions,
                  didIncludeRenderPhaseUpdate,
                  spawnedLane,
                  updatedLanes,
                  suspendedRetryLanes,
                  exitStatus,
                  suspendedState,
                  suspendedState.waitingForViewTransition ? "Waiting for the previous Animation" : 0 < suspendedState.count ? 0 < suspendedState.imgCount ? "Suspended on CSS and Images" : "Suspended on CSS" : 1 === suspendedState.imgCount ? "Suspended on an Image" : 0 < suspendedState.imgCount ? "Suspended on Images" : null,
                  completedRenderStartTime,
                  completedRenderEndTime
                )
              );
              markRootSuspended(
                root2,
                lanes,
                spawnedLane,
                !didSkipSuspendedSiblings
              );
              return;
            }
          }
          commitRoot(
            root2,
            finishedWork,
            lanes,
            recoverableErrors,
            transitions,
            didIncludeRenderPhaseUpdate,
            spawnedLane,
            updatedLanes,
            suspendedRetryLanes,
            exitStatus,
            suspendedState,
            suspendedCommitReason,
            completedRenderStartTime,
            completedRenderEndTime
          );
        }
        function isRenderConsistentWithExternalStores(finishedWork) {
          for (var node = finishedWork; ; ) {
            var tag = node.tag;
            if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag)))
              for (var i8 = 0; i8 < tag.length; i8++) {
                var check = tag[i8], getSnapshot = check.getSnapshot;
                check = check.value;
                try {
                  if (!objectIs(getSnapshot(), check)) return false;
                } catch (error) {
                  return false;
                }
              }
            tag = node.child;
            if (node.subtreeFlags & 16384 && null !== tag)
              tag.return = node, node = tag;
            else {
              if (node === finishedWork) break;
              for (; null === node.sibling; ) {
                if (null === node.return || node.return === finishedWork) return true;
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
          }
          return true;
        }
        function markRootSuspended(root2, suspendedLanes, spawnedLane, didAttemptEntireTree) {
          suspendedLanes &= ~workInProgressRootPingedLanes;
          suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
          root2.suspendedLanes |= suspendedLanes;
          root2.pingedLanes &= ~suspendedLanes;
          didAttemptEntireTree && (root2.warmLanes |= suspendedLanes);
          didAttemptEntireTree = root2.expirationTimes;
          for (var lanes = suspendedLanes; 0 < lanes; ) {
            var index = 31 - clz32(lanes), lane = 1 << index;
            didAttemptEntireTree[index] = -1;
            lanes &= ~lane;
          }
          0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, suspendedLanes);
        }
        function flushSyncWork$1() {
          return (executionContext & (RenderContext | CommitContext)) === NoContext ? (flushSyncWorkAcrossRoots_impl(0, false), false) : true;
        }
        function resetWorkInProgressStack() {
          if (null !== workInProgress) {
            if (workInProgressSuspendedReason === NotSuspended)
              var interruptedWork = workInProgress.return;
            else
              interruptedWork = workInProgress, resetContextDependencies(), resetHooksOnUnwind(interruptedWork), thenableState$1 = null, thenableIndexCounter$1 = 0, interruptedWork = workInProgress;
            for (; null !== interruptedWork; )
              unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
            workInProgress = null;
          }
        }
        function finalizeRender(lanes, finalizationTime) {
          0 !== (lanes & 127) && (blockingClampTime = finalizationTime);
          0 !== (lanes & 4194048) && (transitionClampTime = finalizationTime);
          0 !== (lanes & 62914560) && (retryClampTime = finalizationTime);
          0 !== (lanes & 2080374784) && (idleClampTime = finalizationTime);
        }
        function prepareFreshStack(root2, lanes) {
          supportsUserTiming && (console.timeStamp(
            "Blocking Track",
            3e-3,
            3e-3,
            "Blocking",
            LANES_TRACK_GROUP,
            "primary-light"
          ), console.timeStamp(
            "Transition Track",
            3e-3,
            3e-3,
            "Transition",
            LANES_TRACK_GROUP,
            "primary-light"
          ), console.timeStamp(
            "Suspense Track",
            3e-3,
            3e-3,
            "Suspense",
            LANES_TRACK_GROUP,
            "primary-light"
          ), console.timeStamp(
            "Idle Track",
            3e-3,
            3e-3,
            "Idle",
            LANES_TRACK_GROUP,
            "primary-light"
          ));
          var previousRenderStartTime = renderStartTime;
          renderStartTime = now();
          if (0 !== workInProgressRootRenderLanes && 0 < previousRenderStartTime) {
            setCurrentTrackFromLanes(workInProgressRootRenderLanes);
            if (workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootSuspendedWithDelay)
              logSuspendedRenderPhase(
                previousRenderStartTime,
                renderStartTime,
                lanes,
                workInProgressUpdateTask
              );
            else {
              var endTime = renderStartTime, debugTask = workInProgressUpdateTask;
              if (supportsUserTiming && !(endTime <= previousRenderStartTime)) {
                var color = (lanes & 738197653) === lanes ? "tertiary-dark" : "primary-dark", label = (lanes & 536870912) === lanes ? "Prewarm" : (lanes & 201326741) === lanes ? "Interrupted Hydration" : "Interrupted Render";
                debugTask ? debugTask.run(
                  console.timeStamp.bind(
                    console,
                    label,
                    previousRenderStartTime,
                    endTime,
                    currentTrack,
                    LANES_TRACK_GROUP,
                    color
                  )
                ) : console.timeStamp(
                  label,
                  previousRenderStartTime,
                  endTime,
                  currentTrack,
                  LANES_TRACK_GROUP,
                  color
                );
              }
            }
            finalizeRender(workInProgressRootRenderLanes, renderStartTime);
          }
          previousRenderStartTime = workInProgressUpdateTask;
          workInProgressUpdateTask = null;
          if (0 !== (lanes & 127)) {
            workInProgressUpdateTask = blockingUpdateTask;
            debugTask = 0 <= blockingUpdateTime && blockingUpdateTime < blockingClampTime ? blockingClampTime : blockingUpdateTime;
            endTime = 0 <= blockingEventTime && blockingEventTime < blockingClampTime ? blockingClampTime : blockingEventTime;
            color = 0 <= endTime ? endTime : 0 <= debugTask ? debugTask : renderStartTime;
            0 <= blockingSuspendedTime ? (setCurrentTrackFromLanes(2), logSuspendedWithDelayPhase(
              blockingSuspendedTime,
              color,
              lanes,
              previousRenderStartTime
            )) : 0 !== (animatingLanes & 127) && (setCurrentTrackFromLanes(2), logAnimatingPhase(blockingClampTime, color, animatingTask));
            previousRenderStartTime = debugTask;
            var eventTime = endTime, eventType = blockingEventType, eventIsRepeat = 0 < blockingEventRepeatTime, isSpawnedUpdate = blockingUpdateType === SPAWNED_UPDATE, isPingedUpdate = blockingUpdateType === PINGED_UPDATE;
            debugTask = renderStartTime;
            endTime = blockingUpdateTask;
            color = blockingUpdateMethodName;
            label = blockingUpdateComponentName;
            if (supportsUserTiming) {
              currentTrack = "Blocking";
              0 < previousRenderStartTime ? previousRenderStartTime > debugTask && (previousRenderStartTime = debugTask) : previousRenderStartTime = debugTask;
              0 < eventTime ? eventTime > previousRenderStartTime && (eventTime = previousRenderStartTime) : eventTime = previousRenderStartTime;
              if (null !== eventType && previousRenderStartTime > eventTime) {
                var color$jscomp$0 = eventIsRepeat ? "secondary-light" : "warning";
                endTime ? endTime.run(
                  console.timeStamp.bind(
                    console,
                    eventIsRepeat ? "Consecutive" : "Event: " + eventType,
                    eventTime,
                    previousRenderStartTime,
                    currentTrack,
                    LANES_TRACK_GROUP,
                    color$jscomp$0
                  )
                ) : console.timeStamp(
                  eventIsRepeat ? "Consecutive" : "Event: " + eventType,
                  eventTime,
                  previousRenderStartTime,
                  currentTrack,
                  LANES_TRACK_GROUP,
                  color$jscomp$0
                );
              }
              debugTask > previousRenderStartTime && (eventTime = isSpawnedUpdate ? "error" : (lanes & 738197653) === lanes ? "tertiary-light" : "primary-light", isSpawnedUpdate = isPingedUpdate ? "Promise Resolved" : isSpawnedUpdate ? "Cascading Update" : 5 < debugTask - previousRenderStartTime ? "Update Blocked" : "Update", isPingedUpdate = [], null != label && isPingedUpdate.push(["Component name", label]), null != color && isPingedUpdate.push(["Method name", color]), previousRenderStartTime = {
                start: previousRenderStartTime,
                end: debugTask,
                detail: {
                  devtools: {
                    properties: isPingedUpdate,
                    track: currentTrack,
                    trackGroup: LANES_TRACK_GROUP,
                    color: eventTime
                  }
                }
              }, endTime ? endTime.run(
                performance.measure.bind(
                  performance,
                  isSpawnedUpdate,
                  previousRenderStartTime
                )
              ) : performance.measure(isSpawnedUpdate, previousRenderStartTime));
            }
            blockingUpdateTime = -1.1;
            blockingUpdateType = 0;
            blockingUpdateComponentName = blockingUpdateMethodName = null;
            blockingSuspendedTime = -1.1;
            blockingEventRepeatTime = blockingEventTime;
            blockingEventTime = -1.1;
            blockingClampTime = now();
          }
          0 !== (lanes & 4194048) && (workInProgressUpdateTask = transitionUpdateTask, debugTask = 0 <= transitionStartTime && transitionStartTime < transitionClampTime ? transitionClampTime : transitionStartTime, previousRenderStartTime = 0 <= transitionUpdateTime && transitionUpdateTime < transitionClampTime ? transitionClampTime : transitionUpdateTime, endTime = 0 <= transitionEventTime && transitionEventTime < transitionClampTime ? transitionClampTime : transitionEventTime, color = 0 <= endTime ? endTime : 0 <= previousRenderStartTime ? previousRenderStartTime : renderStartTime, 0 <= transitionSuspendedTime ? (setCurrentTrackFromLanes(256), logSuspendedWithDelayPhase(
            transitionSuspendedTime,
            color,
            lanes,
            workInProgressUpdateTask
          )) : 0 !== (animatingLanes & 4194048) && (setCurrentTrackFromLanes(256), logAnimatingPhase(transitionClampTime, color, animatingTask)), isPingedUpdate = endTime, eventTime = transitionEventType, eventType = 0 < transitionEventRepeatTime, eventIsRepeat = transitionUpdateType === PINGED_UPDATE, color = renderStartTime, endTime = transitionUpdateTask, label = transitionUpdateMethodName, isSpawnedUpdate = transitionUpdateComponentName, supportsUserTiming && (currentTrack = "Transition", 0 < previousRenderStartTime ? previousRenderStartTime > color && (previousRenderStartTime = color) : previousRenderStartTime = color, 0 < debugTask ? debugTask > previousRenderStartTime && (debugTask = previousRenderStartTime) : debugTask = previousRenderStartTime, 0 < isPingedUpdate ? isPingedUpdate > debugTask && (isPingedUpdate = debugTask) : isPingedUpdate = debugTask, debugTask > isPingedUpdate && null !== eventTime && (color$jscomp$0 = eventType ? "secondary-light" : "warning", endTime ? endTime.run(
            console.timeStamp.bind(
              console,
              eventType ? "Consecutive" : "Event: " + eventTime,
              isPingedUpdate,
              debugTask,
              currentTrack,
              LANES_TRACK_GROUP,
              color$jscomp$0
            )
          ) : console.timeStamp(
            eventType ? "Consecutive" : "Event: " + eventTime,
            isPingedUpdate,
            debugTask,
            currentTrack,
            LANES_TRACK_GROUP,
            color$jscomp$0
          )), previousRenderStartTime > debugTask && (endTime ? endTime.run(
            console.timeStamp.bind(
              console,
              "Action",
              debugTask,
              previousRenderStartTime,
              currentTrack,
              LANES_TRACK_GROUP,
              "primary-dark"
            )
          ) : console.timeStamp(
            "Action",
            debugTask,
            previousRenderStartTime,
            currentTrack,
            LANES_TRACK_GROUP,
            "primary-dark"
          )), color > previousRenderStartTime && (debugTask = eventIsRepeat ? "Promise Resolved" : 5 < color - previousRenderStartTime ? "Update Blocked" : "Update", isPingedUpdate = [], null != isSpawnedUpdate && isPingedUpdate.push(["Component name", isSpawnedUpdate]), null != label && isPingedUpdate.push(["Method name", label]), previousRenderStartTime = {
            start: previousRenderStartTime,
            end: color,
            detail: {
              devtools: {
                properties: isPingedUpdate,
                track: currentTrack,
                trackGroup: LANES_TRACK_GROUP,
                color: "primary-light"
              }
            }
          }, endTime ? endTime.run(
            performance.measure.bind(
              performance,
              debugTask,
              previousRenderStartTime
            )
          ) : performance.measure(debugTask, previousRenderStartTime))), transitionUpdateTime = transitionStartTime = -1.1, transitionUpdateType = 0, transitionSuspendedTime = -1.1, transitionEventRepeatTime = transitionEventTime, transitionEventTime = -1.1, transitionClampTime = now());
          0 !== (lanes & 62914560) && 0 !== (animatingLanes & 62914560) && (setCurrentTrackFromLanes(4194304), logAnimatingPhase(retryClampTime, renderStartTime, animatingTask));
          0 !== (lanes & 2080374784) && 0 !== (animatingLanes & 2080374784) && (setCurrentTrackFromLanes(268435456), logAnimatingPhase(idleClampTime, renderStartTime, animatingTask));
          previousRenderStartTime = root2.timeoutHandle;
          previousRenderStartTime !== noTimeout && (root2.timeoutHandle = noTimeout, cancelTimeout(previousRenderStartTime));
          previousRenderStartTime = root2.cancelPendingCommit;
          null !== previousRenderStartTime && (root2.cancelPendingCommit = null, previousRenderStartTime());
          pendingEffectsLanes = 0;
          resetWorkInProgressStack();
          workInProgressRoot = root2;
          workInProgress = previousRenderStartTime = createWorkInProgress(
            root2.current,
            null
          );
          workInProgressRootRenderLanes = lanes;
          workInProgressSuspendedReason = NotSuspended;
          workInProgressThrownValue = null;
          workInProgressRootDidSkipSuspendedSiblings = false;
          workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root2, lanes);
          workInProgressRootDidAttachPingListener = false;
          workInProgressRootExitStatus = RootInProgress;
          workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = 0;
          workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
          workInProgressRootDidIncludeRecursiveRenderUpdate = false;
          0 !== (lanes & 8) && (lanes |= lanes & 32);
          endTime = root2.entangledLanes;
          if (0 !== endTime)
            for (root2 = root2.entanglements, endTime &= lanes; 0 < endTime; )
              debugTask = 31 - clz32(endTime), color = 1 << debugTask, lanes |= root2[debugTask], endTime &= ~color;
          entangledRenderLanes = lanes;
          finishQueueingConcurrentUpdates();
          root2 = getCurrentTime();
          1e3 < root2 - lastResetTime && (ReactSharedInternals.recentlyCreatedOwnerStacks = 0, lastResetTime = root2);
          ReactStrictModeWarnings.discardPendingWarnings();
          return previousRenderStartTime;
        }
        function handleThrow(root2, thrownValue) {
          currentlyRenderingFiber = null;
          ReactSharedInternals.H = ContextOnlyDispatcher;
          ReactSharedInternals.getCurrentStack = null;
          isRendering = false;
          current = null;
          thrownValue === SuspenseException || thrownValue === SuspenseActionException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnImmediate) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnInstance) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? SuspendedOnHydration : null !== thrownValue && "object" === typeof thrownValue && "function" === typeof thrownValue.then ? SuspendedOnDeprecatedThrowPromise : SuspendedOnError;
          workInProgressThrownValue = thrownValue;
          var erroredWork = workInProgress;
          null === erroredWork ? (workInProgressRootExitStatus = RootFatalErrored, logUncaughtError(
            root2,
            createCapturedValueAtFiber(thrownValue, root2.current)
          )) : erroredWork.mode & ProfileMode && stopProfilerTimerIfRunningAndRecordDuration(erroredWork);
        }
        function shouldRemainOnPreviousScreen() {
          var handler = suspenseHandlerStackCursor.current;
          return null === handler ? true : (workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes ? null === shellBoundary ? true : false : (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes || 0 !== (workInProgressRootRenderLanes & 536870912) ? handler === shellBoundary : false;
        }
        function pushDispatcher() {
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = ContextOnlyDispatcher;
          return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
        }
        function pushAsyncDispatcher() {
          var prevAsyncDispatcher = ReactSharedInternals.A;
          ReactSharedInternals.A = DefaultAsyncDispatcher;
          return prevAsyncDispatcher;
        }
        function markRenderDerivedCause(fiber) {
          null === workInProgressUpdateTask && (workInProgressUpdateTask = null == fiber._debugTask ? null : fiber._debugTask);
        }
        function renderDidSuspendDelayIfPossible() {
          workInProgressRootExitStatus = RootSuspendedWithDelay;
          workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = true);
          0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(
            workInProgressRoot,
            workInProgressRootRenderLanes,
            workInProgressDeferredLane,
            false
          );
        }
        function renderRootSync(root2, lanes, shouldYieldForPrerendering) {
          var prevExecutionContext = executionContext;
          executionContext |= RenderContext;
          var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
          if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
            if (isDevToolsPresent) {
              var memoizedUpdaters = root2.memoizedUpdaters;
              0 < memoizedUpdaters.size && (restorePendingUpdaters(root2, workInProgressRootRenderLanes), memoizedUpdaters.clear());
              movePendingFibersToMemoized(root2, lanes);
            }
            workInProgressTransitions = null;
            prepareFreshStack(root2, lanes);
          }
          lanes = false;
          memoizedUpdaters = workInProgressRootExitStatus;
          a: do
            try {
              if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress) {
                var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;
                switch (workInProgressSuspendedReason) {
                  case SuspendedOnHydration:
                    resetWorkInProgressStack();
                    memoizedUpdaters = RootSuspendedAtTheShell;
                    break a;
                  case SuspendedOnImmediate:
                  case SuspendedOnData:
                  case SuspendedOnAction:
                  case SuspendedOnDeprecatedThrowPromise:
                    null === suspenseHandlerStackCursor.current && (lanes = true);
                    var reason = workInProgressSuspendedReason;
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
                    if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
                      memoizedUpdaters = RootInProgress;
                      break a;
                    }
                    break;
                  default:
                    reason = workInProgressSuspendedReason, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
                }
              }
              workLoopSync();
              memoizedUpdaters = workInProgressRootExitStatus;
              break;
            } catch (thrownValue$8) {
              handleThrow(root2, thrownValue$8);
            }
          while (1);
          lanes && root2.shellSuspendCounter++;
          resetContextDependencies();
          executionContext = prevExecutionContext;
          ReactSharedInternals.H = prevDispatcher;
          ReactSharedInternals.A = prevAsyncDispatcher;
          null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
          return memoizedUpdaters;
        }
        function workLoopSync() {
          for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
        }
        function renderRootConcurrent(root2, lanes) {
          var prevExecutionContext = executionContext;
          executionContext |= RenderContext;
          var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
          if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
            if (isDevToolsPresent) {
              var memoizedUpdaters = root2.memoizedUpdaters;
              0 < memoizedUpdaters.size && (restorePendingUpdaters(root2, workInProgressRootRenderLanes), memoizedUpdaters.clear());
              movePendingFibersToMemoized(root2, lanes);
            }
            workInProgressTransitions = null;
            workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS;
            prepareFreshStack(root2, lanes);
          } else
            workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
              root2,
              lanes
            );
          a: do
            try {
              if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress)
                b: switch (lanes = workInProgress, memoizedUpdaters = workInProgressThrownValue, workInProgressSuspendedReason) {
                  case SuspendedOnError:
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(
                      root2,
                      lanes,
                      memoizedUpdaters,
                      SuspendedOnError
                    );
                    break;
                  case SuspendedOnData:
                  case SuspendedOnAction:
                    if (isThenableResolved(memoizedUpdaters)) {
                      workInProgressSuspendedReason = NotSuspended;
                      workInProgressThrownValue = null;
                      replaySuspendedUnitOfWork(lanes);
                      break;
                    }
                    lanes = function() {
                      workInProgressSuspendedReason !== SuspendedOnData && workInProgressSuspendedReason !== SuspendedOnAction || workInProgressRoot !== root2 || (workInProgressSuspendedReason = SuspendedAndReadyToContinue);
                      ensureRootIsScheduled(root2);
                    };
                    memoizedUpdaters.then(lanes, lanes);
                    break a;
                  case SuspendedOnImmediate:
                    workInProgressSuspendedReason = SuspendedAndReadyToContinue;
                    break a;
                  case SuspendedOnInstance:
                    workInProgressSuspendedReason = SuspendedOnInstanceAndReadyToContinue;
                    break a;
                  case SuspendedAndReadyToContinue:
                    isThenableResolved(memoizedUpdaters) ? (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(
                      root2,
                      lanes,
                      memoizedUpdaters,
                      SuspendedAndReadyToContinue
                    ));
                    break;
                  case SuspendedOnInstanceAndReadyToContinue:
                    var resource = null;
                    switch (workInProgress.tag) {
                      case 26:
                        resource = workInProgress.memoizedState;
                      case 5:
                      case 27:
                        var hostFiber = workInProgress;
                        if (resource ? preloadResource(resource) : hostFiber.stateNode.complete) {
                          workInProgressSuspendedReason = NotSuspended;
                          workInProgressThrownValue = null;
                          var sibling = hostFiber.sibling;
                          if (null !== sibling) workInProgress = sibling;
                          else {
                            var returnFiber = hostFiber.return;
                            null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
                          }
                          break b;
                        }
                        break;
                      default:
                        console.error(
                          "Unexpected type of fiber triggered a suspensey commit. This is a bug in React."
                        );
                    }
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(
                      root2,
                      lanes,
                      memoizedUpdaters,
                      SuspendedOnInstanceAndReadyToContinue
                    );
                    break;
                  case SuspendedOnDeprecatedThrowPromise:
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(
                      root2,
                      lanes,
                      memoizedUpdaters,
                      SuspendedOnDeprecatedThrowPromise
                    );
                    break;
                  case SuspendedOnHydration:
                    resetWorkInProgressStack();
                    workInProgressRootExitStatus = RootSuspendedAtTheShell;
                    break a;
                  default:
                    throw Error(
                      "Unexpected SuspendedReason. This is a bug in React."
                    );
                }
              null !== ReactSharedInternals.actQueue ? workLoopSync() : workLoopConcurrentByScheduler();
              break;
            } catch (thrownValue$9) {
              handleThrow(root2, thrownValue$9);
            }
          while (1);
          resetContextDependencies();
          ReactSharedInternals.H = prevDispatcher;
          ReactSharedInternals.A = prevAsyncDispatcher;
          executionContext = prevExecutionContext;
          if (null !== workInProgress) return RootInProgress;
          workInProgressRoot = null;
          workInProgressRootRenderLanes = 0;
          finishQueueingConcurrentUpdates();
          return workInProgressRootExitStatus;
        }
        function workLoopConcurrentByScheduler() {
          for (; null !== workInProgress && !shouldYield(); )
            performUnitOfWork(workInProgress);
        }
        function performUnitOfWork(unitOfWork) {
          var current2 = unitOfWork.alternate;
          (unitOfWork.mode & ProfileMode) !== NoMode ? (startProfilerTimer(unitOfWork), current2 = runWithFiberInDEV(
            unitOfWork,
            beginWork,
            current2,
            unitOfWork,
            entangledRenderLanes
          ), stopProfilerTimerIfRunningAndRecordDuration(unitOfWork)) : current2 = runWithFiberInDEV(
            unitOfWork,
            beginWork,
            current2,
            unitOfWork,
            entangledRenderLanes
          );
          unitOfWork.memoizedProps = unitOfWork.pendingProps;
          null === current2 ? completeUnitOfWork(unitOfWork) : workInProgress = current2;
        }
        function replaySuspendedUnitOfWork(unitOfWork) {
          var next = runWithFiberInDEV(unitOfWork, replayBeginWork, unitOfWork);
          unitOfWork.memoizedProps = unitOfWork.pendingProps;
          null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
        }
        function replayBeginWork(unitOfWork) {
          var current2 = unitOfWork.alternate, isProfilingMode = (unitOfWork.mode & ProfileMode) !== NoMode;
          isProfilingMode && startProfilerTimer(unitOfWork);
          switch (unitOfWork.tag) {
            case 15:
            case 0:
              current2 = replayFunctionComponent(
                current2,
                unitOfWork,
                unitOfWork.pendingProps,
                unitOfWork.type,
                void 0,
                workInProgressRootRenderLanes
              );
              break;
            case 11:
              current2 = replayFunctionComponent(
                current2,
                unitOfWork,
                unitOfWork.pendingProps,
                unitOfWork.type.render,
                unitOfWork.ref,
                workInProgressRootRenderLanes
              );
              break;
            case 5:
              resetHooksOnUnwind(unitOfWork);
            default:
              unwindInterruptedWork(current2, unitOfWork), unitOfWork = workInProgress = resetWorkInProgress(unitOfWork, entangledRenderLanes), current2 = beginWork(current2, unitOfWork, entangledRenderLanes);
          }
          isProfilingMode && stopProfilerTimerIfRunningAndRecordDuration(unitOfWork);
          return current2;
        }
        function throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, suspendedReason) {
          resetContextDependencies();
          resetHooksOnUnwind(unitOfWork);
          thenableState$1 = null;
          thenableIndexCounter$1 = 0;
          var returnFiber = unitOfWork.return;
          try {
            if (throwException(
              root2,
              returnFiber,
              unitOfWork,
              thrownValue,
              workInProgressRootRenderLanes
            )) {
              workInProgressRootExitStatus = RootFatalErrored;
              logUncaughtError(
                root2,
                createCapturedValueAtFiber(thrownValue, root2.current)
              );
              workInProgress = null;
              return;
            }
          } catch (error) {
            if (null !== returnFiber) throw workInProgress = returnFiber, error;
            workInProgressRootExitStatus = RootFatalErrored;
            logUncaughtError(
              root2,
              createCapturedValueAtFiber(thrownValue, root2.current)
            );
            workInProgress = null;
            return;
          }
          if (unitOfWork.flags & 32768) {
            if (isHydrating || suspendedReason === SuspendedOnError) root2 = true;
            else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912))
              root2 = false;
            else if (workInProgressRootDidSkipSuspendedSiblings = root2 = true, suspendedReason === SuspendedOnData || suspendedReason === SuspendedOnAction || suspendedReason === SuspendedOnImmediate || suspendedReason === SuspendedOnDeprecatedThrowPromise)
              suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);
            unwindUnitOfWork(unitOfWork, root2);
          } else completeUnitOfWork(unitOfWork);
        }
        function completeUnitOfWork(unitOfWork) {
          var completedWork = unitOfWork;
          do {
            if (0 !== (completedWork.flags & 32768)) {
              unwindUnitOfWork(
                completedWork,
                workInProgressRootDidSkipSuspendedSiblings
              );
              return;
            }
            var current2 = completedWork.alternate;
            unitOfWork = completedWork.return;
            startProfilerTimer(completedWork);
            current2 = runWithFiberInDEV(
              completedWork,
              completeWork,
              current2,
              completedWork,
              entangledRenderLanes
            );
            (completedWork.mode & ProfileMode) !== NoMode && stopProfilerTimerIfRunningAndRecordIncompleteDuration(completedWork);
            if (null !== current2) {
              workInProgress = current2;
              return;
            }
            completedWork = completedWork.sibling;
            if (null !== completedWork) {
              workInProgress = completedWork;
              return;
            }
            workInProgress = completedWork = unitOfWork;
          } while (null !== completedWork);
          workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootCompleted);
        }
        function unwindUnitOfWork(unitOfWork, skipSiblings) {
          do {
            var next = unwindWork(unitOfWork.alternate, unitOfWork);
            if (null !== next) {
              next.flags &= 32767;
              workInProgress = next;
              return;
            }
            if ((unitOfWork.mode & ProfileMode) !== NoMode) {
              stopProfilerTimerIfRunningAndRecordIncompleteDuration(unitOfWork);
              next = unitOfWork.actualDuration;
              for (var child = unitOfWork.child; null !== child; )
                next += child.actualDuration, child = child.sibling;
              unitOfWork.actualDuration = next;
            }
            next = unitOfWork.return;
            null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);
            if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {
              workInProgress = unitOfWork;
              return;
            }
            workInProgress = unitOfWork = next;
          } while (null !== unitOfWork);
          workInProgressRootExitStatus = RootSuspendedAtTheShell;
          workInProgress = null;
        }
        function commitRoot(root2, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, exitStatus, suspendedState, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
          root2.cancelPendingCommit = null;
          do
            flushPendingEffects();
          while (pendingEffectsStatus !== NO_PENDING_EFFECTS);
          ReactStrictModeWarnings.flushLegacyContextWarning();
          ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
            throw Error("Should not already be working.");
          setCurrentTrackFromLanes(lanes);
          exitStatus === RootErrored ? logErroredRenderPhase(
            completedRenderStartTime,
            completedRenderEndTime,
            lanes,
            workInProgressUpdateTask
          ) : null !== recoverableErrors ? logRecoveredRenderPhase(
            completedRenderStartTime,
            completedRenderEndTime,
            lanes,
            recoverableErrors,
            null !== finishedWork && null !== finishedWork.alternate && finishedWork.alternate.memoizedState.isDehydrated && 0 !== (finishedWork.flags & 256),
            workInProgressUpdateTask
          ) : logRenderPhase(
            completedRenderStartTime,
            completedRenderEndTime,
            lanes,
            workInProgressUpdateTask
          );
          if (null !== finishedWork) {
            0 === lanes && console.error(
              "finishedLanes should not be empty during a commit. This is a bug in React."
            );
            if (finishedWork === root2.current)
              throw Error(
                "Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue."
              );
            didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
            didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
            markRootFinished(
              root2,
              lanes,
              didIncludeRenderPhaseUpdate,
              spawnedLane,
              updatedLanes,
              suspendedRetryLanes
            );
            root2 === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
            pendingFinishedWork = finishedWork;
            pendingEffectsRoot = root2;
            pendingEffectsLanes = lanes;
            pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
            pendingPassiveTransitions = transitions;
            pendingRecoverableErrors = recoverableErrors;
            pendingEffectsRenderEndTime = completedRenderEndTime;
            pendingSuspendedCommitReason = suspendedCommitReason;
            pendingDelayedCommitReason = IMMEDIATE_COMMIT;
            pendingSuspendedViewTransitionReason = null;
            0 !== finishedWork.actualDuration || 0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? (root2.callbackNode = null, root2.callbackPriority = 0, scheduleCallback$1(NormalPriority$1, function() {
              schedulerEvent = window.event;
              pendingDelayedCommitReason === IMMEDIATE_COMMIT && (pendingDelayedCommitReason = DELAYED_PASSIVE_COMMIT);
              flushPassiveEffects();
              return null;
            })) : (root2.callbackNode = null, root2.callbackPriority = 0);
            commitErrors = null;
            commitStartTime = now();
            null !== suspendedCommitReason && logSuspendedCommitPhase(
              completedRenderEndTime,
              commitStartTime,
              suspendedCommitReason,
              workInProgressUpdateTask
            );
            recoverableErrors = 0 !== (finishedWork.flags & 13878);
            if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
              recoverableErrors = ReactSharedInternals.T;
              ReactSharedInternals.T = null;
              transitions = ReactDOMSharedInternals.p;
              ReactDOMSharedInternals.p = DiscreteEventPriority;
              spawnedLane = executionContext;
              executionContext |= CommitContext;
              try {
                commitBeforeMutationEffects(root2, finishedWork, lanes);
              } finally {
                executionContext = spawnedLane, ReactDOMSharedInternals.p = transitions, ReactSharedInternals.T = recoverableErrors;
              }
            }
            pendingEffectsStatus = PENDING_MUTATION_PHASE;
            flushMutationEffects();
            flushLayoutEffects();
            flushSpawnedWork();
          }
        }
        function flushMutationEffects() {
          if (pendingEffectsStatus === PENDING_MUTATION_PHASE) {
            pendingEffectsStatus = NO_PENDING_EFFECTS;
            var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
            if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
              rootMutationHasEffect = ReactSharedInternals.T;
              ReactSharedInternals.T = null;
              var previousPriority = ReactDOMSharedInternals.p;
              ReactDOMSharedInternals.p = DiscreteEventPriority;
              var prevExecutionContext = executionContext;
              executionContext |= CommitContext;
              try {
                inProgressLanes = lanes;
                inProgressRoot = root2;
                resetComponentEffectTimers();
                commitMutationEffectsOnFiber(finishedWork, root2);
                inProgressRoot = inProgressLanes = null;
                lanes = selectionInformation;
                var curFocusedElem = getActiveElementDeep(root2.containerInfo), priorFocusedElem = lanes.focusedElem, priorSelectionRange = lanes.selectionRange;
                if (curFocusedElem !== priorFocusedElem && priorFocusedElem && priorFocusedElem.ownerDocument && containsNode(
                  priorFocusedElem.ownerDocument.documentElement,
                  priorFocusedElem
                )) {
                  if (null !== priorSelectionRange && hasSelectionCapabilities(priorFocusedElem)) {
                    var start2 = priorSelectionRange.start, end = priorSelectionRange.end;
                    void 0 === end && (end = start2);
                    if ("selectionStart" in priorFocusedElem)
                      priorFocusedElem.selectionStart = start2, priorFocusedElem.selectionEnd = Math.min(
                        end,
                        priorFocusedElem.value.length
                      );
                    else {
                      var doc = priorFocusedElem.ownerDocument || document, win = doc && doc.defaultView || window;
                      if (win.getSelection) {
                        var selection = win.getSelection(), length = priorFocusedElem.textContent.length, start$jscomp$0 = Math.min(
                          priorSelectionRange.start,
                          length
                        ), end$jscomp$0 = void 0 === priorSelectionRange.end ? start$jscomp$0 : Math.min(priorSelectionRange.end, length);
                        !selection.extend && start$jscomp$0 > end$jscomp$0 && (curFocusedElem = end$jscomp$0, end$jscomp$0 = start$jscomp$0, start$jscomp$0 = curFocusedElem);
                        var startMarker = getNodeForCharacterOffset(
                          priorFocusedElem,
                          start$jscomp$0
                        ), endMarker = getNodeForCharacterOffset(
                          priorFocusedElem,
                          end$jscomp$0
                        );
                        if (startMarker && endMarker && (1 !== selection.rangeCount || selection.anchorNode !== startMarker.node || selection.anchorOffset !== startMarker.offset || selection.focusNode !== endMarker.node || selection.focusOffset !== endMarker.offset)) {
                          var range = doc.createRange();
                          range.setStart(startMarker.node, startMarker.offset);
                          selection.removeAllRanges();
                          start$jscomp$0 > end$jscomp$0 ? (selection.addRange(range), selection.extend(endMarker.node, endMarker.offset)) : (range.setEnd(endMarker.node, endMarker.offset), selection.addRange(range));
                        }
                      }
                    }
                  }
                  doc = [];
                  for (selection = priorFocusedElem; selection = selection.parentNode; )
                    1 === selection.nodeType && doc.push({
                      element: selection,
                      left: selection.scrollLeft,
                      top: selection.scrollTop
                    });
                  "function" === typeof priorFocusedElem.focus && priorFocusedElem.focus();
                  for (priorFocusedElem = 0; priorFocusedElem < doc.length; priorFocusedElem++) {
                    var info = doc[priorFocusedElem];
                    info.element.scrollLeft = info.left;
                    info.element.scrollTop = info.top;
                  }
                }
                _enabled = !!eventsEnabled;
                selectionInformation = eventsEnabled = null;
              } finally {
                executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootMutationHasEffect;
              }
            }
            root2.current = finishedWork;
            pendingEffectsStatus = PENDING_LAYOUT_PHASE;
          }
        }
        function flushLayoutEffects() {
          if (pendingEffectsStatus === PENDING_LAYOUT_PHASE) {
            pendingEffectsStatus = NO_PENDING_EFFECTS;
            var suspendedViewTransitionReason = pendingSuspendedViewTransitionReason;
            if (null !== suspendedViewTransitionReason) {
              commitStartTime = now();
              var startTime = commitEndTime, endTime = commitStartTime;
              !supportsUserTiming || endTime <= startTime || (animatingTask ? animatingTask.run(
                console.timeStamp.bind(
                  console,
                  suspendedViewTransitionReason,
                  startTime,
                  endTime,
                  currentTrack,
                  LANES_TRACK_GROUP,
                  "secondary-light"
                )
              ) : console.timeStamp(
                suspendedViewTransitionReason,
                startTime,
                endTime,
                currentTrack,
                LANES_TRACK_GROUP,
                "secondary-light"
              ));
            }
            suspendedViewTransitionReason = pendingEffectsRoot;
            startTime = pendingFinishedWork;
            endTime = pendingEffectsLanes;
            var rootHasLayoutEffect = 0 !== (startTime.flags & 8772);
            if (0 !== (startTime.subtreeFlags & 8772) || rootHasLayoutEffect) {
              rootHasLayoutEffect = ReactSharedInternals.T;
              ReactSharedInternals.T = null;
              var _previousPriority = ReactDOMSharedInternals.p;
              ReactDOMSharedInternals.p = DiscreteEventPriority;
              var _prevExecutionContext = executionContext;
              executionContext |= CommitContext;
              try {
                inProgressLanes = endTime, inProgressRoot = suspendedViewTransitionReason, resetComponentEffectTimers(), commitLayoutEffectOnFiber(
                  suspendedViewTransitionReason,
                  startTime.alternate,
                  startTime
                ), inProgressRoot = inProgressLanes = null;
              } finally {
                executionContext = _prevExecutionContext, ReactDOMSharedInternals.p = _previousPriority, ReactSharedInternals.T = rootHasLayoutEffect;
              }
            }
            suspendedViewTransitionReason = pendingEffectsRenderEndTime;
            startTime = pendingSuspendedCommitReason;
            commitEndTime = now();
            suspendedViewTransitionReason = null === startTime ? suspendedViewTransitionReason : commitStartTime;
            startTime = commitEndTime;
            endTime = pendingDelayedCommitReason === ABORTED_VIEW_TRANSITION_COMMIT;
            rootHasLayoutEffect = workInProgressUpdateTask;
            null !== commitErrors ? logCommitErrored(
              suspendedViewTransitionReason,
              startTime,
              commitErrors,
              false,
              rootHasLayoutEffect
            ) : !supportsUserTiming || startTime <= suspendedViewTransitionReason || (rootHasLayoutEffect ? rootHasLayoutEffect.run(
              console.timeStamp.bind(
                console,
                endTime ? "Commit Interrupted View Transition" : "Commit",
                suspendedViewTransitionReason,
                startTime,
                currentTrack,
                LANES_TRACK_GROUP,
                endTime ? "error" : "secondary-dark"
              )
            ) : console.timeStamp(
              endTime ? "Commit Interrupted View Transition" : "Commit",
              suspendedViewTransitionReason,
              startTime,
              currentTrack,
              LANES_TRACK_GROUP,
              endTime ? "error" : "secondary-dark"
            ));
            pendingEffectsStatus = PENDING_AFTER_MUTATION_PHASE;
          }
        }
        function flushSpawnedWork() {
          if (pendingEffectsStatus === PENDING_SPAWNED_WORK || pendingEffectsStatus === PENDING_AFTER_MUTATION_PHASE) {
            if (pendingEffectsStatus === PENDING_SPAWNED_WORK) {
              var startViewTransitionStartTime = commitEndTime;
              commitEndTime = now();
              var endTime = commitEndTime, abortedViewTransition = pendingDelayedCommitReason === ABORTED_VIEW_TRANSITION_COMMIT;
              !supportsUserTiming || endTime <= startViewTransitionStartTime || (animatingTask ? animatingTask.run(
                console.timeStamp.bind(
                  console,
                  abortedViewTransition ? "Interrupted View Transition" : "Starting Animation",
                  startViewTransitionStartTime,
                  endTime,
                  currentTrack,
                  LANES_TRACK_GROUP,
                  abortedViewTransition ? "error" : "secondary-light"
                )
              ) : console.timeStamp(
                abortedViewTransition ? "Interrupted View Transition" : "Starting Animation",
                startViewTransitionStartTime,
                endTime,
                currentTrack,
                LANES_TRACK_GROUP,
                abortedViewTransition ? " error" : "secondary-light"
              ));
              pendingDelayedCommitReason !== ABORTED_VIEW_TRANSITION_COMMIT && (pendingDelayedCommitReason = ANIMATION_STARTED_COMMIT);
            }
            pendingEffectsStatus = NO_PENDING_EFFECTS;
            requestPaint();
            startViewTransitionStartTime = pendingEffectsRoot;
            var finishedWork = pendingFinishedWork;
            endTime = pendingEffectsLanes;
            abortedViewTransition = pendingRecoverableErrors;
            var rootDidHavePassiveEffects = 0 !== finishedWork.actualDuration || 0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256);
            rootDidHavePassiveEffects ? pendingEffectsStatus = PENDING_PASSIVE_PHASE : (pendingEffectsStatus = NO_PENDING_EFFECTS, pendingFinishedWork = pendingEffectsRoot = null, releaseRootPooledCache(
              startViewTransitionStartTime,
              startViewTransitionStartTime.pendingLanes
            ), nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null);
            var remainingLanes = startViewTransitionStartTime.pendingLanes;
            0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
            rootDidHavePassiveEffects || commitDoubleInvokeEffectsInDEV(startViewTransitionStartTime);
            remainingLanes = lanesToEventPriority(endTime);
            finishedWork = finishedWork.stateNode;
            if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
              try {
                var didError = 128 === (finishedWork.current.flags & 128);
                switch (remainingLanes) {
                  case DiscreteEventPriority:
                    var schedulerPriority = ImmediatePriority;
                    break;
                  case ContinuousEventPriority:
                    schedulerPriority = UserBlockingPriority;
                    break;
                  case DefaultEventPriority:
                    schedulerPriority = NormalPriority$1;
                    break;
                  case IdleEventPriority:
                    schedulerPriority = IdlePriority;
                    break;
                  default:
                    schedulerPriority = NormalPriority$1;
                }
                injectedHook.onCommitFiberRoot(
                  rendererID,
                  finishedWork,
                  schedulerPriority,
                  didError
                );
              } catch (err) {
                hasLoggedError || (hasLoggedError = true, console.error(
                  "React instrumentation encountered an error: %o",
                  err
                ));
              }
            isDevToolsPresent && startViewTransitionStartTime.memoizedUpdaters.clear();
            onCommitRoot();
            if (null !== abortedViewTransition) {
              didError = ReactSharedInternals.T;
              schedulerPriority = ReactDOMSharedInternals.p;
              ReactDOMSharedInternals.p = DiscreteEventPriority;
              ReactSharedInternals.T = null;
              try {
                var onRecoverableError = startViewTransitionStartTime.onRecoverableError;
                for (finishedWork = 0; finishedWork < abortedViewTransition.length; finishedWork++) {
                  var recoverableError = abortedViewTransition[finishedWork], errorInfo = makeErrorInfo(recoverableError.stack);
                  runWithFiberInDEV(
                    recoverableError.source,
                    onRecoverableError,
                    recoverableError.value,
                    errorInfo
                  );
                }
              } finally {
                ReactSharedInternals.T = didError, ReactDOMSharedInternals.p = schedulerPriority;
              }
            }
            0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
            ensureRootIsScheduled(startViewTransitionStartTime);
            remainingLanes = startViewTransitionStartTime.pendingLanes;
            0 !== (endTime & 261930) && 0 !== (remainingLanes & 42) ? (nestedUpdateScheduled = true, startViewTransitionStartTime === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = startViewTransitionStartTime)) : nestedUpdateCount = 0;
            rootDidHavePassiveEffects || finalizeRender(endTime, commitEndTime);
            flushSyncWorkAcrossRoots_impl(0, false);
          }
        }
        function makeErrorInfo(componentStack) {
          componentStack = { componentStack };
          Object.defineProperty(componentStack, "digest", {
            get: function() {
              console.error(
                'You are accessing "digest" from the errorInfo object passed to onRecoverableError. This property is no longer provided as part of errorInfo but can be accessed as a property of the Error instance itself.'
              );
            }
          });
          return componentStack;
        }
        function releaseRootPooledCache(root2, remainingLanes) {
          0 === (root2.pooledCacheLanes &= remainingLanes) && (remainingLanes = root2.pooledCache, null != remainingLanes && (root2.pooledCache = null, releaseCache(remainingLanes)));
        }
        function flushPendingEffects() {
          flushMutationEffects();
          flushLayoutEffects();
          flushSpawnedWork();
          return flushPassiveEffects();
        }
        function flushPassiveEffects() {
          if (pendingEffectsStatus !== PENDING_PASSIVE_PHASE) return false;
          var root2 = pendingEffectsRoot, remainingLanes = pendingEffectsRemainingLanes;
          pendingEffectsRemainingLanes = 0;
          var renderPriority = lanesToEventPriority(pendingEffectsLanes), priority = 0 === DefaultEventPriority || DefaultEventPriority > renderPriority ? DefaultEventPriority : renderPriority;
          renderPriority = ReactSharedInternals.T;
          var previousPriority = ReactDOMSharedInternals.p;
          try {
            ReactDOMSharedInternals.p = priority;
            ReactSharedInternals.T = null;
            var transitions = pendingPassiveTransitions;
            pendingPassiveTransitions = null;
            priority = pendingEffectsRoot;
            var lanes = pendingEffectsLanes;
            pendingEffectsStatus = NO_PENDING_EFFECTS;
            pendingFinishedWork = pendingEffectsRoot = null;
            pendingEffectsLanes = 0;
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
              throw Error("Cannot flush passive effects while already rendering.");
            setCurrentTrackFromLanes(lanes);
            isFlushingPassiveEffects = true;
            didScheduleUpdateDuringPassiveEffects = false;
            var passiveEffectStartTime = 0;
            commitErrors = null;
            passiveEffectStartTime = now$1();
            if (pendingDelayedCommitReason === ANIMATION_STARTED_COMMIT)
              logAnimatingPhase(
                commitEndTime,
                passiveEffectStartTime,
                animatingTask
              );
            else {
              var startTime = commitEndTime, endTime = passiveEffectStartTime, delayedUntilPaint = pendingDelayedCommitReason === DELAYED_PASSIVE_COMMIT;
              !supportsUserTiming || endTime <= startTime || (workInProgressUpdateTask ? workInProgressUpdateTask.run(
                console.timeStamp.bind(
                  console,
                  delayedUntilPaint ? "Waiting for Paint" : "Waiting",
                  startTime,
                  endTime,
                  currentTrack,
                  LANES_TRACK_GROUP,
                  "secondary-light"
                )
              ) : console.timeStamp(
                delayedUntilPaint ? "Waiting for Paint" : "Waiting",
                startTime,
                endTime,
                currentTrack,
                LANES_TRACK_GROUP,
                "secondary-light"
              ));
            }
            startTime = executionContext;
            executionContext |= CommitContext;
            var finishedWork = priority.current;
            resetComponentEffectTimers();
            commitPassiveUnmountOnFiber(finishedWork);
            var finishedWork$jscomp$0 = priority.current;
            finishedWork = pendingEffectsRenderEndTime;
            resetComponentEffectTimers();
            commitPassiveMountOnFiber(
              priority,
              finishedWork$jscomp$0,
              lanes,
              transitions,
              finishedWork
            );
            commitDoubleInvokeEffectsInDEV(priority);
            executionContext = startTime;
            var passiveEffectsEndTime = now$1();
            finishedWork$jscomp$0 = passiveEffectStartTime;
            finishedWork = workInProgressUpdateTask;
            null !== commitErrors ? logCommitErrored(
              finishedWork$jscomp$0,
              passiveEffectsEndTime,
              commitErrors,
              true,
              finishedWork
            ) : !supportsUserTiming || passiveEffectsEndTime <= finishedWork$jscomp$0 || (finishedWork ? finishedWork.run(
              console.timeStamp.bind(
                console,
                "Remaining Effects",
                finishedWork$jscomp$0,
                passiveEffectsEndTime,
                currentTrack,
                LANES_TRACK_GROUP,
                "secondary-dark"
              )
            ) : console.timeStamp(
              "Remaining Effects",
              finishedWork$jscomp$0,
              passiveEffectsEndTime,
              currentTrack,
              LANES_TRACK_GROUP,
              "secondary-dark"
            ));
            finalizeRender(lanes, passiveEffectsEndTime);
            flushSyncWorkAcrossRoots_impl(0, false);
            didScheduleUpdateDuringPassiveEffects ? priority === rootWithPassiveNestedUpdates ? nestedPassiveUpdateCount++ : (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = priority) : nestedPassiveUpdateCount = 0;
            didScheduleUpdateDuringPassiveEffects = isFlushingPassiveEffects = false;
            if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot)
              try {
                injectedHook.onPostCommitFiberRoot(rendererID, priority);
              } catch (err) {
                hasLoggedError || (hasLoggedError = true, console.error(
                  "React instrumentation encountered an error: %o",
                  err
                ));
              }
            var stateNode = priority.current.stateNode;
            stateNode.effectDuration = 0;
            stateNode.passiveEffectDuration = 0;
            return true;
          } finally {
            ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = renderPriority, releaseRootPooledCache(root2, remainingLanes);
          }
        }
        function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
          sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
          recordEffectError(sourceFiber);
          sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
          rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
          null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
        }
        function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
          isRunningInsertionEffect = false;
          if (3 === sourceFiber.tag)
            captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
          else {
            for (; null !== nearestMountedAncestor; ) {
              if (3 === nearestMountedAncestor.tag) {
                captureCommitPhaseErrorOnRoot(
                  nearestMountedAncestor,
                  sourceFiber,
                  error
                );
                return;
              }
              if (1 === nearestMountedAncestor.tag) {
                var instance = nearestMountedAncestor.stateNode;
                if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
                  sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
                  recordEffectError(sourceFiber);
                  error = createClassErrorUpdate(2);
                  instance = enqueueUpdate(nearestMountedAncestor, error, 2);
                  null !== instance && (initializeClassErrorUpdate(
                    error,
                    instance,
                    nearestMountedAncestor,
                    sourceFiber
                  ), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
                  return;
                }
              }
              nearestMountedAncestor = nearestMountedAncestor.return;
            }
            console.error(
              "Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Potential causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s",
              error
            );
          }
        }
        function attachPingListener(root2, wakeable, lanes) {
          var pingCache = root2.pingCache;
          if (null === pingCache) {
            pingCache = root2.pingCache = new PossiblyWeakMap();
            var threadIDs = /* @__PURE__ */ new Set();
            pingCache.set(wakeable, threadIDs);
          } else
            threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = /* @__PURE__ */ new Set(), pingCache.set(wakeable, threadIDs));
          threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = true, threadIDs.add(lanes), pingCache = pingSuspendedRoot.bind(null, root2, wakeable, lanes), isDevToolsPresent && restorePendingUpdaters(root2, lanes), wakeable.then(pingCache, pingCache));
        }
        function pingSuspendedRoot(root2, wakeable, pingedLanes) {
          var pingCache = root2.pingCache;
          null !== pingCache && pingCache.delete(wakeable);
          root2.pingedLanes |= root2.suspendedLanes & pingedLanes;
          root2.warmLanes &= ~pingedLanes;
          0 !== (pingedLanes & 127) ? 0 > blockingUpdateTime && (blockingClampTime = blockingUpdateTime = now(), blockingUpdateTask = createTask("Promise Resolved"), blockingUpdateType = PINGED_UPDATE) : 0 !== (pingedLanes & 4194048) && 0 > transitionUpdateTime && (transitionClampTime = transitionUpdateTime = now(), transitionUpdateTask = createTask("Promise Resolved"), transitionUpdateType = PINGED_UPDATE);
          isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && console.error(
            "A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() => {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act"
          );
          workInProgressRoot === root2 && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && now$1() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS ? (executionContext & RenderContext) === NoContext && prepareFreshStack(root2, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
          ensureRootIsScheduled(root2);
        }
        function retryTimedOutBoundary(boundaryFiber, retryLane) {
          0 === retryLane && (retryLane = claimNextRetryLane());
          boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
          null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
        }
        function retryDehydratedSuspenseBoundary(boundaryFiber) {
          var suspenseState = boundaryFiber.memoizedState, retryLane = 0;
          null !== suspenseState && (retryLane = suspenseState.retryLane);
          retryTimedOutBoundary(boundaryFiber, retryLane);
        }
        function resolveRetryWakeable(boundaryFiber, wakeable) {
          var retryLane = 0;
          switch (boundaryFiber.tag) {
            case 31:
            case 13:
              var retryCache = boundaryFiber.stateNode;
              var suspenseState = boundaryFiber.memoizedState;
              null !== suspenseState && (retryLane = suspenseState.retryLane);
              break;
            case 19:
              retryCache = boundaryFiber.stateNode;
              break;
            case 22:
              retryCache = boundaryFiber.stateNode._retryCache;
              break;
            default:
              throw Error(
                "Pinged unknown suspense boundary type. This is probably a bug in React."
              );
          }
          null !== retryCache && retryCache.delete(wakeable);
          retryTimedOutBoundary(boundaryFiber, retryLane);
        }
        function recursivelyTraverseAndDoubleInvokeEffectsInDEV(root$jscomp$0, parentFiber, isInStrictMode) {
          if (0 !== (parentFiber.subtreeFlags & 67117056))
            for (parentFiber = parentFiber.child; null !== parentFiber; ) {
              var root2 = root$jscomp$0, fiber = parentFiber, isStrictModeFiber = fiber.type === REACT_STRICT_MODE_TYPE;
              isStrictModeFiber = isInStrictMode || isStrictModeFiber;
              22 !== fiber.tag ? fiber.flags & 67108864 ? isStrictModeFiber && runWithFiberInDEV(
                fiber,
                doubleInvokeEffectsOnFiber,
                root2,
                fiber
              ) : recursivelyTraverseAndDoubleInvokeEffectsInDEV(
                root2,
                fiber,
                isStrictModeFiber
              ) : null === fiber.memoizedState && (isStrictModeFiber && fiber.flags & 8192 ? runWithFiberInDEV(
                fiber,
                doubleInvokeEffectsOnFiber,
                root2,
                fiber
              ) : fiber.subtreeFlags & 67108864 && runWithFiberInDEV(
                fiber,
                recursivelyTraverseAndDoubleInvokeEffectsInDEV,
                root2,
                fiber,
                isStrictModeFiber
              ));
              parentFiber = parentFiber.sibling;
            }
        }
        function doubleInvokeEffectsOnFiber(root2, fiber) {
          setIsStrictModeForDevtools(true);
          try {
            disappearLayoutEffects(fiber), disconnectPassiveEffect(fiber), reappearLayoutEffects(root2, fiber.alternate, fiber, false), reconnectPassiveEffects(root2, fiber, 0, null, false, 0);
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
        function commitDoubleInvokeEffectsInDEV(root2) {
          var doubleInvokeEffects = true;
          root2.current.mode & (StrictLegacyMode | StrictEffectsMode) || (doubleInvokeEffects = false);
          recursivelyTraverseAndDoubleInvokeEffectsInDEV(
            root2,
            root2.current,
            doubleInvokeEffects
          );
        }
        function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
          if ((executionContext & RenderContext) === NoContext) {
            var tag = fiber.tag;
            if (3 === tag || 1 === tag || 0 === tag || 11 === tag || 14 === tag || 15 === tag) {
              tag = getComponentNameFromFiber(fiber) || "ReactComponent";
              if (null !== didWarnStateUpdateForNotYetMountedComponent) {
                if (didWarnStateUpdateForNotYetMountedComponent.has(tag)) return;
                didWarnStateUpdateForNotYetMountedComponent.add(tag);
              } else didWarnStateUpdateForNotYetMountedComponent = /* @__PURE__ */ new Set([tag]);
              runWithFiberInDEV(fiber, function() {
                console.error(
                  "Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously tries to update the component. Move this work to useEffect instead."
                );
              });
            }
          }
        }
        function restorePendingUpdaters(root2, lanes) {
          isDevToolsPresent && root2.memoizedUpdaters.forEach(function(schedulingFiber) {
            addFiberToLanesMap(root2, schedulingFiber, lanes);
          });
        }
        function scheduleCallback$1(priorityLevel, callback) {
          var actQueue = ReactSharedInternals.actQueue;
          return null !== actQueue ? (actQueue.push(callback), fakeActCallbackNode$1) : scheduleCallback$3(priorityLevel, callback);
        }
        function warnIfUpdatesNotWrappedWithActDEV(fiber) {
          isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && runWithFiberInDEV(fiber, function() {
            console.error(
              "An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act",
              getComponentNameFromFiber(fiber)
            );
          });
        }
        function ensureRootIsScheduled(root2) {
          root2 !== lastScheduledRoot && null === root2.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root2 : lastScheduledRoot = lastScheduledRoot.next = root2);
          mightHavePendingSyncWork = true;
          null !== ReactSharedInternals.actQueue ? didScheduleMicrotask_act || (didScheduleMicrotask_act = true, scheduleImmediateRootScheduleTask()) : didScheduleMicrotask || (didScheduleMicrotask = true, scheduleImmediateRootScheduleTask());
        }
        function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
          if (!isFlushingWork && mightHavePendingSyncWork) {
            isFlushingWork = true;
            do {
              var didPerformSomeWork = false;
              for (var root2 = firstScheduledRoot; null !== root2; ) {
                if (!onlyLegacy)
                  if (0 !== syncTransitionLanes) {
                    var pendingLanes = root2.pendingLanes;
                    if (0 === pendingLanes) var nextLanes = 0;
                    else {
                      var suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes;
                      nextLanes = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
                      nextLanes &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
                      nextLanes = nextLanes & 201326741 ? nextLanes & 201326741 | 1 : nextLanes ? nextLanes | 2 : 0;
                    }
                    0 !== nextLanes && (didPerformSomeWork = true, performSyncWorkOnRoot(root2, nextLanes));
                  } else
                    nextLanes = workInProgressRootRenderLanes, nextLanes = getNextLanes(
                      root2,
                      root2 === workInProgressRoot ? nextLanes : 0,
                      null !== root2.cancelPendingCommit || root2.timeoutHandle !== noTimeout
                    ), 0 === (nextLanes & 3) || checkIfRootIsPrerendering(root2, nextLanes) || (didPerformSomeWork = true, performSyncWorkOnRoot(root2, nextLanes));
                root2 = root2.next;
              }
            } while (didPerformSomeWork);
            isFlushingWork = false;
          }
        }
        function processRootScheduleInImmediateTask() {
          schedulerEvent = window.event;
          processRootScheduleInMicrotask();
        }
        function processRootScheduleInMicrotask() {
          mightHavePendingSyncWork = didScheduleMicrotask_act = didScheduleMicrotask = false;
          var syncTransitionLanes = 0;
          0 !== currentEventTransitionLane && shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane);
          for (var currentTime = now$1(), prev = null, root2 = firstScheduledRoot; null !== root2; ) {
            var next = root2.next, nextLanes = scheduleTaskForRootDuringMicrotask(root2, currentTime);
            if (0 === nextLanes)
              root2.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);
            else if (prev = root2, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
              mightHavePendingSyncWork = true;
            root2 = next;
          }
          pendingEffectsStatus !== NO_PENDING_EFFECTS && pendingEffectsStatus !== PENDING_PASSIVE_PHASE || flushSyncWorkAcrossRoots_impl(syncTransitionLanes, false);
          0 !== currentEventTransitionLane && (currentEventTransitionLane = 0);
        }
        function scheduleTaskForRootDuringMicrotask(root2, currentTime) {
          for (var suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes, expirationTimes = root2.expirationTimes, lanes = root2.pendingLanes & -62914561; 0 < lanes; ) {
            var index = 31 - clz32(lanes), lane = 1 << index, expirationTime = expirationTimes[index];
            if (-1 === expirationTime) {
              if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
                expirationTimes[index] = computeExpirationTime(lane, currentTime);
            } else expirationTime <= currentTime && (root2.expiredLanes |= lane);
            lanes &= ~lane;
          }
          currentTime = workInProgressRoot;
          suspendedLanes = workInProgressRootRenderLanes;
          suspendedLanes = getNextLanes(
            root2,
            root2 === currentTime ? suspendedLanes : 0,
            null !== root2.cancelPendingCommit || root2.timeoutHandle !== noTimeout
          );
          pingedLanes = root2.callbackNode;
          if (0 === suspendedLanes || root2 === currentTime && (workInProgressSuspendedReason === SuspendedOnData || workInProgressSuspendedReason === SuspendedOnAction) || null !== root2.cancelPendingCommit)
            return null !== pingedLanes && cancelCallback(pingedLanes), root2.callbackNode = null, root2.callbackPriority = 0;
          if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root2, suspendedLanes)) {
            currentTime = suspendedLanes & -suspendedLanes;
            if (currentTime !== root2.callbackPriority || null !== ReactSharedInternals.actQueue && pingedLanes !== fakeActCallbackNode)
              cancelCallback(pingedLanes);
            else return currentTime;
            switch (lanesToEventPriority(suspendedLanes)) {
              case DiscreteEventPriority:
              case ContinuousEventPriority:
                suspendedLanes = UserBlockingPriority;
                break;
              case DefaultEventPriority:
                suspendedLanes = NormalPriority$1;
                break;
              case IdleEventPriority:
                suspendedLanes = IdlePriority;
                break;
              default:
                suspendedLanes = NormalPriority$1;
            }
            pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root2);
            null !== ReactSharedInternals.actQueue ? (ReactSharedInternals.actQueue.push(pingedLanes), suspendedLanes = fakeActCallbackNode) : suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
            root2.callbackPriority = currentTime;
            root2.callbackNode = suspendedLanes;
            return currentTime;
          }
          null !== pingedLanes && cancelCallback(pingedLanes);
          root2.callbackPriority = 2;
          root2.callbackNode = null;
          return 2;
        }
        function performWorkOnRootViaSchedulerTask(root2, didTimeout) {
          nestedUpdateScheduled = currentUpdateIsNested = false;
          schedulerEvent = window.event;
          if (pendingEffectsStatus !== NO_PENDING_EFFECTS && pendingEffectsStatus !== PENDING_PASSIVE_PHASE)
            return root2.callbackNode = null, root2.callbackPriority = 0, null;
          var originalCallbackNode = root2.callbackNode;
          pendingDelayedCommitReason === IMMEDIATE_COMMIT && (pendingDelayedCommitReason = DELAYED_PASSIVE_COMMIT);
          if (flushPendingEffects() && root2.callbackNode !== originalCallbackNode)
            return null;
          var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
          workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
            root2,
            root2 === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0,
            null !== root2.cancelPendingCommit || root2.timeoutHandle !== noTimeout
          );
          if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
          performWorkOnRoot(
            root2,
            workInProgressRootRenderLanes$jscomp$0,
            didTimeout
          );
          scheduleTaskForRootDuringMicrotask(root2, now$1());
          return null != root2.callbackNode && root2.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root2) : null;
        }
        function performSyncWorkOnRoot(root2, lanes) {
          if (flushPendingEffects()) return null;
          currentUpdateIsNested = nestedUpdateScheduled;
          nestedUpdateScheduled = false;
          performWorkOnRoot(root2, lanes, true);
        }
        function cancelCallback(callbackNode) {
          callbackNode !== fakeActCallbackNode && null !== callbackNode && cancelCallback$1(callbackNode);
        }
        function scheduleImmediateRootScheduleTask() {
          null !== ReactSharedInternals.actQueue && ReactSharedInternals.actQueue.push(function() {
            processRootScheduleInMicrotask();
            return null;
          });
          scheduleMicrotask(function() {
            (executionContext & (RenderContext | CommitContext)) !== NoContext ? scheduleCallback$3(
              ImmediatePriority,
              processRootScheduleInImmediateTask
            ) : processRootScheduleInMicrotask();
          });
        }
        function requestTransitionLane() {
          if (0 === currentEventTransitionLane) {
            var actionScopeLane = currentEntangledLane;
            0 === actionScopeLane && (actionScopeLane = nextTransitionUpdateLane, nextTransitionUpdateLane <<= 1, 0 === (nextTransitionUpdateLane & 261888) && (nextTransitionUpdateLane = 256));
            currentEventTransitionLane = actionScopeLane;
          }
          return currentEventTransitionLane;
        }
        function coerceFormActionProp(actionProp) {
          if (null == actionProp || "symbol" === typeof actionProp || "boolean" === typeof actionProp)
            return null;
          if ("function" === typeof actionProp) return actionProp;
          checkAttributeStringCoercion(actionProp, "action");
          return sanitizeURL("" + actionProp);
        }
        function createFormDataWithSubmitter(form, submitter) {
          var temp = submitter.ownerDocument.createElement("input");
          temp.name = submitter.name;
          temp.value = submitter.value;
          form.id && temp.setAttribute("form", form.id);
          submitter.parentNode.insertBefore(temp, submitter);
          form = new FormData(form);
          temp.parentNode.removeChild(temp);
          return form;
        }
        function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
          if ("submit" === domEventName && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
            var action = coerceFormActionProp(
              (nativeEventTarget[internalPropsKey] || null).action
            ), submitter = nativeEvent.submitter;
            submitter && (domEventName = (domEventName = submitter[internalPropsKey] || null) ? coerceFormActionProp(domEventName.formAction) : submitter.getAttribute("formAction"), null !== domEventName && (action = domEventName, submitter = null));
            var event = new SyntheticEvent(
              "action",
              "action",
              null,
              nativeEvent,
              nativeEventTarget
            );
            dispatchQueue.push({
              event,
              listeners: [
                {
                  instance: null,
                  listener: function() {
                    if (nativeEvent.defaultPrevented) {
                      if (0 !== currentEventTransitionLane) {
                        var formData = submitter ? createFormDataWithSubmitter(
                          nativeEventTarget,
                          submitter
                        ) : new FormData(nativeEventTarget), pendingState = {
                          pending: true,
                          data: formData,
                          method: nativeEventTarget.method,
                          action
                        };
                        Object.freeze(pendingState);
                        startHostTransition(
                          maybeTargetInst,
                          pendingState,
                          null,
                          formData
                        );
                      }
                    } else
                      "function" === typeof action && (event.preventDefault(), formData = submitter ? createFormDataWithSubmitter(
                        nativeEventTarget,
                        submitter
                      ) : new FormData(nativeEventTarget), pendingState = {
                        pending: true,
                        data: formData,
                        method: nativeEventTarget.method,
                        action
                      }, Object.freeze(pendingState), startHostTransition(
                        maybeTargetInst,
                        pendingState,
                        action,
                        formData
                      ));
                  },
                  currentTarget: nativeEventTarget
                }
              ]
            });
          }
        }
        function executeDispatch(event, listener, currentTarget) {
          event.currentTarget = currentTarget;
          try {
            listener(event);
          } catch (error) {
            reportGlobalError(error);
          }
          event.currentTarget = null;
        }
        function processDispatchQueue(dispatchQueue, eventSystemFlags) {
          eventSystemFlags = 0 !== (eventSystemFlags & 4);
          for (var i8 = 0; i8 < dispatchQueue.length; i8++) {
            var _dispatchQueue$i = dispatchQueue[i8];
            a: {
              var previousInstance = void 0, event = _dispatchQueue$i.event;
              _dispatchQueue$i = _dispatchQueue$i.listeners;
              if (eventSystemFlags)
                for (var i$jscomp$0 = _dispatchQueue$i.length - 1; 0 <= i$jscomp$0; i$jscomp$0--) {
                  var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget;
                  _dispatchListeners$i = _dispatchListeners$i.listener;
                  if (instance !== previousInstance && event.isPropagationStopped())
                    break a;
                  null !== instance ? runWithFiberInDEV(
                    instance,
                    executeDispatch,
                    event,
                    _dispatchListeners$i,
                    currentTarget
                  ) : executeDispatch(event, _dispatchListeners$i, currentTarget);
                  previousInstance = instance;
                }
              else
                for (i$jscomp$0 = 0; i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++) {
                  _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
                  instance = _dispatchListeners$i.instance;
                  currentTarget = _dispatchListeners$i.currentTarget;
                  _dispatchListeners$i = _dispatchListeners$i.listener;
                  if (instance !== previousInstance && event.isPropagationStopped())
                    break a;
                  null !== instance ? runWithFiberInDEV(
                    instance,
                    executeDispatch,
                    event,
                    _dispatchListeners$i,
                    currentTarget
                  ) : executeDispatch(event, _dispatchListeners$i, currentTarget);
                  previousInstance = instance;
                }
            }
          }
        }
        function listenToNonDelegatedEvent(domEventName, targetElement) {
          nonDelegatedEvents.has(domEventName) || console.error(
            'Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.',
            domEventName
          );
          var listenerSet = targetElement[internalEventHandlersKey];
          void 0 === listenerSet && (listenerSet = targetElement[internalEventHandlersKey] = /* @__PURE__ */ new Set());
          var listenerSetKey = domEventName + "__bubble";
          listenerSet.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, false), listenerSet.add(listenerSetKey));
        }
        function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
          nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener && console.error(
            'Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.',
            domEventName
          );
          var eventSystemFlags = 0;
          isCapturePhaseListener && (eventSystemFlags |= 4);
          addTrappedEventListener(
            target,
            domEventName,
            eventSystemFlags,
            isCapturePhaseListener
          );
        }
        function listenToAllSupportedEvents(rootContainerElement) {
          if (!rootContainerElement[listeningMarker]) {
            rootContainerElement[listeningMarker] = true;
            allNativeEvents.forEach(function(domEventName) {
              "selectionchange" !== domEventName && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, false, rootContainerElement), listenToNativeEvent(domEventName, true, rootContainerElement));
            });
            var ownerDocument = 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
            null === ownerDocument || ownerDocument[listeningMarker] || (ownerDocument[listeningMarker] = true, listenToNativeEvent("selectionchange", false, ownerDocument));
          }
        }
        function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
          switch (getEventPriority(domEventName)) {
            case DiscreteEventPriority:
              var listenerWrapper = dispatchDiscreteEvent;
              break;
            case ContinuousEventPriority:
              listenerWrapper = dispatchContinuousEvent;
              break;
            default:
              listenerWrapper = dispatchEvent;
          }
          eventSystemFlags = listenerWrapper.bind(
            null,
            domEventName,
            eventSystemFlags,
            targetContainer
          );
          listenerWrapper = void 0;
          !passiveBrowserEventsSupported || "touchstart" !== domEventName && "touchmove" !== domEventName && "wheel" !== domEventName || (listenerWrapper = true);
          isCapturePhaseListener ? void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
            capture: true,
            passive: listenerWrapper
          }) : targetContainer.addEventListener(domEventName, eventSystemFlags, true) : void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
            passive: listenerWrapper
          }) : targetContainer.addEventListener(
            domEventName,
            eventSystemFlags,
            false
          );
        }
        function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {
          var ancestorInst = targetInst$jscomp$0;
          if (0 === (eventSystemFlags & 1) && 0 === (eventSystemFlags & 2) && null !== targetInst$jscomp$0)
            a: for (; ; ) {
              if (null === targetInst$jscomp$0) return;
              var nodeTag = targetInst$jscomp$0.tag;
              if (3 === nodeTag || 4 === nodeTag) {
                var container = targetInst$jscomp$0.stateNode.containerInfo;
                if (container === targetContainer) break;
                if (4 === nodeTag)
                  for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
                    var grandTag = nodeTag.tag;
                    if ((3 === grandTag || 4 === grandTag) && nodeTag.stateNode.containerInfo === targetContainer)
                      return;
                    nodeTag = nodeTag.return;
                  }
                for (; null !== container; ) {
                  nodeTag = getClosestInstanceFromNode(container);
                  if (null === nodeTag) return;
                  grandTag = nodeTag.tag;
                  if (5 === grandTag || 6 === grandTag || 26 === grandTag || 27 === grandTag) {
                    targetInst$jscomp$0 = ancestorInst = nodeTag;
                    continue a;
                  }
                  container = container.parentNode;
                }
              }
              targetInst$jscomp$0 = targetInst$jscomp$0.return;
            }
          batchedUpdates$1(function() {
            var targetInst = ancestorInst, nativeEventTarget = getEventTarget(nativeEvent), dispatchQueue = [];
            a: {
              var reactName = topLevelEventsToReactNames.get(domEventName);
              if (void 0 !== reactName) {
                var SyntheticEventCtor = SyntheticEvent, reactEventType = domEventName;
                switch (domEventName) {
                  case "keypress":
                    if (0 === getEventCharCode(nativeEvent)) break a;
                  case "keydown":
                  case "keyup":
                    SyntheticEventCtor = SyntheticKeyboardEvent;
                    break;
                  case "focusin":
                    reactEventType = "focus";
                    SyntheticEventCtor = SyntheticFocusEvent;
                    break;
                  case "focusout":
                    reactEventType = "blur";
                    SyntheticEventCtor = SyntheticFocusEvent;
                    break;
                  case "beforeblur":
                  case "afterblur":
                    SyntheticEventCtor = SyntheticFocusEvent;
                    break;
                  case "click":
                    if (2 === nativeEvent.button) break a;
                  case "auxclick":
                  case "dblclick":
                  case "mousedown":
                  case "mousemove":
                  case "mouseup":
                  case "mouseout":
                  case "mouseover":
                  case "contextmenu":
                    SyntheticEventCtor = SyntheticMouseEvent;
                    break;
                  case "drag":
                  case "dragend":
                  case "dragenter":
                  case "dragexit":
                  case "dragleave":
                  case "dragover":
                  case "dragstart":
                  case "drop":
                    SyntheticEventCtor = SyntheticDragEvent;
                    break;
                  case "touchcancel":
                  case "touchend":
                  case "touchmove":
                  case "touchstart":
                    SyntheticEventCtor = SyntheticTouchEvent;
                    break;
                  case ANIMATION_END:
                  case ANIMATION_ITERATION:
                  case ANIMATION_START:
                    SyntheticEventCtor = SyntheticAnimationEvent;
                    break;
                  case TRANSITION_END:
                    SyntheticEventCtor = SyntheticTransitionEvent;
                    break;
                  case "scroll":
                  case "scrollend":
                    SyntheticEventCtor = SyntheticUIEvent;
                    break;
                  case "wheel":
                    SyntheticEventCtor = SyntheticWheelEvent;
                    break;
                  case "copy":
                  case "cut":
                  case "paste":
                    SyntheticEventCtor = SyntheticClipboardEvent;
                    break;
                  case "gotpointercapture":
                  case "lostpointercapture":
                  case "pointercancel":
                  case "pointerdown":
                  case "pointermove":
                  case "pointerout":
                  case "pointerover":
                  case "pointerup":
                    SyntheticEventCtor = SyntheticPointerEvent;
                    break;
                  case "toggle":
                  case "beforetoggle":
                    SyntheticEventCtor = SyntheticToggleEvent;
                }
                var inCapturePhase = 0 !== (eventSystemFlags & 4), accumulateTargetOnly = !inCapturePhase && ("scroll" === domEventName || "scrollend" === domEventName), reactEventName = inCapturePhase ? null !== reactName ? reactName + "Capture" : null : reactName;
                inCapturePhase = [];
                for (var instance = targetInst, lastHostComponent; null !== instance; ) {
                  var _instance2 = instance;
                  lastHostComponent = _instance2.stateNode;
                  _instance2 = _instance2.tag;
                  5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2 || null === lastHostComponent || null === reactEventName || (_instance2 = getListener(instance, reactEventName), null != _instance2 && inCapturePhase.push(
                    createDispatchListener(
                      instance,
                      _instance2,
                      lastHostComponent
                    )
                  ));
                  if (accumulateTargetOnly) break;
                  instance = instance.return;
                }
                0 < inCapturePhase.length && (reactName = new SyntheticEventCtor(
                  reactName,
                  reactEventType,
                  null,
                  nativeEvent,
                  nativeEventTarget
                ), dispatchQueue.push({
                  event: reactName,
                  listeners: inCapturePhase
                }));
              }
            }
            if (0 === (eventSystemFlags & 7)) {
              a: {
                reactName = "mouseover" === domEventName || "pointerover" === domEventName;
                SyntheticEventCtor = "mouseout" === domEventName || "pointerout" === domEventName;
                if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey]))
                  break a;
                if (SyntheticEventCtor || reactName) {
                  reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : (reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : window;
                  if (SyntheticEventCtor) {
                    if (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement, SyntheticEventCtor = targetInst, reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null, null !== reactEventType && (accumulateTargetOnly = getNearestMountedFiber(reactEventType), inCapturePhase = reactEventType.tag, reactEventType !== accumulateTargetOnly || 5 !== inCapturePhase && 27 !== inCapturePhase && 6 !== inCapturePhase))
                      reactEventType = null;
                  } else SyntheticEventCtor = null, reactEventType = targetInst;
                  if (SyntheticEventCtor !== reactEventType) {
                    inCapturePhase = SyntheticMouseEvent;
                    _instance2 = "onMouseLeave";
                    reactEventName = "onMouseEnter";
                    instance = "mouse";
                    if ("pointerout" === domEventName || "pointerover" === domEventName)
                      inCapturePhase = SyntheticPointerEvent, _instance2 = "onPointerLeave", reactEventName = "onPointerEnter", instance = "pointer";
                    accumulateTargetOnly = null == SyntheticEventCtor ? reactName : getNodeFromInstance(SyntheticEventCtor);
                    lastHostComponent = null == reactEventType ? reactName : getNodeFromInstance(reactEventType);
                    reactName = new inCapturePhase(
                      _instance2,
                      instance + "leave",
                      SyntheticEventCtor,
                      nativeEvent,
                      nativeEventTarget
                    );
                    reactName.target = accumulateTargetOnly;
                    reactName.relatedTarget = lastHostComponent;
                    _instance2 = null;
                    getClosestInstanceFromNode(nativeEventTarget) === targetInst && (inCapturePhase = new inCapturePhase(
                      reactEventName,
                      instance + "enter",
                      reactEventType,
                      nativeEvent,
                      nativeEventTarget
                    ), inCapturePhase.target = lastHostComponent, inCapturePhase.relatedTarget = accumulateTargetOnly, _instance2 = inCapturePhase);
                    accumulateTargetOnly = _instance2;
                    if (SyntheticEventCtor && reactEventType)
                      b: {
                        inCapturePhase = getParent;
                        reactEventName = SyntheticEventCtor;
                        instance = reactEventType;
                        lastHostComponent = 0;
                        for (_instance2 = reactEventName; _instance2; _instance2 = inCapturePhase(_instance2))
                          lastHostComponent++;
                        _instance2 = 0;
                        for (var tempB = instance; tempB; tempB = inCapturePhase(tempB))
                          _instance2++;
                        for (; 0 < lastHostComponent - _instance2; )
                          reactEventName = inCapturePhase(reactEventName), lastHostComponent--;
                        for (; 0 < _instance2 - lastHostComponent; )
                          instance = inCapturePhase(instance), _instance2--;
                        for (; lastHostComponent--; ) {
                          if (reactEventName === instance || null !== instance && reactEventName === instance.alternate) {
                            inCapturePhase = reactEventName;
                            break b;
                          }
                          reactEventName = inCapturePhase(reactEventName);
                          instance = inCapturePhase(instance);
                        }
                        inCapturePhase = null;
                      }
                    else inCapturePhase = null;
                    null !== SyntheticEventCtor && accumulateEnterLeaveListenersForEvent(
                      dispatchQueue,
                      reactName,
                      SyntheticEventCtor,
                      inCapturePhase,
                      false
                    );
                    null !== reactEventType && null !== accumulateTargetOnly && accumulateEnterLeaveListenersForEvent(
                      dispatchQueue,
                      accumulateTargetOnly,
                      reactEventType,
                      inCapturePhase,
                      true
                    );
                  }
                }
              }
              a: {
                reactName = targetInst ? getNodeFromInstance(targetInst) : window;
                SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
                if ("select" === SyntheticEventCtor || "input" === SyntheticEventCtor && "file" === reactName.type)
                  var getTargetInstFunc = getTargetInstForChangeEvent;
                else if (isTextInputElement(reactName))
                  if (isInputEventSupported)
                    getTargetInstFunc = getTargetInstForInputOrChangeEvent;
                  else {
                    getTargetInstFunc = getTargetInstForInputEventPolyfill;
                    var handleEventFunc = handleEventsForInputEventPolyfill;
                  }
                else
                  SyntheticEventCtor = reactName.nodeName, !SyntheticEventCtor || "input" !== SyntheticEventCtor.toLowerCase() || "checkbox" !== reactName.type && "radio" !== reactName.type ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunc = getTargetInstForChangeEvent) : getTargetInstFunc = getTargetInstForClickEvent;
                if (getTargetInstFunc && (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))) {
                  createAndAccumulateChangeEvent(
                    dispatchQueue,
                    getTargetInstFunc,
                    nativeEvent,
                    nativeEventTarget
                  );
                  break a;
                }
                handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
                "focusout" === domEventName && targetInst && "number" === reactName.type && null != targetInst.memoizedProps.value && setDefaultValue(reactName, "number", reactName.value);
              }
              handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
              switch (domEventName) {
                case "focusin":
                  if (isTextInputElement(handleEventFunc) || "true" === handleEventFunc.contentEditable)
                    activeElement = handleEventFunc, activeElementInst = targetInst, lastSelection = null;
                  break;
                case "focusout":
                  lastSelection = activeElementInst = activeElement = null;
                  break;
                case "mousedown":
                  mouseDown = true;
                  break;
                case "contextmenu":
                case "mouseup":
                case "dragend":
                  mouseDown = false;
                  constructSelectEvent(
                    dispatchQueue,
                    nativeEvent,
                    nativeEventTarget
                  );
                  break;
                case "selectionchange":
                  if (skipSelectionChangeEvent) break;
                case "keydown":
                case "keyup":
                  constructSelectEvent(
                    dispatchQueue,
                    nativeEvent,
                    nativeEventTarget
                  );
              }
              var fallbackData;
              if (canUseCompositionEvent)
                b: {
                  switch (domEventName) {
                    case "compositionstart":
                      var eventType = "onCompositionStart";
                      break b;
                    case "compositionend":
                      eventType = "onCompositionEnd";
                      break b;
                    case "compositionupdate":
                      eventType = "onCompositionUpdate";
                      break b;
                  }
                  eventType = void 0;
                }
              else
                isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : "keydown" === domEventName && nativeEvent.keyCode === START_KEYCODE && (eventType = "onCompositionStart");
              eventType && (useFallbackCompositionData && "ko" !== nativeEvent.locale && (isComposing || "onCompositionStart" !== eventType ? "onCompositionEnd" === eventType && isComposing && (fallbackData = getData()) : (root = nativeEventTarget, startText = "value" in root ? root.value : root.textContent, isComposing = true)), handleEventFunc = accumulateTwoPhaseListeners(
                targetInst,
                eventType
              ), 0 < handleEventFunc.length && (eventType = new SyntheticCompositionEvent(
                eventType,
                domEventName,
                null,
                nativeEvent,
                nativeEventTarget
              ), dispatchQueue.push({
                event: eventType,
                listeners: handleEventFunc
              }), fallbackData ? eventType.data = fallbackData : (fallbackData = getDataFromCustomEvent(nativeEvent), null !== fallbackData && (eventType.data = fallbackData))));
              if (fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent))
                eventType = accumulateTwoPhaseListeners(
                  targetInst,
                  "onBeforeInput"
                ), 0 < eventType.length && (handleEventFunc = new SyntheticInputEvent(
                  "onBeforeInput",
                  "beforeinput",
                  null,
                  nativeEvent,
                  nativeEventTarget
                ), dispatchQueue.push({
                  event: handleEventFunc,
                  listeners: eventType
                }), handleEventFunc.data = fallbackData);
              extractEvents$1(
                dispatchQueue,
                domEventName,
                targetInst,
                nativeEvent,
                nativeEventTarget
              );
            }
            processDispatchQueue(dispatchQueue, eventSystemFlags);
          });
        }
        function createDispatchListener(instance, listener, currentTarget) {
          return {
            instance,
            listener,
            currentTarget
          };
        }
        function accumulateTwoPhaseListeners(targetFiber, reactName) {
          for (var captureName = reactName + "Capture", listeners = []; null !== targetFiber; ) {
            var _instance3 = targetFiber, stateNode = _instance3.stateNode;
            _instance3 = _instance3.tag;
            5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3 || null === stateNode || (_instance3 = getListener(targetFiber, captureName), null != _instance3 && listeners.unshift(
              createDispatchListener(targetFiber, _instance3, stateNode)
            ), _instance3 = getListener(targetFiber, reactName), null != _instance3 && listeners.push(
              createDispatchListener(targetFiber, _instance3, stateNode)
            ));
            if (3 === targetFiber.tag) return listeners;
            targetFiber = targetFiber.return;
          }
          return [];
        }
        function getParent(inst) {
          if (null === inst) return null;
          do
            inst = inst.return;
          while (inst && 5 !== inst.tag && 27 !== inst.tag);
          return inst ? inst : null;
        }
        function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
          for (var registrationName = event._reactName, listeners = []; null !== target && target !== common; ) {
            var _instance4 = target, alternate = _instance4.alternate, stateNode = _instance4.stateNode;
            _instance4 = _instance4.tag;
            if (null !== alternate && alternate === common) break;
            5 !== _instance4 && 26 !== _instance4 && 27 !== _instance4 || null === stateNode || (alternate = stateNode, inCapturePhase ? (stateNode = getListener(target, registrationName), null != stateNode && listeners.unshift(
              createDispatchListener(target, stateNode, alternate)
            )) : inCapturePhase || (stateNode = getListener(target, registrationName), null != stateNode && listeners.push(
              createDispatchListener(target, stateNode, alternate)
            )));
            target = target.return;
          }
          0 !== listeners.length && dispatchQueue.push({ event, listeners });
        }
        function validatePropertiesInDevelopment(type, props) {
          validateProperties$2(type, props);
          "input" !== type && "textarea" !== type && "select" !== type || null == props || null !== props.value || didWarnValueNull || (didWarnValueNull = true, "select" === type && props.multiple ? console.error(
            "`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.",
            type
          ) : console.error(
            "`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.",
            type
          ));
          var eventRegistry = {
            registrationNameDependencies,
            possibleRegistrationNames
          };
          isCustomElement(type) || "string" === typeof props.is || warnUnknownProperties(type, props, eventRegistry);
          props.contentEditable && !props.suppressContentEditableWarning && null != props.children && console.error(
            "A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."
          );
        }
        function warnForPropDifference(propName, serverValue, clientValue, serverDifferences) {
          serverValue !== clientValue && (clientValue = normalizeMarkupForTextOrAttribute(clientValue), normalizeMarkupForTextOrAttribute(serverValue) !== clientValue && (serverDifferences[propName] = serverValue));
        }
        function warnForExtraAttributes(domElement, attributeNames, serverDifferences) {
          attributeNames.forEach(function(attributeName) {
            serverDifferences[getPropNameFromAttributeName(attributeName)] = "style" === attributeName ? getStylesObjectFromElement(domElement) : domElement.getAttribute(attributeName);
          });
        }
        function warnForInvalidEventListener(registrationName, listener) {
          false === listener ? console.error(
            "Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.",
            registrationName,
            registrationName,
            registrationName
          ) : console.error(
            "Expected `%s` listener to be a function, instead got a value of `%s` type.",
            registrationName,
            typeof listener
          );
        }
        function normalizeHTML(parent, html) {
          parent = parent.namespaceURI === MATH_NAMESPACE || parent.namespaceURI === SVG_NAMESPACE ? parent.ownerDocument.createElementNS(
            parent.namespaceURI,
            parent.tagName
          ) : parent.ownerDocument.createElement(parent.tagName);
          parent.innerHTML = html;
          return parent.innerHTML;
        }
        function normalizeMarkupForTextOrAttribute(markup) {
          willCoercionThrow(markup) && (console.error(
            "The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.",
            typeName(markup)
          ), testStringCoercion(markup));
          return ("string" === typeof markup ? markup : "" + markup).replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
        }
        function checkForUnmatchedText(serverText, clientText) {
          clientText = normalizeMarkupForTextOrAttribute(clientText);
          return normalizeMarkupForTextOrAttribute(serverText) === clientText ? true : false;
        }
        function setProp(domElement, tag, key, value, props, prevValue) {
          switch (key) {
            case "children":
              if ("string" === typeof value)
                validateTextNesting(value, tag, false), "body" === tag || "textarea" === tag && "" === value || setTextContent(domElement, value);
              else if ("number" === typeof value || "bigint" === typeof value)
                validateTextNesting("" + value, tag, false), "body" !== tag && setTextContent(domElement, "" + value);
              break;
            case "className":
              setValueForKnownAttribute(domElement, "class", value);
              break;
            case "tabIndex":
              setValueForKnownAttribute(domElement, "tabindex", value);
              break;
            case "dir":
            case "role":
            case "viewBox":
            case "width":
            case "height":
              setValueForKnownAttribute(domElement, key, value);
              break;
            case "style":
              setValueForStyles(domElement, value, prevValue);
              break;
            case "data":
              if ("object" !== tag) {
                setValueForKnownAttribute(domElement, "data", value);
                break;
              }
            case "src":
            case "href":
              if ("" === value && ("a" !== tag || "href" !== key)) {
                "src" === key ? console.error(
                  'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                  key,
                  key
                ) : console.error(
                  'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                  key,
                  key
                );
                domElement.removeAttribute(key);
                break;
              }
              if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) {
                domElement.removeAttribute(key);
                break;
              }
              checkAttributeStringCoercion(value, key);
              value = sanitizeURL("" + value);
              domElement.setAttribute(key, value);
              break;
            case "action":
            case "formAction":
              null != value && ("form" === tag ? "formAction" === key ? console.error(
                "You can only pass the formAction prop to <input> or <button>. Use the action prop on <form>."
              ) : "function" === typeof value && (null == props.encType && null == props.method || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error(
                "Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden."
              )), null == props.target || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error(
                "Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window."
              ))) : "input" === tag || "button" === tag ? "action" === key ? console.error(
                "You can only pass the action prop to <form>. Use the formAction prop on <input> or <button>."
              ) : "input" !== tag || "submit" === props.type || "image" === props.type || didWarnFormActionType ? "button" !== tag || null == props.type || "submit" === props.type || didWarnFormActionType ? "function" === typeof value && (null == props.name || didWarnFormActionName || (didWarnFormActionName = true, console.error(
                'Cannot specify a "name" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.'
              )), null == props.formEncType && null == props.formMethod || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error(
                "Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden."
              )), null == props.formTarget || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error(
                "Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window."
              ))) : (didWarnFormActionType = true, console.error(
                'A button can only specify a formAction along with type="submit" or no type.'
              )) : (didWarnFormActionType = true, console.error(
                'An input can only specify a formAction along with type="submit" or type="image".'
              )) : "action" === key ? console.error(
                "You can only pass the action prop to <form>."
              ) : console.error(
                "You can only pass the formAction prop to <input> or <button>."
              ));
              if ("function" === typeof value) {
                domElement.setAttribute(
                  key,
                  "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
                );
                break;
              } else
                "function" === typeof prevValue && ("formAction" === key ? ("input" !== tag && setProp(domElement, tag, "name", props.name, props, null), setProp(
                  domElement,
                  tag,
                  "formEncType",
                  props.formEncType,
                  props,
                  null
                ), setProp(
                  domElement,
                  tag,
                  "formMethod",
                  props.formMethod,
                  props,
                  null
                ), setProp(
                  domElement,
                  tag,
                  "formTarget",
                  props.formTarget,
                  props,
                  null
                )) : (setProp(
                  domElement,
                  tag,
                  "encType",
                  props.encType,
                  props,
                  null
                ), setProp(domElement, tag, "method", props.method, props, null), setProp(
                  domElement,
                  tag,
                  "target",
                  props.target,
                  props,
                  null
                )));
              if (null == value || "symbol" === typeof value || "boolean" === typeof value) {
                domElement.removeAttribute(key);
                break;
              }
              checkAttributeStringCoercion(value, key);
              value = sanitizeURL("" + value);
              domElement.setAttribute(key, value);
              break;
            case "onClick":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), domElement.onclick = noop$1);
              break;
            case "onScroll":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scroll", domElement));
              break;
            case "onScrollEnd":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scrollend", domElement));
              break;
            case "dangerouslySetInnerHTML":
              if (null != value) {
                if ("object" !== typeof value || !("__html" in value))
                  throw Error(
                    "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
                  );
                key = value.__html;
                if (null != key) {
                  if (null != props.children)
                    throw Error(
                      "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                    );
                  domElement.innerHTML = key;
                }
              }
              break;
            case "multiple":
              domElement.multiple = value && "function" !== typeof value && "symbol" !== typeof value;
              break;
            case "muted":
              domElement.muted = value && "function" !== typeof value && "symbol" !== typeof value;
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
            case "defaultValue":
            case "defaultChecked":
            case "innerHTML":
            case "ref":
              break;
            case "autoFocus":
              break;
            case "xlinkHref":
              if (null == value || "function" === typeof value || "boolean" === typeof value || "symbol" === typeof value) {
                domElement.removeAttribute("xlink:href");
                break;
              }
              checkAttributeStringCoercion(value, key);
              key = sanitizeURL("" + value);
              domElement.setAttributeNS(xlinkNamespace, "xlink:href", key);
              break;
            case "contentEditable":
            case "spellCheck":
            case "draggable":
            case "value":
            case "autoReverse":
            case "externalResourcesRequired":
            case "focusable":
            case "preserveAlpha":
              null != value && "function" !== typeof value && "symbol" !== typeof value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, "" + value)) : domElement.removeAttribute(key);
              break;
            case "inert":
              "" !== value || didWarnForNewBooleanPropsWithEmptyValue[key] || (didWarnForNewBooleanPropsWithEmptyValue[key] = true, console.error(
                "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
                key
              ));
            case "allowFullScreen":
            case "async":
            case "autoPlay":
            case "controls":
            case "default":
            case "defer":
            case "disabled":
            case "disablePictureInPicture":
            case "disableRemotePlayback":
            case "formNoValidate":
            case "hidden":
            case "loop":
            case "noModule":
            case "noValidate":
            case "open":
            case "playsInline":
            case "readOnly":
            case "required":
            case "reversed":
            case "scoped":
            case "seamless":
            case "itemScope":
              value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "") : domElement.removeAttribute(key);
              break;
            case "capture":
            case "download":
              true === value ? domElement.setAttribute(key, "") : false !== value && null != value && "function" !== typeof value && "symbol" !== typeof value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value)) : domElement.removeAttribute(key);
              break;
            case "cols":
            case "rows":
            case "size":
            case "span":
              null != value && "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value)) : domElement.removeAttribute(key);
              break;
            case "rowSpan":
            case "start":
              null == value || "function" === typeof value || "symbol" === typeof value || isNaN(value) ? domElement.removeAttribute(key) : (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value));
              break;
            case "popover":
              listenToNonDelegatedEvent("beforetoggle", domElement);
              listenToNonDelegatedEvent("toggle", domElement);
              setValueForAttribute(domElement, "popover", value);
              break;
            case "xlinkActuate":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:actuate",
                value
              );
              break;
            case "xlinkArcrole":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:arcrole",
                value
              );
              break;
            case "xlinkRole":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:role",
                value
              );
              break;
            case "xlinkShow":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:show",
                value
              );
              break;
            case "xlinkTitle":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:title",
                value
              );
              break;
            case "xlinkType":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:type",
                value
              );
              break;
            case "xmlBase":
              setValueForNamespacedAttribute(
                domElement,
                xmlNamespace,
                "xml:base",
                value
              );
              break;
            case "xmlLang":
              setValueForNamespacedAttribute(
                domElement,
                xmlNamespace,
                "xml:lang",
                value
              );
              break;
            case "xmlSpace":
              setValueForNamespacedAttribute(
                domElement,
                xmlNamespace,
                "xml:space",
                value
              );
              break;
            case "is":
              null != prevValue && console.error(
                'Cannot update the "is" prop after it has been initialized.'
              );
              setValueForAttribute(domElement, "is", value);
              break;
            case "innerText":
            case "textContent":
              break;
            case "popoverTarget":
              didWarnPopoverTargetObject || null == value || "object" !== typeof value || (didWarnPopoverTargetObject = true, console.error(
                "The `popoverTarget` prop expects the ID of an Element as a string. Received %s instead.",
                value
              ));
            default:
              !(2 < key.length) || "o" !== key[0] && "O" !== key[0] || "n" !== key[1] && "N" !== key[1] ? (key = getAttributeAlias(key), setValueForAttribute(domElement, key, value)) : registrationNameDependencies.hasOwnProperty(key) && null != value && "function" !== typeof value && warnForInvalidEventListener(key, value);
          }
        }
        function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
          switch (key) {
            case "style":
              setValueForStyles(domElement, value, prevValue);
              break;
            case "dangerouslySetInnerHTML":
              if (null != value) {
                if ("object" !== typeof value || !("__html" in value))
                  throw Error(
                    "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
                  );
                key = value.__html;
                if (null != key) {
                  if (null != props.children)
                    throw Error(
                      "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                    );
                  domElement.innerHTML = key;
                }
              }
              break;
            case "children":
              "string" === typeof value ? setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && setTextContent(domElement, "" + value);
              break;
            case "onScroll":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scroll", domElement));
              break;
            case "onScrollEnd":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scrollend", domElement));
              break;
            case "onClick":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), domElement.onclick = noop$1);
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
            case "innerHTML":
            case "ref":
              break;
            case "innerText":
            case "textContent":
              break;
            default:
              if (registrationNameDependencies.hasOwnProperty(key))
                null != value && "function" !== typeof value && warnForInvalidEventListener(key, value);
              else
                a: {
                  if ("o" === key[0] && "n" === key[1] && (props = key.endsWith("Capture"), tag = key.slice(2, props ? key.length - 7 : void 0), prevValue = domElement[internalPropsKey] || null, prevValue = null != prevValue ? prevValue[key] : null, "function" === typeof prevValue && domElement.removeEventListener(tag, prevValue, props), "function" === typeof value)) {
                    "function" !== typeof prevValue && null !== prevValue && (key in domElement ? domElement[key] = null : domElement.hasAttribute(key) && domElement.removeAttribute(key));
                    domElement.addEventListener(tag, value, props);
                    break a;
                  }
                  key in domElement ? domElement[key] = value : true === value ? domElement.setAttribute(key, "") : setValueForAttribute(domElement, key, value);
                }
          }
        }
        function setInitialProperties(domElement, tag, props) {
          validatePropertiesInDevelopment(tag, props);
          switch (tag) {
            case "div":
            case "span":
            case "svg":
            case "path":
            case "a":
            case "g":
            case "p":
            case "li":
              break;
            case "img":
              listenToNonDelegatedEvent("error", domElement);
              listenToNonDelegatedEvent("load", domElement);
              var hasSrc = false, hasSrcSet = false, propKey;
              for (propKey in props)
                if (props.hasOwnProperty(propKey)) {
                  var propValue = props[propKey];
                  if (null != propValue)
                    switch (propKey) {
                      case "src":
                        hasSrc = true;
                        break;
                      case "srcSet":
                        hasSrcSet = true;
                        break;
                      case "children":
                      case "dangerouslySetInnerHTML":
                        throw Error(
                          tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                        );
                      default:
                        setProp(domElement, tag, propKey, propValue, props, null);
                    }
                }
              hasSrcSet && setProp(domElement, tag, "srcSet", props.srcSet, props, null);
              hasSrc && setProp(domElement, tag, "src", props.src, props, null);
              return;
            case "input":
              checkControlledValueProps("input", props);
              listenToNonDelegatedEvent("invalid", domElement);
              var defaultValue = propKey = propValue = hasSrcSet = null, checked = null, defaultChecked = null;
              for (hasSrc in props)
                if (props.hasOwnProperty(hasSrc)) {
                  var _propValue = props[hasSrc];
                  if (null != _propValue)
                    switch (hasSrc) {
                      case "name":
                        hasSrcSet = _propValue;
                        break;
                      case "type":
                        propValue = _propValue;
                        break;
                      case "checked":
                        checked = _propValue;
                        break;
                      case "defaultChecked":
                        defaultChecked = _propValue;
                        break;
                      case "value":
                        propKey = _propValue;
                        break;
                      case "defaultValue":
                        defaultValue = _propValue;
                        break;
                      case "children":
                      case "dangerouslySetInnerHTML":
                        if (null != _propValue)
                          throw Error(
                            tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                          );
                        break;
                      default:
                        setProp(domElement, tag, hasSrc, _propValue, props, null);
                    }
                }
              validateInputProps(domElement, props);
              initInput(
                domElement,
                propKey,
                defaultValue,
                checked,
                defaultChecked,
                propValue,
                hasSrcSet,
                false
              );
              return;
            case "select":
              checkControlledValueProps("select", props);
              listenToNonDelegatedEvent("invalid", domElement);
              hasSrc = propValue = propKey = null;
              for (hasSrcSet in props)
                if (props.hasOwnProperty(hasSrcSet) && (defaultValue = props[hasSrcSet], null != defaultValue))
                  switch (hasSrcSet) {
                    case "value":
                      propKey = defaultValue;
                      break;
                    case "defaultValue":
                      propValue = defaultValue;
                      break;
                    case "multiple":
                      hasSrc = defaultValue;
                    default:
                      setProp(
                        domElement,
                        tag,
                        hasSrcSet,
                        defaultValue,
                        props,
                        null
                      );
                  }
              validateSelectProps(domElement, props);
              tag = propKey;
              props = propValue;
              domElement.multiple = !!hasSrc;
              null != tag ? updateOptions(domElement, !!hasSrc, tag, false) : null != props && updateOptions(domElement, !!hasSrc, props, true);
              return;
            case "textarea":
              checkControlledValueProps("textarea", props);
              listenToNonDelegatedEvent("invalid", domElement);
              propKey = hasSrcSet = hasSrc = null;
              for (propValue in props)
                if (props.hasOwnProperty(propValue) && (defaultValue = props[propValue], null != defaultValue))
                  switch (propValue) {
                    case "value":
                      hasSrc = defaultValue;
                      break;
                    case "defaultValue":
                      hasSrcSet = defaultValue;
                      break;
                    case "children":
                      propKey = defaultValue;
                      break;
                    case "dangerouslySetInnerHTML":
                      if (null != defaultValue)
                        throw Error(
                          "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                        );
                      break;
                    default:
                      setProp(
                        domElement,
                        tag,
                        propValue,
                        defaultValue,
                        props,
                        null
                      );
                  }
              validateTextareaProps(domElement, props);
              initTextarea(domElement, hasSrc, hasSrcSet, propKey);
              return;
            case "option":
              validateOptionProps(domElement, props);
              for (checked in props)
                if (props.hasOwnProperty(checked) && (hasSrc = props[checked], null != hasSrc))
                  switch (checked) {
                    case "selected":
                      domElement.selected = hasSrc && "function" !== typeof hasSrc && "symbol" !== typeof hasSrc;
                      break;
                    default:
                      setProp(domElement, tag, checked, hasSrc, props, null);
                  }
              return;
            case "dialog":
              listenToNonDelegatedEvent("beforetoggle", domElement);
              listenToNonDelegatedEvent("toggle", domElement);
              listenToNonDelegatedEvent("cancel", domElement);
              listenToNonDelegatedEvent("close", domElement);
              break;
            case "iframe":
            case "object":
              listenToNonDelegatedEvent("load", domElement);
              break;
            case "video":
            case "audio":
              for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
                listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
              break;
            case "image":
              listenToNonDelegatedEvent("error", domElement);
              listenToNonDelegatedEvent("load", domElement);
              break;
            case "details":
              listenToNonDelegatedEvent("toggle", domElement);
              break;
            case "embed":
            case "source":
            case "link":
              listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
            case "area":
            case "base":
            case "br":
            case "col":
            case "hr":
            case "keygen":
            case "meta":
            case "param":
            case "track":
            case "wbr":
            case "menuitem":
              for (defaultChecked in props)
                if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], null != hasSrc))
                  switch (defaultChecked) {
                    case "children":
                    case "dangerouslySetInnerHTML":
                      throw Error(
                        tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                      );
                    default:
                      setProp(domElement, tag, defaultChecked, hasSrc, props, null);
                  }
              return;
            default:
              if (isCustomElement(tag)) {
                for (_propValue in props)
                  props.hasOwnProperty(_propValue) && (hasSrc = props[_propValue], void 0 !== hasSrc && setPropOnCustomElement(
                    domElement,
                    tag,
                    _propValue,
                    hasSrc,
                    props,
                    void 0
                  ));
                return;
              }
          }
          for (defaultValue in props)
            props.hasOwnProperty(defaultValue) && (hasSrc = props[defaultValue], null != hasSrc && setProp(domElement, tag, defaultValue, hasSrc, props, null));
        }
        function updateProperties(domElement, tag, lastProps, nextProps) {
          validatePropertiesInDevelopment(tag, nextProps);
          switch (tag) {
            case "div":
            case "span":
            case "svg":
            case "path":
            case "a":
            case "g":
            case "p":
            case "li":
              break;
            case "input":
              var name = null, type = null, value = null, defaultValue = null, lastDefaultValue = null, checked = null, defaultChecked = null;
              for (propKey in lastProps) {
                var lastProp = lastProps[propKey];
                if (lastProps.hasOwnProperty(propKey) && null != lastProp)
                  switch (propKey) {
                    case "checked":
                      break;
                    case "value":
                      break;
                    case "defaultValue":
                      lastDefaultValue = lastProp;
                    default:
                      nextProps.hasOwnProperty(propKey) || setProp(
                        domElement,
                        tag,
                        propKey,
                        null,
                        nextProps,
                        lastProp
                      );
                  }
              }
              for (var _propKey8 in nextProps) {
                var propKey = nextProps[_propKey8];
                lastProp = lastProps[_propKey8];
                if (nextProps.hasOwnProperty(_propKey8) && (null != propKey || null != lastProp))
                  switch (_propKey8) {
                    case "type":
                      type = propKey;
                      break;
                    case "name":
                      name = propKey;
                      break;
                    case "checked":
                      checked = propKey;
                      break;
                    case "defaultChecked":
                      defaultChecked = propKey;
                      break;
                    case "value":
                      value = propKey;
                      break;
                    case "defaultValue":
                      defaultValue = propKey;
                      break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                      if (null != propKey)
                        throw Error(
                          tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                        );
                      break;
                    default:
                      propKey !== lastProp && setProp(
                        domElement,
                        tag,
                        _propKey8,
                        propKey,
                        nextProps,
                        lastProp
                      );
                  }
              }
              tag = "checkbox" === lastProps.type || "radio" === lastProps.type ? null != lastProps.checked : null != lastProps.value;
              nextProps = "checkbox" === nextProps.type || "radio" === nextProps.type ? null != nextProps.checked : null != nextProps.value;
              tag || !nextProps || didWarnUncontrolledToControlled || (console.error(
                "A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"
              ), didWarnUncontrolledToControlled = true);
              !tag || nextProps || didWarnControlledToUncontrolled || (console.error(
                "A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"
              ), didWarnControlledToUncontrolled = true);
              updateInput(
                domElement,
                value,
                defaultValue,
                lastDefaultValue,
                checked,
                defaultChecked,
                type,
                name
              );
              return;
            case "select":
              propKey = value = defaultValue = _propKey8 = null;
              for (type in lastProps)
                if (lastDefaultValue = lastProps[type], lastProps.hasOwnProperty(type) && null != lastDefaultValue)
                  switch (type) {
                    case "value":
                      break;
                    case "multiple":
                      propKey = lastDefaultValue;
                    default:
                      nextProps.hasOwnProperty(type) || setProp(
                        domElement,
                        tag,
                        type,
                        null,
                        nextProps,
                        lastDefaultValue
                      );
                  }
              for (name in nextProps)
                if (type = nextProps[name], lastDefaultValue = lastProps[name], nextProps.hasOwnProperty(name) && (null != type || null != lastDefaultValue))
                  switch (name) {
                    case "value":
                      _propKey8 = type;
                      break;
                    case "defaultValue":
                      defaultValue = type;
                      break;
                    case "multiple":
                      value = type;
                    default:
                      type !== lastDefaultValue && setProp(
                        domElement,
                        tag,
                        name,
                        type,
                        nextProps,
                        lastDefaultValue
                      );
                  }
              nextProps = defaultValue;
              tag = value;
              lastProps = propKey;
              null != _propKey8 ? updateOptions(domElement, !!tag, _propKey8, false) : !!lastProps !== !!tag && (null != nextProps ? updateOptions(domElement, !!tag, nextProps, true) : updateOptions(domElement, !!tag, tag ? [] : "", false));
              return;
            case "textarea":
              propKey = _propKey8 = null;
              for (defaultValue in lastProps)
                if (name = lastProps[defaultValue], lastProps.hasOwnProperty(defaultValue) && null != name && !nextProps.hasOwnProperty(defaultValue))
                  switch (defaultValue) {
                    case "value":
                      break;
                    case "children":
                      break;
                    default:
                      setProp(domElement, tag, defaultValue, null, nextProps, name);
                  }
              for (value in nextProps)
                if (name = nextProps[value], type = lastProps[value], nextProps.hasOwnProperty(value) && (null != name || null != type))
                  switch (value) {
                    case "value":
                      _propKey8 = name;
                      break;
                    case "defaultValue":
                      propKey = name;
                      break;
                    case "children":
                      break;
                    case "dangerouslySetInnerHTML":
                      if (null != name)
                        throw Error(
                          "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                        );
                      break;
                    default:
                      name !== type && setProp(domElement, tag, value, name, nextProps, type);
                  }
              updateTextarea(domElement, _propKey8, propKey);
              return;
            case "option":
              for (var _propKey13 in lastProps)
                if (_propKey8 = lastProps[_propKey13], lastProps.hasOwnProperty(_propKey13) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey13))
                  switch (_propKey13) {
                    case "selected":
                      domElement.selected = false;
                      break;
                    default:
                      setProp(
                        domElement,
                        tag,
                        _propKey13,
                        null,
                        nextProps,
                        _propKey8
                      );
                  }
              for (lastDefaultValue in nextProps)
                if (_propKey8 = nextProps[lastDefaultValue], propKey = lastProps[lastDefaultValue], nextProps.hasOwnProperty(lastDefaultValue) && _propKey8 !== propKey && (null != _propKey8 || null != propKey))
                  switch (lastDefaultValue) {
                    case "selected":
                      domElement.selected = _propKey8 && "function" !== typeof _propKey8 && "symbol" !== typeof _propKey8;
                      break;
                    default:
                      setProp(
                        domElement,
                        tag,
                        lastDefaultValue,
                        _propKey8,
                        nextProps,
                        propKey
                      );
                  }
              return;
            case "img":
            case "link":
            case "area":
            case "base":
            case "br":
            case "col":
            case "embed":
            case "hr":
            case "keygen":
            case "meta":
            case "param":
            case "source":
            case "track":
            case "wbr":
            case "menuitem":
              for (var _propKey15 in lastProps)
                _propKey8 = lastProps[_propKey15], lastProps.hasOwnProperty(_propKey15) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey15) && setProp(
                  domElement,
                  tag,
                  _propKey15,
                  null,
                  nextProps,
                  _propKey8
                );
              for (checked in nextProps)
                if (_propKey8 = nextProps[checked], propKey = lastProps[checked], nextProps.hasOwnProperty(checked) && _propKey8 !== propKey && (null != _propKey8 || null != propKey))
                  switch (checked) {
                    case "children":
                    case "dangerouslySetInnerHTML":
                      if (null != _propKey8)
                        throw Error(
                          tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                        );
                      break;
                    default:
                      setProp(
                        domElement,
                        tag,
                        checked,
                        _propKey8,
                        nextProps,
                        propKey
                      );
                  }
              return;
            default:
              if (isCustomElement(tag)) {
                for (var _propKey17 in lastProps)
                  _propKey8 = lastProps[_propKey17], lastProps.hasOwnProperty(_propKey17) && void 0 !== _propKey8 && !nextProps.hasOwnProperty(_propKey17) && setPropOnCustomElement(
                    domElement,
                    tag,
                    _propKey17,
                    void 0,
                    nextProps,
                    _propKey8
                  );
                for (defaultChecked in nextProps)
                  _propKey8 = nextProps[defaultChecked], propKey = lastProps[defaultChecked], !nextProps.hasOwnProperty(defaultChecked) || _propKey8 === propKey || void 0 === _propKey8 && void 0 === propKey || setPropOnCustomElement(
                    domElement,
                    tag,
                    defaultChecked,
                    _propKey8,
                    nextProps,
                    propKey
                  );
                return;
              }
          }
          for (var _propKey19 in lastProps)
            _propKey8 = lastProps[_propKey19], lastProps.hasOwnProperty(_propKey19) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey19) && setProp(domElement, tag, _propKey19, null, nextProps, _propKey8);
          for (lastProp in nextProps)
            _propKey8 = nextProps[lastProp], propKey = lastProps[lastProp], !nextProps.hasOwnProperty(lastProp) || _propKey8 === propKey || null == _propKey8 && null == propKey || setProp(domElement, tag, lastProp, _propKey8, nextProps, propKey);
        }
        function getPropNameFromAttributeName(attrName) {
          switch (attrName) {
            case "class":
              return "className";
            case "for":
              return "htmlFor";
            default:
              return attrName;
          }
        }
        function getStylesObjectFromElement(domElement) {
          var serverValueInObjectForm = {};
          domElement = domElement.style;
          for (var i8 = 0; i8 < domElement.length; i8++) {
            var styleName = domElement[i8];
            serverValueInObjectForm[styleName] = domElement.getPropertyValue(styleName);
          }
          return serverValueInObjectForm;
        }
        function diffHydratedStyles(domElement, value$jscomp$0, serverDifferences) {
          if (null != value$jscomp$0 && "object" !== typeof value$jscomp$0)
            console.error(
              "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
            );
          else {
            var clientValue;
            var delimiter = clientValue = "", styleName;
            for (styleName in value$jscomp$0)
              if (value$jscomp$0.hasOwnProperty(styleName)) {
                var value = value$jscomp$0[styleName];
                null != value && "boolean" !== typeof value && "" !== value && (0 === styleName.indexOf("--") ? (checkCSSPropertyStringCoercion(value, styleName), clientValue += delimiter + styleName + ":" + ("" + value).trim()) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? (checkCSSPropertyStringCoercion(value, styleName), clientValue += delimiter + styleName.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-") + ":" + ("" + value).trim()) : clientValue += delimiter + styleName.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-") + ":" + value + "px", delimiter = ";");
              }
            clientValue = clientValue || null;
            value$jscomp$0 = domElement.getAttribute("style");
            value$jscomp$0 !== clientValue && (clientValue = normalizeMarkupForTextOrAttribute(clientValue), normalizeMarkupForTextOrAttribute(value$jscomp$0) !== clientValue && (serverDifferences.style = getStylesObjectFromElement(domElement)));
          }
        }
        function hydrateAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
          extraAttributes.delete(attributeName);
          domElement = domElement.getAttribute(attributeName);
          if (null === domElement)
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                return;
            }
          else if (null != value)
            switch (typeof value) {
              case "function":
              case "symbol":
              case "boolean":
                break;
              default:
                if (checkAttributeStringCoercion(value, propKey), domElement === "" + value)
                  return;
            }
          warnForPropDifference(propKey, domElement, value, serverDifferences);
        }
        function hydrateBooleanAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
          extraAttributes.delete(attributeName);
          domElement = domElement.getAttribute(attributeName);
          if (null === domElement) {
            switch (typeof value) {
              case "function":
              case "symbol":
                return;
            }
            if (!value) return;
          } else
            switch (typeof value) {
              case "function":
              case "symbol":
                break;
              default:
                if (value) return;
            }
          warnForPropDifference(propKey, domElement, value, serverDifferences);
        }
        function hydrateBooleanishAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
          extraAttributes.delete(attributeName);
          domElement = domElement.getAttribute(attributeName);
          if (null === domElement)
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
                return;
            }
          else if (null != value)
            switch (typeof value) {
              case "function":
              case "symbol":
                break;
              default:
                if (checkAttributeStringCoercion(value, attributeName), domElement === "" + value)
                  return;
            }
          warnForPropDifference(propKey, domElement, value, serverDifferences);
        }
        function hydrateNumericAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
          extraAttributes.delete(attributeName);
          domElement = domElement.getAttribute(attributeName);
          if (null === domElement)
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                return;
              default:
                if (isNaN(value)) return;
            }
          else if (null != value)
            switch (typeof value) {
              case "function":
              case "symbol":
              case "boolean":
                break;
              default:
                if (!isNaN(value) && (checkAttributeStringCoercion(value, propKey), domElement === "" + value))
                  return;
            }
          warnForPropDifference(propKey, domElement, value, serverDifferences);
        }
        function hydrateSanitizedAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
          extraAttributes.delete(attributeName);
          domElement = domElement.getAttribute(attributeName);
          if (null === domElement)
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                return;
            }
          else if (null != value)
            switch (typeof value) {
              case "function":
              case "symbol":
              case "boolean":
                break;
              default:
                if (checkAttributeStringCoercion(value, propKey), attributeName = sanitizeURL("" + value), domElement === attributeName)
                  return;
            }
          warnForPropDifference(propKey, domElement, value, serverDifferences);
        }
        function diffHydratedProperties(domElement, tag, props, hostContext) {
          for (var serverDifferences = {}, extraAttributes = /* @__PURE__ */ new Set(), attributes = domElement.attributes, i8 = 0; i8 < attributes.length; i8++)
            switch (attributes[i8].name.toLowerCase()) {
              case "value":
                break;
              case "checked":
                break;
              case "selected":
                break;
              default:
                extraAttributes.add(attributes[i8].name);
            }
          if (isCustomElement(tag))
            for (var propKey in props) {
              if (props.hasOwnProperty(propKey)) {
                var value = props[propKey];
                if (null != value) {
                  if (registrationNameDependencies.hasOwnProperty(propKey))
                    "function" !== typeof value && warnForInvalidEventListener(propKey, value);
                  else if (true !== props.suppressHydrationWarning)
                    switch (propKey) {
                      case "children":
                        "string" !== typeof value && "number" !== typeof value || warnForPropDifference(
                          "children",
                          domElement.textContent,
                          value,
                          serverDifferences
                        );
                        continue;
                      case "suppressContentEditableWarning":
                      case "suppressHydrationWarning":
                      case "defaultValue":
                      case "defaultChecked":
                      case "innerHTML":
                      case "ref":
                        continue;
                      case "dangerouslySetInnerHTML":
                        attributes = domElement.innerHTML;
                        value = value ? value.__html : void 0;
                        null != value && (value = normalizeHTML(domElement, value), warnForPropDifference(
                          propKey,
                          attributes,
                          value,
                          serverDifferences
                        ));
                        continue;
                      case "style":
                        extraAttributes.delete(propKey);
                        diffHydratedStyles(domElement, value, serverDifferences);
                        continue;
                      case "offsetParent":
                      case "offsetTop":
                      case "offsetLeft":
                      case "offsetWidth":
                      case "offsetHeight":
                      case "isContentEditable":
                      case "outerText":
                      case "outerHTML":
                        extraAttributes.delete(propKey.toLowerCase());
                        console.error(
                          "Assignment to read-only property will result in a no-op: `%s`",
                          propKey
                        );
                        continue;
                      case "className":
                        extraAttributes.delete("class");
                        attributes = getValueForAttributeOnCustomComponent(
                          domElement,
                          "class",
                          value
                        );
                        warnForPropDifference(
                          "className",
                          attributes,
                          value,
                          serverDifferences
                        );
                        continue;
                      default:
                        hostContext.context === HostContextNamespaceNone && "svg" !== tag && "math" !== tag ? extraAttributes.delete(propKey.toLowerCase()) : extraAttributes.delete(propKey), attributes = getValueForAttributeOnCustomComponent(
                          domElement,
                          propKey,
                          value
                        ), warnForPropDifference(
                          propKey,
                          attributes,
                          value,
                          serverDifferences
                        );
                    }
                }
              }
            }
          else
            for (value in props)
              if (props.hasOwnProperty(value) && (propKey = props[value], null != propKey)) {
                if (registrationNameDependencies.hasOwnProperty(value))
                  "function" !== typeof propKey && warnForInvalidEventListener(value, propKey);
                else if (true !== props.suppressHydrationWarning)
                  switch (value) {
                    case "children":
                      "string" !== typeof propKey && "number" !== typeof propKey || warnForPropDifference(
                        "children",
                        domElement.textContent,
                        propKey,
                        serverDifferences
                      );
                      continue;
                    case "suppressContentEditableWarning":
                    case "suppressHydrationWarning":
                    case "value":
                    case "checked":
                    case "selected":
                    case "defaultValue":
                    case "defaultChecked":
                    case "innerHTML":
                    case "ref":
                      continue;
                    case "dangerouslySetInnerHTML":
                      attributes = domElement.innerHTML;
                      propKey = propKey ? propKey.__html : void 0;
                      null != propKey && (propKey = normalizeHTML(domElement, propKey), attributes !== propKey && (serverDifferences[value] = { __html: attributes }));
                      continue;
                    case "className":
                      hydrateAttribute(
                        domElement,
                        value,
                        "class",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "tabIndex":
                      hydrateAttribute(
                        domElement,
                        value,
                        "tabindex",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "style":
                      extraAttributes.delete(value);
                      diffHydratedStyles(domElement, propKey, serverDifferences);
                      continue;
                    case "multiple":
                      extraAttributes.delete(value);
                      warnForPropDifference(
                        value,
                        domElement.multiple,
                        propKey,
                        serverDifferences
                      );
                      continue;
                    case "muted":
                      extraAttributes.delete(value);
                      warnForPropDifference(
                        value,
                        domElement.muted,
                        propKey,
                        serverDifferences
                      );
                      continue;
                    case "autoFocus":
                      extraAttributes.delete("autofocus");
                      warnForPropDifference(
                        value,
                        domElement.autofocus,
                        propKey,
                        serverDifferences
                      );
                      continue;
                    case "data":
                      if ("object" !== tag) {
                        extraAttributes.delete(value);
                        attributes = domElement.getAttribute("data");
                        warnForPropDifference(
                          value,
                          attributes,
                          propKey,
                          serverDifferences
                        );
                        continue;
                      }
                    case "src":
                    case "href":
                      if (!("" !== propKey || "a" === tag && "href" === value || "object" === tag && "data" === value)) {
                        "src" === value ? console.error(
                          'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                          value,
                          value
                        ) : console.error(
                          'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                          value,
                          value
                        );
                        continue;
                      }
                      hydrateSanitizedAttribute(
                        domElement,
                        value,
                        value,
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "action":
                    case "formAction":
                      attributes = domElement.getAttribute(value);
                      if ("function" === typeof propKey) {
                        extraAttributes.delete(value.toLowerCase());
                        "formAction" === value ? (extraAttributes.delete("name"), extraAttributes.delete("formenctype"), extraAttributes.delete("formmethod"), extraAttributes.delete("formtarget")) : (extraAttributes.delete("enctype"), extraAttributes.delete("method"), extraAttributes.delete("target"));
                        continue;
                      } else if (attributes === EXPECTED_FORM_ACTION_URL) {
                        extraAttributes.delete(value.toLowerCase());
                        warnForPropDifference(
                          value,
                          "function",
                          propKey,
                          serverDifferences
                        );
                        continue;
                      }
                      hydrateSanitizedAttribute(
                        domElement,
                        value,
                        value.toLowerCase(),
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkHref":
                      hydrateSanitizedAttribute(
                        domElement,
                        value,
                        "xlink:href",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "contentEditable":
                      hydrateBooleanishAttribute(
                        domElement,
                        value,
                        "contenteditable",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "spellCheck":
                      hydrateBooleanishAttribute(
                        domElement,
                        value,
                        "spellcheck",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "draggable":
                    case "autoReverse":
                    case "externalResourcesRequired":
                    case "focusable":
                    case "preserveAlpha":
                      hydrateBooleanishAttribute(
                        domElement,
                        value,
                        value,
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "allowFullScreen":
                    case "async":
                    case "autoPlay":
                    case "controls":
                    case "default":
                    case "defer":
                    case "disabled":
                    case "disablePictureInPicture":
                    case "disableRemotePlayback":
                    case "formNoValidate":
                    case "hidden":
                    case "loop":
                    case "noModule":
                    case "noValidate":
                    case "open":
                    case "playsInline":
                    case "readOnly":
                    case "required":
                    case "reversed":
                    case "scoped":
                    case "seamless":
                    case "itemScope":
                      hydrateBooleanAttribute(
                        domElement,
                        value,
                        value.toLowerCase(),
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "capture":
                    case "download":
                      a: {
                        i8 = domElement;
                        var attributeName = attributes = value, serverDifferences$jscomp$0 = serverDifferences;
                        extraAttributes.delete(attributeName);
                        i8 = i8.getAttribute(attributeName);
                        if (null === i8)
                          switch (typeof propKey) {
                            case "undefined":
                            case "function":
                            case "symbol":
                              break a;
                            default:
                              if (false === propKey) break a;
                          }
                        else if (null != propKey)
                          switch (typeof propKey) {
                            case "function":
                            case "symbol":
                              break;
                            case "boolean":
                              if (true === propKey && "" === i8) break a;
                              break;
                            default:
                              if (checkAttributeStringCoercion(propKey, attributes), i8 === "" + propKey)
                                break a;
                          }
                        warnForPropDifference(
                          attributes,
                          i8,
                          propKey,
                          serverDifferences$jscomp$0
                        );
                      }
                      continue;
                    case "cols":
                    case "rows":
                    case "size":
                    case "span":
                      a: {
                        i8 = domElement;
                        attributeName = attributes = value;
                        serverDifferences$jscomp$0 = serverDifferences;
                        extraAttributes.delete(attributeName);
                        i8 = i8.getAttribute(attributeName);
                        if (null === i8)
                          switch (typeof propKey) {
                            case "undefined":
                            case "function":
                            case "symbol":
                            case "boolean":
                              break a;
                            default:
                              if (isNaN(propKey) || 1 > propKey) break a;
                          }
                        else if (null != propKey)
                          switch (typeof propKey) {
                            case "function":
                            case "symbol":
                            case "boolean":
                              break;
                            default:
                              if (!(isNaN(propKey) || 1 > propKey) && (checkAttributeStringCoercion(propKey, attributes), i8 === "" + propKey))
                                break a;
                          }
                        warnForPropDifference(
                          attributes,
                          i8,
                          propKey,
                          serverDifferences$jscomp$0
                        );
                      }
                      continue;
                    case "rowSpan":
                      hydrateNumericAttribute(
                        domElement,
                        value,
                        "rowspan",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "start":
                      hydrateNumericAttribute(
                        domElement,
                        value,
                        value,
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xHeight":
                      hydrateAttribute(
                        domElement,
                        value,
                        "x-height",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkActuate":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:actuate",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkArcrole":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:arcrole",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkRole":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:role",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkShow":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:show",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkTitle":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:title",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkType":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:type",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xmlBase":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xml:base",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xmlLang":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xml:lang",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xmlSpace":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xml:space",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "inert":
                      "" !== propKey || didWarnForNewBooleanPropsWithEmptyValue[value] || (didWarnForNewBooleanPropsWithEmptyValue[value] = true, console.error(
                        "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
                        value
                      ));
                      hydrateBooleanAttribute(
                        domElement,
                        value,
                        value,
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    default:
                      if (!(2 < value.length) || "o" !== value[0] && "O" !== value[0] || "n" !== value[1] && "N" !== value[1]) {
                        i8 = getAttributeAlias(value);
                        attributes = false;
                        hostContext.context === HostContextNamespaceNone && "svg" !== tag && "math" !== tag ? extraAttributes.delete(i8.toLowerCase()) : (attributeName = value.toLowerCase(), attributeName = possibleStandardNames.hasOwnProperty(
                          attributeName
                        ) ? possibleStandardNames[attributeName] || null : null, null !== attributeName && attributeName !== value && (attributes = true, extraAttributes.delete(attributeName)), extraAttributes.delete(i8));
                        a: if (attributeName = domElement, serverDifferences$jscomp$0 = i8, i8 = propKey, isAttributeNameSafe(serverDifferences$jscomp$0))
                          if (attributeName.hasAttribute(serverDifferences$jscomp$0))
                            attributeName = attributeName.getAttribute(
                              serverDifferences$jscomp$0
                            ), checkAttributeStringCoercion(
                              i8,
                              serverDifferences$jscomp$0
                            ), i8 = attributeName === "" + i8 ? i8 : attributeName;
                          else {
                            switch (typeof i8) {
                              case "function":
                              case "symbol":
                                break a;
                              case "boolean":
                                if (attributeName = serverDifferences$jscomp$0.toLowerCase().slice(0, 5), "data-" !== attributeName && "aria-" !== attributeName)
                                  break a;
                            }
                            i8 = void 0 === i8 ? void 0 : null;
                          }
                        else i8 = void 0;
                        attributes || warnForPropDifference(
                          value,
                          i8,
                          propKey,
                          serverDifferences
                        );
                      }
                  }
              }
          0 < extraAttributes.size && true !== props.suppressHydrationWarning && warnForExtraAttributes(domElement, extraAttributes, serverDifferences);
          return 0 === Object.keys(serverDifferences).length ? null : serverDifferences;
        }
        function propNamesListJoin(list, combinator) {
          switch (list.length) {
            case 0:
              return "";
            case 1:
              return list[0];
            case 2:
              return list[0] + " " + combinator + " " + list[1];
            default:
              return list.slice(0, -1).join(", ") + ", " + combinator + " " + list[list.length - 1];
          }
        }
        function isLikelyStaticResource(initiatorType) {
          switch (initiatorType) {
            case "css":
            case "script":
            case "font":
            case "img":
            case "image":
            case "input":
            case "link":
              return true;
            default:
              return false;
          }
        }
        function estimateBandwidth() {
          if ("function" === typeof performance.getEntriesByType) {
            for (var count = 0, bits = 0, resourceEntries = performance.getEntriesByType("resource"), i8 = 0; i8 < resourceEntries.length; i8++) {
              var entry = resourceEntries[i8], transferSize = entry.transferSize, initiatorType = entry.initiatorType, duration = entry.duration;
              if (transferSize && duration && isLikelyStaticResource(initiatorType)) {
                initiatorType = 0;
                duration = entry.responseEnd;
                for (i8 += 1; i8 < resourceEntries.length; i8++) {
                  var overlapEntry = resourceEntries[i8], overlapStartTime = overlapEntry.startTime;
                  if (overlapStartTime > duration) break;
                  var overlapTransferSize = overlapEntry.transferSize, overlapInitiatorType = overlapEntry.initiatorType;
                  overlapTransferSize && isLikelyStaticResource(overlapInitiatorType) && (overlapEntry = overlapEntry.responseEnd, initiatorType += overlapTransferSize * (overlapEntry < duration ? 1 : (duration - overlapStartTime) / (overlapEntry - overlapStartTime)));
                }
                --i8;
                bits += 8 * (transferSize + initiatorType) / (entry.duration / 1e3);
                count++;
                if (10 < count) break;
              }
            }
            if (0 < count) return bits / count / 1e6;
          }
          return navigator.connection && (count = navigator.connection.downlink, "number" === typeof count) ? count : 5;
        }
        function getOwnerDocumentFromRootContainer(rootContainerElement) {
          return 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
        }
        function getOwnHostContext(namespaceURI) {
          switch (namespaceURI) {
            case SVG_NAMESPACE:
              return HostContextNamespaceSvg;
            case MATH_NAMESPACE:
              return HostContextNamespaceMath;
            default:
              return HostContextNamespaceNone;
          }
        }
        function getChildHostContextProd(parentNamespace, type) {
          if (parentNamespace === HostContextNamespaceNone)
            switch (type) {
              case "svg":
                return HostContextNamespaceSvg;
              case "math":
                return HostContextNamespaceMath;
              default:
                return HostContextNamespaceNone;
            }
          return parentNamespace === HostContextNamespaceSvg && "foreignObject" === type ? HostContextNamespaceNone : parentNamespace;
        }
        function shouldSetTextContent(type, props) {
          return "textarea" === type || "noscript" === type || "string" === typeof props.children || "number" === typeof props.children || "bigint" === typeof props.children || "object" === typeof props.dangerouslySetInnerHTML && null !== props.dangerouslySetInnerHTML && null != props.dangerouslySetInnerHTML.__html;
        }
        function shouldAttemptEagerTransition() {
          var event = window.event;
          if (event && "popstate" === event.type) {
            if (event === currentPopstateTransitionEvent) return false;
            currentPopstateTransitionEvent = event;
            return true;
          }
          currentPopstateTransitionEvent = null;
          return false;
        }
        function resolveEventType() {
          var event = window.event;
          return event && event !== schedulerEvent ? event.type : null;
        }
        function resolveEventTimeStamp() {
          var event = window.event;
          return event && event !== schedulerEvent ? event.timeStamp : -1.1;
        }
        function handleErrorInNextTick(error) {
          setTimeout(function() {
            throw error;
          });
        }
        function commitMount(domElement, type, newProps) {
          switch (type) {
            case "button":
            case "input":
            case "select":
            case "textarea":
              newProps.autoFocus && domElement.focus();
              break;
            case "img":
              newProps.src ? domElement.src = newProps.src : newProps.srcSet && (domElement.srcset = newProps.srcSet);
          }
        }
        function commitHydratedInstance() {
        }
        function commitUpdate(domElement, type, oldProps, newProps) {
          updateProperties(domElement, type, oldProps, newProps);
          domElement[internalPropsKey] = newProps;
        }
        function resetTextContent(domElement) {
          setTextContent(domElement, "");
        }
        function commitTextUpdate(textInstance, oldText, newText) {
          textInstance.nodeValue = newText;
        }
        function warnForReactChildrenConflict(container) {
          if (!container.__reactWarnedAboutChildrenConflict) {
            var props = container[internalPropsKey] || null;
            if (null !== props) {
              var fiber = getInstanceFromNode(container);
              null !== fiber && ("string" === typeof props.children || "number" === typeof props.children ? (container.__reactWarnedAboutChildrenConflict = true, runWithFiberInDEV(fiber, function() {
                console.error(
                  'Cannot use a ref on a React element as a container to `createRoot` or `createPortal` if that element also sets "children" text content using React. It should be a leaf with no children. Otherwise it\'s ambiguous which children should be used.'
                );
              })) : null != props.dangerouslySetInnerHTML && (container.__reactWarnedAboutChildrenConflict = true, runWithFiberInDEV(fiber, function() {
                console.error(
                  'Cannot use a ref on a React element as a container to `createRoot` or `createPortal` if that element also sets "dangerouslySetInnerHTML" using React. It should be a leaf with no children. Otherwise it\'s ambiguous which children should be used.'
                );
              })));
            }
          }
        }
        function isSingletonScope(type) {
          return "head" === type;
        }
        function removeChild(parentInstance, child) {
          parentInstance.removeChild(child);
        }
        function removeChildFromContainer(container, child) {
          (9 === container.nodeType ? container.body : "HTML" === container.nodeName ? container.ownerDocument.body : container).removeChild(child);
        }
        function clearHydrationBoundary(parentInstance, hydrationInstance) {
          var node = hydrationInstance, depth = 0;
          do {
            var nextNode = node.nextSibling;
            parentInstance.removeChild(node);
            if (nextNode && 8 === nextNode.nodeType)
              if (node = nextNode.data, node === SUSPENSE_END_DATA || node === ACTIVITY_END_DATA) {
                if (0 === depth) {
                  parentInstance.removeChild(nextNode);
                  retryIfBlockedOn(hydrationInstance);
                  return;
                }
                depth--;
              } else if (node === SUSPENSE_START_DATA || node === SUSPENSE_PENDING_START_DATA || node === SUSPENSE_QUEUED_START_DATA || node === SUSPENSE_FALLBACK_START_DATA || node === ACTIVITY_START_DATA)
                depth++;
              else if (node === PREAMBLE_CONTRIBUTION_HTML)
                releaseSingletonInstance(
                  parentInstance.ownerDocument.documentElement
                );
              else if (node === PREAMBLE_CONTRIBUTION_HEAD) {
                node = parentInstance.ownerDocument.head;
                releaseSingletonInstance(node);
                for (var node$jscomp$0 = node.firstChild; node$jscomp$0; ) {
                  var nextNode$jscomp$0 = node$jscomp$0.nextSibling, nodeName = node$jscomp$0.nodeName;
                  node$jscomp$0[internalHoistableMarker] || "SCRIPT" === nodeName || "STYLE" === nodeName || "LINK" === nodeName && "stylesheet" === node$jscomp$0.rel.toLowerCase() || node.removeChild(node$jscomp$0);
                  node$jscomp$0 = nextNode$jscomp$0;
                }
              } else
                node === PREAMBLE_CONTRIBUTION_BODY && releaseSingletonInstance(parentInstance.ownerDocument.body);
            node = nextNode;
          } while (node);
          retryIfBlockedOn(hydrationInstance);
        }
        function hideOrUnhideDehydratedBoundary(suspenseInstance, isHidden) {
          var node = suspenseInstance;
          suspenseInstance = 0;
          do {
            var nextNode = node.nextSibling;
            1 === node.nodeType ? isHidden ? (node._stashedDisplay = node.style.display, node.style.display = "none") : (node.style.display = node._stashedDisplay || "", "" === node.getAttribute("style") && node.removeAttribute("style")) : 3 === node.nodeType && (isHidden ? (node._stashedText = node.nodeValue, node.nodeValue = "") : node.nodeValue = node._stashedText || "");
            if (nextNode && 8 === nextNode.nodeType)
              if (node = nextNode.data, node === SUSPENSE_END_DATA)
                if (0 === suspenseInstance) break;
                else suspenseInstance--;
              else
                node !== SUSPENSE_START_DATA && node !== SUSPENSE_PENDING_START_DATA && node !== SUSPENSE_QUEUED_START_DATA && node !== SUSPENSE_FALLBACK_START_DATA || suspenseInstance++;
            node = nextNode;
          } while (node);
        }
        function hideDehydratedBoundary(suspenseInstance) {
          hideOrUnhideDehydratedBoundary(suspenseInstance, true);
        }
        function hideInstance(instance) {
          instance = instance.style;
          "function" === typeof instance.setProperty ? instance.setProperty("display", "none", "important") : instance.display = "none";
        }
        function hideTextInstance(textInstance) {
          textInstance.nodeValue = "";
        }
        function unhideDehydratedBoundary(dehydratedInstance) {
          hideOrUnhideDehydratedBoundary(dehydratedInstance, false);
        }
        function unhideInstance(instance, props) {
          props = props[STYLE];
          props = void 0 !== props && null !== props && props.hasOwnProperty("display") ? props.display : null;
          instance.style.display = null == props || "boolean" === typeof props ? "" : ("" + props).trim();
        }
        function unhideTextInstance(textInstance, text) {
          textInstance.nodeValue = text;
        }
        function clearContainerSparingly(container) {
          var nextNode = container.firstChild;
          nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
          for (; nextNode; ) {
            var node = nextNode;
            nextNode = nextNode.nextSibling;
            switch (node.nodeName) {
              case "HTML":
              case "HEAD":
              case "BODY":
                clearContainerSparingly(node);
                detachDeletedInstance(node);
                continue;
              case "SCRIPT":
              case "STYLE":
                continue;
              case "LINK":
                if ("stylesheet" === node.rel.toLowerCase()) continue;
            }
            container.removeChild(node);
          }
        }
        function canHydrateInstance(instance, type, props, inRootOrSingleton) {
          for (; 1 === instance.nodeType; ) {
            var anyProps = props;
            if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
              if (!inRootOrSingleton && ("INPUT" !== instance.nodeName || "hidden" !== instance.type))
                break;
            } else if (!inRootOrSingleton)
              if ("input" === type && "hidden" === instance.type) {
                checkAttributeStringCoercion(anyProps.name, "name");
                var name = null == anyProps.name ? null : "" + anyProps.name;
                if ("hidden" === anyProps.type && instance.getAttribute("name") === name)
                  return instance;
              } else return instance;
            else if (!instance[internalHoistableMarker])
              switch (type) {
                case "meta":
                  if (!instance.hasAttribute("itemprop")) break;
                  return instance;
                case "link":
                  name = instance.getAttribute("rel");
                  if ("stylesheet" === name && instance.hasAttribute("data-precedence"))
                    break;
                  else if (name !== anyProps.rel || instance.getAttribute("href") !== (null == anyProps.href || "" === anyProps.href ? null : anyProps.href) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) || instance.getAttribute("title") !== (null == anyProps.title ? null : anyProps.title))
                    break;
                  return instance;
                case "style":
                  if (instance.hasAttribute("data-precedence")) break;
                  return instance;
                case "script":
                  name = instance.getAttribute("src");
                  if ((name !== (null == anyProps.src ? null : anyProps.src) || instance.getAttribute("type") !== (null == anyProps.type ? null : anyProps.type) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) && name && instance.hasAttribute("async") && !instance.hasAttribute("itemprop"))
                    break;
                  return instance;
                default:
                  return instance;
              }
            instance = getNextHydratable(instance.nextSibling);
            if (null === instance) break;
          }
          return null;
        }
        function canHydrateTextInstance(instance, text, inRootOrSingleton) {
          if ("" === text) return null;
          for (; 3 !== instance.nodeType; ) {
            if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
              return null;
            instance = getNextHydratable(instance.nextSibling);
            if (null === instance) return null;
          }
          return instance;
        }
        function canHydrateHydrationBoundary(instance, inRootOrSingleton) {
          for (; 8 !== instance.nodeType; ) {
            if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
              return null;
            instance = getNextHydratable(instance.nextSibling);
            if (null === instance) return null;
          }
          return instance;
        }
        function isSuspenseInstancePending(instance) {
          return instance.data === SUSPENSE_PENDING_START_DATA || instance.data === SUSPENSE_QUEUED_START_DATA;
        }
        function isSuspenseInstanceFallback(instance) {
          return instance.data === SUSPENSE_FALLBACK_START_DATA || instance.data === SUSPENSE_PENDING_START_DATA && instance.ownerDocument.readyState !== DOCUMENT_READY_STATE_LOADING;
        }
        function registerSuspenseInstanceRetry(instance, callback) {
          var ownerDocument = instance.ownerDocument;
          if (instance.data === SUSPENSE_QUEUED_START_DATA)
            instance._reactRetry = callback;
          else if (instance.data !== SUSPENSE_PENDING_START_DATA || ownerDocument.readyState !== DOCUMENT_READY_STATE_LOADING)
            callback();
          else {
            var listener = function() {
              callback();
              ownerDocument.removeEventListener("DOMContentLoaded", listener);
            };
            ownerDocument.addEventListener("DOMContentLoaded", listener);
            instance._reactRetry = listener;
          }
        }
        function getNextHydratable(node) {
          for (; null != node; node = node.nextSibling) {
            var nodeType = node.nodeType;
            if (1 === nodeType || 3 === nodeType) break;
            if (8 === nodeType) {
              nodeType = node.data;
              if (nodeType === SUSPENSE_START_DATA || nodeType === SUSPENSE_FALLBACK_START_DATA || nodeType === SUSPENSE_PENDING_START_DATA || nodeType === SUSPENSE_QUEUED_START_DATA || nodeType === ACTIVITY_START_DATA || nodeType === FORM_STATE_IS_MATCHING || nodeType === FORM_STATE_IS_NOT_MATCHING)
                break;
              if (nodeType === SUSPENSE_END_DATA || nodeType === ACTIVITY_END_DATA)
                return null;
            }
          }
          return node;
        }
        function describeHydratableInstanceForDevWarnings(instance) {
          if (1 === instance.nodeType) {
            for (var JSCompiler_temp_const = instance.nodeName.toLowerCase(), serverDifferences = {}, attributes = instance.attributes, i8 = 0; i8 < attributes.length; i8++) {
              var attr = attributes[i8];
              serverDifferences[getPropNameFromAttributeName(attr.name)] = "style" === attr.name.toLowerCase() ? getStylesObjectFromElement(instance) : attr.value;
            }
            return { type: JSCompiler_temp_const, props: serverDifferences };
          }
          return 8 === instance.nodeType ? instance.data === ACTIVITY_START_DATA ? { type: "Activity", props: {} } : { type: "Suspense", props: {} } : instance.nodeValue;
        }
        function diffHydratedTextForDevWarnings(textInstance, text, parentProps) {
          return null === parentProps || true !== parentProps[SUPPRESS_HYDRATION_WARNING] ? (textInstance.nodeValue === text ? textInstance = null : (text = normalizeMarkupForTextOrAttribute(text), textInstance = normalizeMarkupForTextOrAttribute(textInstance.nodeValue) === text ? null : textInstance.nodeValue), textInstance) : null;
        }
        function getNextHydratableInstanceAfterHydrationBoundary(hydrationInstance) {
          hydrationInstance = hydrationInstance.nextSibling;
          for (var depth = 0; hydrationInstance; ) {
            if (8 === hydrationInstance.nodeType) {
              var data = hydrationInstance.data;
              if (data === SUSPENSE_END_DATA || data === ACTIVITY_END_DATA) {
                if (0 === depth)
                  return getNextHydratable(hydrationInstance.nextSibling);
                depth--;
              } else
                data !== SUSPENSE_START_DATA && data !== SUSPENSE_FALLBACK_START_DATA && data !== SUSPENSE_PENDING_START_DATA && data !== SUSPENSE_QUEUED_START_DATA && data !== ACTIVITY_START_DATA || depth++;
            }
            hydrationInstance = hydrationInstance.nextSibling;
          }
          return null;
        }
        function getParentHydrationBoundary(targetInstance) {
          targetInstance = targetInstance.previousSibling;
          for (var depth = 0; targetInstance; ) {
            if (8 === targetInstance.nodeType) {
              var data = targetInstance.data;
              if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA || data === SUSPENSE_QUEUED_START_DATA || data === ACTIVITY_START_DATA) {
                if (0 === depth) return targetInstance;
                depth--;
              } else
                data !== SUSPENSE_END_DATA && data !== ACTIVITY_END_DATA || depth++;
            }
            targetInstance = targetInstance.previousSibling;
          }
          return null;
        }
        function commitHydratedContainer(container) {
          retryIfBlockedOn(container);
        }
        function commitHydratedActivityInstance(activityInstance) {
          retryIfBlockedOn(activityInstance);
        }
        function commitHydratedSuspenseInstance(suspenseInstance) {
          retryIfBlockedOn(suspenseInstance);
        }
        function resolveSingletonInstance(type, props, rootContainerInstance, hostContext, validateDOMNestingDev) {
          validateDOMNestingDev && validateDOMNesting(type, hostContext.ancestorInfo);
          props = getOwnerDocumentFromRootContainer(rootContainerInstance);
          switch (type) {
            case "html":
              type = props.documentElement;
              if (!type)
                throw Error(
                  "React expected an <html> element (document.documentElement) to exist in the Document but one was not found. React never removes the documentElement for any Document it renders into so the cause is likely in some other script running on this page."
                );
              return type;
            case "head":
              type = props.head;
              if (!type)
                throw Error(
                  "React expected a <head> element (document.head) to exist in the Document but one was not found. React never removes the head for any Document it renders into so the cause is likely in some other script running on this page."
                );
              return type;
            case "body":
              type = props.body;
              if (!type)
                throw Error(
                  "React expected a <body> element (document.body) to exist in the Document but one was not found. React never removes the body for any Document it renders into so the cause is likely in some other script running on this page."
                );
              return type;
            default:
              throw Error(
                "resolveSingletonInstance was called with an element type that is not supported. This is a bug in React."
              );
          }
        }
        function acquireSingletonInstance(type, props, instance, internalInstanceHandle) {
          if (!instance[internalContainerInstanceKey] && getInstanceFromNode(instance)) {
            var tagName = instance.tagName.toLowerCase();
            console.error(
              "You are mounting a new %s component when a previous one has not first unmounted. It is an error to render more than one %s component at a time and attributes and children of these components will likely fail in unpredictable ways. Please only render a single instance of <%s> and if you need to mount a new one, ensure any previous ones have unmounted first.",
              tagName,
              tagName,
              tagName
            );
          }
          switch (type) {
            case "html":
            case "head":
            case "body":
              break;
            default:
              console.error(
                "acquireSingletonInstance was called with an element type that is not supported. This is a bug in React."
              );
          }
          for (tagName = instance.attributes; tagName.length; )
            instance.removeAttributeNode(tagName[0]);
          setInitialProperties(instance, type, props);
          instance[internalInstanceKey] = internalInstanceHandle;
          instance[internalPropsKey] = props;
        }
        function releaseSingletonInstance(instance) {
          for (var attributes = instance.attributes; attributes.length; )
            instance.removeAttributeNode(attributes[0]);
          detachDeletedInstance(instance);
        }
        function getHoistableRoot(container) {
          return "function" === typeof container.getRootNode ? container.getRootNode() : 9 === container.nodeType ? container : container.ownerDocument;
        }
        function preconnectAs(rel, href, crossOrigin) {
          var ownerDocument = globalDocument;
          if (ownerDocument && "string" === typeof href && href) {
            var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
            limitedEscapedHref = 'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
            "string" === typeof crossOrigin && (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
            preconnectsSet.has(limitedEscapedHref) || (preconnectsSet.add(limitedEscapedHref), rel = { rel, crossOrigin, href }, null === ownerDocument.querySelector(limitedEscapedHref) && (href = ownerDocument.createElement("link"), setInitialProperties(href, "link", rel), markNodeAsHoistable(href), ownerDocument.head.appendChild(href)));
          }
        }
        function getResource(type, currentProps, pendingProps, currentResource) {
          var resourceRoot = (resourceRoot = rootInstanceStackCursor.current) ? getHoistableRoot(resourceRoot) : null;
          if (!resourceRoot)
            throw Error(
              '"resourceRoot" was expected to exist. This is a bug in React.'
            );
          switch (type) {
            case "meta":
            case "title":
              return null;
            case "style":
              return "string" === typeof pendingProps.precedence && "string" === typeof pendingProps.href ? (pendingProps = getStyleKey(pendingProps.href), currentProps = getResourcesFromRoot(resourceRoot).hoistableStyles, currentResource = currentProps.get(pendingProps), currentResource || (currentResource = {
                type: "style",
                instance: null,
                count: 0,
                state: null
              }, currentProps.set(pendingProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
            case "link":
              if ("stylesheet" === pendingProps.rel && "string" === typeof pendingProps.href && "string" === typeof pendingProps.precedence) {
                type = getStyleKey(pendingProps.href);
                var _styles = getResourcesFromRoot(resourceRoot).hoistableStyles, _resource = _styles.get(type);
                if (!_resource && (resourceRoot = resourceRoot.ownerDocument || resourceRoot, _resource = {
                  type: "stylesheet",
                  instance: null,
                  count: 0,
                  state: { loading: NotLoaded, preload: null }
                }, _styles.set(type, _resource), (_styles = resourceRoot.querySelector(
                  getStylesheetSelectorFromKey(type)
                )) && !_styles._p && (_resource.instance = _styles, _resource.state.loading = Loaded | Inserted), !preloadPropsMap.has(type))) {
                  var preloadProps = {
                    rel: "preload",
                    as: "style",
                    href: pendingProps.href,
                    crossOrigin: pendingProps.crossOrigin,
                    integrity: pendingProps.integrity,
                    media: pendingProps.media,
                    hrefLang: pendingProps.hrefLang,
                    referrerPolicy: pendingProps.referrerPolicy
                  };
                  preloadPropsMap.set(type, preloadProps);
                  _styles || preloadStylesheet(
                    resourceRoot,
                    type,
                    preloadProps,
                    _resource.state
                  );
                }
                if (currentProps && null === currentResource)
                  throw pendingProps = "\n\n  - " + describeLinkForResourceErrorDEV(currentProps) + "\n  + " + describeLinkForResourceErrorDEV(pendingProps), Error(
                    "Expected <link> not to update to be updated to a stylesheet with precedence. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + pendingProps
                  );
                return _resource;
              }
              if (currentProps && null !== currentResource)
                throw pendingProps = "\n\n  - " + describeLinkForResourceErrorDEV(currentProps) + "\n  + " + describeLinkForResourceErrorDEV(pendingProps), Error(
                  "Expected stylesheet with precedence to not be updated to a different kind of <link>. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + pendingProps
                );
              return null;
            case "script":
              return currentProps = pendingProps.async, pendingProps = pendingProps.src, "string" === typeof pendingProps && currentProps && "function" !== typeof currentProps && "symbol" !== typeof currentProps ? (pendingProps = getScriptKey(pendingProps), currentProps = getResourcesFromRoot(resourceRoot).hoistableScripts, currentResource = currentProps.get(pendingProps), currentResource || (currentResource = {
                type: "script",
                instance: null,
                count: 0,
                state: null
              }, currentProps.set(pendingProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
            default:
              throw Error(
                'getResource encountered a type it did not expect: "' + type + '". this is a bug in React.'
              );
          }
        }
        function describeLinkForResourceErrorDEV(props) {
          var describedProps = 0, description = "<link";
          "string" === typeof props.rel ? (describedProps++, description += ' rel="' + props.rel + '"') : hasOwnProperty.call(props, "rel") && (describedProps++, description += ' rel="' + (null === props.rel ? "null" : "invalid type " + typeof props.rel) + '"');
          "string" === typeof props.href ? (describedProps++, description += ' href="' + props.href + '"') : hasOwnProperty.call(props, "href") && (describedProps++, description += ' href="' + (null === props.href ? "null" : "invalid type " + typeof props.href) + '"');
          "string" === typeof props.precedence ? (describedProps++, description += ' precedence="' + props.precedence + '"') : hasOwnProperty.call(props, "precedence") && (describedProps++, description += " precedence={" + (null === props.precedence ? "null" : "invalid type " + typeof props.precedence) + "}");
          Object.getOwnPropertyNames(props).length > describedProps && (description += " ...");
          return description + " />";
        }
        function getStyleKey(href) {
          return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
        }
        function getStylesheetSelectorFromKey(key) {
          return 'link[rel="stylesheet"][' + key + "]";
        }
        function stylesheetPropsFromRawProps(rawProps) {
          return assign({}, rawProps, {
            "data-precedence": rawProps.precedence,
            precedence: null
          });
        }
        function preloadStylesheet(ownerDocument, key, preloadProps, state) {
          ownerDocument.querySelector(
            'link[rel="preload"][as="style"][' + key + "]"
          ) ? state.loading = Loaded : (key = ownerDocument.createElement("link"), state.preload = key, key.addEventListener("load", function() {
            return state.loading |= Loaded;
          }), key.addEventListener("error", function() {
            return state.loading |= Errored;
          }), setInitialProperties(key, "link", preloadProps), markNodeAsHoistable(key), ownerDocument.head.appendChild(key));
        }
        function getScriptKey(src) {
          return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
        }
        function getScriptSelectorFromKey(key) {
          return "script[async]" + key;
        }
        function acquireResource(hoistableRoot, resource, props) {
          resource.count++;
          if (null === resource.instance)
            switch (resource.type) {
              case "style":
                var instance = hoistableRoot.querySelector(
                  'style[data-href~="' + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + '"]'
                );
                if (instance)
                  return resource.instance = instance, markNodeAsHoistable(instance), instance;
                var styleProps = assign({}, props, {
                  "data-href": props.href,
                  "data-precedence": props.precedence,
                  href: null,
                  precedence: null
                });
                instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement("style");
                markNodeAsHoistable(instance);
                setInitialProperties(instance, "style", styleProps);
                insertStylesheet(instance, props.precedence, hoistableRoot);
                return resource.instance = instance;
              case "stylesheet":
                styleProps = getStyleKey(props.href);
                var _instance = hoistableRoot.querySelector(
                  getStylesheetSelectorFromKey(styleProps)
                );
                if (_instance)
                  return resource.state.loading |= Inserted, resource.instance = _instance, markNodeAsHoistable(_instance), _instance;
                instance = stylesheetPropsFromRawProps(props);
                (styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance, styleProps);
                _instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement("link");
                markNodeAsHoistable(_instance);
                var linkInstance = _instance;
                linkInstance._p = new Promise(function(resolve, reject) {
                  linkInstance.onload = resolve;
                  linkInstance.onerror = reject;
                });
                setInitialProperties(_instance, "link", instance);
                resource.state.loading |= Inserted;
                insertStylesheet(_instance, props.precedence, hoistableRoot);
                return resource.instance = _instance;
              case "script":
                _instance = getScriptKey(props.src);
                if (styleProps = hoistableRoot.querySelector(
                  getScriptSelectorFromKey(_instance)
                ))
                  return resource.instance = styleProps, markNodeAsHoistable(styleProps), styleProps;
                instance = props;
                if (styleProps = preloadPropsMap.get(_instance))
                  instance = assign({}, props), adoptPreloadPropsForScript(instance, styleProps);
                hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
                styleProps = hoistableRoot.createElement("script");
                markNodeAsHoistable(styleProps);
                setInitialProperties(styleProps, "link", instance);
                hoistableRoot.head.appendChild(styleProps);
                return resource.instance = styleProps;
              case "void":
                return null;
              default:
                throw Error(
                  'acquireResource encountered a resource type it did not expect: "' + resource.type + '". this is a bug in React.'
                );
            }
          else
            "stylesheet" === resource.type && (resource.state.loading & Inserted) === NotLoaded && (instance = resource.instance, resource.state.loading |= Inserted, insertStylesheet(instance, props.precedence, hoistableRoot));
          return resource.instance;
        }
        function insertStylesheet(instance, precedence, root2) {
          for (var nodes = root2.querySelectorAll(
            'link[rel="stylesheet"][data-precedence],style[data-precedence]'
          ), last = nodes.length ? nodes[nodes.length - 1] : null, prior = last, i8 = 0; i8 < nodes.length; i8++) {
            var node = nodes[i8];
            if (node.dataset.precedence === precedence) prior = node;
            else if (prior !== last) break;
          }
          prior ? prior.parentNode.insertBefore(instance, prior.nextSibling) : (precedence = 9 === root2.nodeType ? root2.head : root2, precedence.insertBefore(instance, precedence.firstChild));
        }
        function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
          null == stylesheetProps.crossOrigin && (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
          null == stylesheetProps.referrerPolicy && (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
          null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
        }
        function adoptPreloadPropsForScript(scriptProps, preloadProps) {
          null == scriptProps.crossOrigin && (scriptProps.crossOrigin = preloadProps.crossOrigin);
          null == scriptProps.referrerPolicy && (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
          null == scriptProps.integrity && (scriptProps.integrity = preloadProps.integrity);
        }
        function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
          if (null === tagCaches) {
            var cache = /* @__PURE__ */ new Map();
            var caches = tagCaches = /* @__PURE__ */ new Map();
            caches.set(ownerDocument, cache);
          } else
            caches = tagCaches, cache = caches.get(ownerDocument), cache || (cache = /* @__PURE__ */ new Map(), caches.set(ownerDocument, cache));
          if (cache.has(type)) return cache;
          cache.set(type, null);
          ownerDocument = ownerDocument.getElementsByTagName(type);
          for (caches = 0; caches < ownerDocument.length; caches++) {
            var node = ownerDocument[caches];
            if (!(node[internalHoistableMarker] || node[internalInstanceKey] || "link" === type && "stylesheet" === node.getAttribute("rel")) && node.namespaceURI !== SVG_NAMESPACE) {
              var nodeKey = node.getAttribute(keyAttribute) || "";
              nodeKey = type + nodeKey;
              var existing = cache.get(nodeKey);
              existing ? existing.push(node) : cache.set(nodeKey, [node]);
            }
          }
          return cache;
        }
        function mountHoistable(hoistableRoot, type, instance) {
          hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
          hoistableRoot.head.insertBefore(
            instance,
            "title" === type ? hoistableRoot.querySelector("head > title") : null
          );
        }
        function isHostHoistableType(type, props, hostContext) {
          var outsideHostContainerContext = !hostContext.ancestorInfo.containerTagInScope;
          if (hostContext.context === HostContextNamespaceSvg || null != props.itemProp)
            return !outsideHostContainerContext || null == props.itemProp || "meta" !== type && "title" !== type && "style" !== type && "link" !== type && "script" !== type || console.error(
              "Cannot render a <%s> outside the main document if it has an `itemProp` prop. `itemProp` suggests the tag belongs to an `itemScope` which can appear anywhere in the DOM. If you were intending for React to hoist this <%s> remove the `itemProp` prop. Otherwise, try moving this tag into the <head> or <body> of the Document.",
              type,
              type
            ), false;
          switch (type) {
            case "meta":
            case "title":
              return true;
            case "style":
              if ("string" !== typeof props.precedence || "string" !== typeof props.href || "" === props.href) {
                outsideHostContainerContext && console.error(
                  'Cannot render a <style> outside the main document without knowing its precedence and a unique href key. React can hoist and deduplicate <style> tags if you provide a `precedence` prop along with an `href` prop that does not conflict with the `href` values used in any other hoisted <style> or <link rel="stylesheet" ...> tags.  Note that hoisting <style> tags is considered an advanced feature that most will not use directly. Consider moving the <style> tag to the <head> or consider adding a `precedence="default"` and `href="some unique resource identifier"`.'
                );
                break;
              }
              return true;
            case "link":
              if ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href || props.onLoad || props.onError) {
                if ("stylesheet" === props.rel && "string" === typeof props.precedence) {
                  type = props.href;
                  var onError = props.onError, disabled = props.disabled;
                  hostContext = [];
                  props.onLoad && hostContext.push("`onLoad`");
                  onError && hostContext.push("`onError`");
                  null != disabled && hostContext.push("`disabled`");
                  onError = propNamesListJoin(hostContext, "and");
                  onError += 1 === hostContext.length ? " prop" : " props";
                  disabled = 1 === hostContext.length ? "an " + onError : "the " + onError;
                  hostContext.length && console.error(
                    'React encountered a <link rel="stylesheet" href="%s" ... /> with a `precedence` prop that also included %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.',
                    type,
                    disabled,
                    onError
                  );
                }
                outsideHostContainerContext && ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href ? console.error(
                  "Cannot render a <link> outside the main document without a `rel` and `href` prop. Try adding a `rel` and/or `href` prop to this <link> or moving the link into the <head> tag"
                ) : (props.onError || props.onLoad) && console.error(
                  "Cannot render a <link> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."
                ));
                break;
              }
              switch (props.rel) {
                case "stylesheet":
                  return type = props.precedence, props = props.disabled, "string" !== typeof type && outsideHostContainerContext && console.error(
                    'Cannot render a <link rel="stylesheet" /> outside the main document without knowing its precedence. Consider adding precedence="default" or moving it into the root <head> tag.'
                  ), "string" === typeof type && null == props;
                default:
                  return true;
              }
            case "script":
              type = props.async && "function" !== typeof props.async && "symbol" !== typeof props.async;
              if (!type || props.onLoad || props.onError || !props.src || "string" !== typeof props.src) {
                outsideHostContainerContext && (type ? props.onLoad || props.onError ? console.error(
                  "Cannot render a <script> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."
                ) : console.error(
                  "Cannot render a <script> outside the main document without `async={true}` and a non-empty `src` prop. Ensure there is a valid `src` and either make the script async or move it into the root <head> tag or somewhere in the <body>."
                ) : console.error(
                  'Cannot render a sync or defer <script> outside the main document without knowing its order. Try adding async="" or moving it into the root <head> tag.'
                ));
                break;
              }
              return true;
            case "noscript":
            case "template":
              outsideHostContainerContext && console.error(
                "Cannot render <%s> outside the main document. Try moving it into the root <head> tag.",
                type
              );
          }
          return false;
        }
        function preloadResource(resource) {
          return "stylesheet" === resource.type && (resource.state.loading & Settled) === NotLoaded ? false : true;
        }
        function suspendResource(state, hoistableRoot, resource, props) {
          if ("stylesheet" === resource.type && ("string" !== typeof props.media || false !== matchMedia(props.media).matches) && (resource.state.loading & Inserted) === NotLoaded) {
            if (null === resource.instance) {
              var key = getStyleKey(props.href), instance = hoistableRoot.querySelector(
                getStylesheetSelectorFromKey(key)
              );
              if (instance) {
                hoistableRoot = instance._p;
                null !== hoistableRoot && "object" === typeof hoistableRoot && "function" === typeof hoistableRoot.then && (state.count++, state = onUnsuspend.bind(state), hoistableRoot.then(state, state));
                resource.state.loading |= Inserted;
                resource.instance = instance;
                markNodeAsHoistable(instance);
                return;
              }
              instance = hoistableRoot.ownerDocument || hoistableRoot;
              props = stylesheetPropsFromRawProps(props);
              (key = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(props, key);
              instance = instance.createElement("link");
              markNodeAsHoistable(instance);
              var linkInstance = instance;
              linkInstance._p = new Promise(function(resolve, reject) {
                linkInstance.onload = resolve;
                linkInstance.onerror = reject;
              });
              setInitialProperties(instance, "link", props);
              resource.instance = instance;
            }
            null === state.stylesheets && (state.stylesheets = /* @__PURE__ */ new Map());
            state.stylesheets.set(resource, hoistableRoot);
            (hoistableRoot = resource.state.preload) && (resource.state.loading & Settled) === NotLoaded && (state.count++, resource = onUnsuspend.bind(state), hoistableRoot.addEventListener("load", resource), hoistableRoot.addEventListener("error", resource));
          }
        }
        function waitForCommitToBeReady(state, timeoutOffset) {
          state.stylesheets && 0 === state.count && insertSuspendedStylesheets(state, state.stylesheets);
          return 0 < state.count || 0 < state.imgCount ? function(commit) {
            var stylesheetTimer = setTimeout(function() {
              state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets);
              if (state.unsuspend) {
                var unsuspend = state.unsuspend;
                state.unsuspend = null;
                unsuspend();
              }
            }, SUSPENSEY_STYLESHEET_TIMEOUT + timeoutOffset);
            0 < state.imgBytes && 0 === estimatedBytesWithinLimit && (estimatedBytesWithinLimit = 125 * estimateBandwidth() * SUSPENSEY_IMAGE_TIME_ESTIMATE);
            var imgTimer = setTimeout(
              function() {
                state.waitingForImages = false;
                if (0 === state.count && (state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets), state.unsuspend)) {
                  var unsuspend = state.unsuspend;
                  state.unsuspend = null;
                  unsuspend();
                }
              },
              (state.imgBytes > estimatedBytesWithinLimit ? 50 : SUSPENSEY_IMAGE_TIMEOUT) + timeoutOffset
            );
            state.unsuspend = commit;
            return function() {
              state.unsuspend = null;
              clearTimeout(stylesheetTimer);
              clearTimeout(imgTimer);
            };
          } : null;
        }
        function onUnsuspend() {
          this.count--;
          if (0 === this.count && (0 === this.imgCount || !this.waitingForImages)) {
            if (this.stylesheets)
              insertSuspendedStylesheets(this, this.stylesheets);
            else if (this.unsuspend) {
              var unsuspend = this.unsuspend;
              this.unsuspend = null;
              unsuspend();
            }
          }
        }
        function insertSuspendedStylesheets(state, resources) {
          state.stylesheets = null;
          null !== state.unsuspend && (state.count++, precedencesByRoot = /* @__PURE__ */ new Map(), resources.forEach(insertStylesheetIntoRoot, state), precedencesByRoot = null, onUnsuspend.call(state));
        }
        function insertStylesheetIntoRoot(root2, resource) {
          if (!(resource.state.loading & Inserted)) {
            var precedences = precedencesByRoot.get(root2);
            if (precedences) var last = precedences.get(LAST_PRECEDENCE);
            else {
              precedences = /* @__PURE__ */ new Map();
              precedencesByRoot.set(root2, precedences);
              for (var nodes = root2.querySelectorAll(
                "link[data-precedence],style[data-precedence]"
              ), i8 = 0; i8 < nodes.length; i8++) {
                var node = nodes[i8];
                if ("LINK" === node.nodeName || "not all" !== node.getAttribute("media"))
                  precedences.set(node.dataset.precedence, node), last = node;
              }
              last && precedences.set(LAST_PRECEDENCE, last);
            }
            nodes = resource.instance;
            node = nodes.getAttribute("data-precedence");
            i8 = precedences.get(node) || last;
            i8 === last && precedences.set(LAST_PRECEDENCE, nodes);
            precedences.set(node, nodes);
            this.count++;
            last = onUnsuspend.bind(this);
            nodes.addEventListener("load", last);
            nodes.addEventListener("error", last);
            i8 ? i8.parentNode.insertBefore(nodes, i8.nextSibling) : (root2 = 9 === root2.nodeType ? root2.head : root2, root2.insertBefore(nodes, root2.firstChild));
            resource.state.loading |= Inserted;
          }
        }
        function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator, formState) {
          this.tag = 1;
          this.containerInfo = containerInfo;
          this.pingCache = this.current = this.pendingChildren = null;
          this.timeoutHandle = noTimeout;
          this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
          this.callbackPriority = 0;
          this.expirationTimes = createLaneMap(-1);
          this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
          this.entanglements = createLaneMap(0);
          this.hiddenUpdates = createLaneMap(null);
          this.identifierPrefix = identifierPrefix;
          this.onUncaughtError = onUncaughtError;
          this.onCaughtError = onCaughtError;
          this.onRecoverableError = onRecoverableError;
          this.pooledCache = null;
          this.pooledCacheLanes = 0;
          this.formState = formState;
          this.incompleteTransitions = /* @__PURE__ */ new Map();
          this.passiveEffectDuration = this.effectDuration = -0;
          this.memoizedUpdaters = /* @__PURE__ */ new Set();
          containerInfo = this.pendingUpdatersLaneMap = [];
          for (tag = 0; 31 > tag; tag++) containerInfo.push(/* @__PURE__ */ new Set());
          this._debugRootType = hydrate ? "hydrateRoot()" : "createRoot()";
        }
        function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, formState, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator) {
          containerInfo = new FiberRootNode(
            containerInfo,
            tag,
            hydrate,
            identifierPrefix,
            onUncaughtError,
            onCaughtError,
            onRecoverableError,
            onDefaultTransitionIndicator,
            formState
          );
          tag = ConcurrentMode;
          true === isStrictMode && (tag |= StrictLegacyMode | StrictEffectsMode);
          tag |= ProfileMode;
          isStrictMode = createFiber(3, null, null, tag);
          containerInfo.current = isStrictMode;
          isStrictMode.stateNode = containerInfo;
          tag = createCache();
          retainCache(tag);
          containerInfo.pooledCache = tag;
          retainCache(tag);
          isStrictMode.memoizedState = {
            element: initialChildren,
            isDehydrated: hydrate,
            cache: tag
          };
          initializeUpdateQueue(isStrictMode);
          return containerInfo;
        }
        function getContextForSubtree(parentComponent) {
          if (!parentComponent) return emptyContextObject;
          parentComponent = emptyContextObject;
          return parentComponent;
        }
        function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {
          if (injectedHook && "function" === typeof injectedHook.onScheduleFiberRoot)
            try {
              injectedHook.onScheduleFiberRoot(rendererID, container, element);
            } catch (err) {
              hasLoggedError || (hasLoggedError = true, console.error(
                "React instrumentation encountered an error: %o",
                err
              ));
            }
          parentComponent = getContextForSubtree(parentComponent);
          null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;
          isRendering && null !== current && !didWarnAboutNestedUpdates && (didWarnAboutNestedUpdates = true, console.error(
            "Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.",
            getComponentNameFromFiber(current) || "Unknown"
          ));
          container = createUpdate(lane);
          container.payload = { element };
          callback = void 0 === callback ? null : callback;
          null !== callback && ("function" !== typeof callback && console.error(
            "Expected the last optional `callback` argument to be a function. Instead received: %s.",
            callback
          ), container.callback = callback);
          element = enqueueUpdate(rootFiber, container, lane);
          null !== element && (startUpdateTimerByLane(lane, "root.render()", null), scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
        }
        function markRetryLaneImpl(fiber, retryLane) {
          fiber = fiber.memoizedState;
          if (null !== fiber && null !== fiber.dehydrated) {
            var a5 = fiber.retryLane;
            fiber.retryLane = 0 !== a5 && a5 < retryLane ? a5 : retryLane;
          }
        }
        function markRetryLaneIfNotHydrated(fiber, retryLane) {
          markRetryLaneImpl(fiber, retryLane);
          (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
        }
        function attemptContinuousHydration(fiber) {
          if (13 === fiber.tag || 31 === fiber.tag) {
            var root2 = enqueueConcurrentRenderForLane(fiber, 67108864);
            null !== root2 && scheduleUpdateOnFiber(root2, fiber, 67108864);
            markRetryLaneIfNotHydrated(fiber, 67108864);
          }
        }
        function attemptHydrationAtCurrentPriority(fiber) {
          if (13 === fiber.tag || 31 === fiber.tag) {
            var lane = requestUpdateLane(fiber);
            lane = getBumpedLaneForHydrationByLane(lane);
            var root2 = enqueueConcurrentRenderForLane(fiber, lane);
            null !== root2 && scheduleUpdateOnFiber(root2, fiber, lane);
            markRetryLaneIfNotHydrated(fiber, lane);
          }
        }
        function getCurrentFiberForDevTools() {
          return current;
        }
        function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
          var prevTransition = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          var previousPriority = ReactDOMSharedInternals.p;
          try {
            ReactDOMSharedInternals.p = DiscreteEventPriority, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
          } finally {
            ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
          }
        }
        function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
          var prevTransition = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          var previousPriority = ReactDOMSharedInternals.p;
          try {
            ReactDOMSharedInternals.p = ContinuousEventPriority, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
          } finally {
            ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
          }
        }
        function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          if (_enabled) {
            var blockedOn = findInstanceBlockingEvent(nativeEvent);
            if (null === blockedOn)
              dispatchEventForPluginEventSystem(
                domEventName,
                eventSystemFlags,
                nativeEvent,
                return_targetInst,
                targetContainer
              ), clearIfContinuousEvent(domEventName, nativeEvent);
            else if (queueIfContinuousEvent(
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            ))
              nativeEvent.stopPropagation();
            else if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)) {
              for (; null !== blockedOn; ) {
                var fiber = getInstanceFromNode(blockedOn);
                if (null !== fiber)
                  switch (fiber.tag) {
                    case 3:
                      fiber = fiber.stateNode;
                      if (fiber.current.memoizedState.isDehydrated) {
                        var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                        if (0 !== lanes) {
                          var root2 = fiber;
                          root2.pendingLanes |= 2;
                          for (root2.entangledLanes |= 2; lanes; ) {
                            var lane = 1 << 31 - clz32(lanes);
                            root2.entanglements[1] |= lane;
                            lanes &= ~lane;
                          }
                          ensureRootIsScheduled(fiber);
                          (executionContext & (RenderContext | CommitContext)) === NoContext && (workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS, flushSyncWorkAcrossRoots_impl(0, false));
                        }
                      }
                      break;
                    case 31:
                    case 13:
                      root2 = enqueueConcurrentRenderForLane(fiber, 2), null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);
                  }
                fiber = findInstanceBlockingEvent(nativeEvent);
                null === fiber && dispatchEventForPluginEventSystem(
                  domEventName,
                  eventSystemFlags,
                  nativeEvent,
                  return_targetInst,
                  targetContainer
                );
                if (fiber === blockedOn) break;
                blockedOn = fiber;
              }
              null !== blockedOn && nativeEvent.stopPropagation();
            } else
              dispatchEventForPluginEventSystem(
                domEventName,
                eventSystemFlags,
                nativeEvent,
                null,
                targetContainer
              );
          }
        }
        function findInstanceBlockingEvent(nativeEvent) {
          nativeEvent = getEventTarget(nativeEvent);
          return findInstanceBlockingTarget(nativeEvent);
        }
        function findInstanceBlockingTarget(targetNode) {
          return_targetInst = null;
          targetNode = getClosestInstanceFromNode(targetNode);
          if (null !== targetNode) {
            var nearestMounted = getNearestMountedFiber(targetNode);
            if (null === nearestMounted) targetNode = null;
            else {
              var tag = nearestMounted.tag;
              if (13 === tag) {
                targetNode = getSuspenseInstanceFromFiber(nearestMounted);
                if (null !== targetNode) return targetNode;
                targetNode = null;
              } else if (31 === tag) {
                targetNode = getActivityInstanceFromFiber(nearestMounted);
                if (null !== targetNode) return targetNode;
                targetNode = null;
              } else if (3 === tag) {
                if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
                  return 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
                targetNode = null;
              } else nearestMounted !== targetNode && (targetNode = null);
            }
          }
          return_targetInst = targetNode;
          return null;
        }
        function getEventPriority(domEventName) {
          switch (domEventName) {
            case "beforetoggle":
            case "cancel":
            case "click":
            case "close":
            case "contextmenu":
            case "copy":
            case "cut":
            case "auxclick":
            case "dblclick":
            case "dragend":
            case "dragstart":
            case "drop":
            case "focusin":
            case "focusout":
            case "input":
            case "invalid":
            case "keydown":
            case "keypress":
            case "keyup":
            case "mousedown":
            case "mouseup":
            case "paste":
            case "pause":
            case "play":
            case "pointercancel":
            case "pointerdown":
            case "pointerup":
            case "ratechange":
            case "reset":
            case "resize":
            case "seeked":
            case "submit":
            case "toggle":
            case "touchcancel":
            case "touchend":
            case "touchstart":
            case "volumechange":
            case "change":
            case "selectionchange":
            case "textInput":
            case "compositionstart":
            case "compositionend":
            case "compositionupdate":
            case "beforeblur":
            case "afterblur":
            case "beforeinput":
            case "blur":
            case "fullscreenchange":
            case "focus":
            case "hashchange":
            case "popstate":
            case "select":
            case "selectstart":
              return DiscreteEventPriority;
            case "drag":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "mousemove":
            case "mouseout":
            case "mouseover":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "scroll":
            case "touchmove":
            case "wheel":
            case "mouseenter":
            case "mouseleave":
            case "pointerenter":
            case "pointerleave":
              return ContinuousEventPriority;
            case "message":
              switch (getCurrentPriorityLevel()) {
                case ImmediatePriority:
                  return DiscreteEventPriority;
                case UserBlockingPriority:
                  return ContinuousEventPriority;
                case NormalPriority$1:
                case LowPriority:
                  return DefaultEventPriority;
                case IdlePriority:
                  return IdleEventPriority;
                default:
                  return DefaultEventPriority;
              }
            default:
              return DefaultEventPriority;
          }
        }
        function clearIfContinuousEvent(domEventName, nativeEvent) {
          switch (domEventName) {
            case "focusin":
            case "focusout":
              queuedFocus = null;
              break;
            case "dragenter":
            case "dragleave":
              queuedDrag = null;
              break;
            case "mouseover":
            case "mouseout":
              queuedMouse = null;
              break;
            case "pointerover":
            case "pointerout":
              queuedPointers.delete(nativeEvent.pointerId);
              break;
            case "gotpointercapture":
            case "lostpointercapture":
              queuedPointerCaptures.delete(nativeEvent.pointerId);
          }
        }
        function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          if (null === existingQueuedEvent || existingQueuedEvent.nativeEvent !== nativeEvent)
            return existingQueuedEvent = {
              blockedOn,
              domEventName,
              eventSystemFlags,
              nativeEvent,
              targetContainers: [targetContainer]
            }, null !== blockedOn && (blockedOn = getInstanceFromNode(blockedOn), null !== blockedOn && attemptContinuousHydration(blockedOn)), existingQueuedEvent;
          existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
          blockedOn = existingQueuedEvent.targetContainers;
          null !== targetContainer && -1 === blockedOn.indexOf(targetContainer) && blockedOn.push(targetContainer);
          return existingQueuedEvent;
        }
        function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          switch (domEventName) {
            case "focusin":
              return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedFocus,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              ), true;
            case "dragenter":
              return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedDrag,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              ), true;
            case "mouseover":
              return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedMouse,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              ), true;
            case "pointerover":
              var pointerId = nativeEvent.pointerId;
              queuedPointers.set(
                pointerId,
                accumulateOrCreateContinuousQueuedReplayableEvent(
                  queuedPointers.get(pointerId) || null,
                  blockedOn,
                  domEventName,
                  eventSystemFlags,
                  targetContainer,
                  nativeEvent
                )
              );
              return true;
            case "gotpointercapture":
              return pointerId = nativeEvent.pointerId, queuedPointerCaptures.set(
                pointerId,
                accumulateOrCreateContinuousQueuedReplayableEvent(
                  queuedPointerCaptures.get(pointerId) || null,
                  blockedOn,
                  domEventName,
                  eventSystemFlags,
                  targetContainer,
                  nativeEvent
                )
              ), true;
          }
          return false;
        }
        function attemptExplicitHydrationTarget(queuedTarget) {
          var targetInst = getClosestInstanceFromNode(queuedTarget.target);
          if (null !== targetInst) {
            var nearestMounted = getNearestMountedFiber(targetInst);
            if (null !== nearestMounted) {
              if (targetInst = nearestMounted.tag, 13 === targetInst) {
                if (targetInst = getSuspenseInstanceFromFiber(nearestMounted), null !== targetInst) {
                  queuedTarget.blockedOn = targetInst;
                  runWithPriority(queuedTarget.priority, function() {
                    attemptHydrationAtCurrentPriority(nearestMounted);
                  });
                  return;
                }
              } else if (31 === targetInst) {
                if (targetInst = getActivityInstanceFromFiber(nearestMounted), null !== targetInst) {
                  queuedTarget.blockedOn = targetInst;
                  runWithPriority(queuedTarget.priority, function() {
                    attemptHydrationAtCurrentPriority(nearestMounted);
                  });
                  return;
                }
              } else if (3 === targetInst && nearestMounted.stateNode.current.memoizedState.isDehydrated) {
                queuedTarget.blockedOn = 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
                return;
              }
            }
          }
          queuedTarget.blockedOn = null;
        }
        function attemptReplayContinuousQueuedEvent(queuedEvent) {
          if (null !== queuedEvent.blockedOn) return false;
          for (var targetContainers = queuedEvent.targetContainers; 0 < targetContainers.length; ) {
            var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
            if (null === nextBlockedOn) {
              nextBlockedOn = queuedEvent.nativeEvent;
              var nativeEventClone = new nextBlockedOn.constructor(
                nextBlockedOn.type,
                nextBlockedOn
              ), event = nativeEventClone;
              null !== currentReplayingEvent && console.error(
                "Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."
              );
              currentReplayingEvent = event;
              nextBlockedOn.target.dispatchEvent(nativeEventClone);
              null === currentReplayingEvent && console.error(
                "Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."
              );
              currentReplayingEvent = null;
            } else
              return targetContainers = getInstanceFromNode(nextBlockedOn), null !== targetContainers && attemptContinuousHydration(targetContainers), queuedEvent.blockedOn = nextBlockedOn, false;
            targetContainers.shift();
          }
          return true;
        }
        function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
          attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
        }
        function replayUnblockedEvents() {
          hasScheduledReplayAttempt = false;
          null !== queuedFocus && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);
          null !== queuedDrag && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);
          null !== queuedMouse && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);
          queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
          queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
        }
        function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
          queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = true, Scheduler.unstable_scheduleCallback(
            Scheduler.unstable_NormalPriority,
            replayUnblockedEvents
          )));
        }
        function scheduleReplayQueueIfNeeded(formReplayingQueue) {
          lastScheduledReplayQueue !== formReplayingQueue && (lastScheduledReplayQueue = formReplayingQueue, Scheduler.unstable_scheduleCallback(
            Scheduler.unstable_NormalPriority,
            function() {
              lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
              for (var i8 = 0; i8 < formReplayingQueue.length; i8 += 3) {
                var form = formReplayingQueue[i8], submitterOrAction = formReplayingQueue[i8 + 1], formData = formReplayingQueue[i8 + 2];
                if ("function" !== typeof submitterOrAction)
                  if (null === findInstanceBlockingTarget(submitterOrAction || form))
                    continue;
                  else break;
                var formInst = getInstanceFromNode(form);
                null !== formInst && (formReplayingQueue.splice(i8, 3), i8 -= 3, form = {
                  pending: true,
                  data: formData,
                  method: form.method,
                  action: submitterOrAction
                }, Object.freeze(form), startHostTransition(
                  formInst,
                  form,
                  submitterOrAction,
                  formData
                ));
              }
            }
          ));
        }
        function retryIfBlockedOn(unblocked) {
          function unblock(queuedEvent) {
            return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
          }
          null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
          null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
          null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
          queuedPointers.forEach(unblock);
          queuedPointerCaptures.forEach(unblock);
          for (var i8 = 0; i8 < queuedExplicitHydrationTargets.length; i8++) {
            var queuedTarget = queuedExplicitHydrationTargets[i8];
            queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
          }
          for (; 0 < queuedExplicitHydrationTargets.length && (i8 = queuedExplicitHydrationTargets[0], null === i8.blockedOn); )
            attemptExplicitHydrationTarget(i8), null === i8.blockedOn && queuedExplicitHydrationTargets.shift();
          i8 = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
          if (null != i8)
            for (queuedTarget = 0; queuedTarget < i8.length; queuedTarget += 3) {
              var form = i8[queuedTarget], submitterOrAction = i8[queuedTarget + 1], formProps = form[internalPropsKey] || null;
              if ("function" === typeof submitterOrAction)
                formProps || scheduleReplayQueueIfNeeded(i8);
              else if (formProps) {
                var action = null;
                if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))
                  if (form = submitterOrAction, formProps = submitterOrAction[internalPropsKey] || null)
                    action = formProps.formAction;
                  else {
                    if (null !== findInstanceBlockingTarget(form)) continue;
                  }
                else action = formProps.action;
                "function" === typeof action ? i8[queuedTarget + 1] = action : (i8.splice(queuedTarget, 3), queuedTarget -= 3);
                scheduleReplayQueueIfNeeded(i8);
              }
            }
        }
        function defaultOnDefaultTransitionIndicator() {
          function handleNavigate(event) {
            event.canIntercept && "react-transition" === event.info && event.intercept({
              handler: function() {
                return new Promise(function(resolve) {
                  return pendingResolve = resolve;
                });
              },
              focusReset: "manual",
              scroll: "manual"
            });
          }
          function handleNavigateComplete() {
            null !== pendingResolve && (pendingResolve(), pendingResolve = null);
            isCancelled || setTimeout(startFakeNavigation, 20);
          }
          function startFakeNavigation() {
            if (!isCancelled && !navigation.transition) {
              var currentEntry = navigation.currentEntry;
              currentEntry && null != currentEntry.url && navigation.navigate(currentEntry.url, {
                state: currentEntry.getState(),
                info: "react-transition",
                history: "replace"
              });
            }
          }
          if ("object" === typeof navigation) {
            var isCancelled = false, pendingResolve = null;
            navigation.addEventListener("navigate", handleNavigate);
            navigation.addEventListener("navigatesuccess", handleNavigateComplete);
            navigation.addEventListener("navigateerror", handleNavigateComplete);
            setTimeout(startFakeNavigation, 100);
            return function() {
              isCancelled = true;
              navigation.removeEventListener("navigate", handleNavigate);
              navigation.removeEventListener(
                "navigatesuccess",
                handleNavigateComplete
              );
              navigation.removeEventListener(
                "navigateerror",
                handleNavigateComplete
              );
              null !== pendingResolve && (pendingResolve(), pendingResolve = null);
            };
          }
        }
        function ReactDOMRoot(internalRoot) {
          this._internalRoot = internalRoot;
        }
        function ReactDOMHydrationRoot(internalRoot) {
          this._internalRoot = internalRoot;
        }
        function warnIfReactDOMContainerInDEV(container) {
          container[internalContainerInstanceKey] && (container._reactRootContainer ? console.error(
            "You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported."
          ) : console.error(
            "You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."
          ));
        }
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
        var Scheduler = require_scheduler(), React2 = require_react(), ReactDOM = require_react_dom(), assign = Object.assign, REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy");
        Symbol.for("react.scope");
        var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
        Symbol.for("react.legacy_hidden");
        Symbol.for("react.tracing_marker");
        var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
        Symbol.for("react.view_transition");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), isArrayImpl = Array.isArray, ReactSharedInternals = React2.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, NotPending = Object.freeze({
          pending: false,
          data: null,
          method: null,
          action: null
        }), valueStack = [];
        var fiberStack = [];
        var index$jscomp$0 = -1, contextStackCursor = createCursor(null), contextFiberStackCursor = createCursor(null), rootInstanceStackCursor = createCursor(null), hostTransitionProviderCursor = createCursor(null), disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
        disabledLog.__reactDisabledLog = true;
        var prefix, suffix, reentry = false;
        var componentFrameCache = new ("function" === typeof WeakMap ? WeakMap : Map)();
        var current = null, isRendering = false, hasOwnProperty = Object.prototype.hasOwnProperty, scheduleCallback$3 = Scheduler.unstable_scheduleCallback, cancelCallback$1 = Scheduler.unstable_cancelCallback, shouldYield = Scheduler.unstable_shouldYield, requestPaint = Scheduler.unstable_requestPaint, now$1 = Scheduler.unstable_now, getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel, ImmediatePriority = Scheduler.unstable_ImmediatePriority, UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, NormalPriority$1 = Scheduler.unstable_NormalPriority, LowPriority = Scheduler.unstable_LowPriority, IdlePriority = Scheduler.unstable_IdlePriority, log$1 = Scheduler.log, unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue, rendererID = null, injectedHook = null, hasLoggedError = false, isDevToolsPresent = "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__, clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log = Math.log, LN2 = Math.LN2, nextTransitionUpdateLane = 256, nextTransitionDeferredLane = 262144, nextRetryLane = 4194304, DiscreteEventPriority = 2, ContinuousEventPriority = 8, DefaultEventPriority = 32, IdleEventPriority = 268435456, randomKey = Math.random().toString(36).slice(2), internalInstanceKey = "__reactFiber$" + randomKey, internalPropsKey = "__reactProps$" + randomKey, internalContainerInstanceKey = "__reactContainer$" + randomKey, internalEventHandlersKey = "__reactEvents$" + randomKey, internalEventHandlerListenersKey = "__reactListeners$" + randomKey, internalEventHandlesSetKey = "__reactHandles$" + randomKey, internalRootNodeResourcesKey = "__reactResources$" + randomKey, internalHoistableMarker = "__reactMarker$" + randomKey, allNativeEvents = /* @__PURE__ */ new Set(), registrationNameDependencies = {}, possibleRegistrationNames = {}, hasReadOnlyValue = {
          button: true,
          checkbox: true,
          image: true,
          hidden: true,
          radio: true,
          reset: true,
          submit: true
        }, VALID_ATTRIBUTE_NAME_REGEX = RegExp(
          "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), illegalAttributeNameCache = {}, validatedAttributeNameCache = {}, escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g, didWarnValueDefaultValue$1 = false, didWarnCheckedDefaultChecked = false, didWarnSelectedSetOnOption = false, didWarnInvalidChild = false, didWarnInvalidInnerHTML = false;
        var didWarnValueDefaultValue = false;
        var valuePropNames = ["value", "defaultValue"], didWarnValDefaultVal = false, needsEscaping = /["'&<>\n\t]|^\s|\s$/, specialTags = "address applet area article aside base basefont bgsound blockquote body br button caption center col colgroup dd details dir div dl dt embed fieldset figcaption figure footer form frame frameset h1 h2 h3 h4 h5 h6 head header hgroup hr html iframe img input isindex li link listing main marquee menu menuitem meta nav noembed noframes noscript object ol p param plaintext pre script section select source style summary table tbody td template textarea tfoot th thead title tr track ul wbr xmp".split(
          " "
        ), inScopeTags = "applet caption html table td th marquee object template foreignObject desc title".split(
          " "
        ), buttonScopeTags = inScopeTags.concat(["button"]), impliedEndTags = "dd dt li option optgroup p rp rt".split(" "), emptyAncestorInfoDev = {
          current: null,
          formTag: null,
          aTagInScope: null,
          buttonTagInScope: null,
          nobrTagInScope: null,
          pTagInButtonScope: null,
          listItemTagAutoclosing: null,
          dlItemTagAutoclosing: null,
          containerTagInScope: null,
          implicitRootScope: false
        }, didWarn = {}, shorthandToLonghand = {
          animation: "animationDelay animationDirection animationDuration animationFillMode animationIterationCount animationName animationPlayState animationTimingFunction".split(
            " "
          ),
          background: "backgroundAttachment backgroundClip backgroundColor backgroundImage backgroundOrigin backgroundPositionX backgroundPositionY backgroundRepeat backgroundSize".split(
            " "
          ),
          backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
          border: "borderBottomColor borderBottomStyle borderBottomWidth borderImageOutset borderImageRepeat borderImageSlice borderImageSource borderImageWidth borderLeftColor borderLeftStyle borderLeftWidth borderRightColor borderRightStyle borderRightWidth borderTopColor borderTopStyle borderTopWidth".split(
            " "
          ),
          borderBlockEnd: [
            "borderBlockEndColor",
            "borderBlockEndStyle",
            "borderBlockEndWidth"
          ],
          borderBlockStart: [
            "borderBlockStartColor",
            "borderBlockStartStyle",
            "borderBlockStartWidth"
          ],
          borderBottom: [
            "borderBottomColor",
            "borderBottomStyle",
            "borderBottomWidth"
          ],
          borderColor: [
            "borderBottomColor",
            "borderLeftColor",
            "borderRightColor",
            "borderTopColor"
          ],
          borderImage: [
            "borderImageOutset",
            "borderImageRepeat",
            "borderImageSlice",
            "borderImageSource",
            "borderImageWidth"
          ],
          borderInlineEnd: [
            "borderInlineEndColor",
            "borderInlineEndStyle",
            "borderInlineEndWidth"
          ],
          borderInlineStart: [
            "borderInlineStartColor",
            "borderInlineStartStyle",
            "borderInlineStartWidth"
          ],
          borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
          borderRadius: [
            "borderBottomLeftRadius",
            "borderBottomRightRadius",
            "borderTopLeftRadius",
            "borderTopRightRadius"
          ],
          borderRight: [
            "borderRightColor",
            "borderRightStyle",
            "borderRightWidth"
          ],
          borderStyle: [
            "borderBottomStyle",
            "borderLeftStyle",
            "borderRightStyle",
            "borderTopStyle"
          ],
          borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
          borderWidth: [
            "borderBottomWidth",
            "borderLeftWidth",
            "borderRightWidth",
            "borderTopWidth"
          ],
          columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
          columns: ["columnCount", "columnWidth"],
          flex: ["flexBasis", "flexGrow", "flexShrink"],
          flexFlow: ["flexDirection", "flexWrap"],
          font: "fontFamily fontFeatureSettings fontKerning fontLanguageOverride fontSize fontSizeAdjust fontStretch fontStyle fontVariant fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition fontWeight lineHeight".split(
            " "
          ),
          fontVariant: "fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition".split(
            " "
          ),
          gap: ["columnGap", "rowGap"],
          grid: "gridAutoColumns gridAutoFlow gridAutoRows gridTemplateAreas gridTemplateColumns gridTemplateRows".split(
            " "
          ),
          gridArea: [
            "gridColumnEnd",
            "gridColumnStart",
            "gridRowEnd",
            "gridRowStart"
          ],
          gridColumn: ["gridColumnEnd", "gridColumnStart"],
          gridColumnGap: ["columnGap"],
          gridGap: ["columnGap", "rowGap"],
          gridRow: ["gridRowEnd", "gridRowStart"],
          gridRowGap: ["rowGap"],
          gridTemplate: [
            "gridTemplateAreas",
            "gridTemplateColumns",
            "gridTemplateRows"
          ],
          listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
          margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
          marker: ["markerEnd", "markerMid", "markerStart"],
          mask: "maskClip maskComposite maskImage maskMode maskOrigin maskPositionX maskPositionY maskRepeat maskSize".split(
            " "
          ),
          maskPosition: ["maskPositionX", "maskPositionY"],
          outline: ["outlineColor", "outlineStyle", "outlineWidth"],
          overflow: ["overflowX", "overflowY"],
          padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
          placeContent: ["alignContent", "justifyContent"],
          placeItems: ["alignItems", "justifyItems"],
          placeSelf: ["alignSelf", "justifySelf"],
          textDecoration: [
            "textDecorationColor",
            "textDecorationLine",
            "textDecorationStyle"
          ],
          textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
          transition: [
            "transitionDelay",
            "transitionDuration",
            "transitionProperty",
            "transitionTimingFunction"
          ],
          wordWrap: ["overflowWrap"]
        }, uppercasePattern = /([A-Z])/g, msPattern$1 = /^ms-/, badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/, msPattern = /^-ms-/, hyphenPattern = /-(.)/g, badStyleValueWithSemicolonPattern = /;\s*$/, warnedStyleNames = {}, warnedStyleValues = {}, warnedForNaNValue = false, warnedForInfinityValue = false, unitlessNumbers = new Set(
          "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
            " "
          )
        ), MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML", SVG_NAMESPACE = "http://www.w3.org/2000/svg", aliases = /* @__PURE__ */ new Map([
          ["acceptCharset", "accept-charset"],
          ["htmlFor", "for"],
          ["httpEquiv", "http-equiv"],
          ["crossOrigin", "crossorigin"],
          ["accentHeight", "accent-height"],
          ["alignmentBaseline", "alignment-baseline"],
          ["arabicForm", "arabic-form"],
          ["baselineShift", "baseline-shift"],
          ["capHeight", "cap-height"],
          ["clipPath", "clip-path"],
          ["clipRule", "clip-rule"],
          ["colorInterpolation", "color-interpolation"],
          ["colorInterpolationFilters", "color-interpolation-filters"],
          ["colorProfile", "color-profile"],
          ["colorRendering", "color-rendering"],
          ["dominantBaseline", "dominant-baseline"],
          ["enableBackground", "enable-background"],
          ["fillOpacity", "fill-opacity"],
          ["fillRule", "fill-rule"],
          ["floodColor", "flood-color"],
          ["floodOpacity", "flood-opacity"],
          ["fontFamily", "font-family"],
          ["fontSize", "font-size"],
          ["fontSizeAdjust", "font-size-adjust"],
          ["fontStretch", "font-stretch"],
          ["fontStyle", "font-style"],
          ["fontVariant", "font-variant"],
          ["fontWeight", "font-weight"],
          ["glyphName", "glyph-name"],
          ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
          ["glyphOrientationVertical", "glyph-orientation-vertical"],
          ["horizAdvX", "horiz-adv-x"],
          ["horizOriginX", "horiz-origin-x"],
          ["imageRendering", "image-rendering"],
          ["letterSpacing", "letter-spacing"],
          ["lightingColor", "lighting-color"],
          ["markerEnd", "marker-end"],
          ["markerMid", "marker-mid"],
          ["markerStart", "marker-start"],
          ["overlinePosition", "overline-position"],
          ["overlineThickness", "overline-thickness"],
          ["paintOrder", "paint-order"],
          ["panose-1", "panose-1"],
          ["pointerEvents", "pointer-events"],
          ["renderingIntent", "rendering-intent"],
          ["shapeRendering", "shape-rendering"],
          ["stopColor", "stop-color"],
          ["stopOpacity", "stop-opacity"],
          ["strikethroughPosition", "strikethrough-position"],
          ["strikethroughThickness", "strikethrough-thickness"],
          ["strokeDasharray", "stroke-dasharray"],
          ["strokeDashoffset", "stroke-dashoffset"],
          ["strokeLinecap", "stroke-linecap"],
          ["strokeLinejoin", "stroke-linejoin"],
          ["strokeMiterlimit", "stroke-miterlimit"],
          ["strokeOpacity", "stroke-opacity"],
          ["strokeWidth", "stroke-width"],
          ["textAnchor", "text-anchor"],
          ["textDecoration", "text-decoration"],
          ["textRendering", "text-rendering"],
          ["transformOrigin", "transform-origin"],
          ["underlinePosition", "underline-position"],
          ["underlineThickness", "underline-thickness"],
          ["unicodeBidi", "unicode-bidi"],
          ["unicodeRange", "unicode-range"],
          ["unitsPerEm", "units-per-em"],
          ["vAlphabetic", "v-alphabetic"],
          ["vHanging", "v-hanging"],
          ["vIdeographic", "v-ideographic"],
          ["vMathematical", "v-mathematical"],
          ["vectorEffect", "vector-effect"],
          ["vertAdvY", "vert-adv-y"],
          ["vertOriginX", "vert-origin-x"],
          ["vertOriginY", "vert-origin-y"],
          ["wordSpacing", "word-spacing"],
          ["writingMode", "writing-mode"],
          ["xmlnsXlink", "xmlns:xlink"],
          ["xHeight", "x-height"]
        ]), possibleStandardNames = {
          accept: "accept",
          acceptcharset: "acceptCharset",
          "accept-charset": "acceptCharset",
          accesskey: "accessKey",
          action: "action",
          allowfullscreen: "allowFullScreen",
          alt: "alt",
          as: "as",
          async: "async",
          autocapitalize: "autoCapitalize",
          autocomplete: "autoComplete",
          autocorrect: "autoCorrect",
          autofocus: "autoFocus",
          autoplay: "autoPlay",
          autosave: "autoSave",
          capture: "capture",
          cellpadding: "cellPadding",
          cellspacing: "cellSpacing",
          challenge: "challenge",
          charset: "charSet",
          checked: "checked",
          children: "children",
          cite: "cite",
          class: "className",
          classid: "classID",
          classname: "className",
          cols: "cols",
          colspan: "colSpan",
          content: "content",
          contenteditable: "contentEditable",
          contextmenu: "contextMenu",
          controls: "controls",
          controlslist: "controlsList",
          coords: "coords",
          crossorigin: "crossOrigin",
          dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
          data: "data",
          datetime: "dateTime",
          default: "default",
          defaultchecked: "defaultChecked",
          defaultvalue: "defaultValue",
          defer: "defer",
          dir: "dir",
          disabled: "disabled",
          disablepictureinpicture: "disablePictureInPicture",
          disableremoteplayback: "disableRemotePlayback",
          download: "download",
          draggable: "draggable",
          enctype: "encType",
          enterkeyhint: "enterKeyHint",
          fetchpriority: "fetchPriority",
          for: "htmlFor",
          form: "form",
          formmethod: "formMethod",
          formaction: "formAction",
          formenctype: "formEncType",
          formnovalidate: "formNoValidate",
          formtarget: "formTarget",
          frameborder: "frameBorder",
          headers: "headers",
          height: "height",
          hidden: "hidden",
          high: "high",
          href: "href",
          hreflang: "hrefLang",
          htmlfor: "htmlFor",
          httpequiv: "httpEquiv",
          "http-equiv": "httpEquiv",
          icon: "icon",
          id: "id",
          imagesizes: "imageSizes",
          imagesrcset: "imageSrcSet",
          inert: "inert",
          innerhtml: "innerHTML",
          inputmode: "inputMode",
          integrity: "integrity",
          is: "is",
          itemid: "itemID",
          itemprop: "itemProp",
          itemref: "itemRef",
          itemscope: "itemScope",
          itemtype: "itemType",
          keyparams: "keyParams",
          keytype: "keyType",
          kind: "kind",
          label: "label",
          lang: "lang",
          list: "list",
          loop: "loop",
          low: "low",
          manifest: "manifest",
          marginwidth: "marginWidth",
          marginheight: "marginHeight",
          max: "max",
          maxlength: "maxLength",
          media: "media",
          mediagroup: "mediaGroup",
          method: "method",
          min: "min",
          minlength: "minLength",
          multiple: "multiple",
          muted: "muted",
          name: "name",
          nomodule: "noModule",
          nonce: "nonce",
          novalidate: "noValidate",
          open: "open",
          optimum: "optimum",
          pattern: "pattern",
          placeholder: "placeholder",
          playsinline: "playsInline",
          poster: "poster",
          preload: "preload",
          profile: "profile",
          radiogroup: "radioGroup",
          readonly: "readOnly",
          referrerpolicy: "referrerPolicy",
          rel: "rel",
          required: "required",
          reversed: "reversed",
          role: "role",
          rows: "rows",
          rowspan: "rowSpan",
          sandbox: "sandbox",
          scope: "scope",
          scoped: "scoped",
          scrolling: "scrolling",
          seamless: "seamless",
          selected: "selected",
          shape: "shape",
          size: "size",
          sizes: "sizes",
          span: "span",
          spellcheck: "spellCheck",
          src: "src",
          srcdoc: "srcDoc",
          srclang: "srcLang",
          srcset: "srcSet",
          start: "start",
          step: "step",
          style: "style",
          summary: "summary",
          tabindex: "tabIndex",
          target: "target",
          title: "title",
          type: "type",
          usemap: "useMap",
          value: "value",
          width: "width",
          wmode: "wmode",
          wrap: "wrap",
          about: "about",
          accentheight: "accentHeight",
          "accent-height": "accentHeight",
          accumulate: "accumulate",
          additive: "additive",
          alignmentbaseline: "alignmentBaseline",
          "alignment-baseline": "alignmentBaseline",
          allowreorder: "allowReorder",
          alphabetic: "alphabetic",
          amplitude: "amplitude",
          arabicform: "arabicForm",
          "arabic-form": "arabicForm",
          ascent: "ascent",
          attributename: "attributeName",
          attributetype: "attributeType",
          autoreverse: "autoReverse",
          azimuth: "azimuth",
          basefrequency: "baseFrequency",
          baselineshift: "baselineShift",
          "baseline-shift": "baselineShift",
          baseprofile: "baseProfile",
          bbox: "bbox",
          begin: "begin",
          bias: "bias",
          by: "by",
          calcmode: "calcMode",
          capheight: "capHeight",
          "cap-height": "capHeight",
          clip: "clip",
          clippath: "clipPath",
          "clip-path": "clipPath",
          clippathunits: "clipPathUnits",
          cliprule: "clipRule",
          "clip-rule": "clipRule",
          color: "color",
          colorinterpolation: "colorInterpolation",
          "color-interpolation": "colorInterpolation",
          colorinterpolationfilters: "colorInterpolationFilters",
          "color-interpolation-filters": "colorInterpolationFilters",
          colorprofile: "colorProfile",
          "color-profile": "colorProfile",
          colorrendering: "colorRendering",
          "color-rendering": "colorRendering",
          contentscripttype: "contentScriptType",
          contentstyletype: "contentStyleType",
          cursor: "cursor",
          cx: "cx",
          cy: "cy",
          d: "d",
          datatype: "datatype",
          decelerate: "decelerate",
          descent: "descent",
          diffuseconstant: "diffuseConstant",
          direction: "direction",
          display: "display",
          divisor: "divisor",
          dominantbaseline: "dominantBaseline",
          "dominant-baseline": "dominantBaseline",
          dur: "dur",
          dx: "dx",
          dy: "dy",
          edgemode: "edgeMode",
          elevation: "elevation",
          enablebackground: "enableBackground",
          "enable-background": "enableBackground",
          end: "end",
          exponent: "exponent",
          externalresourcesrequired: "externalResourcesRequired",
          fill: "fill",
          fillopacity: "fillOpacity",
          "fill-opacity": "fillOpacity",
          fillrule: "fillRule",
          "fill-rule": "fillRule",
          filter: "filter",
          filterres: "filterRes",
          filterunits: "filterUnits",
          floodopacity: "floodOpacity",
          "flood-opacity": "floodOpacity",
          floodcolor: "floodColor",
          "flood-color": "floodColor",
          focusable: "focusable",
          fontfamily: "fontFamily",
          "font-family": "fontFamily",
          fontsize: "fontSize",
          "font-size": "fontSize",
          fontsizeadjust: "fontSizeAdjust",
          "font-size-adjust": "fontSizeAdjust",
          fontstretch: "fontStretch",
          "font-stretch": "fontStretch",
          fontstyle: "fontStyle",
          "font-style": "fontStyle",
          fontvariant: "fontVariant",
          "font-variant": "fontVariant",
          fontweight: "fontWeight",
          "font-weight": "fontWeight",
          format: "format",
          from: "from",
          fx: "fx",
          fy: "fy",
          g1: "g1",
          g2: "g2",
          glyphname: "glyphName",
          "glyph-name": "glyphName",
          glyphorientationhorizontal: "glyphOrientationHorizontal",
          "glyph-orientation-horizontal": "glyphOrientationHorizontal",
          glyphorientationvertical: "glyphOrientationVertical",
          "glyph-orientation-vertical": "glyphOrientationVertical",
          glyphref: "glyphRef",
          gradienttransform: "gradientTransform",
          gradientunits: "gradientUnits",
          hanging: "hanging",
          horizadvx: "horizAdvX",
          "horiz-adv-x": "horizAdvX",
          horizoriginx: "horizOriginX",
          "horiz-origin-x": "horizOriginX",
          ideographic: "ideographic",
          imagerendering: "imageRendering",
          "image-rendering": "imageRendering",
          in2: "in2",
          in: "in",
          inlist: "inlist",
          intercept: "intercept",
          k1: "k1",
          k2: "k2",
          k3: "k3",
          k4: "k4",
          k: "k",
          kernelmatrix: "kernelMatrix",
          kernelunitlength: "kernelUnitLength",
          kerning: "kerning",
          keypoints: "keyPoints",
          keysplines: "keySplines",
          keytimes: "keyTimes",
          lengthadjust: "lengthAdjust",
          letterspacing: "letterSpacing",
          "letter-spacing": "letterSpacing",
          lightingcolor: "lightingColor",
          "lighting-color": "lightingColor",
          limitingconeangle: "limitingConeAngle",
          local: "local",
          markerend: "markerEnd",
          "marker-end": "markerEnd",
          markerheight: "markerHeight",
          markermid: "markerMid",
          "marker-mid": "markerMid",
          markerstart: "markerStart",
          "marker-start": "markerStart",
          markerunits: "markerUnits",
          markerwidth: "markerWidth",
          mask: "mask",
          maskcontentunits: "maskContentUnits",
          maskunits: "maskUnits",
          mathematical: "mathematical",
          mode: "mode",
          numoctaves: "numOctaves",
          offset: "offset",
          opacity: "opacity",
          operator: "operator",
          order: "order",
          orient: "orient",
          orientation: "orientation",
          origin: "origin",
          overflow: "overflow",
          overlineposition: "overlinePosition",
          "overline-position": "overlinePosition",
          overlinethickness: "overlineThickness",
          "overline-thickness": "overlineThickness",
          paintorder: "paintOrder",
          "paint-order": "paintOrder",
          panose1: "panose1",
          "panose-1": "panose1",
          pathlength: "pathLength",
          patterncontentunits: "patternContentUnits",
          patterntransform: "patternTransform",
          patternunits: "patternUnits",
          pointerevents: "pointerEvents",
          "pointer-events": "pointerEvents",
          points: "points",
          pointsatx: "pointsAtX",
          pointsaty: "pointsAtY",
          pointsatz: "pointsAtZ",
          popover: "popover",
          popovertarget: "popoverTarget",
          popovertargetaction: "popoverTargetAction",
          prefix: "prefix",
          preservealpha: "preserveAlpha",
          preserveaspectratio: "preserveAspectRatio",
          primitiveunits: "primitiveUnits",
          property: "property",
          r: "r",
          radius: "radius",
          refx: "refX",
          refy: "refY",
          renderingintent: "renderingIntent",
          "rendering-intent": "renderingIntent",
          repeatcount: "repeatCount",
          repeatdur: "repeatDur",
          requiredextensions: "requiredExtensions",
          requiredfeatures: "requiredFeatures",
          resource: "resource",
          restart: "restart",
          result: "result",
          results: "results",
          rotate: "rotate",
          rx: "rx",
          ry: "ry",
          scale: "scale",
          security: "security",
          seed: "seed",
          shaperendering: "shapeRendering",
          "shape-rendering": "shapeRendering",
          slope: "slope",
          spacing: "spacing",
          specularconstant: "specularConstant",
          specularexponent: "specularExponent",
          speed: "speed",
          spreadmethod: "spreadMethod",
          startoffset: "startOffset",
          stddeviation: "stdDeviation",
          stemh: "stemh",
          stemv: "stemv",
          stitchtiles: "stitchTiles",
          stopcolor: "stopColor",
          "stop-color": "stopColor",
          stopopacity: "stopOpacity",
          "stop-opacity": "stopOpacity",
          strikethroughposition: "strikethroughPosition",
          "strikethrough-position": "strikethroughPosition",
          strikethroughthickness: "strikethroughThickness",
          "strikethrough-thickness": "strikethroughThickness",
          string: "string",
          stroke: "stroke",
          strokedasharray: "strokeDasharray",
          "stroke-dasharray": "strokeDasharray",
          strokedashoffset: "strokeDashoffset",
          "stroke-dashoffset": "strokeDashoffset",
          strokelinecap: "strokeLinecap",
          "stroke-linecap": "strokeLinecap",
          strokelinejoin: "strokeLinejoin",
          "stroke-linejoin": "strokeLinejoin",
          strokemiterlimit: "strokeMiterlimit",
          "stroke-miterlimit": "strokeMiterlimit",
          strokewidth: "strokeWidth",
          "stroke-width": "strokeWidth",
          strokeopacity: "strokeOpacity",
          "stroke-opacity": "strokeOpacity",
          suppresscontenteditablewarning: "suppressContentEditableWarning",
          suppresshydrationwarning: "suppressHydrationWarning",
          surfacescale: "surfaceScale",
          systemlanguage: "systemLanguage",
          tablevalues: "tableValues",
          targetx: "targetX",
          targety: "targetY",
          textanchor: "textAnchor",
          "text-anchor": "textAnchor",
          textdecoration: "textDecoration",
          "text-decoration": "textDecoration",
          textlength: "textLength",
          textrendering: "textRendering",
          "text-rendering": "textRendering",
          to: "to",
          transform: "transform",
          transformorigin: "transformOrigin",
          "transform-origin": "transformOrigin",
          typeof: "typeof",
          u1: "u1",
          u2: "u2",
          underlineposition: "underlinePosition",
          "underline-position": "underlinePosition",
          underlinethickness: "underlineThickness",
          "underline-thickness": "underlineThickness",
          unicode: "unicode",
          unicodebidi: "unicodeBidi",
          "unicode-bidi": "unicodeBidi",
          unicoderange: "unicodeRange",
          "unicode-range": "unicodeRange",
          unitsperem: "unitsPerEm",
          "units-per-em": "unitsPerEm",
          unselectable: "unselectable",
          valphabetic: "vAlphabetic",
          "v-alphabetic": "vAlphabetic",
          values: "values",
          vectoreffect: "vectorEffect",
          "vector-effect": "vectorEffect",
          version: "version",
          vertadvy: "vertAdvY",
          "vert-adv-y": "vertAdvY",
          vertoriginx: "vertOriginX",
          "vert-origin-x": "vertOriginX",
          vertoriginy: "vertOriginY",
          "vert-origin-y": "vertOriginY",
          vhanging: "vHanging",
          "v-hanging": "vHanging",
          videographic: "vIdeographic",
          "v-ideographic": "vIdeographic",
          viewbox: "viewBox",
          viewtarget: "viewTarget",
          visibility: "visibility",
          vmathematical: "vMathematical",
          "v-mathematical": "vMathematical",
          vocab: "vocab",
          widths: "widths",
          wordspacing: "wordSpacing",
          "word-spacing": "wordSpacing",
          writingmode: "writingMode",
          "writing-mode": "writingMode",
          x1: "x1",
          x2: "x2",
          x: "x",
          xchannelselector: "xChannelSelector",
          xheight: "xHeight",
          "x-height": "xHeight",
          xlinkactuate: "xlinkActuate",
          "xlink:actuate": "xlinkActuate",
          xlinkarcrole: "xlinkArcrole",
          "xlink:arcrole": "xlinkArcrole",
          xlinkhref: "xlinkHref",
          "xlink:href": "xlinkHref",
          xlinkrole: "xlinkRole",
          "xlink:role": "xlinkRole",
          xlinkshow: "xlinkShow",
          "xlink:show": "xlinkShow",
          xlinktitle: "xlinkTitle",
          "xlink:title": "xlinkTitle",
          xlinktype: "xlinkType",
          "xlink:type": "xlinkType",
          xmlbase: "xmlBase",
          "xml:base": "xmlBase",
          xmllang: "xmlLang",
          "xml:lang": "xmlLang",
          xmlns: "xmlns",
          "xml:space": "xmlSpace",
          xmlnsxlink: "xmlnsXlink",
          "xmlns:xlink": "xmlnsXlink",
          xmlspace: "xmlSpace",
          y1: "y1",
          y2: "y2",
          y: "y",
          ychannelselector: "yChannelSelector",
          z: "z",
          zoomandpan: "zoomAndPan"
        }, ariaProperties = {
          "aria-current": 0,
          "aria-description": 0,
          "aria-details": 0,
          "aria-disabled": 0,
          "aria-hidden": 0,
          "aria-invalid": 0,
          "aria-keyshortcuts": 0,
          "aria-label": 0,
          "aria-roledescription": 0,
          "aria-autocomplete": 0,
          "aria-checked": 0,
          "aria-expanded": 0,
          "aria-haspopup": 0,
          "aria-level": 0,
          "aria-modal": 0,
          "aria-multiline": 0,
          "aria-multiselectable": 0,
          "aria-orientation": 0,
          "aria-placeholder": 0,
          "aria-pressed": 0,
          "aria-readonly": 0,
          "aria-required": 0,
          "aria-selected": 0,
          "aria-sort": 0,
          "aria-valuemax": 0,
          "aria-valuemin": 0,
          "aria-valuenow": 0,
          "aria-valuetext": 0,
          "aria-atomic": 0,
          "aria-busy": 0,
          "aria-live": 0,
          "aria-relevant": 0,
          "aria-dropeffect": 0,
          "aria-grabbed": 0,
          "aria-activedescendant": 0,
          "aria-colcount": 0,
          "aria-colindex": 0,
          "aria-colspan": 0,
          "aria-controls": 0,
          "aria-describedby": 0,
          "aria-errormessage": 0,
          "aria-flowto": 0,
          "aria-labelledby": 0,
          "aria-owns": 0,
          "aria-posinset": 0,
          "aria-rowcount": 0,
          "aria-rowindex": 0,
          "aria-rowspan": 0,
          "aria-setsize": 0,
          "aria-braillelabel": 0,
          "aria-brailleroledescription": 0,
          "aria-colindextext": 0,
          "aria-rowindextext": 0
        }, warnedProperties$1 = {}, rARIA$1 = RegExp(
          "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), rARIACamel$1 = RegExp(
          "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), didWarnValueNull = false, warnedProperties = {}, EVENT_NAME_REGEX = /^on./, INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/, rARIA = RegExp(
          "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), rARIACamel = RegExp(
          "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i, currentReplayingEvent = null, restoreTarget = null, restoreQueue = null, isInsideEventHandler = false, canUseDOM = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), passiveBrowserEventsSupported = false;
        if (canUseDOM)
          try {
            var options$jscomp$0 = {};
            Object.defineProperty(options$jscomp$0, "passive", {
              get: function() {
                passiveBrowserEventsSupported = true;
              }
            });
            window.addEventListener("test", options$jscomp$0, options$jscomp$0);
            window.removeEventListener("test", options$jscomp$0, options$jscomp$0);
          } catch (e2) {
            passiveBrowserEventsSupported = false;
          }
        var root = null, startText = null, fallbackText = null, EventInterface = {
          eventPhase: 0,
          bubbles: 0,
          cancelable: 0,
          timeStamp: function(event) {
            return event.timeStamp || Date.now();
          },
          defaultPrevented: 0,
          isTrusted: 0
        }, SyntheticEvent = createSyntheticEvent(EventInterface), UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 }), SyntheticUIEvent = createSyntheticEvent(UIEventInterface), lastMovementX, lastMovementY, lastMouseEvent, MouseEventInterface = assign({}, UIEventInterface, {
          screenX: 0,
          screenY: 0,
          clientX: 0,
          clientY: 0,
          pageX: 0,
          pageY: 0,
          ctrlKey: 0,
          shiftKey: 0,
          altKey: 0,
          metaKey: 0,
          getModifierState: getEventModifierState,
          button: 0,
          buttons: 0,
          relatedTarget: function(event) {
            return void 0 === event.relatedTarget ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
          },
          movementX: function(event) {
            if ("movementX" in event) return event.movementX;
            event !== lastMouseEvent && (lastMouseEvent && "mousemove" === event.type ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = event);
            return lastMovementX;
          },
          movementY: function(event) {
            return "movementY" in event ? event.movementY : lastMovementY;
          }
        }), SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface), DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 }), SyntheticDragEvent = createSyntheticEvent(DragEventInterface), FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 }), SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface), AnimationEventInterface = assign({}, EventInterface, {
          animationName: 0,
          elapsedTime: 0,
          pseudoElement: 0
        }), SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface), ClipboardEventInterface = assign({}, EventInterface, {
          clipboardData: function(event) {
            return "clipboardData" in event ? event.clipboardData : window.clipboardData;
          }
        }), SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface), CompositionEventInterface = assign({}, EventInterface, { data: 0 }), SyntheticCompositionEvent = createSyntheticEvent(
          CompositionEventInterface
        ), SyntheticInputEvent = SyntheticCompositionEvent, normalizeKey = {
          Esc: "Escape",
          Spacebar: " ",
          Left: "ArrowLeft",
          Up: "ArrowUp",
          Right: "ArrowRight",
          Down: "ArrowDown",
          Del: "Delete",
          Win: "OS",
          Menu: "ContextMenu",
          Apps: "ContextMenu",
          Scroll: "ScrollLock",
          MozPrintableKey: "Unidentified"
        }, translateToKey = {
          8: "Backspace",
          9: "Tab",
          12: "Clear",
          13: "Enter",
          16: "Shift",
          17: "Control",
          18: "Alt",
          19: "Pause",
          20: "CapsLock",
          27: "Escape",
          32: " ",
          33: "PageUp",
          34: "PageDown",
          35: "End",
          36: "Home",
          37: "ArrowLeft",
          38: "ArrowUp",
          39: "ArrowRight",
          40: "ArrowDown",
          45: "Insert",
          46: "Delete",
          112: "F1",
          113: "F2",
          114: "F3",
          115: "F4",
          116: "F5",
          117: "F6",
          118: "F7",
          119: "F8",
          120: "F9",
          121: "F10",
          122: "F11",
          123: "F12",
          144: "NumLock",
          145: "ScrollLock",
          224: "Meta"
        }, modifierKeyToProp = {
          Alt: "altKey",
          Control: "ctrlKey",
          Meta: "metaKey",
          Shift: "shiftKey"
        }, KeyboardEventInterface = assign({}, UIEventInterface, {
          key: function(nativeEvent) {
            if (nativeEvent.key) {
              var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
              if ("Unidentified" !== key) return key;
            }
            return "keypress" === nativeEvent.type ? (nativeEvent = getEventCharCode(nativeEvent), 13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent)) : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
          },
          code: 0,
          location: 0,
          ctrlKey: 0,
          shiftKey: 0,
          altKey: 0,
          metaKey: 0,
          repeat: 0,
          locale: 0,
          getModifierState: getEventModifierState,
          charCode: function(event) {
            return "keypress" === event.type ? getEventCharCode(event) : 0;
          },
          keyCode: function(event) {
            return "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
          },
          which: function(event) {
            return "keypress" === event.type ? getEventCharCode(event) : "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
          }
        }), SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface), PointerEventInterface = assign({}, MouseEventInterface, {
          pointerId: 0,
          width: 0,
          height: 0,
          pressure: 0,
          tangentialPressure: 0,
          tiltX: 0,
          tiltY: 0,
          twist: 0,
          pointerType: 0,
          isPrimary: 0
        }), SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface), TouchEventInterface = assign({}, UIEventInterface, {
          touches: 0,
          targetTouches: 0,
          changedTouches: 0,
          altKey: 0,
          metaKey: 0,
          ctrlKey: 0,
          shiftKey: 0,
          getModifierState: getEventModifierState
        }), SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface), TransitionEventInterface = assign({}, EventInterface, {
          propertyName: 0,
          elapsedTime: 0,
          pseudoElement: 0
        }), SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface), WheelEventInterface = assign({}, MouseEventInterface, {
          deltaX: function(event) {
            return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
          },
          deltaY: function(event) {
            return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
          },
          deltaZ: 0,
          deltaMode: 0
        }), SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface), ToggleEventInterface = assign({}, EventInterface, {
          newState: 0,
          oldState: 0
        }), SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface), END_KEYCODES = [9, 13, 27, 32], START_KEYCODE = 229, canUseCompositionEvent = canUseDOM && "CompositionEvent" in window, documentMode = null;
        canUseDOM && "documentMode" in document && (documentMode = document.documentMode);
        var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode, useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode), SPACEBAR_CODE = 32, SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE), hasSpaceKeypress = false, isComposing = false, supportedInputTypes = {
          color: true,
          date: true,
          datetime: true,
          "datetime-local": true,
          email: true,
          month: true,
          number: true,
          password: true,
          range: true,
          search: true,
          tel: true,
          text: true,
          time: true,
          url: true,
          week: true
        }, activeElement$1 = null, activeElementInst$1 = null, isInputEventSupported = false;
        canUseDOM && (isInputEventSupported = isEventSupported("input") && (!document.documentMode || 9 < document.documentMode));
        var objectIs = "function" === typeof Object.is ? Object.is : is, skipSelectionChangeEvent = canUseDOM && "documentMode" in document && 11 >= document.documentMode, activeElement = null, activeElementInst = null, lastSelection = null, mouseDown = false, vendorPrefixes = {
          animationend: makePrefixMap("Animation", "AnimationEnd"),
          animationiteration: makePrefixMap("Animation", "AnimationIteration"),
          animationstart: makePrefixMap("Animation", "AnimationStart"),
          transitionrun: makePrefixMap("Transition", "TransitionRun"),
          transitionstart: makePrefixMap("Transition", "TransitionStart"),
          transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
          transitionend: makePrefixMap("Transition", "TransitionEnd")
        }, prefixedEventNames = {}, style = {};
        canUseDOM && (style = document.createElement("div").style, "AnimationEvent" in window || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), "TransitionEvent" in window || delete vendorPrefixes.transitionend.transition);
        var ANIMATION_END = getVendorPrefixedEventName("animationend"), ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"), ANIMATION_START = getVendorPrefixedEventName("animationstart"), TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"), TRANSITION_START = getVendorPrefixedEventName("transitionstart"), TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"), TRANSITION_END = getVendorPrefixedEventName("transitionend"), topLevelEventsToReactNames = /* @__PURE__ */ new Map(), simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
          " "
        );
        simpleEventPluginEvents.push("scrollEnd");
        var lastResetTime = 0;
        if ("object" === typeof performance && "function" === typeof performance.now) {
          var localPerformance = performance;
          var getCurrentTime = function() {
            return localPerformance.now();
          };
        } else {
          var localDate = Date;
          getCurrentTime = function() {
            return localDate.now();
          };
        }
        var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
          if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
            var event = new window.ErrorEvent("error", {
              bubbles: true,
              cancelable: true,
              message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
              error
            });
            if (!window.dispatchEvent(event)) return;
          } else if ("object" === typeof process && "function" === typeof process.emit) {
            process.emit("uncaughtException", error);
            return;
          }
          console.error(error);
        }, OMITTED_PROP_ERROR = "This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects.", EMPTY_ARRAY = 0, COMPLEX_ARRAY = 1, PRIMITIVE_ARRAY = 2, ENTRIES_ARRAY = 3, REMOVED = "\u2013\xA0", ADDED = "+\xA0", UNCHANGED = "\u2007\xA0", supportsUserTiming = "undefined" !== typeof console && "function" === typeof console.timeStamp && "undefined" !== typeof performance && "function" === typeof performance.measure, COMPONENTS_TRACK = "Components \u269B", LANES_TRACK_GROUP = "Scheduler \u269B", currentTrack = "Blocking", alreadyWarnedForDeepEquality = false, reusableComponentDevToolDetails = {
          color: "primary",
          properties: null,
          tooltipText: "",
          track: COMPONENTS_TRACK
        }, reusableComponentOptions = {
          start: -0,
          end: -0,
          detail: { devtools: reusableComponentDevToolDetails }
        }, resuableChangedPropsEntry = ["Changed Props", ""], DEEP_EQUALITY_WARNING = "This component received deeply equal props. It might benefit from useMemo or the React Compiler in its owner.", reusableDeeplyEqualPropsEntry = ["Changed Props", DEEP_EQUALITY_WARNING], OffscreenVisible = 1, OffscreenPassiveEffectsConnected = 2, concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0, emptyContextObject = {};
        Object.freeze(emptyContextObject);
        var resolveFamily = null, failedBoundaries = null, NoMode = 0, ConcurrentMode = 1, ProfileMode = 2, StrictLegacyMode = 8, StrictEffectsMode = 16, SuspenseyImagesMode = 32;
        var hasBadMapPolyfill = false;
        try {
          var nonExtensibleObject = Object.preventExtensions({});
          /* @__PURE__ */ new Map([[nonExtensibleObject, null]]);
          /* @__PURE__ */ new Set([nonExtensibleObject]);
        } catch (e$3) {
          hasBadMapPolyfill = true;
        }
        var CapturedStacks = /* @__PURE__ */ new WeakMap(), forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = "", hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = false, didSuspendOrErrorDEV = false, hydrationDiffRootDEV = null, hydrationErrors = null, rootOrSingletonContext = false, HydrationMismatchException = Error(
          "Hydration Mismatch Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
        ), valueCursor = createCursor(null);
        var rendererCursorDEV = createCursor(null);
        var rendererSigil = {};
        var currentlyRenderingFiber$1 = null, lastContextDependency = null, isDisallowedContextReadInDEV = false, AbortControllerLocal = "undefined" !== typeof AbortController ? AbortController : function() {
          var listeners = [], signal = this.signal = {
            aborted: false,
            addEventListener: function(type, listener) {
              listeners.push(listener);
            }
          };
          this.abort = function() {
            signal.aborted = true;
            listeners.forEach(function(listener) {
              return listener();
            });
          };
        }, scheduleCallback$2 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority, CacheContext = {
          $$typeof: REACT_CONTEXT_TYPE,
          Consumer: null,
          Provider: null,
          _currentValue: null,
          _currentValue2: null,
          _threadCount: 0,
          _currentRenderer: null,
          _currentRenderer2: null
        }, now = Scheduler.unstable_now, createTask = console.createTask ? console.createTask : function() {
          return null;
        }, SPAWNED_UPDATE = 1, PINGED_UPDATE = 2, renderStartTime = -0, commitStartTime = -0, commitEndTime = -0, commitErrors = null, profilerStartTime = -1.1, profilerEffectDuration = -0, componentEffectDuration = -0, componentEffectStartTime = -1.1, componentEffectEndTime = -1.1, componentEffectErrors = null, componentEffectSpawnedUpdate = false, blockingClampTime = -0, blockingUpdateTime = -1.1, blockingUpdateTask = null, blockingUpdateType = 0, blockingUpdateMethodName = null, blockingUpdateComponentName = null, blockingEventTime = -1.1, blockingEventType = null, blockingEventRepeatTime = -1.1, blockingSuspendedTime = -1.1, transitionClampTime = -0, transitionStartTime = -1.1, transitionUpdateTime = -1.1, transitionUpdateType = 0, transitionUpdateTask = null, transitionUpdateMethodName = null, transitionUpdateComponentName = null, transitionEventTime = -1.1, transitionEventType = null, transitionEventRepeatTime = -1.1, transitionSuspendedTime = -1.1, retryClampTime = -0, idleClampTime = -0, animatingLanes = 0, animatingTask = null, yieldReason = 0, yieldStartTime = -1.1, currentUpdateIsNested = false, nestedUpdateScheduled = false, currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null, prevOnStartTransitionFinish = ReactSharedInternals.S;
        ReactSharedInternals.S = function(transition, returnValue) {
          globalMostRecentTransitionTime = now$1();
          if ("object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then) {
            if (0 > transitionStartTime && 0 > transitionUpdateTime) {
              transitionStartTime = now();
              var newEventTime = resolveEventTimeStamp(), newEventType = resolveEventType();
              if (newEventTime !== transitionEventRepeatTime || newEventType !== transitionEventType)
                transitionEventRepeatTime = -1.1;
              transitionEventTime = newEventTime;
              transitionEventType = newEventType;
            }
            entangleAsyncAction(transition, returnValue);
          }
          null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);
        };
        var resumedCache = createCursor(null), ReactStrictModeWarnings = {
          recordUnsafeLifecycleWarnings: function() {
          },
          flushPendingUnsafeLifecycleWarnings: function() {
          },
          recordLegacyContextWarning: function() {
          },
          flushLegacyContextWarning: function() {
          },
          discardPendingWarnings: function() {
          }
        }, pendingComponentWillMountWarnings = [], pendingUNSAFE_ComponentWillMountWarnings = [], pendingComponentWillReceivePropsWarnings = [], pendingUNSAFE_ComponentWillReceivePropsWarnings = [], pendingComponentWillUpdateWarnings = [], pendingUNSAFE_ComponentWillUpdateWarnings = [], didWarnAboutUnsafeLifecycles = /* @__PURE__ */ new Set();
        ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {
          didWarnAboutUnsafeLifecycles.has(fiber.type) || ("function" === typeof instance.componentWillMount && true !== instance.componentWillMount.__suppressDeprecationWarning && pendingComponentWillMountWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillMount && pendingUNSAFE_ComponentWillMountWarnings.push(fiber), "function" === typeof instance.componentWillReceiveProps && true !== instance.componentWillReceiveProps.__suppressDeprecationWarning && pendingComponentWillReceivePropsWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillReceiveProps && pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber), "function" === typeof instance.componentWillUpdate && true !== instance.componentWillUpdate.__suppressDeprecationWarning && pendingComponentWillUpdateWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillUpdate && pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber));
        };
        ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
          var componentWillMountUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingComponentWillMountWarnings.length && (pendingComponentWillMountWarnings.forEach(function(fiber) {
            componentWillMountUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingComponentWillMountWarnings = []);
          var UNSAFE_componentWillMountUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingUNSAFE_ComponentWillMountWarnings.length && (pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
            UNSAFE_componentWillMountUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingUNSAFE_ComponentWillMountWarnings = []);
          var componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingComponentWillReceivePropsWarnings.length && (pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
            componentWillReceivePropsUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingComponentWillReceivePropsWarnings = []);
          var UNSAFE_componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingUNSAFE_ComponentWillReceivePropsWarnings.length && (pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(
            function(fiber) {
              UNSAFE_componentWillReceivePropsUniqueNames.add(
                getComponentNameFromFiber(fiber) || "Component"
              );
              didWarnAboutUnsafeLifecycles.add(fiber.type);
            }
          ), pendingUNSAFE_ComponentWillReceivePropsWarnings = []);
          var componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingComponentWillUpdateWarnings.length && (pendingComponentWillUpdateWarnings.forEach(function(fiber) {
            componentWillUpdateUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingComponentWillUpdateWarnings = []);
          var UNSAFE_componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingUNSAFE_ComponentWillUpdateWarnings.length && (pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
            UNSAFE_componentWillUpdateUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingUNSAFE_ComponentWillUpdateWarnings = []);
          if (0 < UNSAFE_componentWillMountUniqueNames.size) {
            var sortedNames = setToSortedString(
              UNSAFE_componentWillMountUniqueNames
            );
            console.error(
              "Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s",
              sortedNames
            );
          }
          0 < UNSAFE_componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(
            UNSAFE_componentWillReceivePropsUniqueNames
          ), console.error(
            "Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n\nPlease update the following components: %s",
            sortedNames
          ));
          0 < UNSAFE_componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(
            UNSAFE_componentWillUpdateUniqueNames
          ), console.error(
            "Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s",
            sortedNames
          ));
          0 < componentWillMountUniqueNames.size && (sortedNames = setToSortedString(componentWillMountUniqueNames), console.warn(
            "componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
            sortedNames
          ));
          0 < componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(
            componentWillReceivePropsUniqueNames
          ), console.warn(
            "componentWillReceiveProps has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
            sortedNames
          ));
          0 < componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(componentWillUpdateUniqueNames), console.warn(
            "componentWillUpdate has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
            sortedNames
          ));
        };
        var pendingLegacyContextWarning = /* @__PURE__ */ new Map(), didWarnAboutLegacyContext = /* @__PURE__ */ new Set();
        ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {
          var strictRoot = null;
          for (var node = fiber; null !== node; )
            node.mode & StrictLegacyMode && (strictRoot = node), node = node.return;
          null === strictRoot ? console.error(
            "Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue."
          ) : !didWarnAboutLegacyContext.has(fiber.type) && (node = pendingLegacyContextWarning.get(strictRoot), null != fiber.type.contextTypes || null != fiber.type.childContextTypes || null !== instance && "function" === typeof instance.getChildContext) && (void 0 === node && (node = [], pendingLegacyContextWarning.set(strictRoot, node)), node.push(fiber));
        };
        ReactStrictModeWarnings.flushLegacyContextWarning = function() {
          pendingLegacyContextWarning.forEach(function(fiberArray) {
            if (0 !== fiberArray.length) {
              var firstFiber = fiberArray[0], uniqueNames = /* @__PURE__ */ new Set();
              fiberArray.forEach(function(fiber) {
                uniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutLegacyContext.add(fiber.type);
              });
              var sortedNames = setToSortedString(uniqueNames);
              runWithFiberInDEV(firstFiber, function() {
                console.error(
                  "Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://react.dev/link/legacy-context",
                  sortedNames
                );
              });
            }
          });
        };
        ReactStrictModeWarnings.discardPendingWarnings = function() {
          pendingComponentWillMountWarnings = [];
          pendingUNSAFE_ComponentWillMountWarnings = [];
          pendingComponentWillReceivePropsWarnings = [];
          pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
          pendingComponentWillUpdateWarnings = [];
          pendingUNSAFE_ComponentWillUpdateWarnings = [];
          pendingLegacyContextWarning = /* @__PURE__ */ new Map();
        };
        var callComponent = {
          react_stack_bottom_frame: function(Component, props, secondArg) {
            var wasRendering = isRendering;
            isRendering = true;
            try {
              return Component(props, secondArg);
            } finally {
              isRendering = wasRendering;
            }
          }
        }, callComponentInDEV = callComponent.react_stack_bottom_frame.bind(callComponent), callRender = {
          react_stack_bottom_frame: function(instance) {
            var wasRendering = isRendering;
            isRendering = true;
            try {
              return instance.render();
            } finally {
              isRendering = wasRendering;
            }
          }
        }, callRenderInDEV = callRender.react_stack_bottom_frame.bind(callRender), callComponentDidMount = {
          react_stack_bottom_frame: function(finishedWork, instance) {
            try {
              instance.componentDidMount();
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
        }, callComponentDidMountInDEV = callComponentDidMount.react_stack_bottom_frame.bind(
          callComponentDidMount
        ), callComponentDidUpdate = {
          react_stack_bottom_frame: function(finishedWork, instance, prevProps, prevState, snapshot) {
            try {
              instance.componentDidUpdate(prevProps, prevState, snapshot);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
        }, callComponentDidUpdateInDEV = callComponentDidUpdate.react_stack_bottom_frame.bind(
          callComponentDidUpdate
        ), callComponentDidCatch = {
          react_stack_bottom_frame: function(instance, errorInfo) {
            var stack = errorInfo.stack;
            instance.componentDidCatch(errorInfo.value, {
              componentStack: null !== stack ? stack : ""
            });
          }
        }, callComponentDidCatchInDEV = callComponentDidCatch.react_stack_bottom_frame.bind(
          callComponentDidCatch
        ), callComponentWillUnmount = {
          react_stack_bottom_frame: function(current2, nearestMountedAncestor, instance) {
            try {
              instance.componentWillUnmount();
            } catch (error) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error);
            }
          }
        }, callComponentWillUnmountInDEV = callComponentWillUnmount.react_stack_bottom_frame.bind(
          callComponentWillUnmount
        ), callCreate = {
          react_stack_bottom_frame: function(effect) {
            var create2 = effect.create;
            effect = effect.inst;
            create2 = create2();
            return effect.destroy = create2;
          }
        }, callCreateInDEV = callCreate.react_stack_bottom_frame.bind(callCreate), callDestroy = {
          react_stack_bottom_frame: function(current2, nearestMountedAncestor, destroy) {
            try {
              destroy();
            } catch (error) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error);
            }
          }
        }, callDestroyInDEV = callDestroy.react_stack_bottom_frame.bind(callDestroy), callLazyInit = {
          react_stack_bottom_frame: function(lazy) {
            var init = lazy._init;
            return init(lazy._payload);
          }
        }, callLazyInitInDEV = callLazyInit.react_stack_bottom_frame.bind(callLazyInit), SuspenseException = Error(
          "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."
        ), SuspenseyCommitException = Error(
          "Suspense Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
        ), SuspenseActionException = Error(
          "Suspense Exception: This is not a real error! It's an implementation detail of `useActionState` to interrupt the current render. You must either rethrow it immediately, or move the `useActionState` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary."
        ), noopSuspenseyCommitThenable = {
          then: function() {
            console.error(
              'Internal React error: A listener was unexpectedly attached to a "noop" thenable. This is a bug in React. Please file an issue.'
            );
          }
        }, suspendedThenable = null, needsToResetSuspendedThenableDEV = false, thenableState$1 = null, thenableIndexCounter$1 = 0, currentDebugInfo = null, didWarnAboutMaps;
        var didWarnAboutGenerators = didWarnAboutMaps = false;
        var ownerHasKeyUseWarning = {};
        var ownerHasFunctionTypeWarning = {};
        var ownerHasSymbolTypeWarning = {};
        warnForMissingKey = function(returnFiber, workInProgress2, child) {
          if (null !== child && "object" === typeof child && child._store && (!child._store.validated && null == child.key || 2 === child._store.validated)) {
            if ("object" !== typeof child._store)
              throw Error(
                "React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue."
              );
            child._store.validated = 1;
            var componentName2 = getComponentNameFromFiber(returnFiber), componentKey = componentName2 || "null";
            if (!ownerHasKeyUseWarning[componentKey]) {
              ownerHasKeyUseWarning[componentKey] = true;
              child = child._owner;
              returnFiber = returnFiber._debugOwner;
              var currentComponentErrorInfo = "";
              returnFiber && "number" === typeof returnFiber.tag && (componentKey = getComponentNameFromFiber(returnFiber)) && (currentComponentErrorInfo = "\n\nCheck the render method of `" + componentKey + "`.");
              currentComponentErrorInfo || componentName2 && (currentComponentErrorInfo = "\n\nCheck the top-level render call using <" + componentName2 + ">.");
              var childOwnerAppendix = "";
              null != child && returnFiber !== child && (componentName2 = null, "number" === typeof child.tag ? componentName2 = getComponentNameFromFiber(child) : "string" === typeof child.name && (componentName2 = child.name), componentName2 && (childOwnerAppendix = " It was passed a child from " + componentName2 + "."));
              runWithFiberInDEV(workInProgress2, function() {
                console.error(
                  'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
                  currentComponentErrorInfo,
                  childOwnerAppendix
                );
              });
            }
          }
        };
        var reconcileChildFibers = createChildReconciler(true), mountChildFibers = createChildReconciler(false), UpdateState = 0, ReplaceState = 1, ForceUpdate = 2, CaptureUpdate = 3, hasForceUpdate = false;
        var didWarnUpdateInsideUpdate = false;
        var currentlyProcessingQueue = null;
        var didReadFromEntangledAsyncAction = false, currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0), suspenseHandlerStackCursor = createCursor(null), shellBoundary = null, SubtreeSuspenseContextMask = 1, ForceSuspenseFallback = 2, suspenseStackCursor = createCursor(0), NoFlags = 0, HasEffect = 1, Insertion = 2, Layout = 4, Passive = 8, didWarnUncachedGetSnapshot;
        var didWarnAboutMismatchedHooksForComponent = /* @__PURE__ */ new Set();
        var didWarnAboutUseWrappedInTryCatch = /* @__PURE__ */ new Set();
        var didWarnAboutAsyncClientComponent = /* @__PURE__ */ new Set();
        var didWarnAboutUseFormState = /* @__PURE__ */ new Set();
        var renderLanes = 0, currentlyRenderingFiber = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = false, didScheduleRenderPhaseUpdateDuringThisPass = false, shouldDoubleInvokeUserFnsInHooksDEV = false, localIdCounter = 0, thenableIndexCounter = 0, thenableState = null, globalClientIdCounter = 0, RE_RENDER_LIMIT = 25, currentHookNameInDev = null, hookTypesDev = null, hookTypesUpdateIndexDev = -1, ignorePreviousDependencies = false, ContextOnlyDispatcher = {
          readContext,
          use,
          useCallback: throwInvalidHookError,
          useContext: throwInvalidHookError,
          useEffect: throwInvalidHookError,
          useImperativeHandle: throwInvalidHookError,
          useLayoutEffect: throwInvalidHookError,
          useInsertionEffect: throwInvalidHookError,
          useMemo: throwInvalidHookError,
          useReducer: throwInvalidHookError,
          useRef: throwInvalidHookError,
          useState: throwInvalidHookError,
          useDebugValue: throwInvalidHookError,
          useDeferredValue: throwInvalidHookError,
          useTransition: throwInvalidHookError,
          useSyncExternalStore: throwInvalidHookError,
          useId: throwInvalidHookError,
          useHostTransitionStatus: throwInvalidHookError,
          useFormState: throwInvalidHookError,
          useActionState: throwInvalidHookError,
          useOptimistic: throwInvalidHookError,
          useMemoCache: throwInvalidHookError,
          useCacheRefresh: throwInvalidHookError
        };
        ContextOnlyDispatcher.useEffectEvent = throwInvalidHookError;
        var HooksDispatcherOnMountInDEV = null, HooksDispatcherOnMountWithHookTypesInDEV = null, HooksDispatcherOnUpdateInDEV = null, HooksDispatcherOnRerenderInDEV = null, InvalidNestedHooksDispatcherOnMountInDEV = null, InvalidNestedHooksDispatcherOnUpdateInDEV = null, InvalidNestedHooksDispatcherOnRerenderInDEV = null;
        HooksDispatcherOnMountInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          use,
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            mountHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create2, deps) {
            currentHookNameInDev = "useEffect";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountEffect(create2, deps);
          },
          useImperativeHandle: function(ref, create2, deps) {
            currentHookNameInDev = "useImperativeHandle";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountImperativeHandle(ref, create2, deps);
          },
          useInsertionEffect: function(create2, deps) {
            currentHookNameInDev = "useInsertionEffect";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            mountEffectImpl(4, Insertion, create2, deps);
          },
          useLayoutEffect: function(create2, deps) {
            currentHookNameInDev = "useLayoutEffect";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountLayoutEffect(create2, deps);
          },
          useMemo: function(create2, deps) {
            currentHookNameInDev = "useMemo";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountMemo(create2, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            mountHookTypesDev();
            return mountRef(initialValue);
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState";
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountState(initialState);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            mountHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            mountHookTypesDev();
            return mountDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            mountHookTypesDev();
            return mountTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            mountHookTypesDev();
            return mountSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            mountHookTypesDev();
            return mountId();
          },
          useFormState: function(action, initialState) {
            currentHookNameInDev = "useFormState";
            mountHookTypesDev();
            warnOnUseFormStateInDev();
            return mountActionState(action, initialState);
          },
          useActionState: function(action, initialState) {
            currentHookNameInDev = "useActionState";
            mountHookTypesDev();
            return mountActionState(action, initialState);
          },
          useOptimistic: function(passthrough) {
            currentHookNameInDev = "useOptimistic";
            mountHookTypesDev();
            return mountOptimistic(passthrough);
          },
          useHostTransitionStatus,
          useMemoCache,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            mountHookTypesDev();
            return mountRefresh();
          },
          useEffectEvent: function(callback) {
            currentHookNameInDev = "useEffectEvent";
            mountHookTypesDev();
            return mountEvent(callback);
          }
        };
        HooksDispatcherOnMountWithHookTypesInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          use,
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            updateHookTypesDev();
            return mountCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create2, deps) {
            currentHookNameInDev = "useEffect";
            updateHookTypesDev();
            return mountEffect(create2, deps);
          },
          useImperativeHandle: function(ref, create2, deps) {
            currentHookNameInDev = "useImperativeHandle";
            updateHookTypesDev();
            return mountImperativeHandle(ref, create2, deps);
          },
          useInsertionEffect: function(create2, deps) {
            currentHookNameInDev = "useInsertionEffect";
            updateHookTypesDev();
            mountEffectImpl(4, Insertion, create2, deps);
          },
          useLayoutEffect: function(create2, deps) {
            currentHookNameInDev = "useLayoutEffect";
            updateHookTypesDev();
            return mountLayoutEffect(create2, deps);
          },
          useMemo: function(create2, deps) {
            currentHookNameInDev = "useMemo";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountMemo(create2, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            updateHookTypesDev();
            return mountRef(initialValue);
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountState(initialState);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            updateHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            updateHookTypesDev();
            return mountDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            updateHookTypesDev();
            return mountTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            updateHookTypesDev();
            return mountSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            updateHookTypesDev();
            return mountId();
          },
          useActionState: function(action, initialState) {
            currentHookNameInDev = "useActionState";
            updateHookTypesDev();
            return mountActionState(action, initialState);
          },
          useFormState: function(action, initialState) {
            currentHookNameInDev = "useFormState";
            updateHookTypesDev();
            warnOnUseFormStateInDev();
            return mountActionState(action, initialState);
          },
          useOptimistic: function(passthrough) {
            currentHookNameInDev = "useOptimistic";
            updateHookTypesDev();
            return mountOptimistic(passthrough);
          },
          useHostTransitionStatus,
          useMemoCache,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return mountRefresh();
          },
          useEffectEvent: function(callback) {
            currentHookNameInDev = "useEffectEvent";
            updateHookTypesDev();
            return mountEvent(callback);
          }
        };
        HooksDispatcherOnUpdateInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          use,
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create2, deps) {
            currentHookNameInDev = "useEffect";
            updateHookTypesDev();
            updateEffectImpl(2048, Passive, create2, deps);
          },
          useImperativeHandle: function(ref, create2, deps) {
            currentHookNameInDev = "useImperativeHandle";
            updateHookTypesDev();
            return updateImperativeHandle(ref, create2, deps);
          },
          useInsertionEffect: function(create2, deps) {
            currentHookNameInDev = "useInsertionEffect";
            updateHookTypesDev();
            return updateEffectImpl(4, Insertion, create2, deps);
          },
          useLayoutEffect: function(create2, deps) {
            currentHookNameInDev = "useLayoutEffect";
            updateHookTypesDev();
            return updateEffectImpl(4, Layout, create2, deps);
          },
          useMemo: function(create2, deps) {
            currentHookNameInDev = "useMemo";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateMemo(create2, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function() {
            currentHookNameInDev = "useRef";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useState: function() {
            currentHookNameInDev = "useState";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(basicStateReducer);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            updateHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            updateHookTypesDev();
            return updateDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            updateHookTypesDev();
            return updateTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            updateHookTypesDev();
            return updateSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useFormState: function(action) {
            currentHookNameInDev = "useFormState";
            updateHookTypesDev();
            warnOnUseFormStateInDev();
            return updateActionState(action);
          },
          useActionState: function(action) {
            currentHookNameInDev = "useActionState";
            updateHookTypesDev();
            return updateActionState(action);
          },
          useOptimistic: function(passthrough, reducer) {
            currentHookNameInDev = "useOptimistic";
            updateHookTypesDev();
            return updateOptimistic(passthrough, reducer);
          },
          useHostTransitionStatus,
          useMemoCache,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useEffectEvent: function(callback) {
            currentHookNameInDev = "useEffectEvent";
            updateHookTypesDev();
            return updateEvent(callback);
          }
        };
        HooksDispatcherOnRerenderInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          use,
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create2, deps) {
            currentHookNameInDev = "useEffect";
            updateHookTypesDev();
            updateEffectImpl(2048, Passive, create2, deps);
          },
          useImperativeHandle: function(ref, create2, deps) {
            currentHookNameInDev = "useImperativeHandle";
            updateHookTypesDev();
            return updateImperativeHandle(ref, create2, deps);
          },
          useInsertionEffect: function(create2, deps) {
            currentHookNameInDev = "useInsertionEffect";
            updateHookTypesDev();
            return updateEffectImpl(4, Insertion, create2, deps);
          },
          useLayoutEffect: function(create2, deps) {
            currentHookNameInDev = "useLayoutEffect";
            updateHookTypesDev();
            return updateEffectImpl(4, Layout, create2, deps);
          },
          useMemo: function(create2, deps) {
            currentHookNameInDev = "useMemo";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
              return updateMemo(create2, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
              return rerenderReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function() {
            currentHookNameInDev = "useRef";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useState: function() {
            currentHookNameInDev = "useState";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
              return rerenderReducer(basicStateReducer);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            updateHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            updateHookTypesDev();
            return rerenderDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            updateHookTypesDev();
            return rerenderTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            updateHookTypesDev();
            return updateSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useFormState: function(action) {
            currentHookNameInDev = "useFormState";
            updateHookTypesDev();
            warnOnUseFormStateInDev();
            return rerenderActionState(action);
          },
          useActionState: function(action) {
            currentHookNameInDev = "useActionState";
            updateHookTypesDev();
            return rerenderActionState(action);
          },
          useOptimistic: function(passthrough, reducer) {
            currentHookNameInDev = "useOptimistic";
            updateHookTypesDev();
            return rerenderOptimistic(passthrough, reducer);
          },
          useHostTransitionStatus,
          useMemoCache,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useEffectEvent: function(callback) {
            currentHookNameInDev = "useEffectEvent";
            updateHookTypesDev();
            return updateEvent(callback);
          }
        };
        InvalidNestedHooksDispatcherOnMountInDEV = {
          readContext: function(context) {
            warnInvalidContextAccess();
            return readContext(context);
          },
          use: function(usable) {
            warnInvalidHookAccess();
            return use(usable);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create2, deps) {
            currentHookNameInDev = "useEffect";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountEffect(create2, deps);
          },
          useImperativeHandle: function(ref, create2, deps) {
            currentHookNameInDev = "useImperativeHandle";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountImperativeHandle(ref, create2, deps);
          },
          useInsertionEffect: function(create2, deps) {
            currentHookNameInDev = "useInsertionEffect";
            warnInvalidHookAccess();
            mountHookTypesDev();
            mountEffectImpl(4, Insertion, create2, deps);
          },
          useLayoutEffect: function(create2, deps) {
            currentHookNameInDev = "useLayoutEffect";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountLayoutEffect(create2, deps);
          },
          useMemo: function(create2, deps) {
            currentHookNameInDev = "useMemo";
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountMemo(create2, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountRef(initialValue);
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState";
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountState(initialState);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            warnInvalidHookAccess();
            mountHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountId();
          },
          useFormState: function(action, initialState) {
            currentHookNameInDev = "useFormState";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountActionState(action, initialState);
          },
          useActionState: function(action, initialState) {
            currentHookNameInDev = "useActionState";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountActionState(action, initialState);
          },
          useOptimistic: function(passthrough) {
            currentHookNameInDev = "useOptimistic";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountOptimistic(passthrough);
          },
          useMemoCache: function(size) {
            warnInvalidHookAccess();
            return useMemoCache(size);
          },
          useHostTransitionStatus,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            mountHookTypesDev();
            return mountRefresh();
          },
          useEffectEvent: function(callback) {
            currentHookNameInDev = "useEffectEvent";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountEvent(callback);
          }
        };
        InvalidNestedHooksDispatcherOnUpdateInDEV = {
          readContext: function(context) {
            warnInvalidContextAccess();
            return readContext(context);
          },
          use: function(usable) {
            warnInvalidHookAccess();
            return use(usable);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create2, deps) {
            currentHookNameInDev = "useEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            updateEffectImpl(2048, Passive, create2, deps);
          },
          useImperativeHandle: function(ref, create2, deps) {
            currentHookNameInDev = "useImperativeHandle";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateImperativeHandle(ref, create2, deps);
          },
          useInsertionEffect: function(create2, deps) {
            currentHookNameInDev = "useInsertionEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffectImpl(4, Insertion, create2, deps);
          },
          useLayoutEffect: function(create2, deps) {
            currentHookNameInDev = "useLayoutEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffectImpl(4, Layout, create2, deps);
          },
          useMemo: function(create2, deps) {
            currentHookNameInDev = "useMemo";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateMemo(create2, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function() {
            currentHookNameInDev = "useRef";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useState: function() {
            currentHookNameInDev = "useState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(basicStateReducer);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useFormState: function(action) {
            currentHookNameInDev = "useFormState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateActionState(action);
          },
          useActionState: function(action) {
            currentHookNameInDev = "useActionState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateActionState(action);
          },
          useOptimistic: function(passthrough, reducer) {
            currentHookNameInDev = "useOptimistic";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateOptimistic(passthrough, reducer);
          },
          useMemoCache: function(size) {
            warnInvalidHookAccess();
            return useMemoCache(size);
          },
          useHostTransitionStatus,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useEffectEvent: function(callback) {
            currentHookNameInDev = "useEffectEvent";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEvent(callback);
          }
        };
        InvalidNestedHooksDispatcherOnRerenderInDEV = {
          readContext: function(context) {
            warnInvalidContextAccess();
            return readContext(context);
          },
          use: function(usable) {
            warnInvalidHookAccess();
            return use(usable);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create2, deps) {
            currentHookNameInDev = "useEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            updateEffectImpl(2048, Passive, create2, deps);
          },
          useImperativeHandle: function(ref, create2, deps) {
            currentHookNameInDev = "useImperativeHandle";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateImperativeHandle(ref, create2, deps);
          },
          useInsertionEffect: function(create2, deps) {
            currentHookNameInDev = "useInsertionEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffectImpl(4, Insertion, create2, deps);
          },
          useLayoutEffect: function(create2, deps) {
            currentHookNameInDev = "useLayoutEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffectImpl(4, Layout, create2, deps);
          },
          useMemo: function(create2, deps) {
            currentHookNameInDev = "useMemo";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateMemo(create2, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return rerenderReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function() {
            currentHookNameInDev = "useRef";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useState: function() {
            currentHookNameInDev = "useState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return rerenderReducer(basicStateReducer);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useFormState: function(action) {
            currentHookNameInDev = "useFormState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderActionState(action);
          },
          useActionState: function(action) {
            currentHookNameInDev = "useActionState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderActionState(action);
          },
          useOptimistic: function(passthrough, reducer) {
            currentHookNameInDev = "useOptimistic";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderOptimistic(passthrough, reducer);
          },
          useMemoCache: function(size) {
            warnInvalidHookAccess();
            return useMemoCache(size);
          },
          useHostTransitionStatus,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useEffectEvent: function(callback) {
            currentHookNameInDev = "useEffectEvent";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEvent(callback);
          }
        };
        var fakeInternalInstance = {};
        var didWarnAboutStateAssignmentForComponent = /* @__PURE__ */ new Set();
        var didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
        var didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
        var didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
        var didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
        var didWarnAboutContextTypes$1 = /* @__PURE__ */ new Set();
        var didWarnAboutChildContextTypes = /* @__PURE__ */ new Set();
        var didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
        var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
        Object.freeze(fakeInternalInstance);
        var classComponentUpdater = {
          enqueueSetState: function(inst, payload, callback) {
            inst = inst._reactInternals;
            var lane = requestUpdateLane(inst), update = createUpdate(lane);
            update.payload = payload;
            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
            payload = enqueueUpdate(inst, update, lane);
            null !== payload && (startUpdateTimerByLane(lane, "this.setState()", inst), scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
          },
          enqueueReplaceState: function(inst, payload, callback) {
            inst = inst._reactInternals;
            var lane = requestUpdateLane(inst), update = createUpdate(lane);
            update.tag = ReplaceState;
            update.payload = payload;
            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
            payload = enqueueUpdate(inst, update, lane);
            null !== payload && (startUpdateTimerByLane(lane, "this.replaceState()", inst), scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
          },
          enqueueForceUpdate: function(inst, callback) {
            inst = inst._reactInternals;
            var lane = requestUpdateLane(inst), update = createUpdate(lane);
            update.tag = ForceUpdate;
            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
            callback = enqueueUpdate(inst, update, lane);
            null !== callback && (startUpdateTimerByLane(lane, "this.forceUpdate()", inst), scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
          }
        }, componentName = null, errorBoundaryName = null, SelectiveHydrationException = Error(
          "This is not a real error. It's an implementation detail of React's selective hydration feature. If this leaks into userspace, it's a bug in React. Please file an issue."
        ), didReceiveUpdate = false;
        var didWarnAboutBadClass = {};
        var didWarnAboutContextTypeOnFunctionComponent = {};
        var didWarnAboutContextTypes = {};
        var didWarnAboutGetDerivedStateOnFunctionComponent = {};
        var didWarnAboutReassigningProps = false;
        var didWarnAboutRevealOrder = {};
        var didWarnAboutTailOptions = {};
        var SUSPENDED_MARKER = {
          dehydrated: null,
          treeContext: null,
          retryLane: 0,
          hydrationErrors: null
        }, hasWarnedAboutUsingNoValuePropOnContextProvider = false, didWarnAboutUndefinedSnapshotBeforeUpdate = null;
        didWarnAboutUndefinedSnapshotBeforeUpdate = /* @__PURE__ */ new Set();
        var offscreenSubtreeIsHidden = false, offscreenSubtreeWasHidden = false, needsFormReset = false, PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set, nextEffect = null, inProgressLanes = null, inProgressRoot = null, hostParent = null, hostParentIsContainer = false, currentHoistableRoot = null, inHydratedSubtree = false, suspenseyCommitFlag = 8192, DefaultAsyncDispatcher = {
          getCacheForType: function(resourceType) {
            var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);
            void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));
            return cacheForType;
          },
          cacheSignal: function() {
            return readContext(CacheContext).controller.signal;
          },
          getOwner: function() {
            return current;
          }
        };
        if ("function" === typeof Symbol && Symbol.for) {
          var symbolFor = Symbol.for;
          symbolFor("selector.component");
          symbolFor("selector.has_pseudo_class");
          symbolFor("selector.role");
          symbolFor("selector.test_id");
          symbolFor("selector.text");
        }
        var commitHooks = [], PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map, NoContext = 0, RenderContext = 2, CommitContext = 4, RootInProgress = 0, RootFatalErrored = 1, RootErrored = 2, RootSuspended = 3, RootSuspendedWithDelay = 4, RootSuspendedAtTheShell = 6, RootCompleted = 5, executionContext = NoContext, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, NotSuspended = 0, SuspendedOnError = 1, SuspendedOnData = 2, SuspendedOnImmediate = 3, SuspendedOnInstance = 4, SuspendedOnInstanceAndReadyToContinue = 5, SuspendedOnDeprecatedThrowPromise = 6, SuspendedAndReadyToContinue = 7, SuspendedOnHydration = 8, SuspendedOnAction = 9, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = false, workInProgressRootIsPrerendering = false, workInProgressRootDidAttachPingListener = false, entangledRenderLanes = 0, workInProgressRootExitStatus = RootInProgress, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = false, globalMostRecentFallbackTime = 0, globalMostRecentTransitionTime = 0, FALLBACK_THROTTLE_MS = 300, workInProgressRootRenderTargetTime = Infinity, RENDER_TIMEOUT_MS = 500, workInProgressTransitions = null, workInProgressUpdateTask = null, legacyErrorBoundariesThatAlreadyFailed = null, IMMEDIATE_COMMIT = 0, ABORTED_VIEW_TRANSITION_COMMIT = 1, DELAYED_PASSIVE_COMMIT = 2, ANIMATION_STARTED_COMMIT = 3, NO_PENDING_EFFECTS = 0, PENDING_MUTATION_PHASE = 1, PENDING_LAYOUT_PHASE = 2, PENDING_AFTER_MUTATION_PHASE = 3, PENDING_SPAWNED_WORK = 4, PENDING_PASSIVE_PHASE = 5, pendingEffectsStatus = 0, pendingEffectsRoot = null, pendingFinishedWork = null, pendingEffectsLanes = 0, pendingEffectsRemainingLanes = 0, pendingEffectsRenderEndTime = -0, pendingPassiveTransitions = null, pendingRecoverableErrors = null, pendingSuspendedCommitReason = null, pendingDelayedCommitReason = IMMEDIATE_COMMIT, pendingSuspendedViewTransitionReason = null, NESTED_UPDATE_LIMIT = 50, nestedUpdateCount = 0, rootWithNestedUpdates = null, isFlushingPassiveEffects = false, didScheduleUpdateDuringPassiveEffects = false, NESTED_PASSIVE_UPDATE_LIMIT = 50, nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, isRunningInsertionEffect = false, didWarnStateUpdateForNotYetMountedComponent = null, didWarnAboutUpdateInRender = false;
        var didWarnAboutUpdateInRenderForAnotherComponent = /* @__PURE__ */ new Set();
        var fakeActCallbackNode$1 = {}, firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = false, didScheduleMicrotask_act = false, mightHavePendingSyncWork = false, isFlushingWork = false, currentEventTransitionLane = 0, fakeActCallbackNode = {};
        (function() {
          for (var i8 = 0; i8 < simpleEventPluginEvents.length; i8++) {
            var eventName = simpleEventPluginEvents[i8], domEventName = eventName.toLowerCase();
            eventName = eventName[0].toUpperCase() + eventName.slice(1);
            registerSimpleEvent(domEventName, "on" + eventName);
          }
          registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
          registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
          registerSimpleEvent(ANIMATION_START, "onAnimationStart");
          registerSimpleEvent("dblclick", "onDoubleClick");
          registerSimpleEvent("focusin", "onFocus");
          registerSimpleEvent("focusout", "onBlur");
          registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
          registerSimpleEvent(TRANSITION_START, "onTransitionStart");
          registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
          registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
        })();
        registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
        registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
        registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
        registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
        registerTwoPhaseEvent(
          "onChange",
          "change click focusin focusout input keydown keyup selectionchange".split(
            " "
          )
        );
        registerTwoPhaseEvent(
          "onSelect",
          "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
            " "
          )
        );
        registerTwoPhaseEvent("onBeforeInput", [
          "compositionend",
          "keypress",
          "textInput",
          "paste"
        ]);
        registerTwoPhaseEvent(
          "onCompositionEnd",
          "compositionend focusout keydown keypress keyup mousedown".split(" ")
        );
        registerTwoPhaseEvent(
          "onCompositionStart",
          "compositionstart focusout keydown keypress keyup mousedown".split(" ")
        );
        registerTwoPhaseEvent(
          "onCompositionUpdate",
          "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
        );
        var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
          " "
        ), nonDelegatedEvents = new Set(
          "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes)
        ), listeningMarker = "_reactListening" + Math.random().toString(36).slice(2), didWarnControlledToUncontrolled = false, didWarnUncontrolledToControlled = false, didWarnFormActionType = false, didWarnFormActionName = false, didWarnFormActionTarget = false, didWarnFormActionMethod = false, didWarnPopoverTargetObject = false;
        var didWarnForNewBooleanPropsWithEmptyValue = {};
        var NORMALIZE_NEWLINES_REGEX = /\r\n?/g, NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g, xlinkNamespace = "http://www.w3.org/1999/xlink", xmlNamespace = "http://www.w3.org/XML/1998/namespace", EXPECTED_FORM_ACTION_URL = "javascript:throw new Error('React form unexpectedly submitted.')", SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning", ACTIVITY_START_DATA = "&", ACTIVITY_END_DATA = "/&", SUSPENSE_START_DATA = "$", SUSPENSE_END_DATA = "/$", SUSPENSE_PENDING_START_DATA = "$?", SUSPENSE_QUEUED_START_DATA = "$~", SUSPENSE_FALLBACK_START_DATA = "$!", PREAMBLE_CONTRIBUTION_HTML = "html", PREAMBLE_CONTRIBUTION_BODY = "body", PREAMBLE_CONTRIBUTION_HEAD = "head", FORM_STATE_IS_MATCHING = "F!", FORM_STATE_IS_NOT_MATCHING = "F", DOCUMENT_READY_STATE_LOADING = "loading", STYLE = "style", HostContextNamespaceNone = 0, HostContextNamespaceSvg = 1, HostContextNamespaceMath = 2, eventsEnabled = null, selectionInformation = null, warnedUnknownTags = { dialog: true, webview: true }, currentPopstateTransitionEvent = null, schedulerEvent = void 0, scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0, cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0, noTimeout = -1, localPromise = "function" === typeof Promise ? Promise : void 0, scheduleMicrotask = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof localPromise ? function(callback) {
          return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
        } : scheduleTimeout, previousHydratableOnEnteringScopedSingleton = null, NotLoaded = 0, Loaded = 1, Errored = 2, Settled = 3, Inserted = 4, preloadPropsMap = /* @__PURE__ */ new Map(), preconnectsSet = /* @__PURE__ */ new Set(), previousDispatcher = ReactDOMSharedInternals.d;
        ReactDOMSharedInternals.d = {
          f: function() {
            var previousWasRendering = previousDispatcher.f(), wasRendering = flushSyncWork$1();
            return previousWasRendering || wasRendering;
          },
          r: function(form) {
            var formInst = getInstanceFromNode(form);
            null !== formInst && 5 === formInst.tag && "form" === formInst.type ? requestFormReset$1(formInst) : previousDispatcher.r(form);
          },
          D: function(href) {
            previousDispatcher.D(href);
            preconnectAs("dns-prefetch", href, null);
          },
          C: function(href, crossOrigin) {
            previousDispatcher.C(href, crossOrigin);
            preconnectAs("preconnect", href, crossOrigin);
          },
          L: function(href, as, options) {
            previousDispatcher.L(href, as, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && href && as) {
              var preloadSelector = 'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"]';
              "image" === as ? options && options.imageSrcSet ? (preloadSelector += '[imagesrcset="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                options.imageSrcSet
              ) + '"]', "string" === typeof options.imageSizes && (preloadSelector += '[imagesizes="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                options.imageSizes
              ) + '"]')) : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]' : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]';
              var key = preloadSelector;
              switch (as) {
                case "style":
                  key = getStyleKey(href);
                  break;
                case "script":
                  key = getScriptKey(href);
              }
              preloadPropsMap.has(key) || (href = assign(
                {
                  rel: "preload",
                  href: "image" === as && options && options.imageSrcSet ? void 0 : href,
                  as
                },
                options
              ), preloadPropsMap.set(key, href), null !== ownerDocument.querySelector(preloadSelector) || "style" === as && ownerDocument.querySelector(
                getStylesheetSelectorFromKey(key)
              ) || "script" === as && ownerDocument.querySelector(getScriptSelectorFromKey(key)) || (as = ownerDocument.createElement("link"), setInitialProperties(as, "link", href), markNodeAsHoistable(as), ownerDocument.head.appendChild(as)));
            }
          },
          m: function(href, options) {
            previousDispatcher.m(href, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && href) {
              var as = options && "string" === typeof options.as ? options.as : "script", preloadSelector = 'link[rel="modulepreload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"][href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]', key = preloadSelector;
              switch (as) {
                case "audioworklet":
                case "paintworklet":
                case "serviceworker":
                case "sharedworker":
                case "worker":
                case "script":
                  key = getScriptKey(href);
              }
              if (!preloadPropsMap.has(key) && (href = assign({ rel: "modulepreload", href }, options), preloadPropsMap.set(key, href), null === ownerDocument.querySelector(preloadSelector))) {
                switch (as) {
                  case "audioworklet":
                  case "paintworklet":
                  case "serviceworker":
                  case "sharedworker":
                  case "worker":
                  case "script":
                    if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
                      return;
                }
                as = ownerDocument.createElement("link");
                setInitialProperties(as, "link", href);
                markNodeAsHoistable(as);
                ownerDocument.head.appendChild(as);
              }
            }
          },
          X: function(src, options) {
            previousDispatcher.X(src, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && src) {
              var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
              resource || (resource = ownerDocument.querySelector(
                getScriptSelectorFromKey(key)
              ), resource || (src = assign({ src, async: true }, options), (options = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
                type: "script",
                instance: resource,
                count: 1,
                state: null
              }, scripts.set(key, resource));
            }
          },
          S: function(href, precedence, options) {
            previousDispatcher.S(href, precedence, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && href) {
              var styles = getResourcesFromRoot(ownerDocument).hoistableStyles, key = getStyleKey(href);
              precedence = precedence || "default";
              var resource = styles.get(key);
              if (!resource) {
                var state = { loading: NotLoaded, preload: null };
                if (resource = ownerDocument.querySelector(
                  getStylesheetSelectorFromKey(key)
                ))
                  state.loading = Loaded | Inserted;
                else {
                  href = assign(
                    {
                      rel: "stylesheet",
                      href,
                      "data-precedence": precedence
                    },
                    options
                  );
                  (options = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(href, options);
                  var link = resource = ownerDocument.createElement("link");
                  markNodeAsHoistable(link);
                  setInitialProperties(link, "link", href);
                  link._p = new Promise(function(resolve, reject) {
                    link.onload = resolve;
                    link.onerror = reject;
                  });
                  link.addEventListener("load", function() {
                    state.loading |= Loaded;
                  });
                  link.addEventListener("error", function() {
                    state.loading |= Errored;
                  });
                  state.loading |= Inserted;
                  insertStylesheet(resource, precedence, ownerDocument);
                }
                resource = {
                  type: "stylesheet",
                  instance: resource,
                  count: 1,
                  state
                };
                styles.set(key, resource);
              }
            }
          },
          M: function(src, options) {
            previousDispatcher.M(src, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && src) {
              var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
              resource || (resource = ownerDocument.querySelector(
                getScriptSelectorFromKey(key)
              ), resource || (src = assign({ src, async: true, type: "module" }, options), (options = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
                type: "script",
                instance: resource,
                count: 1,
                state: null
              }, scripts.set(key, resource));
            }
          }
        };
        var globalDocument = "undefined" === typeof document ? null : document, tagCaches = null, SUSPENSEY_STYLESHEET_TIMEOUT = 6e4, SUSPENSEY_IMAGE_TIMEOUT = 800, SUSPENSEY_IMAGE_TIME_ESTIMATE = 500, estimatedBytesWithinLimit = 0, LAST_PRECEDENCE = null, precedencesByRoot = null, NotPendingTransition = NotPending, HostTransitionContext = {
          $$typeof: REACT_CONTEXT_TYPE,
          Provider: null,
          Consumer: null,
          _currentValue: NotPendingTransition,
          _currentValue2: NotPendingTransition,
          _threadCount: 0
        }, badgeFormat = "%c%s%c", badgeStyle = "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px", resetStyle = "", pad = " ", bind = Function.prototype.bind;
        var didWarnAboutNestedUpdates = false;
        var overrideHookState = null, overrideHookStateDeletePath = null, overrideHookStateRenamePath = null, overrideProps = null, overridePropsDeletePath = null, overridePropsRenamePath = null, scheduleUpdate = null, scheduleRetry = null, setErrorHandler = null, setSuspenseHandler = null;
        overrideHookState = function(fiber, id, path, value) {
          id = findHook(fiber, id);
          null !== id && (path = copyWithSetImpl(id.memoizedState, path, 0, value), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), null !== path && scheduleUpdateOnFiber(path, fiber, 2));
        };
        overrideHookStateDeletePath = function(fiber, id, path) {
          id = findHook(fiber, id);
          null !== id && (path = copyWithDeleteImpl(id.memoizedState, path, 0), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), null !== path && scheduleUpdateOnFiber(path, fiber, 2));
        };
        overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {
          id = findHook(fiber, id);
          null !== id && (oldPath = copyWithRename(id.memoizedState, oldPath, newPath), id.memoizedState = oldPath, id.baseState = oldPath, fiber.memoizedProps = assign({}, fiber.memoizedProps), oldPath = enqueueConcurrentRenderForLane(fiber, 2), null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2));
        };
        overrideProps = function(fiber, path, value) {
          fiber.pendingProps = copyWithSetImpl(fiber.memoizedProps, path, 0, value);
          fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
          path = enqueueConcurrentRenderForLane(fiber, 2);
          null !== path && scheduleUpdateOnFiber(path, fiber, 2);
        };
        overridePropsDeletePath = function(fiber, path) {
          fiber.pendingProps = copyWithDeleteImpl(fiber.memoizedProps, path, 0);
          fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
          path = enqueueConcurrentRenderForLane(fiber, 2);
          null !== path && scheduleUpdateOnFiber(path, fiber, 2);
        };
        overridePropsRenamePath = function(fiber, oldPath, newPath) {
          fiber.pendingProps = copyWithRename(
            fiber.memoizedProps,
            oldPath,
            newPath
          );
          fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
          oldPath = enqueueConcurrentRenderForLane(fiber, 2);
          null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2);
        };
        scheduleUpdate = function(fiber) {
          var root2 = enqueueConcurrentRenderForLane(fiber, 2);
          null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2);
        };
        scheduleRetry = function(fiber) {
          var lane = claimNextRetryLane(), root2 = enqueueConcurrentRenderForLane(fiber, lane);
          null !== root2 && scheduleUpdateOnFiber(root2, fiber, lane);
        };
        setErrorHandler = function(newShouldErrorImpl) {
          shouldErrorImpl = newShouldErrorImpl;
        };
        setSuspenseHandler = function(newShouldSuspendImpl) {
          shouldSuspendImpl = newShouldSuspendImpl;
        };
        var _enabled = true, return_targetInst = null, hasScheduledReplayAttempt = false, queuedFocus = null, queuedDrag = null, queuedMouse = null, queuedPointers = /* @__PURE__ */ new Map(), queuedPointerCaptures = /* @__PURE__ */ new Map(), queuedExplicitHydrationTargets = [], discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
          " "
        ), lastScheduledReplayQueue = null;
        ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
          var root2 = this._internalRoot;
          if (null === root2) throw Error("Cannot update an unmounted root.");
          var args = arguments;
          "function" === typeof args[1] ? console.error(
            "does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."
          ) : isValidContainer(args[1]) ? console.error(
            "You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root."
          ) : "undefined" !== typeof args[1] && console.error(
            "You passed a second argument to root.render(...) but it only accepts one argument."
          );
          args = children;
          var current2 = root2.current, lane = requestUpdateLane(current2);
          updateContainerImpl(current2, lane, args, root2, null, null);
        };
        ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
          var args = arguments;
          "function" === typeof args[0] && console.error(
            "does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."
          );
          args = this._internalRoot;
          if (null !== args) {
            this._internalRoot = null;
            var container = args.containerInfo;
            (executionContext & (RenderContext | CommitContext)) !== NoContext && console.error(
              "Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."
            );
            updateContainerImpl(args.current, 2, null, args, null, null);
            flushSyncWork$1();
            container[internalContainerInstanceKey] = null;
          }
        };
        ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function(target) {
          if (target) {
            var updatePriority = resolveUpdatePriority();
            target = { blockedOn: null, target, priority: updatePriority };
            for (var i8 = 0; i8 < queuedExplicitHydrationTargets.length && 0 !== updatePriority && updatePriority < queuedExplicitHydrationTargets[i8].priority; i8++) ;
            queuedExplicitHydrationTargets.splice(i8, 0, target);
            0 === i8 && attemptExplicitHydrationTarget(target);
          }
        };
        (function() {
          var isomorphicReactPackageVersion = React2.version;
          if ("19.2.0" !== isomorphicReactPackageVersion)
            throw Error(
              'Incompatible React versions: The "react" and "react-dom" packages must have the exact same version. Instead got:\n  - react:      ' + (isomorphicReactPackageVersion + "\n  - react-dom:  19.2.0\nLearn more: https://react.dev/warnings/version-mismatch")
            );
        })();
        "function" === typeof Map && null != Map.prototype && "function" === typeof Map.prototype.forEach && "function" === typeof Set && null != Set.prototype && "function" === typeof Set.prototype.clear && "function" === typeof Set.prototype.forEach || console.error(
          "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://react.dev/link/react-polyfills"
        );
        ReactDOMSharedInternals.findDOMNode = function(componentOrElement) {
          var fiber = componentOrElement._reactInternals;
          if (void 0 === fiber) {
            if ("function" === typeof componentOrElement.render)
              throw Error("Unable to find node on an unmounted component.");
            componentOrElement = Object.keys(componentOrElement).join(",");
            throw Error(
              "Argument appears to not be a ReactComponent. Keys: " + componentOrElement
            );
          }
          componentOrElement = findCurrentFiberUsingSlowPath(fiber);
          componentOrElement = null !== componentOrElement ? findCurrentHostFiberImpl(componentOrElement) : null;
          componentOrElement = null === componentOrElement ? null : componentOrElement.stateNode;
          return componentOrElement;
        };
        if (!(function() {
          var internals = {
            bundleType: 1,
            version: "19.2.0",
            rendererPackageName: "react-dom",
            currentDispatcherRef: ReactSharedInternals,
            reconcilerVersion: "19.2.0"
          };
          internals.overrideHookState = overrideHookState;
          internals.overrideHookStateDeletePath = overrideHookStateDeletePath;
          internals.overrideHookStateRenamePath = overrideHookStateRenamePath;
          internals.overrideProps = overrideProps;
          internals.overridePropsDeletePath = overridePropsDeletePath;
          internals.overridePropsRenamePath = overridePropsRenamePath;
          internals.scheduleUpdate = scheduleUpdate;
          internals.scheduleRetry = scheduleRetry;
          internals.setErrorHandler = setErrorHandler;
          internals.setSuspenseHandler = setSuspenseHandler;
          internals.scheduleRefresh = scheduleRefresh;
          internals.scheduleRoot = scheduleRoot;
          internals.setRefreshHandler = setRefreshHandler;
          internals.getCurrentFiber = getCurrentFiberForDevTools;
          return injectInternals(internals);
        })() && canUseDOM && window.top === window.self && (-1 < navigator.userAgent.indexOf("Chrome") && -1 === navigator.userAgent.indexOf("Edge") || -1 < navigator.userAgent.indexOf("Firefox"))) {
          var protocol = window.location.protocol;
          /^(https?|file):$/.test(protocol) && console.info(
            "%cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools" + ("file:" === protocol ? "\nYou might need to use a local HTTP server (instead of file://): https://react.dev/link/react-devtools-faq" : ""),
            "font-weight:bold"
          );
        }
        exports.createRoot = function(container, options) {
          if (!isValidContainer(container))
            throw Error("Target container is not a DOM element.");
          warnIfReactDOMContainerInDEV(container);
          var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError;
          null !== options && void 0 !== options && (options.hydrate ? console.warn(
            "hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead."
          ) : "object" === typeof options && null !== options && options.$$typeof === REACT_ELEMENT_TYPE && console.error(
            "You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:\n\n  let root = createRoot(domContainer);\n  root.render(<App />);"
          ), true === options.unstable_strictMode && (isStrictMode = true), void 0 !== options.identifierPrefix && (identifierPrefix = options.identifierPrefix), void 0 !== options.onUncaughtError && (onUncaughtError = options.onUncaughtError), void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError), void 0 !== options.onRecoverableError && (onRecoverableError = options.onRecoverableError));
          options = createFiberRoot(
            container,
            1,
            false,
            null,
            null,
            isStrictMode,
            identifierPrefix,
            null,
            onUncaughtError,
            onCaughtError,
            onRecoverableError,
            defaultOnDefaultTransitionIndicator
          );
          container[internalContainerInstanceKey] = options.current;
          listenToAllSupportedEvents(container);
          return new ReactDOMRoot(options);
        };
        exports.hydrateRoot = function(container, initialChildren, options) {
          if (!isValidContainer(container))
            throw Error("Target container is not a DOM element.");
          warnIfReactDOMContainerInDEV(container);
          void 0 === initialChildren && console.error(
            "Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)"
          );
          var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, formState = null;
          null !== options && void 0 !== options && (true === options.unstable_strictMode && (isStrictMode = true), void 0 !== options.identifierPrefix && (identifierPrefix = options.identifierPrefix), void 0 !== options.onUncaughtError && (onUncaughtError = options.onUncaughtError), void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError), void 0 !== options.onRecoverableError && (onRecoverableError = options.onRecoverableError), void 0 !== options.formState && (formState = options.formState));
          initialChildren = createFiberRoot(
            container,
            1,
            true,
            initialChildren,
            null != options ? options : null,
            isStrictMode,
            identifierPrefix,
            formState,
            onUncaughtError,
            onCaughtError,
            onRecoverableError,
            defaultOnDefaultTransitionIndicator
          );
          initialChildren.context = getContextForSubtree(null);
          options = initialChildren.current;
          isStrictMode = requestUpdateLane(options);
          isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
          identifierPrefix = createUpdate(isStrictMode);
          identifierPrefix.callback = null;
          enqueueUpdate(options, identifierPrefix, isStrictMode);
          startUpdateTimerByLane(isStrictMode, "hydrateRoot()", null);
          options = isStrictMode;
          initialChildren.current.lanes = options;
          markRootUpdated$1(initialChildren, options);
          ensureRootIsScheduled(initialChildren);
          container[internalContainerInstanceKey] = initialChildren.current;
          listenToAllSupportedEvents(container);
          return new ReactDOMHydrationRoot(initialChildren);
        };
        exports.version = "19.2.0";
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
      })();
    }
  });

  // node_modules/.pnpm/react-dom@19.2.0_react@19.2.0/node_modules/react-dom/client.js
  var require_client = __commonJS({
    "node_modules/.pnpm/react-dom@19.2.0_react@19.2.0/node_modules/react-dom/client.js"(exports, module) {
      "use strict";
      if (false) {
        checkDCE();
        module.exports = null;
      } else {
        module.exports = require_react_dom_client_development();
      }
    }
  });

  // node_modules/.pnpm/react@19.2.0/node_modules/react/cjs/react-jsx-runtime.development.js
  var require_react_jsx_runtime_development = __commonJS({
    "node_modules/.pnpm/react@19.2.0/node_modules/react/cjs/react-jsx-runtime.development.js"(exports) {
      "use strict";
      (function() {
        function getComponentNameFromType(type) {
          if (null == type) return null;
          if ("function" === typeof type)
            return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
          if ("string" === typeof type) return type;
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
              return "Activity";
          }
          if ("object" === typeof type)
            switch ("number" === typeof type.tag && console.error(
              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
            ), type.$$typeof) {
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_CONTEXT_TYPE:
                return type.displayName || "Context";
              case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
              case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
              case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                  return getComponentNameFromType(type(innerType));
                } catch (x6) {
                }
            }
          return null;
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkKeyStringCoercion(value) {
          try {
            testStringCoercion(value);
            var JSCompiler_inline_result = false;
          } catch (e2) {
            JSCompiler_inline_result = true;
          }
          if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(
              JSCompiler_inline_result,
              "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
              JSCompiler_inline_result$jscomp$0
            );
            return testStringCoercion(value);
          }
        }
        function getTaskName(type) {
          if (type === REACT_FRAGMENT_TYPE) return "<>";
          if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE)
            return "<...>";
          try {
            var name = getComponentNameFromType(type);
            return name ? "<" + name + ">" : "<...>";
          } catch (x6) {
            return "<...>";
          }
        }
        function getOwner() {
          var dispatcher = ReactSharedInternals.A;
          return null === dispatcher ? null : dispatcher.getOwner();
        }
        function UnknownOwner() {
          return Error("react-stack-top-frame");
        }
        function hasValidKey(config) {
          if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) return false;
          }
          return void 0 !== config.key;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error(
              "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
              displayName
            ));
          }
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function elementRefGetterWithDeprecationWarning() {
          var componentName = getComponentNameFromType(this.type);
          didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error(
            "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
          ));
          componentName = this.props.ref;
          return void 0 !== componentName ? componentName : null;
        }
        function ReactElement(type, key, props, owner, debugStack, debugTask) {
          var refProp = props.ref;
          type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type,
            key,
            props,
            _owner: owner
          };
          null !== (void 0 !== refProp ? refProp : null) ? Object.defineProperty(type, "ref", {
            enumerable: false,
            get: elementRefGetterWithDeprecationWarning
          }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
          type._store = {};
          Object.defineProperty(type._store, "validated", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: 0
          });
          Object.defineProperty(type, "_debugInfo", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: null
          });
          Object.defineProperty(type, "_debugStack", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: debugStack
          });
          Object.defineProperty(type, "_debugTask", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: debugTask
          });
          Object.freeze && (Object.freeze(type.props), Object.freeze(type));
          return type;
        }
        function jsxDEVImpl(type, config, maybeKey, isStaticChildren, debugStack, debugTask) {
          var children = config.children;
          if (void 0 !== children)
            if (isStaticChildren)
              if (isArrayImpl(children)) {
                for (isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)
                  validateChildKeys(children[isStaticChildren]);
                Object.freeze && Object.freeze(children);
              } else
                console.error(
                  "React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead."
                );
            else validateChildKeys(children);
          if (hasOwnProperty.call(config, "key")) {
            children = getComponentNameFromType(type);
            var keys = Object.keys(config).filter(function(k4) {
              return "key" !== k4;
            });
            isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
            didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error(
              'A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />',
              isStaticChildren,
              children,
              keys,
              children
            ), didWarnAboutKeySpread[children + isStaticChildren] = true);
          }
          children = null;
          void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
          hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
          if ("key" in config) {
            maybeKey = {};
            for (var propName in config)
              "key" !== propName && (maybeKey[propName] = config[propName]);
          } else maybeKey = config;
          children && defineKeyPropWarningGetter(
            maybeKey,
            "function" === typeof type ? type.displayName || type.name || "Unknown" : type
          );
          return ReactElement(
            type,
            children,
            maybeKey,
            getOwner(),
            debugStack,
            debugTask
          );
        }
        function validateChildKeys(node) {
          isValidElement(node) ? node._store && (node._store.validated = 1) : "object" === typeof node && null !== node && node.$$typeof === REACT_LAZY_TYPE && ("fulfilled" === node._payload.status ? isValidElement(node._payload.value) && node._payload.value._store && (node._payload.value._store.validated = 1) : node._store && (node._store.validated = 1));
        }
        function isValidElement(object) {
          return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        var React2 = require_react(), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = React2.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray, createTask = console.createTask ? console.createTask : function() {
          return null;
        };
        React2 = {
          react_stack_bottom_frame: function(callStackForError) {
            return callStackForError();
          }
        };
        var specialPropKeyWarningShown;
        var didWarnAboutElementRef = {};
        var unknownOwnerDebugStack = React2.react_stack_bottom_frame.bind(
          React2,
          UnknownOwner
        )();
        var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
        var didWarnAboutKeySpread = {};
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.jsx = function(type, config, maybeKey) {
          var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
          return jsxDEVImpl(
            type,
            config,
            maybeKey,
            false,
            trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
            trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask
          );
        };
        exports.jsxs = function(type, config, maybeKey) {
          var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
          return jsxDEVImpl(
            type,
            config,
            maybeKey,
            true,
            trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
            trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask
          );
        };
      })();
    }
  });

  // node_modules/.pnpm/react@19.2.0/node_modules/react/jsx-runtime.js
  var require_jsx_runtime = __commonJS({
    "node_modules/.pnpm/react@19.2.0/node_modules/react/jsx-runtime.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_react_jsx_runtime_development();
      }
    }
  });

  // src/index.ts
  var import_reflect_metadata = __toESM(require_Reflect());

  // node_modules/.pnpm/zois-core@1.1.6/node_modules/zois-core/dist/styles.css
  var styles_default = '*{margin:0;padding:0;box-sizing:border-box}.zcButton{cursor:pointer;background:var(--tmd-element, white);color:var(--tmd-text, black);border:2px solid var(--tmd-accent, black);border-radius:4px}.zcButton:hover{background:var(--tmd-element-hover, #ebf7fe);border-color:var(--tmd-accent-hover, #7dd3fc);color:var(--tmd-accent-hover, #015a8c)}.zcButton .tooltip{position:absolute;color:#000;text-align:center;padding:4px;border-radius:4px;background:#ff8;border:2px solid #e7e787;width:max-content;min-height:100%;visibility:hidden;z-index:10}.zcButton .tooltip[position=left]{right:calc(100% + 1vw)}.zcButton .tooltip[position=right]{left:calc(100% + 1vw)}.zcButton:hover .tooltip{visibility:visible}.zcButton[data-zc-style=green]{background:#7cff7c;border-color:#52cc52;color:#000}.zcButton[data-zc-style=green]:hover{background:#5ec55e;color:#000}.zcButton[data-zc-style=inverted]{background:var(--tmd-accent, #303030);border:none;color:var(--tmd-text, white)}.zcButton[data-zc-style=inverted]:hover{background:var(--tmd-accent-hover, #474747)}.zcInput{background:var(--tmd-element, white);color:var(--tmd-text, black);padding:2vw;border:2px solid var(--tmd-accent, black);border-radius:4px}.zcInput::placeholder{color:var(--tmd-text, black)}.zcBackNextButton{display:flex;column-gap:2vw;justify-content:center;align-items:center;background:var(--tmd-element, white);color:var(--tmd-text, black);border:2px solid var(--tmd-accent, black);border-radius:4px}.zcBackNextButton-btnDisabled{background:#ffa590;pointer-events:none}.zcTabs{display:flex}.zcTabs button{cursor:pointer;width:100%;color:var(--tmd-text, black);background:none;border:none;border-bottom:2px solid var(--tmd-element, rgb(214, 214, 214));padding:.25em}.zcTabs button[data-opened=true]{font-weight:700;border-bottom:2px solid var(--tmd-accent, rgb(81, 81, 231))!important}.zcTabs button:hover{background:var(--tmd-element, rgb(235, 235, 235));border-bottom:2px solid var(--tmd-element-hover, rgb(149, 149, 149))}.zcCard{border:2px solid var(--tmd-accent, rgb(195, 195, 195));border-radius:.4em;background:var(--tmd-element, white);color:var(--tmd-text, black);padding:.4em 2.5em .4em .4em}.zcCard:hover{border:2px solid var(--tmd-accent-hover, rgb(170, 170, 170))}.zcCard_name{font-size:.5em;color:var(--tmd-text, rgb(100, 100, 100))}.zcCard_value{color:var(--tmd-text, black);margin-top:.4em;font-weight:700}.zcSelect{cursor:pointer;background:var(--tmd-element, white);color:var(--tmd-text, black);border:2px solid var(--tmd-accent, rgb(195, 195, 195));border-radius:.4em;padding:.45em;z-index:10}.zcSelect[opened=true]{border-color:var(--tmd-accent-hover, rgb(0, 96, 223))}.zcSelect[opened=false]:hover{border-color:var(--tmd-accent-hover, rgb(170, 170, 170))}.zcSelect>svg{position:absolute;right:.45em;top:50%;transform:translateY(-50%);width:1.5em;height:1.5em;color:var(--tmd-accent, rgb(0, 96, 223))}.zcSelect>div[data-zc-position=bottom]{position:absolute;top:calc(100% + .45em);left:0;width:100%;background:var(--tmd-element, #f6f6f6);border:2px solid var(--tmd-element-hover, rgb(235 235 235));border-radius:.4em}.zcSelect>div[data-zc-position=top]{position:absolute;bottom:calc(100% + .45em);left:0;width:100%;background:var(--tmd-element, #f6f6f6ed);border:2px solid var(--tmd-element-hover, rgb(235 235 235));border-radius:.4em}.zcSelect>div>div{color:var(--tmd-text, black);width:100%;padding:.45em;border-radius:.25em}.zcSelect>div>div>svg{width:1.25em;height:1.25em;color:var(--tmd-accent, rgb(0, 96, 223))}.zcSelect>div>div:hover{background:var(--tmd-element-hover, #ededed)}.zcToastsContainer{display:flex;flex-direction:column;gap:.25vw;cursor:pointer;position:fixed;z-index:10}@keyframes zcToast-progress{0%{width:0}to{width:100%}}@keyframes zcSlideInFromLeft{0%{transform:translate(-100%);opacity:0}to{transform:translate(0);opacity:1}}@keyframes zcSlideOutToLeft{0%{transform:translate(0);opacity:1}to{transform:translate(-100%);opacity:0}}.zcToast{max-width:25vw;animation:zcSlideInFromLeft .3s ease-out forwards}.zcToast.exiting{animation:zcSlideOutToLeft .3s ease-out forwards}.zcToast p{color:#fff}dialog[data-zc-dialog-type=choice_multiple] .zcDialogBtn:before{content:"";position:absolute;left:1vw;top:50%;transform:translateY(-50%);border:2px solid white;width:.5em;aspect-ratio:1/1;border-radius:50%}dialog[data-zc-dialog-type=choice_multiple] .zcDialogBtn[data-zc-picked=true]:before{background:#fff}.zcDialogBtn{cursor:pointer;background:#ffffff17;border:none;font-size:clamp(6px,2vw,24px);color:#fff;padding:.2em;border-radius:.5em}.zcDialogBtn:hover{background:#ffffff24}@keyframes zcSpin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}@keyframes zcCursorBlink{0%{border-right-color:transparent}to{border-right-color:#2a2a2a}}.zcCursor{border-right:2px solid var(--tmd-text, rgb(42, 42, 42));width:fit-content}.zcDisabled{pointer-events:none;opacity:.6}\n';

  // node_modules/.pnpm/zois-core@1.1.6/node_modules/zois-core/dist/modsApi.js
  var import_bondage_club_mod_sdk = __toESM(require_bcmodsdk());

  // node_modules/.pnpm/lucide@0.541.0/node_modules/lucide/dist/esm/defaultAttributes.js
  var defaultAttributes = {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    "stroke-width": 2,
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  };

  // node_modules/.pnpm/lucide@0.541.0/node_modules/lucide/dist/esm/createElement.js
  var createSVGElement = ([tag, attrs, children]) => {
    const element = document.createElementNS("http://www.w3.org/2000/svg", tag);
    Object.keys(attrs).forEach((name) => {
      element.setAttribute(name, String(attrs[name]));
    });
    if (children?.length) {
      children.forEach((child) => {
        const childElement = createSVGElement(child);
        element.appendChild(childElement);
      });
    }
    return element;
  };
  var createElement = (iconNode, customAttrs = {}) => {
    const tag = "svg";
    const attrs = {
      ...defaultAttributes,
      ...customAttrs
    };
    return createSVGElement([tag, attrs, iconNode]);
  };

  // node_modules/.pnpm/lucide@0.541.0/node_modules/lucide/dist/esm/icons/arrow-down.js
  var ArrowDown = [
    ["path", { d: "M12 5v14" }],
    ["path", { d: "m19 12-7 7-7-7" }]
  ];

  // node_modules/.pnpm/lucide@0.541.0/node_modules/lucide/dist/esm/icons/arrow-up.js
  var ArrowUp = [
    ["path", { d: "m5 12 7-7 7 7" }],
    ["path", { d: "M12 19V5" }]
  ];

  // node_modules/.pnpm/lucide@0.541.0/node_modules/lucide/dist/esm/icons/ban.js
  var Ban = [
    ["path", { d: "M4.929 4.929 19.07 19.071" }],
    ["circle", { cx: "12", cy: "12", r: "10" }]
  ];

  // node_modules/.pnpm/lucide@0.541.0/node_modules/lucide/dist/esm/icons/book-heart.js
  var BookHeart = [
    [
      "path",
      { d: "M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H19a1 1 0 0 1 1 1v18a1 1 0 0 1-1 1H6.5a1 1 0 0 1 0-5H20" }
    ],
    [
      "path",
      {
        d: "M8.62 9.8A2.25 2.25 0 1 1 12 6.836a2.25 2.25 0 1 1 3.38 2.966l-2.626 2.856a.998.998 0 0 1-1.507 0z"
      }
    ]
  ];

  // node_modules/.pnpm/lucide@0.541.0/node_modules/lucide/dist/esm/icons/bug.js
  var Bug = [
    ["path", { d: "m8 2 1.88 1.88" }],
    ["path", { d: "M14.12 3.88 16 2" }],
    ["path", { d: "M9 7.13v-1a3.003 3.003 0 1 1 6 0v1" }],
    ["path", { d: "M12 20c-3.3 0-6-2.7-6-6v-3a4 4 0 0 1 4-4h4a4 4 0 0 1 4 4v3c0 3.3-2.7 6-6 6" }],
    ["path", { d: "M12 20v-9" }],
    ["path", { d: "M6.53 9C4.6 8.8 3 7.1 3 5" }],
    ["path", { d: "M6 13H2" }],
    ["path", { d: "M3 21c0-2.1 1.7-3.9 3.8-4" }],
    ["path", { d: "M20.97 5c0 2.1-1.6 3.8-3.5 4" }],
    ["path", { d: "M22 13h-4" }],
    ["path", { d: "M17.2 17c2.1.1 3.8 1.9 3.8 4" }]
  ];

  // node_modules/.pnpm/lucide@0.541.0/node_modules/lucide/dist/esm/icons/check.js
  var Check = [["path", { d: "M20 6 9 17l-5-5" }]];

  // node_modules/.pnpm/lucide@0.541.0/node_modules/lucide/dist/esm/icons/chevron-down.js
  var ChevronDown = [["path", { d: "m6 9 6 6 6-6" }]];

  // node_modules/.pnpm/lucide@0.541.0/node_modules/lucide/dist/esm/icons/chevron-left.js
  var ChevronLeft = [["path", { d: "m15 18-6-6 6-6" }]];

  // node_modules/.pnpm/lucide@0.541.0/node_modules/lucide/dist/esm/icons/circle-x.js
  var CircleX = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["path", { d: "m15 9-6 6" }],
    ["path", { d: "m9 9 6 6" }]
  ];

  // node_modules/.pnpm/lucide@0.541.0/node_modules/lucide/dist/esm/icons/clipboard-copy.js
  var ClipboardCopy = [
    ["rect", { width: "8", height: "4", x: "8", y: "2", rx: "1", ry: "1" }],
    ["path", { d: "M8 4H6a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-2" }],
    ["path", { d: "M16 4h2a2 2 0 0 1 2 2v4" }],
    ["path", { d: "M21 14H11" }],
    ["path", { d: "m15 10-4 4 4 4" }]
  ];

  // node_modules/.pnpm/lucide@0.541.0/node_modules/lucide/dist/esm/icons/clipboard-paste.js
  var ClipboardPaste = [
    ["path", { d: "M11 14h10" }],
    ["path", { d: "M16 4h2a2 2 0 0 1 2 2v1.344" }],
    ["path", { d: "m17 18 4-4-4-4" }],
    ["path", { d: "M8 4H6a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h12a2 2 0 0 0 1.793-1.113" }],
    ["rect", { x: "8", y: "2", width: "8", height: "4", rx: "1" }]
  ];

  // node_modules/.pnpm/lucide@0.541.0/node_modules/lucide/dist/esm/icons/code-xml.js
  var CodeXml = [
    ["path", { d: "m18 16 4-4-4-4" }],
    ["path", { d: "m6 8-4 4 4 4" }],
    ["path", { d: "m14.5 4-5 16" }]
  ];

  // node_modules/.pnpm/lucide@0.541.0/node_modules/lucide/dist/esm/icons/copy-plus.js
  var CopyPlus = [
    ["line", { x1: "15", x2: "15", y1: "12", y2: "18" }],
    ["line", { x1: "12", x2: "18", y1: "15", y2: "15" }],
    ["rect", { width: "14", height: "14", x: "8", y: "8", rx: "2", ry: "2" }],
    ["path", { d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2" }]
  ];

  // node_modules/.pnpm/lucide@0.541.0/node_modules/lucide/dist/esm/icons/eye.js
  var Eye = [
    [
      "path",
      {
        d: "M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0"
      }
    ],
    ["circle", { cx: "12", cy: "12", r: "3" }]
  ];

  // node_modules/.pnpm/lucide@0.541.0/node_modules/lucide/dist/esm/icons/git-pull-request.js
  var GitPullRequest = [
    ["circle", { cx: "18", cy: "18", r: "3" }],
    ["circle", { cx: "6", cy: "6", r: "3" }],
    ["path", { d: "M13 6h3a2 2 0 0 1 2 2v7" }],
    ["line", { x1: "6", x2: "6", y1: "9", y2: "21" }]
  ];

  // node_modules/.pnpm/lucide@0.541.0/node_modules/lucide/dist/esm/icons/hand-coins.js
  var HandCoins = [
    ["path", { d: "M11 15h2a2 2 0 1 0 0-4h-3c-.6 0-1.1.2-1.4.6L3 17" }],
    [
      "path",
      {
        d: "m7 21 1.6-1.4c.3-.4.8-.6 1.4-.6h4c1.1 0 2.1-.4 2.8-1.2l4.6-4.4a2 2 0 0 0-2.75-2.91l-4.2 3.9"
      }
    ],
    ["path", { d: "m2 16 6 6" }],
    ["circle", { cx: "16", cy: "9", r: "2.9" }],
    ["circle", { cx: "6", cy: "5", r: "3" }]
  ];

  // node_modules/.pnpm/lucide@0.541.0/node_modules/lucide/dist/esm/icons/hat-glasses.js
  var HatGlasses = [
    ["path", { d: "M14 18a2 2 0 0 0-4 0" }],
    [
      "path",
      {
        d: "m19 11-2.11-6.657a2 2 0 0 0-2.752-1.148l-1.276.61A2 2 0 0 1 12 4H8.5a2 2 0 0 0-1.925 1.456L5 11"
      }
    ],
    ["path", { d: "M2 11h20" }],
    ["circle", { cx: "17", cy: "18", r: "3" }],
    ["circle", { cx: "7", cy: "18", r: "3" }]
  ];

  // node_modules/.pnpm/lucide@0.541.0/node_modules/lucide/dist/esm/icons/heart.js
  var Heart = [
    [
      "path",
      {
        d: "M2 9.5a5.5 5.5 0 0 1 9.591-3.676.56.56 0 0 0 .818 0A5.49 5.49 0 0 1 22 9.5c0 2.29-1.5 4-3 5.5l-5.492 5.313a2 2 0 0 1-3 .019L5 15c-1.5-1.5-3-3.2-3-5.5"
      }
    ]
  ];

  // node_modules/.pnpm/lucide@0.541.0/node_modules/lucide/dist/esm/icons/lock.js
  var Lock = [
    ["rect", { width: "18", height: "11", x: "3", y: "11", rx: "2", ry: "2" }],
    ["path", { d: "M7 11V7a5 5 0 0 1 10 0v4" }]
  ];

  // node_modules/.pnpm/lucide@0.541.0/node_modules/lucide/dist/esm/icons/lock-open.js
  var LockOpen = [
    ["rect", { width: "18", height: "11", x: "3", y: "11", rx: "2", ry: "2" }],
    ["path", { d: "M7 11V7a5 5 0 0 1 9.9-1" }]
  ];

  // node_modules/.pnpm/lucide@0.541.0/node_modules/lucide/dist/esm/icons/log-out.js
  var LogOut = [
    ["path", { d: "m16 17 5-5-5-5" }],
    ["path", { d: "M21 12H9" }],
    ["path", { d: "M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4" }]
  ];

  // node_modules/.pnpm/lucide@0.541.0/node_modules/lucide/dist/esm/icons/map-pinned.js
  var MapPinned = [
    [
      "path",
      {
        d: "M18 8c0 3.613-3.869 7.429-5.393 8.795a1 1 0 0 1-1.214 0C9.87 15.429 6 11.613 6 8a6 6 0 0 1 12 0"
      }
    ],
    ["circle", { cx: "12", cy: "8", r: "2" }],
    [
      "path",
      {
        d: "M8.714 14h-3.71a1 1 0 0 0-.948.683l-2.004 6A1 1 0 0 0 3 22h18a1 1 0 0 0 .948-1.316l-2-6a1 1 0 0 0-.949-.684h-3.712"
      }
    ]
  ];

  // node_modules/.pnpm/lucide@0.541.0/node_modules/lucide/dist/esm/icons/panels-top-left.js
  var PanelsTopLeft = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M3 9h18" }],
    ["path", { d: "M9 21V9" }]
  ];

  // node_modules/.pnpm/lucide@0.541.0/node_modules/lucide/dist/esm/icons/person-standing.js
  var PersonStanding = [
    ["circle", { cx: "12", cy: "5", r: "1" }],
    ["path", { d: "m9 20 3-6 3 6" }],
    ["path", { d: "m6 8 6 2 6-2" }],
    ["path", { d: "M12 10v4" }]
  ];

  // node_modules/.pnpm/lucide@0.541.0/node_modules/lucide/dist/esm/icons/send-to-back.js
  var SendToBack = [
    ["rect", { x: "14", y: "14", width: "8", height: "8", rx: "2" }],
    ["rect", { x: "2", y: "2", width: "8", height: "8", rx: "2" }],
    ["path", { d: "M7 14v1a2 2 0 0 0 2 2h1" }],
    ["path", { d: "M14 7h1a2 2 0 0 1 2 2v1" }]
  ];

  // node_modules/.pnpm/lucide@0.541.0/node_modules/lucide/dist/esm/icons/settings.js
  var Settings = [
    [
      "path",
      {
        d: "M9.671 4.136a2.34 2.34 0 0 1 4.659 0 2.34 2.34 0 0 0 3.319 1.915 2.34 2.34 0 0 1 2.33 4.033 2.34 2.34 0 0 0 0 3.831 2.34 2.34 0 0 1-2.33 4.033 2.34 2.34 0 0 0-3.319 1.915 2.34 2.34 0 0 1-4.659 0 2.34 2.34 0 0 0-3.32-1.915 2.34 2.34 0 0 1-2.33-4.033 2.34 2.34 0 0 0 0-3.831A2.34 2.34 0 0 1 6.35 6.051a2.34 2.34 0 0 0 3.319-1.915"
      }
    ],
    ["circle", { cx: "12", cy: "12", r: "3" }]
  ];

  // node_modules/.pnpm/lucide@0.541.0/node_modules/lucide/dist/esm/icons/shell.js
  var Shell = [
    [
      "path",
      {
        d: "M14 11a2 2 0 1 1-4 0 4 4 0 0 1 8 0 6 6 0 0 1-12 0 8 8 0 0 1 16 0 10 10 0 1 1-20 0 11.93 11.93 0 0 1 2.42-7.22 2 2 0 1 1 3.16 2.44"
      }
    ]
  ];

  // node_modules/.pnpm/lucide@0.541.0/node_modules/lucide/dist/esm/icons/shield-alert.js
  var ShieldAlert = [
    [
      "path",
      {
        d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z"
      }
    ],
    ["path", { d: "M12 8v4" }],
    ["path", { d: "M12 16h.01" }]
  ];

  // node_modules/.pnpm/lucide@0.541.0/node_modules/lucide/dist/esm/icons/shield-minus.js
  var ShieldMinus = [
    [
      "path",
      {
        d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z"
      }
    ],
    ["path", { d: "M9 12h6" }]
  ];

  // node_modules/.pnpm/lucide@0.541.0/node_modules/lucide/dist/esm/icons/skull.js
  var Skull = [
    ["path", { d: "m12.5 17-.5-1-.5 1h1z" }],
    [
      "path",
      {
        d: "M15 22a1 1 0 0 0 1-1v-1a2 2 0 0 0 1.56-3.25 8 8 0 1 0-11.12 0A2 2 0 0 0 8 20v1a1 1 0 0 0 1 1z"
      }
    ],
    ["circle", { cx: "15", cy: "12", r: "1" }],
    ["circle", { cx: "9", cy: "12", r: "1" }]
  ];

  // node_modules/.pnpm/lucide@0.541.0/node_modules/lucide/dist/esm/icons/target.js
  var Target = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["circle", { cx: "12", cy: "12", r: "6" }],
    ["circle", { cx: "12", cy: "12", r: "2" }]
  ];

  // node_modules/.pnpm/lucide@0.541.0/node_modules/lucide/dist/esm/icons/trash-2.js
  var Trash2 = [
    ["path", { d: "M10 11v6" }],
    ["path", { d: "M14 11v6" }],
    ["path", { d: "M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6" }],
    ["path", { d: "M3 6h18" }],
    ["path", { d: "M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" }]
  ];

  // node_modules/.pnpm/lucide@0.541.0/node_modules/lucide/dist/esm/icons/wand.js
  var Wand = [
    ["path", { d: "M15 4V2" }],
    ["path", { d: "M15 16v-2" }],
    ["path", { d: "M8 9h2" }],
    ["path", { d: "M20 9h2" }],
    ["path", { d: "M17.8 11.8 19 13" }],
    ["path", { d: "M15 9h.01" }],
    ["path", { d: "M17.8 6.2 19 5" }],
    ["path", { d: "m3 21 9-9" }],
    ["path", { d: "M12.2 6.2 11 5" }]
  ];

  // node_modules/.pnpm/zois-core@1.1.6/node_modules/zois-core/dist/modules.js
  var r = class {
    overrideProperties(e2, t4) {
      return e2;
    }
    layoutEffect(e2, t4) {
    }
    effect(e2, t4) {
    }
  };

  // node_modules/.pnpm/zois-core@1.1.6/node_modules/zois-core/dist/ui-modules/counterUpModule.js
  function f(n5, a5, r5, e2) {
    if (!n5) throw new Error("Element not found");
    let s4 = 0, o4, t4;
    const i8 = (m5) => {
      o4 || (o4 = m5);
      const l5 = m5 - o4;
      let u4 = Math.min(l5 / r5, 1);
      const c7 = u4 * (2 - u4), p4 = parseInt(s4 + (a5 - s4) * c7);
      n5.textContent = typeof e2 == "function" ? e2(p4) : p4.toString(), u4 < 1 && (t4 = requestAnimationFrame(i8));
    };
    t4 && cancelAnimationFrame(t4), t4 = requestAnimationFrame(i8);
  }
  var x = class extends r {
    constructor(r5) {
      super();
      this.props = r5;
    }
    effect(r5, e2) {
      f(e2, this.props.endValue, this.props.duration, this.props.formattingFunction);
    }
  };

  // node_modules/.pnpm/zois-core@1.1.6/node_modules/zois-core/dist/ui-modules/typeModule.js
  function l(e2, o4) {
    if (!e2) throw new Error("Element not found");
    const t4 = e2.textContent;
    e2.textContent = "\xA0", e2.classList.add("zcCursor");
    let r5, n5;
    const s4 = (u4) => {
      r5 || (r5 = u4);
      const c7 = u4 - r5;
      let a5 = Math.min(c7 / o4, 1);
      const i8 = t4.slice(0, parseInt(t4.length * a5));
      i8.trim() !== "" && (e2.textContent = i8), a5 < 1 ? n5 = requestAnimationFrame(s4) : setTimeout(() => e2.classList.remove("zcCursor"), o4 / t4.length);
    };
    n5 = requestAnimationFrame(s4);
  }
  var x2 = class extends r {
    constructor(t4) {
      super();
      this.props = t4;
    }
    effect(t4, r5) {
      l(r5, this.props.duration);
    }
  };

  // node_modules/.pnpm/zois-core@1.1.6/node_modules/zois-core/dist/ui-modules/styleModule.js
  var y = class extends r {
    constructor(o4) {
      super();
      this.style = o4;
    }
    applyStyle(o4, t4) {
      for (const e2 of Object.keys(t4)) !isNaN(e2) || typeof t4[e2] == "function" || (o4.style[e2] = t4[e2]);
    }
    layoutEffect(o4, t4) {
      this.applyStyle(t4, this.style);
    }
  };

  // node_modules/.pnpm/zois-core@1.1.6/node_modules/zois-core/dist/ui-modules/dynamicClassModule.js
  var i = class extends r {
    constructor(t4) {
      super();
      this.style = t4;
    }
    layoutEffect(t4, e2) {
      Q(e2, this.style);
    }
  };

  // node_modules/.pnpm/zois-core@1.1.6/node_modules/zois-core/dist/ui-modules/attributesModule.js
  var c = class extends r {
    constructor(e2) {
      super();
      this.attributes = e2;
    }
    layoutEffect(e2, r5) {
      for (const t4 of Object.keys(this.attributes)) r5.setAttribute(t4, this.attributes[t4]);
    }
  };

  // node_modules/.pnpm/zois-core@1.1.6/node_modules/zois-core/dist/ui-modules/clickModule.js
  var i2 = class extends r {
    constructor(t4) {
      super();
      this.callback = t4;
    }
    layoutEffect(t4, e2) {
      e2.addEventListener("click", () => this.callback(e2));
    }
  };

  // node_modules/.pnpm/zois-core@1.1.6/node_modules/zois-core/dist/ui.js
  function N(g5) {
    return g5 * (MainCanvas.canvas.clientHeight / 1e3);
  }
  function D(g5) {
    return g5 * (MainCanvas.canvas.clientWidth / 2e3);
  }
  function W(g5, e2 = "top") {
    const o4 = MainCanvas.canvas.clientHeight / 1e3;
    return e2 === "top" ? MainCanvas.canvas.offsetTop + g5 * o4 : window.innerHeight - (MainCanvas.canvas.offsetTop + MainCanvas.canvas.clientHeight) + g5 * o4;
  }
  function V(g5, e2 = "left") {
    const o4 = MainCanvas.canvas.clientWidth / 2e3;
    return e2 === "left" ? MainCanvas.canvas.offsetLeft + g5 * o4 : window.innerWidth - (MainCanvas.canvas.offsetLeft + MainCanvas.canvas.clientWidth) + g5 * o4;
  }
  function O(g5, e2, o4, l5 = "top-left") {
    const i8 = l5 === "top-left" || l5 === "top-right" ? "top" : "bottom", s4 = l5 === "top-left" || l5 === "bottom-left" ? "left" : "right", t4 = W(o4, i8), f6 = V(e2, s4);
    Object.assign(g5.style, { position: "fixed", [s4]: f6 + "px", [i8]: t4 + "px" });
  }
  function j(g5, e2) {
    const o4 = MainCanvas.canvas.clientWidth, l5 = MainCanvas.canvas.clientHeight, i8 = Math.min(o4, l5) / 100, s4 = e2 * i8;
    Object.assign(g5.style, { fontSize: s4 + "px" });
  }
  function k(g5, e2) {
    g5.style.fontFamily = e2 ?? "sans-serif";
  }
  function G(g5, e2) {
    const o4 = MainCanvas.canvas.clientWidth, l5 = MainCanvas.canvas.clientHeight, i8 = Math.min(o4, l5) / 100, s4 = e2 * i8;
    Object.assign(g5.style, { padding: s4 + "px" });
  }
  function X(g5) {
    const e2 = MainCanvas.canvas.clientWidth <= MainCanvas.canvas.clientHeight * 2 ? MainCanvas.canvas.clientWidth / 50 : MainCanvas.canvas.clientHeight / 25;
    Object.assign(g5.style, { fontSize: e2 + "px" });
  }
  var S2 = [];
  function _(g5) {
    const e2 = (o4) => o4 ? JSON.stringify(Object.keys(o4).sort().reduce((l5, i8) => (l5[i8] = o4[i8], l5), {})) : "null";
    return `base:${e2(g5.base)}|hover:${e2(g5.hover)}|active:${e2(g5.active)}`;
  }
  function Q(g5, e2) {
    const o4 = _(e2), l5 = S2.find((h6) => h6.key === o4);
    if (l5) return g5.classList.add(l5.className);
    let i8;
    do
      i8 = "dynamic-" + Math.random().toString(36).substring(2, 10);
    while (S2.find((h6) => h6.className === i8));
    S2.push({ key: o4, className: i8 });
    const s4 = (h6, m5) => {
      let d4 = `${h6} {`;
      for (const [r5, c7] of Object.entries(m5)) d4 += `${r5.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, "$1-$2").toLowerCase()}: ${c7};`;
      return d4 += "}", d4;
    };
    let t4 = "";
    e2.base && (t4 += s4(`.${i8}`, e2.base)), e2.hover && (t4 += s4(`.${i8}:hover`, e2.hover)), e2.active && (t4 += s4(`.${i8}:active`, e2.active)), e2.focus && (t4 += s4(`.${i8}:focus`, e2.focus)), e2.disabled && (t4 += s4(`.${i8}:disabled`, e2.disabled));
    let f6 = document.getElementById(`${m.key ?? ""}-dynamic-classes`);
    f6 ? f6.textContent += t4 : (f6 = document.createElement("style"), f6.id = `${m.key ?? ""}-dynamic-classes`, f6.textContent = t4, document.head.appendChild(f6)), g5.classList.add(i8);
  }
  function U() {
    R(M);
  }
  function R(g5) {
    M = A, A = g5, A && A.load(), M && M.unload();
  }
  function ee() {
    return A;
  }
  var A;
  var M = null;
  var te = class {
    htmlElements = [];
    resizeEventListeners = [];
    tabHandlers = {};
    addElement(e2, { x: o4, y: l5, width: i8, height: s4, padding: t4, fontSize: f6 = "auto", anchor: h6, place: m5, modules: d4 = {}, modulesMap: r5 }) {
      k(e2, m.fontFamily);
      const c7 = { anchor: h6, x: o4, y: l5, width: i8, height: s4, padding: t4, fontSize: f6, place: m5, element: e2 };
      Object.keys(d4)?.forEach((a5) => {
        d4[a5].forEach((p4) => {
          const u4 = p4.overrideProperties(c7, r5[a5]);
          h6 = u4.anchor, o4 = u4.x, l5 = u4.y, i8 = u4.width, s4 = u4.height, t4 = u4.padding, f6 = u4.fontSize, m5 = u4.place, e2 = u4.element;
        });
      });
      const n5 = () => {
        typeof o4 == "number" && typeof l5 == "number" && O(e2, o4, l5, h6), f6 === "auto" ? X(e2) : j(e2, f6), t4 && G(e2, t4), i8 && (e2.style.width = D(i8) + "px"), s4 && (e2.style.height = N(s4) + "px");
      };
      n5(), window.addEventListener("resize", n5), Object.keys(d4)?.forEach((a5) => {
        d4[a5].forEach((p4) => {
          p4.layoutEffect(c7, r5[a5]);
        });
      }), m5 && document.body.append(e2), this.resizeEventListeners.push(n5), this.htmlElements.push(e2), Object.keys(d4)?.forEach((a5) => {
        d4[a5].forEach((p4) => {
          p4.effect(c7, r5[a5]);
        });
      });
    }
    get currentSubscreen() {
      return A;
    }
    get previousSubscreen() {
      return M;
    }
    get name() {
      return "";
    }
    run() {
      this.tabHandlers.run?.();
    }
    load() {
      this.createButton({ x: 1815, y: 75, width: 90, height: 90, icon: "Icons/Exit.png", modules: { base: [new y({ zIndex: "10" })] } }).addEventListener("click", () => this.exit()), this.name && (this.createText({ text: this.name, x: 100, y: 60, fontSize: 8 }).style.cssText += "max-width: 85%; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; padding: 0.1em;"), T[this.constructor.name] && T[this.name].forEach((e2) => e2(this));
    }
    unload() {
      this.tabHandlers.unload?.(), this.htmlElements.forEach((e2) => {
        e2.remove();
      }), this.resizeEventListeners.forEach((e2) => {
        removeEventListener("resize", e2);
      });
    }
    click() {
    }
    exit() {
      this.tabHandlers.exit?.(), this.setSubscreen(this.previousSubscreen);
    }
    update() {
    }
    setPreviousSubscreen() {
      U();
    }
    setSubscreen(e2) {
      R(e2);
    }
    createButton({ text: e2, x: o4, y: l5, width: i8, height: s4, fontSize: t4 = "auto", anchor: f6 = "top-left", padding: h6, style: m5 = "default", place: d4 = true, icon: r5, iconAbsolutePosition: c7 = true, tooltip: n5, onClick: a5, isDisabled: p4, modules: u4 }) {
      let b3, v3;
      const y5 = document.createElement("button");
      if (y5.classList.add("zcButton"), y5.setAttribute("data-zc-style", m5), y5.style.display = "flex", y5.style.alignItems = "center", y5.style.justifyContent = "center", y5.style.columnGap = "1.25vw", k(y5, m.fontFamily), r5 && (typeof r5 == "string" ? (b3 = document.createElement("img"), b3.src = r5) : b3 = r5, b3.style.height = "80%", b3.style.width = "auto", e2 && c7 && (b3.style.position = "absolute", b3.style.left = "1vw"), e2 && !c7 && (y5.style.justifyContent = ""), y5.append(b3)), e2 && (v3 = document.createElement("span"), v3.textContent = e2, y5.append(v3)), n5) {
        const L4 = document.createElement("span");
        L4.classList.add("tooltip"), L4.setAttribute("position", n5.position), L4.textContent = n5.text, y5.append(L4);
      }
      return typeof p4 == "function" && p4() && y5.classList.add("zcDisabled"), y5.addEventListener("click", () => {
        if (typeof p4 == "function" && p4()) return y5.classList.add("zcDisabled");
        typeof a5 == "function" && a5();
      }), this.addElement(y5, { x: o4, y: l5, width: i8, height: s4, anchor: f6, place: d4, fontSize: t4, padding: h6, modules: u4, modulesMap: { base: y5, text: v3, icon: b3 } }), y5;
    }
    createText({ text: e2, color: o4, x: l5, y: i8, width: s4, height: t4, withBackground: f6 = false, withBorder: h6 = false, fontSize: m5 = "auto", anchor: d4 = "top-left", padding: r5, place: c7 = true, modules: n5 }) {
      const a5 = document.createElement("p");
      return a5.innerHTML = e2, a5.style.color = o4 ?? "var(--tmd-text, black)", f6 && (a5.style.background = "var(--tmd-element,rgb(239, 239, 239))"), h6 && (a5.style.border = "2px solid var(--tmd-accent, rgb(236, 236, 236))"), k(a5, m.fontFamily), this.addElement(a5, { x: l5, y: i8, width: s4, height: t4, anchor: d4, place: c7, fontSize: m5, padding: r5, modules: n5, modulesMap: { base: a5 } }), a5;
    }
    createInput({ value: e2, placeholder: o4, x: l5, y: i8, width: s4, height: t4, textArea: f6 = false, fontSize: h6 = "auto", anchor: m5 = "top-left", padding: d4, place: r5 = true, onChange: c7, onInput: n5, isDisabled: a5, modules: p4 }) {
      const u4 = document.createElement(f6 ? "textarea" : "input");
      return u4.classList.add("zcInput"), o4 && (u4.placeholder = o4), e2 && (u4.value = e2), k(u4, m.fontFamily), typeof a5 == "function" && a5() && u4.classList.add("zcDisabled"), u4.addEventListener("change", () => {
        if (typeof a5 == "function" && a5()) return u4.classList.add("zcDisabled");
        typeof c7 == "function" && c7();
      }), u4.addEventListener("input", () => {
        if (typeof a5 == "function" && a5()) return u4.classList.add("zcDisabled");
        typeof n5 == "function" && n5();
      }), this.addElement(u4, { x: l5, y: i8, width: s4, height: t4, anchor: m5, place: r5, fontSize: h6, padding: d4, modules: p4, modulesMap: { base: u4 } }), u4;
    }
    createCheckbox({ text: e2, x: o4, y: l5, isChecked: i8, width: s4, modules: t4, anchor: f6 = "top-left", place: h6 = true, isDisabled: m5, onChange: d4 }) {
      const r5 = document.createElement("div");
      r5.style.display = "flex", r5.style.alignItems = "center", r5.style.columnGap = "1vw";
      const c7 = document.createElement("input");
      c7.type = "checkbox", c7.checked = i8, c7.style.borderRadius = "min(0.8dvh, 0.3dvw)", c7.style.aspectRatio = "1/1", c7.classList.add("zcCheckbox", "checkbox");
      const n5 = document.createElement("p");
      return n5.textContent = e2, n5.style.color = "var(--tmd-text, black)", k(n5, m.fontFamily), typeof m5 == "function" && m5() && r5.classList.add("zcDisabled"), r5.addEventListener("change", () => {
        if (typeof m5 == "function" && m5()) return r5.classList.add("zcDisabled");
        typeof d4 == "function" && d4();
      }), r5.append(c7, n5), this.addElement(r5, { x: o4, y: l5, width: s4, anchor: f6, place: h6, modules: t4, modulesMap: { base: r5, checkbox: c7, label: n5 } }), r5;
    }
    createScrollView({ scroll: e2, x: o4, y: l5, width: i8, height: s4, anchor: t4 = "top-left", modules: f6, place: h6 = true }) {
      const m5 = document.createElement("div");
      return e2 === "all" && (m5.style.overflow = "scroll"), e2 === "x" && (m5.style.overflowX = "scroll"), e2 === "y" && (m5.style.overflowY = "scroll"), this.addElement(m5, { x: o4, y: l5, width: i8, height: s4, anchor: t4, place: h6, modules: f6, modulesMap: { base: m5 } }), m5;
    }
    createInputList({ x: e2, y: o4, width: l5, height: i8, title: s4, value: t4, modules: f6, anchor: h6 = "top-left", place: m5 = true, numbersOnly: d4 = false, isDisabled: r5, onChange: c7 }) {
      const n5 = [], a5 = document.createElement("div");
      a5.style.cssText = `
        display: flex; flex-direction: column; gap: 1vw; border: 2px solid var(--tmd-accent, black);
        border-radius: 4px; padding: 0.75vw; background: var(--tmd-element, none);
        `, k(a5, m.fontFamily);
      const p4 = document.createElement("div");
      p4.style.cssText = "display: flex; justify-content: center; column-gap: 1vw; width: 100%;";
      const u4 = document.createElement("b");
      u4.textContent = s4 + ":", u4.style.cssText = "width: 100%; font-size: clamp(10px, 2.4vw, 24px); color: var(--tmd-text, black);";
      const b3 = document.createElement("div");
      b3.style.cssText = `display: flex; gap: 1vw; flex-wrap: wrap; align-content: flex-start;
        overflow-y: scroll;`;
      const v3 = document.createElement("input");
      v3.style.cssText = "border: none; outline: none; background: none; height: fit-content; flex-grow: 1; padding: 0.8vw; width: 6vw; font-size: clamp(8px, 2vw, 20px);";
      const y5 = (x6, E3) => {
        const w4 = this.createButton({ icon: x6, place: false, onClick: E3, style: "default", modules: { icon: [new y({ width: "70%", height: "70%" })] } });
        w4.style.width = "2em", w4.style.aspectRatio = "1/1", p4.append(w4);
      }, L4 = (x6) => {
        const E3 = document.createElement("div");
        E3.style.cssText = "cursor: pointer; background: var(--tmd-element-hover, rgb(206, 206, 206)); color: var(--tmd-text, black); height: fit-content; padding: 0.8vw; border-radius: 0.8vw; font-size: clamp(8px, 2vw, 20px);", E3.textContent = x6, b3.insertBefore(E3, v3), E3.addEventListener("click", (w4) => {
          E3.style.border === "" ? E3.style.border = "2px solid red" : E3.style.border = "", w4.stopPropagation();
        }), n5.push(x6);
      };
      return y5(createElement(CircleX), () => {
        if (typeof r5 == "function" && r5()) return a5.classList.add("zcDisabled");
        b3.innerHTML = "", n5.splice(0, n5.length), b3.append(v3), t4.forEach((x6) => L4(String(x6))), typeof c7 == "function" && c7(d4 ? n5.map((x6) => parseInt(x6)) : n5);
      }), y5(createElement(Trash2), () => {
        if (typeof r5 == "function" && r5()) return a5.classList.add("zcDisabled");
        for (const x6 of [...b3.children]) x6.getAttribute("style").includes("border: 2px solid red;") && (n5.splice(n5.indexOf(x6.textContent), 1), x6.remove());
        typeof c7 == "function" && c7(d4 ? n5.map((x6) => parseInt(x6)) : n5);
      }), typeof r5 == "function" && r5() && a5.classList.add("zcDisabled"), v3.addEventListener("keypress", (x6) => {
        if (document.activeElement === v3) switch (x6.key) {
          case "Enter":
            if (d4 && Number.isNaN(parseInt(v3.value)) || v3.value.trim() === "") return;
            if (typeof r5 == "function" && r5()) return a5.classList.add("zcDisabled");
            L4(v3.value), v3.value = "", typeof c7 == "function" && c7(d4 ? n5.map((E3) => parseInt(E3)) : n5);
            break;
        }
      }), a5.addEventListener("click", (x6) => {
        x6.currentTarget == a5 && v3.focus();
      }), b3.append(v3), a5.append(p4, u4, b3), this.addElement(a5, { x: e2, y: o4, width: l5, height: i8, anchor: h6, place: m5, modules: f6, modulesMap: { base: a5, input: v3 } }), t4.forEach((x6) => L4(String(x6))), a5;
    }
    createImage({ x: e2, y: o4, width: l5, src: i8, place: s4 = true, anchor: t4 = "top-left", modules: f6 }) {
      const h6 = document.createElement("img");
      return h6.style.height = "auto", h6.src = i8, this.addElement(h6, { x: e2, y: o4, width: l5, height: 0, anchor: t4, place: s4, modules: f6, modulesMap: { base: h6 } }), h6;
    }
    createSvg({ x: e2, y: o4, size: l5, dataurl: i8, place: s4 = true, anchor: t4 = "top-left", fill: f6 = "var(--tmd-accent, black)", stroke: h6 = "var(--tmd-accent-hover, black)", strokeWidth: m5 = "2px", modules: d4 }) {
      function r5(a5) {
        const p4 = a5.replace("data:image/svg+xml,", ""), u4 = decodeURIComponent(p4), b3 = document.createElement("div");
        return b3.innerHTML = u4, b3.firstElementChild;
      }
      function c7(a5, { fill: p4, stroke: u4 }) {
        return a5.querySelectorAll("*").forEach((v3) => {
          v3.getAttribute("fill") !== "none" && v3.setAttribute("fill", p4), v3.getAttribute("stroke") !== "none" && v3.setAttribute("stroke", u4);
        }), a5.getAttribute("fill") !== "none" && a5.setAttribute("fill", p4), a5.getAttribute("stroke") !== "none" && a5.setAttribute("stroke", u4), a5;
      }
      const n5 = r5(i8);
      return c7(n5, { fill: f6, stroke: h6 }), n5.setAttribute("stroke-width", m5), this.addElement(n5, { x: e2, y: o4, width: l5, height: l5, anchor: t4, place: s4, modules: d4, modulesMap: { base: n5 } }), n5;
    }
    createBackNextButton({ x: e2, y: o4, width: l5, height: i8, items: s4, currentIndex: t4, modules: f6, isBold: h6 = false, anchor: m5 = "top-left", place: d4 = true, onChange: r5, isDisabled: c7 }) {
      const n5 = document.createElement("div");
      n5.classList.add("zcBackNextButton"), k(n5, m.fontFamily);
      const a5 = () => {
        t4 === 0 || typeof c7 == "function" && c7(s4[t4 - 1][1]) ? p4.classList.add("zcBackNextButton-btnDisabled") : p4.classList.remove("zcBackNextButton-btnDisabled"), t4 === s4.length - 1 || typeof c7 == "function" && c7(s4[t4 + 1][1]) ? u4.classList.add("zcBackNextButton-btnDisabled") : u4.classList.remove("zcBackNextButton-btnDisabled");
      }, p4 = document.createElement("button");
      p4.style.cssText = `
        position: absolute; left: 1vw; font-size: 3.5vw; aspect-ratio: 1/1;
        height: 140%; background-image: url("Icons/Prev.png"); background-size: 100%;
        `, p4.classList.add("zcButton"), p4.addEventListener("click", () => {
        if (t4 === 0 || typeof c7 == "function" && c7(s4[t4 - 1][1])) return p4.classList.add("zcDisabled");
        t4--, b3.textContent = s4[t4][0], typeof r5 == "function" && r5(s4[t4][1]), a5();
      });
      const u4 = document.createElement("button");
      u4.style.cssText = `
        position: absolute; right: 1vw; font-size: 3.5vw; aspect-ratio: 1/1;
        height: 140%; background-image: url("Icons/Next.png"); background-size: 100%;
        `, u4.classList.add("zcButton"), u4.addEventListener("click", () => {
        if (t4 === s4.length - 1 || typeof c7 == "function" && c7(s4[t4 + 1][1])) return u4.classList.add("zcDisabled");
        t4++, b3.textContent = s4[t4][0], typeof r5 == "function" && r5(s4[t4][1]), a5();
      }), a5();
      const b3 = document.createElement("p");
      return h6 && (b3.style.fontWeight = "bold"), b3.textContent = s4[t4][0], n5.append(p4, b3, u4), this.addElement(n5, { x: e2, y: o4, width: l5, height: i8, anchor: m5, place: d4, modules: f6, modulesMap: { base: n5, backButton: p4, nextButton: u4, text: b3 } }), n5;
    }
    createTabs({ x: e2, y: o4, width: l5, tabs: i8, anchor: s4 = "top-left", place: t4 = true, currentTabName: f6, modules: h6 }) {
      let m5 = [];
      const d4 = document.createElement("div");
      return d4.classList.add("zcTabs"), k(d4, m.fontFamily), i8.forEach((r5) => {
        const c7 = () => {
          for (const p4 of d4.children) p4.removeAttribute("data-opened");
          for (const p4 of m5) p4 instanceof Node && document.body.removeChild(p4);
          m5 = [], n5.setAttribute("data-opened", "true");
          const a5 = document.body.append.bind(document.body);
          document.body.append = (...p4) => {
            m5.push(...p4), a5(...p4);
          }, this.tabHandlers.unload?.(), this.tabHandlers.exit?.(), r5.load(), this.tabHandlers = { run: r5.run, load: r5.load, unload: r5.unload, exit: r5.exit }, document.body.append = a5;
        }, n5 = document.createElement("button");
        n5.textContent = r5.name, r5.name === f6 && c7(), n5.addEventListener("click", c7), d4.append(n5);
      }), this.addElement(d4, { x: e2, y: o4, width: l5, anchor: s4, place: t4, modules: h6, modulesMap: { base: d4 } }), d4;
    }
    drawPolylineArrow({ points: e2, strokeColor: o4 = S()?.base?.text ?? "black", lineWidth: l5 = 2, circleRadius: i8 = 5, circleColor: s4 = S()?.base?.text ?? "black" }) {
      if (e2.length < 2) return;
      const t4 = MainCanvas.canvas.getContext("2d");
      t4.save(), t4.strokeStyle = o4, t4.lineWidth = l5, t4.fillStyle = s4, t4.beginPath(), t4.moveTo(e2[0].x, e2[0].y);
      for (let f6 = 1; f6 < e2.length; f6++) t4.lineTo(e2[f6].x, e2[f6].y);
      t4.stroke(), t4.beginPath(), t4.arc(e2[0].x, e2[0].y, i8, 0, Math.PI * 2), t4.fill(), t4.beginPath(), t4.arc(e2[e2.length - 1].x, e2[e2.length - 1].y, i8, 0, Math.PI * 2), t4.fill(), t4.restore();
    }
    createCard({ x: e2, y: o4, name: l5, value: i8, icon: s4, anchor: t4 = "top-left", place: f6 = true, modules: h6 }) {
      const m5 = document.createElement("div");
      m5.classList.add("zcCard");
      const d4 = document.createElement("p");
      d4.classList.add("zcCard_name"), d4.textContent = l5;
      const r5 = document.createElement("p");
      return r5.classList.add("zcCard_value"), r5.textContent = `${i8}`, s4 && (s4.style.cssText += "position: absolute; top: 0.4em; right: 0.4em; width: 1.2em; height: 1.2em;", m5.append(s4)), m5.append(d4, r5), this.addElement(m5, { x: e2, y: o4, anchor: t4, place: f6, modules: h6, modulesMap: { name: d4, value: r5, base: m5, icon: null } }), m5;
    }
    createSelect({ x: e2, y: o4, width: l5, options: i8, currentOption: s4, anchor: t4 = "top-left", place: f6 = true, modules: h6, onChange: m5, isDisabled: d4 }) {
      let r5 = false, c7;
      const n5 = document.createElement("div");
      n5.classList.add("zcSelect"), n5.setAttribute("opened", false), n5.addEventListener("click", () => {
        if (d4 && d4()) return n5.classList.add("zcDisabled");
        r5 ? (r5 = false, c7.remove()) : (r5 = true, c7 = document.createElement("div"), c7.setAttribute("data-zc-position", typeof o4 == "number" && o4 > 500 - n5.offsetHeight / 2 ? "top" : "bottom"), i8.forEach((b3) => {
          const v3 = document.createElement("div");
          v3.style.cssText = "display: flex; align-items: center; column-gap: 0.5em;", b3.icon && (b3.icon.style.cssText = "color: #bcbcbc;", v3.append(b3.icon)), v3.append(b3.text), b3.name === s4 && v3.append(u4), v3.addEventListener("click", () => {
            s4 = b3.name, a5.textContent = b3.text, c7.remove(), m5 && m5(b3.name);
          }), c7.append(v3);
        }), n5.append(c7));
      });
      const a5 = document.createElement("p");
      a5.textContent = i8.find((b3) => b3.name === s4).text;
      const p4 = createElement(ChevronDown), u4 = createElement(Check);
      return u4.style.cssText = "position: absolute; right: 0.25em;", n5.append(a5, p4), d4 && d4() && n5.classList.add("zcDisabled"), this.addElement(n5, { x: e2, y: o4, width: l5, anchor: t4, place: f6, modules: h6, modulesMap: { base: n5 } }), n5;
    }
    createContainer({ x: e2, y: o4, anchor: l5 = "top-left", place: i8 = true, modules: s4 }) {
      const t4 = document.createElement("div");
      return this.addElement(t4, { x: e2, y: o4, anchor: l5, place: i8, modules: s4, modulesMap: { base: t4 } }), t4;
    }
  };
  var T = {};

  // node_modules/.pnpm/zois-core@1.1.6/node_modules/zois-core/dist/modsApi.js
  var a = ((o4) => (o4[o4.OBSERVE = 0] = "OBSERVE", o4[o4.ADD_BEHAVIOR = 1] = "ADD_BEHAVIOR", o4[o4.MODIFY_BEHAVIOR = 5] = "MODIFY_BEHAVIOR", o4[o4.OVERRIDE_BEHAVIOR = 10] = "OVERRIDE_BEHAVIOR", o4[o4.TOP = 100] = "TOP", o4))(a || {});
  var t;
  function h() {
    t = import_bondage_club_mod_sdk.default.registerMod({ name: m.name, fullName: m.fullName, version: m.version, repository: m.repository }), c2("GameKeyDown", 1, (e2, n5) => CommonKey.IsPressed(e2[0], "Escape") && ee() ? ee().exit() : n5(e2));
  }
  function c2(e2, n5, d4) {
    if (!t) throw new Error("zois-core is not registered");
    return t.hookFunction(e2, n5, d4);
  }
  function I(e2, n5) {
    if (!t) throw new Error("zois-core is not registered");
    t.patchFunction(e2, n5);
  }
  function x3(e2) {
    return !!import_bondage_club_mod_sdk.default.getModsInfo().find((n5) => n5.name === e2);
  }

  // node_modules/.pnpm/zois-core@1.1.6/node_modules/zois-core/dist/popups.js
  var import_react4 = __toESM(require_react());
  var import_client = __toESM(require_client());

  // node_modules/.pnpm/zustand@5.0.8_react@19.2.0/node_modules/zustand/esm/vanilla.mjs
  var createStoreImpl = (createState) => {
    let state;
    const listeners = /* @__PURE__ */ new Set();
    const setState = (partial, replace) => {
      const nextState = typeof partial === "function" ? partial(state) : partial;
      if (!Object.is(nextState, state)) {
        const previousState = state;
        state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
        listeners.forEach((listener) => listener(state, previousState));
      }
    };
    const getState = () => state;
    const getInitialState = () => initialState;
    const subscribe = (listener) => {
      listeners.add(listener);
      return () => listeners.delete(listener);
    };
    const api = { setState, getState, getInitialState, subscribe };
    const initialState = state = createState(setState, getState, api);
    return api;
  };
  var createStore = ((createState) => createState ? createStoreImpl(createState) : createStoreImpl);

  // node_modules/.pnpm/zustand@5.0.8_react@19.2.0/node_modules/zustand/esm/react.mjs
  var import_react = __toESM(require_react(), 1);
  var identity = (arg) => arg;
  function useStore(api, selector = identity) {
    const slice = import_react.default.useSyncExternalStore(
      api.subscribe,
      import_react.default.useCallback(() => selector(api.getState()), [api, selector]),
      import_react.default.useCallback(() => selector(api.getInitialState()), [api, selector])
    );
    import_react.default.useDebugValue(slice);
    return slice;
  }
  var createImpl = (createState) => {
    const api = createStore(createState);
    const useBoundStore = (selector) => useStore(api, selector);
    Object.assign(useBoundStore, api);
    return useBoundStore;
  };
  var create = ((createState) => createState ? createImpl(createState) : createImpl);

  // node_modules/.pnpm/lucide-react@0.542.0_react@19.2.0/node_modules/lucide-react/dist/esm/createLucideIcon.js
  var import_react3 = __toESM(require_react());

  // node_modules/.pnpm/lucide-react@0.542.0_react@19.2.0/node_modules/lucide-react/dist/esm/shared/src/utils.js
  var toKebabCase = (string) => string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
  var toCamelCase = (string) => string.replace(
    /^([A-Z])|[\s-_]+(\w)/g,
    (match, p1, p22) => p22 ? p22.toUpperCase() : p1.toLowerCase()
  );
  var toPascalCase = (string) => {
    const camelCase = toCamelCase(string);
    return camelCase.charAt(0).toUpperCase() + camelCase.slice(1);
  };
  var mergeClasses = (...classes) => classes.filter((className, index, array) => {
    return Boolean(className) && className.trim() !== "" && array.indexOf(className) === index;
  }).join(" ").trim();
  var hasA11yProp = (props) => {
    for (const prop in props) {
      if (prop.startsWith("aria-") || prop === "role" || prop === "title") {
        return true;
      }
    }
  };

  // node_modules/.pnpm/lucide-react@0.542.0_react@19.2.0/node_modules/lucide-react/dist/esm/Icon.js
  var import_react2 = __toESM(require_react());

  // node_modules/.pnpm/lucide-react@0.542.0_react@19.2.0/node_modules/lucide-react/dist/esm/defaultAttributes.js
  var defaultAttributes2 = {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
  };

  // node_modules/.pnpm/lucide-react@0.542.0_react@19.2.0/node_modules/lucide-react/dist/esm/Icon.js
  var Icon = (0, import_react2.forwardRef)(
    ({
      color = "currentColor",
      size = 24,
      strokeWidth = 2,
      absoluteStrokeWidth,
      className = "",
      children,
      iconNode,
      ...rest
    }, ref) => (0, import_react2.createElement)(
      "svg",
      {
        ref,
        ...defaultAttributes2,
        width: size,
        height: size,
        stroke: color,
        strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size) : strokeWidth,
        className: mergeClasses("lucide", className),
        ...!children && !hasA11yProp(rest) && { "aria-hidden": "true" },
        ...rest
      },
      [
        ...iconNode.map(([tag, attrs]) => (0, import_react2.createElement)(tag, attrs)),
        ...Array.isArray(children) ? children : [children]
      ]
    )
  );

  // node_modules/.pnpm/lucide-react@0.542.0_react@19.2.0/node_modules/lucide-react/dist/esm/createLucideIcon.js
  var createLucideIcon = (iconName, iconNode) => {
    const Component = (0, import_react3.forwardRef)(
      ({ className, ...props }, ref) => (0, import_react3.createElement)(Icon, {
        ref,
        iconNode,
        className: mergeClasses(
          `lucide-${toKebabCase(toPascalCase(iconName))}`,
          `lucide-${iconName}`,
          className
        ),
        ...props
      })
    );
    Component.displayName = toPascalCase(iconName);
    return Component;
  };

  // node_modules/.pnpm/lucide-react@0.542.0_react@19.2.0/node_modules/lucide-react/dist/esm/icons/circle-alert.js
  var __iconNode = [
    ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
    ["line", { x1: "12", x2: "12", y1: "8", y2: "12", key: "1pkeuh" }],
    ["line", { x1: "12", x2: "12.01", y1: "16", y2: "16", key: "4dfq90" }]
  ];
  var CircleAlert = createLucideIcon("circle-alert", __iconNode);

  // node_modules/.pnpm/lucide-react@0.542.0_react@19.2.0/node_modules/lucide-react/dist/esm/icons/circle-check.js
  var __iconNode2 = [
    ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
    ["path", { d: "m9 12 2 2 4-4", key: "dzmm74" }]
  ];
  var CircleCheck = createLucideIcon("circle-check", __iconNode2);

  // node_modules/.pnpm/lucide-react@0.542.0_react@19.2.0/node_modules/lucide-react/dist/esm/icons/circle-x.js
  var __iconNode3 = [
    ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
    ["path", { d: "m15 9-6 6", key: "1uzhvr" }],
    ["path", { d: "m9 9 6 6", key: "z0biqf" }]
  ];
  var CircleX2 = createLucideIcon("circle-x", __iconNode3);

  // node_modules/.pnpm/lucide-react@0.542.0_react@19.2.0/node_modules/lucide-react/dist/esm/icons/info.js
  var __iconNode4 = [
    ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
    ["path", { d: "M12 16v-4", key: "1dtifu" }],
    ["path", { d: "M12 8h.01", key: "e9boi3" }]
  ];
  var Info = createLucideIcon("info", __iconNode4);

  // node_modules/.pnpm/zois-core@1.1.6/node_modules/zois-core/dist/popups.js
  var import_jsx_runtime = __toESM(require_jsx_runtime());
  function I2({ children: o4 }) {
    const [e2, t4] = (0, import_react4.useState)({}), r5 = window.ZOISCORE.useToastsStore((s4) => s4.clearToasts);
    return (0, import_react4.useEffect)(() => {
      const s4 = () => {
        t4({ fontFamily: CommonGetFontName(), bottom: W(5) + "px", left: V(5) + "px" });
      };
      return window.addEventListener("resize", s4), s4(), () => {
        window.removeEventListener("resize", s4);
      };
    }, []), (0, import_jsx_runtime.jsx)("div", { className: "zcToastsContainer", style: e2, onClick: () => {
      document.querySelectorAll(".zcToast").forEach((s4) => {
        s4.classList.add("exiting");
      }), setTimeout(r5, 300);
    }, children: o4 });
  }
  var P = ({ type: o4, theme: e2 }) => {
    switch (o4) {
      case "info":
        return (0, import_jsx_runtime.jsx)(Info, { style: { flexShrink: 0, width: "1.65em", height: "1.65em", fill: e2 ? e2.iconFillColor : "#addbff", stroke: e2 ? e2.iconStrokeColor : "#385073" } });
      case "success":
        return (0, import_jsx_runtime.jsx)(CircleCheck, { style: { flexShrink: 0, width: "1.65em", height: "1.65em", fill: e2 ? e2.iconFillColor : "#c3ffc3", stroke: e2 ? e2.iconStrokeColor : "#028f74" } });
      case "warning":
        return (0, import_jsx_runtime.jsx)(CircleAlert, { style: { flexShrink: 0, width: "1.65em", height: "1.65em", fill: e2 ? e2.iconFillColor : "#ffdfaf", stroke: e2 ? e2.iconStrokeColor : "#9c7633" } });
      case "error":
        return (0, import_jsx_runtime.jsx)(CircleX2, { style: { flexShrink: 0, width: "1.65em", height: "1.65em", fill: e2 ? e2.iconFillColor : "#ffb2b2", stroke: e2 ? e2.iconStrokeColor : "#7f2828" } });
      case "spinner":
        return (0, import_jsx_runtime.jsx)("div", { style: { flexShrink: 0, width: "1.65em", height: "1.65em", boxSizing: "border-box", border: "2px solid", borderRadius: "100%", borderColor: `transparent ${e2 ? e2.iconFillColor : "rgb(154 154 255)"}`, animation: "zcSpin 0.65s linear infinite" } });
    }
  };
  function R2({ title: o4, message: e2, type: t4, duration: r5, id: s4, theme: i8 }) {
    const [n5, c7] = (0, import_react4.useState)({}), [l5, m5] = (0, import_react4.useState)(false);
    return (0, import_react4.useEffect)(() => {
      const u4 = () => {
        const h6 = MainCanvas.canvas.clientWidth, b3 = MainCanvas.canvas.clientHeight, v3 = Math.min(h6, b3) / 100;
        c7({ position: "relative", width: "100%", borderRadius: "0.1em", fontSize: 3 * v3 + "px", padding: 1.5 * v3 + "px", background: i8 ? i8.backgroundColor : t4 === "success" ? "#3ece7e" : t4 === "warning" ? "#debf72" : t4 === "error" ? "rgb(212, 46, 107)" : "rgb(80, 80, 223)" });
      };
      window.addEventListener("resize", u4), u4();
      const S5 = setTimeout(() => m5(true), r5);
      return () => {
        clearTimeout(S5), window.removeEventListener("resize", u4);
      };
    }, []), (0, import_jsx_runtime.jsxs)("div", { className: `zcToast ${l5 && "exiting"}`, "data-zc-toast-type": t4, style: n5, children: [(0, import_jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "center", gap: "1vw", position: "relative", zIndex: 5 }, children: [(0, import_jsx_runtime.jsx)(P, { type: t4, theme: i8 }), (0, import_jsx_runtime.jsxs)("div", { children: [o4 && e2 && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("p", { style: { color: i8 ? i8.titleColor : "white" }, children: o4 }), (0, import_jsx_runtime.jsx)("p", { style: { color: i8 ? i8.messageColor : t4 === "info" || t4 === "spinner" ? "#b8b8ff" : t4 === "success" ? "#c7f9c7" : t4 === "error" ? "#f8bcbc" : "#ffeec5", fontSize: "70%", overflowWrap: "anywhere", marginTop: "0.25em" }, children: e2 })] }), (!o4 && e2 || o4 && !e2) && (0, import_jsx_runtime.jsx)("p", { style: { position: "relative", zIndex: 5 }, children: o4 || e2 })] })] }), t4 !== "spinner" && (0, import_jsx_runtime.jsx)("div", { className: "zcToast-ProgressBar", style: { animation: `zcToast-progress ${r5}ms linear 0s 1 alternate none`, position: "absolute", top: 0, left: 0, height: "100%", background: i8 ? i8.progressBarColor : t4 === "info" ? "rgb(103, 103, 234)" : t4 === "success" ? "#34bc71" : t4 === "warning" ? "#d0af5e" : "rgb(183, 40, 92)" } })] });
  }
  function M2({ dialog: o4 }) {
    const e2 = window.ZOISCORE.useDialogStore((n5) => n5.clearDialog), [t4, r5] = (0, import_react4.useState)({}), [s4, i8] = (0, import_react4.useState)([]);
    return (0, import_react4.useEffect)(() => {
      const n5 = () => {
        const c7 = MainCanvas.canvas.clientWidth, l5 = MainCanvas.canvas.clientHeight, m5 = Math.min(c7, l5) / 100;
        r5({ width: D(o4.width), position: "absolute", top: "50%", left: "50%", transform: "translate(-50%, -50%)", background: "rgba(36, 36, 36, 0.96)", zIndex: 20, fontFamily: CommonGetFontName(), border: "none", padding: 2 * m5 });
      };
      return window.addEventListener("resize", n5), n5(), () => {
        window.removeEventListener("resize", n5);
      };
    }, []), (0, import_jsx_runtime.jsxs)("dialog", { open: Object.keys(t4).length > 0, "data-zc-dialog-type": o4.type, style: t4, children: [o4.title && (0, import_jsx_runtime.jsx)("p", { style: { position: "absolute", top: 0, left: 0, fontWeight: "bold", color: "white", fontSize: "clamp(6px, 2vw, 24px)", padding: "0.25em", background: "#2d2d2d", width: "100%" }, children: o4.title }), (0, import_jsx_runtime.jsx)("p", { style: { padding: "1em", marginTop: "2vw", fontSize: "clamp(6px, 2vw, 24px)", color: "white" }, children: o4.body }), (0, import_jsx_runtime.jsx)("div", { style: { display: "flex", flexDirection: o4.buttons.direction, justifyContent: "center", gap: "0.5vw" }, children: o4.buttons?.list?.map((n5, c7) => (0, import_jsx_runtime.jsx)("button", { className: "zcDialogBtn", "data-zc-picked": s4.includes(c7), style: { width: "100%", position: "relative" }, onClick: () => {
      o4.type === "choice_one" ? (e2(), o4.promise.resolve(n5.value)) : s4.includes(c7) ? i8(s4.filter((l5) => l5 !== c7)) : i8([...s4, c7]);
    }, children: n5.text })) }), o4.type === "choice_multiple" && (0, import_jsx_runtime.jsx)("button", { style: { cursor: "pointer", color: "white", background: "#4d4d4d", border: "none", marginTop: "1vw", fontSize: "clamp(8px,2.5vw,28px)", padding: "0.2em", borderRadius: "4px" }, onClick: () => {
      e2(), o4.promise.resolve(o4.buttons.list.filter((n5, c7) => s4.includes(c7)).map((n5) => n5.value));
    }, children: "Confirm" })] });
  }
  var F = class {
    generateToastId() {
      return crypto.randomUUID();
    }
    process({ title: e2, message: t4, duration: r5, type: s4, id: i8, theme: n5 }) {
      const { addToast: c7, removeToast: l5 } = window.ZOISCORE.useToastsStore.getState();
      c7({ id: i8, title: e2, message: t4, duration: r5, type: s4, theme: n5 }), setTimeout(() => l5(i8), r5 + 300);
    }
    info({ title: e2, message: t4, duration: r5 }) {
      const s4 = this.generateToastId(), i8 = m.singleToastsTheme;
      this.process({ title: e2, message: t4, duration: r5, type: "info", id: s4, theme: i8 });
    }
    success({ title: e2, message: t4, duration: r5 }) {
      const s4 = this.generateToastId(), i8 = m.singleToastsTheme;
      this.process({ title: e2, message: t4, duration: r5, type: "success", id: s4, theme: i8 });
    }
    warn({ title: e2, message: t4, duration: r5 }) {
      const s4 = this.generateToastId(), i8 = m.singleToastsTheme;
      this.process({ title: e2, message: t4, duration: r5, type: "warning", id: s4, theme: i8 });
    }
    error({ title: e2, message: t4, duration: r5 }) {
      const s4 = this.generateToastId(), i8 = m.singleToastsTheme;
      this.process({ title: e2, message: t4, duration: r5, type: "error", id: s4, theme: i8 });
    }
    spinner({ title: e2, message: t4 }) {
      const r5 = this.generateToastId(), s4 = m.singleToastsTheme;
      return this.process({ title: e2, message: t4, duration: 1e6, type: "spinner", id: r5, theme: s4 }), r5;
    }
    removeSpinner(e2) {
      const { removeToast: t4 } = window.ZOISCORE.useToastsStore.getState();
      t4(e2);
    }
  };
  var N2 = class {
    showDialog({ type: e2, title: t4, body: r5, buttons: s4, width: i8 }) {
      const { setDialog: n5 } = window.ZOISCORE.useDialogStore.getState();
      return new Promise((c7, l5) => {
        n5({ width: i8, type: e2, title: t4, body: r5, buttons: s4, promise: { resolve: c7, reject: l5 } });
      });
    }
  };
  function L() {
    const o4 = window.ZOISCORE.useToastsStore((t4) => t4.toasts), e2 = window.ZOISCORE.useDialogStore((t4) => t4.dialog);
    return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)(I2, { children: o4.map(({ title: t4, message: r5, type: s4, duration: i8, id: n5, theme: c7 }) => (0, import_jsx_runtime.jsx)(R2, { id: n5, title: t4, message: r5, type: s4, duration: i8, theme: c7 }, n5)) }), e2 && (0, import_jsx_runtime.jsx)(M2, { dialog: e2 })] });
  }
  var W2 = class extends HTMLElement {
    disconnectedCallback() {
      ServerShowBeep("VirtualDOM was removed, chaos is coming...", 5e3, {});
    }
  };
  var q = create((o4) => ({ toasts: [], addToast: (e2) => o4((t4) => ({ toasts: [...t4.toasts, e2] })), removeToast: (e2) => o4((t4) => ({ toasts: t4.toasts.filter((r5) => r5.id !== e2) })), clearToasts: () => o4({ toasts: [] }) }));
  var Y = create((o4) => ({ dialog: null, setDialog: (e2) => o4({ dialog: e2 }), clearDialog: () => o4({ dialog: null }) }));
  function K() {
    customElements.define("zc-virtual-dom", W2);
    const o4 = document.createElement("zc-virtual-dom");
    document.body.append(o4), import_client.default.createRoot(document.getElementsByTagName("zc-virtual-dom")[0]).render((0, import_jsx_runtime.jsx)(L, {}));
  }
  var Q2 = new F();
  var ee2 = new N2();

  // node_modules/.pnpm/zois-core@1.1.6/node_modules/zois-core/dist/index.js
  var m;
  function C(e2) {
    if (!window.ZOISCORE) {
      const t4 = document.createElement("style");
      t4.innerHTML = styles_default, document.head.append(t4), window.ZOISCORE = Object.freeze({ loaded: true, useToastsStore: q, useDialogStore: Y }), K();
    }
    m = { ...e2 }, h();
  }
  function c3(e2) {
    return new Promise((t4) => setTimeout(t4, e2));
  }
  async function p(e2, t4 = () => false) {
    for (; !e2(); ) {
      if (t4()) return false;
      await c3(10);
    }
    return true;
  }
  function h2(e2, t4) {
    return e2 = Math.ceil(e2), t4 = Math.floor(t4), Math.floor(Math.random() * (t4 - e2 + 1)) + e2;
  }
  function T2(e2) {
    if (e2) return ChatRoomCharacter.find((t4) => t4.MemberNumber == e2 || t4.Name.toLowerCase() === e2 || t4.Nickname?.toLowerCase() === e2);
  }
  function N3(e2) {
    return CharacterNickname(e2);
  }
  function S() {
    if (!x3("Themed")) return null;
    const e2 = JSON.parse(LZString.decompressFromBase64(Player.ExtensionSettings.Themed ?? ""));
    return !e2?.GlobalModule?.themedEnabled || !e2?.GlobalModule?.doVanillaGuiOverhaul ? null : e2.ColorsModule;
  }
  function O2(e2) {
    const t4 = document.createElement("style");
    t4.innerHTML = e2, document.head.append(t4);
  }
  function P2(e2) {
    p(() => typeof Player.MemberNumber == "number").then(() => setTimeout(e2, h2(3e3, 6e3)));
  }

  // src/styles.css
  var styles_default2 = `@import url('https://fonts.googleapis.com/css2?family=Finger+Paint&family=Frijole&family=Rubik+Wet+Paint&family=Yusei+Magic&family=Macondo+Swash+Caps&display=swap');

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

.bccQAM {
  display: flex;
  flex-direction: column;
  position: fixed;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  padding-top: 0.25em;
  max-width: 360px;
  width: 90%;
  border-radius: 4px;
  background: rgb(255, 255, 255);
  border: 2px solid rgba(182 182 182 / 11%);
  box-shadow: 0 0px 6px 0 rgb(168 168 168);
  font-family: "Yusei Magic";
  z-index: 10;
}

.bccQAMButton {
  display: grid;
  place-items: center;
  width: 2.5em;
  aspect-ratio: 1/1;
  border-radius: 4px;
  background: rgba(255, 255, 255, 0.15);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  border: 2px solid var(--tmd-element, rgba(182 182 182 / 11%));
  box-shadow: 0 0px 4px 0 rgb(139 139 139 / 37%);
  cursor: pointer;
  position: fixed;
  top: 10px;
  left: 10px;
  z-index: 25;
}

.bccQAMButton img {
  pointer-events: none;
  width: 80%;
  aspect-ratio: 1/1;
}

.bccQAMSelect {
  cursor: pointer;
  background: white;
  border: 2px solid rgb(195, 195, 195);
  border-radius: 0.4em;
  padding: 0.45em;
  z-index: 10;
}

.bccQAMSelect[opened="true"] {
  border-color: rgb(0, 96, 223);
}

.bccQAMSelect[opened="false"]:hover {
  border-color: rgb(170, 170, 170);
}

.bccQAMSelect>svg {
  position: absolute;
  right: 0.45em;
  top: 50%;
  transform: translateY(-50%);
  width: 1.5em;
  height: 1.5em;
  color: rgb(0, 96, 223);
}

.bccQAMSelect>div {
  position: absolute;
  left: 0;
  width: 100%;
  max-height: 50vh;
  overflow-y: auto;
  scrollbar-width: thin;
  scrollbar-color: #c2c2c2 #e7e7e7;
  background: #f6f6f6;
  border: 2px solid rgb(235 235 235);
  border-radius: 0.4em;
}

.bccQAMSelect>div[data-position="top"] {
  bottom: calc(100% + 0.45em);
}

.bccQAMSelect>div[data-position="bottom"] {
  top: calc(100% + 0.45em);
}

.bccQAMSelect>div>div {
  width: 100%;
  padding: 0.45em;
  border-radius: 0.25em;
}

.bccQAMSelect>div>div>svg {
  width: 1.25em;
  height: 1.25em;
  color: rgb(0, 96, 223);
}

.bccQAMSelect>div>div:hover {
  background: #ededed;
}

.bccChangelog {
  font-family: "Yusei Magic";
  padding: 0.25em;
}

.bccChangelog ul {
  padding-left: 1em;
}

.bccChangelog ul li {
  padding: 0.5em 0;
}

.horror-tentacle-button {
  position: relative;
  padding: 1.25em 2.5em;
  background: linear-gradient(145deg, #0c0c0c, #1a1a1a);
  color: #8ef6e4;
  border: 0.125em solid #00adb5;
  border-radius: 0.5em;
  font-family: 'Cormorant SC', serif;
  font-size: 1rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
  overflow: hidden;
  text-shadow: 0 0 0.3125em rgba(142, 246, 228, 0.3);
  margin: 1em;
}

.horror-tentacle-button:hover {
  background: linear-gradient(145deg, #1a1a1a, #0c0c0c);
  box-shadow: 0 0 1.875em rgba(0, 173, 181, 0.5);
}

.tentacle-horror {
  position: absolute;
  right: -0.3125em;
  top: 50%;
  transform: translateY(-50%);
  height: 80%;
  width: 1.5625em;
  display: flex;
  flex-direction: column;
  justify-content: space-around;
  align-items: flex-end;
}

.tentacle {
  position: relative;
  width: 0.75em;
  height: 0.1875em;
  background: linear-gradient(to left, #00adb5, #007780);
  border-radius: 0.125em;
  opacity: 0.9;
  animation: tentacleWriggle 4s ease-in-out infinite;
  transform-origin: right center;
}

.tentacle::before {
  content: '';
  position: absolute;
  left: -0.0625em;
  top: 50%;
  transform: translateY(-50%);
  width: 0.25em;
  height: 0.25em;
  background: linear-gradient(45deg, #007780, #00565c);
  border-radius: 50%;
  border: 0.0625em solid #00adb5;
  box-shadow: 0 0 0.1875em rgba(0, 173, 181, 0.8);
}

.tentacle::after {
  content: '';
  position: absolute;
  left: -0.375em;
  top: 50%;
  transform: translateY(-50%);
  width: 0.375em;
  height: 0.375em;
  background: #00565c;
  border-radius: 50% 50% 0 50%;
  clip-path: polygon(0 0, 100% 50%, 0 100%);
  opacity: 0.8;
}

.tentacle:nth-child(1) {
  height: 0.25em;
  animation-delay: 0s;
  transform: rotate(-5deg);
}

.tentacle:nth-child(2) {
  animation-delay: 1s;
  transform: rotate(2deg);
}

.tentacle:nth-child(3) {
  height: 0.125em;
  animation-delay: 2s;
  transform: rotate(5deg);
}

.tentacle:nth-child(4) {
  height: 0.1875em;
  animation-delay: 3s;
  transform: rotate(-3deg);
}

.tentacle-detail {
  position: absolute;
  background: rgba(0, 173, 181, 0.3);
  border-radius: 0.0625em;
  animation: detailPulse 3s ease-in-out infinite;
}

.detail-1 {
  width: 0.1875em;
  height: 0.0625em;
  left: -0.5em;
  top: 30%;
  animation-delay: 0s;
}

.detail-2 {
  width: 0.125em;
  height: 0.0625em;
  left: -0.75em;
  top: 60%;
  animation-delay: 1s;
}

.tentacle-particle {
  position: absolute;
  width: 0.0625em;
  height: 0.0625em;
  background: #00adb5;
  border-radius: 50%;
  animation: particleFloat 5s ease-in-out infinite;
  opacity: 0;
}

.particle-1 {
  right: 0.1875em;
  top: 20%;
  animation-delay: 0s;
}

.particle-2 {
  right: 0.5em;
  top: 50%;
  animation-delay: 2s;
}

.particle-3 {
  right: 0.3125em;
  top: 80%;
  animation-delay: 4s;
}

@keyframes tentacleWriggle {

  0%,
  100% {
    transform: rotate(0deg) scaleX(1);
    opacity: 0.9;
  }

  25% {
    transform: rotate(-8deg) scaleX(1.1);
    opacity: 1;
  }

  50% {
    transform: rotate(5deg) scaleX(0.9);
    opacity: 0.8;
  }

  75% {
    transform: rotate(3deg) scaleX(1.05);
    opacity: 0.95;
  }
}

@keyframes detailPulse {

  0%,
  100% {
    opacity: 0.2;
  }

  50% {
    opacity: 0.6;
  }
}

@keyframes particleFloat {
  0% {
    transform: translate(0, 0) scale(0);
    opacity: 0;
  }

  20% {
    transform: translate(-0.3125em, -0.1875em) scale(1);
    opacity: 0.7;
  }

  40% {
    transform: translate(-0.625em, 0.125em) scale(1.2);
    opacity: 0.4;
  }

  60% {
    transform: translate(-0.9375em, -0.0625em) scale(0.8);
    opacity: 0.2;
  }

  80% {
    transform: translate(-1.25em, 0.25em) scale(0.5);
    opacity: 0.1;
  }

  100% {
    transform: translate(-1.5625em, 0) scale(0);
    opacity: 0;
  }
}

.tentacle-slime {
  position: absolute;
  right: 0;
  bottom: 10%;
  width: 0.1875em;
  height: 0.125em;
  background: linear-gradient(to bottom, #00adb5, transparent);
  border-radius: 50%;
  animation: slimeDrip 6s ease-in-out infinite;
  opacity: 0.7;
}

@keyframes slimeDrip {

  0%,
  100% {
    height: 0.125em;
    opacity: 0.5;
  }

  50% {
    height: 0.5em;
    opacity: 0.8;
  }
}

@media (max-width: 768px) {
  .horror-tentacle-button {
    font-size: 0.9rem;
    padding: 1em 2em;
  }
}

@media (max-width: 480px) {
  .horror-tentacle-button {
    font-size: 0.8rem;
    padding: 0.8em 1.6em;
  }

  .tentacle-horror {
    width: 1.2em;
    right: -0.2em;
  }

  .tentacle {
    width: 0.6em;
  }
}

.letter {
  display: inline-block;
  opacity: 0;
  color: var(--tmd-text, black);
  transform: translateY(30px) rotateX(90deg);
  animation: letterReveal 0.45s ease-out forwards;
  font-family: 'Finger Paint';
}

@keyframes letterReveal {
  0% {
    opacity: 0;
    transform: translateY(0.75em) rotateX(90deg);
    text-shadow: 0 0 5px var(--tmd-text, #161616);
  }

  50% {
    opacity: 1;
    transform: translateY(-0.25em) rotateX(0deg);
    text-shadow: 0 0 10px var(--tmd-text, #161616);
  }

  100% {
    opacity: 1;
    transform: translateY(0) rotateX(0deg);
    text-shadow: 0.045em 0.045em 0 var(--tmd-text, black), -0.045em -0.045em 0 var(--tmd-accent, #6600da), 0.045em -0.045em 0 var(--tmd-text, black), -0.045em 0.045em 0 var(--tmd-accent, #6600da);
  }
}`;

  // package.json
  var version = "2.0.0";

  // src/ui-modules/tentaclesModule.ts
  var TentaclesModule = class extends r {
    overrideProperties(context, target) {
      context.element.style.overflow = "hidden";
      context.element.innerHTML += `<div class="tentacle-horror">
    <div class="tentacle">
      <div class="tentacle-detail detail-1"></div>
      <div class="tentacle-detail detail-2"></div>
    </div>
    <div class="tentacle">
      <div class="tentacle-detail detail-1"></div>
    </div>
    <div class="tentacle">
      <div class="tentacle-detail detail-2"></div>
    </div>
    <div class="tentacle">
      <div class="tentacle-detail detail-1"></div>
      <div class="tentacle-detail detail-2"></div>
    </div>
    <div class="tentacle-particle particle-1"></div>
    <div class="tentacle-particle particle-2"></div>
    <div class="tentacle-particle particle-3"></div>
    <div class="tentacle-slime"></div>
  </div>`;
      return context;
    }
  };

  // src/ui-modules/paintTextModule.ts
  var PaintTextModule = class extends r {
    constructor(animation = true) {
      super();
      this.animation = animation;
    }
    effect(context) {
      const text = context.element.textContent;
      const container = context.element;
      container.innerHTML = "";
      text.split("").forEach((letter, index) => {
        const span = document.createElement("span");
        if (this.animation) span.className = "letter";
        else {
          span.style.fontFamily = "Finger Paint";
          span.style.textShadow = "0.045em 0.045em 0 var(--tmd-text, black), -0.045em -0.045em 0 var(--tmd-accent, #6600da), 0.045em -0.045em 0 var(--tmd-text, black), -0.045em 0.045em 0 var(--tmd-accent, #6600da)";
        }
        if (letter === " ") span.innerHTML = "&nbsp;";
        else span.textContent = letter;
        if (this.animation) {
          span.style.animationDelay = `${index * 0.05}s`;
        } else {
          span.style.animation = "";
        }
        container.appendChild(span);
      });
      const space = document.createElement("span");
      space.className = "letter";
      space.innerHTML = "&nbsp;";
      space.style.animationDelay = "0.6s";
      container.appendChild(space);
    }
  };

  // node_modules/.pnpm/class-transformer@0.5.1/node_modules/class-transformer/esm5/enums/transformation-type.enum.js
  var TransformationType;
  (function(TransformationType2) {
    TransformationType2[TransformationType2["PLAIN_TO_CLASS"] = 0] = "PLAIN_TO_CLASS";
    TransformationType2[TransformationType2["CLASS_TO_PLAIN"] = 1] = "CLASS_TO_PLAIN";
    TransformationType2[TransformationType2["CLASS_TO_CLASS"] = 2] = "CLASS_TO_CLASS";
  })(TransformationType || (TransformationType = {}));

  // node_modules/.pnpm/class-transformer@0.5.1/node_modules/class-transformer/esm5/MetadataStorage.js
  var MetadataStorage = (
    /** @class */
    (function() {
      function MetadataStorage3() {
        this._typeMetadatas = /* @__PURE__ */ new Map();
        this._transformMetadatas = /* @__PURE__ */ new Map();
        this._exposeMetadatas = /* @__PURE__ */ new Map();
        this._excludeMetadatas = /* @__PURE__ */ new Map();
        this._ancestorsMap = /* @__PURE__ */ new Map();
      }
      MetadataStorage3.prototype.addTypeMetadata = function(metadata) {
        if (!this._typeMetadatas.has(metadata.target)) {
          this._typeMetadatas.set(metadata.target, /* @__PURE__ */ new Map());
        }
        this._typeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);
      };
      MetadataStorage3.prototype.addTransformMetadata = function(metadata) {
        if (!this._transformMetadatas.has(metadata.target)) {
          this._transformMetadatas.set(metadata.target, /* @__PURE__ */ new Map());
        }
        if (!this._transformMetadatas.get(metadata.target).has(metadata.propertyName)) {
          this._transformMetadatas.get(metadata.target).set(metadata.propertyName, []);
        }
        this._transformMetadatas.get(metadata.target).get(metadata.propertyName).push(metadata);
      };
      MetadataStorage3.prototype.addExposeMetadata = function(metadata) {
        if (!this._exposeMetadatas.has(metadata.target)) {
          this._exposeMetadatas.set(metadata.target, /* @__PURE__ */ new Map());
        }
        this._exposeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);
      };
      MetadataStorage3.prototype.addExcludeMetadata = function(metadata) {
        if (!this._excludeMetadatas.has(metadata.target)) {
          this._excludeMetadatas.set(metadata.target, /* @__PURE__ */ new Map());
        }
        this._excludeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);
      };
      MetadataStorage3.prototype.findTransformMetadatas = function(target, propertyName, transformationType) {
        return this.findMetadatas(this._transformMetadatas, target, propertyName).filter(function(metadata) {
          if (!metadata.options)
            return true;
          if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true)
            return true;
          if (metadata.options.toClassOnly === true) {
            return transformationType === TransformationType.CLASS_TO_CLASS || transformationType === TransformationType.PLAIN_TO_CLASS;
          }
          if (metadata.options.toPlainOnly === true) {
            return transformationType === TransformationType.CLASS_TO_PLAIN;
          }
          return true;
        });
      };
      MetadataStorage3.prototype.findExcludeMetadata = function(target, propertyName) {
        return this.findMetadata(this._excludeMetadatas, target, propertyName);
      };
      MetadataStorage3.prototype.findExposeMetadata = function(target, propertyName) {
        return this.findMetadata(this._exposeMetadatas, target, propertyName);
      };
      MetadataStorage3.prototype.findExposeMetadataByCustomName = function(target, name) {
        return this.getExposedMetadatas(target).find(function(metadata) {
          return metadata.options && metadata.options.name === name;
        });
      };
      MetadataStorage3.prototype.findTypeMetadata = function(target, propertyName) {
        return this.findMetadata(this._typeMetadatas, target, propertyName);
      };
      MetadataStorage3.prototype.getStrategy = function(target) {
        var excludeMap = this._excludeMetadatas.get(target);
        var exclude = excludeMap && excludeMap.get(void 0);
        var exposeMap = this._exposeMetadatas.get(target);
        var expose = exposeMap && exposeMap.get(void 0);
        if (exclude && expose || !exclude && !expose)
          return "none";
        return exclude ? "excludeAll" : "exposeAll";
      };
      MetadataStorage3.prototype.getExposedMetadatas = function(target) {
        return this.getMetadata(this._exposeMetadatas, target);
      };
      MetadataStorage3.prototype.getExcludedMetadatas = function(target) {
        return this.getMetadata(this._excludeMetadatas, target);
      };
      MetadataStorage3.prototype.getExposedProperties = function(target, transformationType) {
        return this.getExposedMetadatas(target).filter(function(metadata) {
          if (!metadata.options)
            return true;
          if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true)
            return true;
          if (metadata.options.toClassOnly === true) {
            return transformationType === TransformationType.CLASS_TO_CLASS || transformationType === TransformationType.PLAIN_TO_CLASS;
          }
          if (metadata.options.toPlainOnly === true) {
            return transformationType === TransformationType.CLASS_TO_PLAIN;
          }
          return true;
        }).map(function(metadata) {
          return metadata.propertyName;
        });
      };
      MetadataStorage3.prototype.getExcludedProperties = function(target, transformationType) {
        return this.getExcludedMetadatas(target).filter(function(metadata) {
          if (!metadata.options)
            return true;
          if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true)
            return true;
          if (metadata.options.toClassOnly === true) {
            return transformationType === TransformationType.CLASS_TO_CLASS || transformationType === TransformationType.PLAIN_TO_CLASS;
          }
          if (metadata.options.toPlainOnly === true) {
            return transformationType === TransformationType.CLASS_TO_PLAIN;
          }
          return true;
        }).map(function(metadata) {
          return metadata.propertyName;
        });
      };
      MetadataStorage3.prototype.clear = function() {
        this._typeMetadatas.clear();
        this._exposeMetadatas.clear();
        this._excludeMetadatas.clear();
        this._ancestorsMap.clear();
      };
      MetadataStorage3.prototype.getMetadata = function(metadatas, target) {
        var metadataFromTargetMap = metadatas.get(target);
        var metadataFromTarget;
        if (metadataFromTargetMap) {
          metadataFromTarget = Array.from(metadataFromTargetMap.values()).filter(function(meta) {
            return meta.propertyName !== void 0;
          });
        }
        var metadataFromAncestors = [];
        for (var _i = 0, _a = this.getAncestors(target); _i < _a.length; _i++) {
          var ancestor = _a[_i];
          var ancestorMetadataMap = metadatas.get(ancestor);
          if (ancestorMetadataMap) {
            var metadataFromAncestor = Array.from(ancestorMetadataMap.values()).filter(function(meta) {
              return meta.propertyName !== void 0;
            });
            metadataFromAncestors.push.apply(metadataFromAncestors, metadataFromAncestor);
          }
        }
        return metadataFromAncestors.concat(metadataFromTarget || []);
      };
      MetadataStorage3.prototype.findMetadata = function(metadatas, target, propertyName) {
        var metadataFromTargetMap = metadatas.get(target);
        if (metadataFromTargetMap) {
          var metadataFromTarget = metadataFromTargetMap.get(propertyName);
          if (metadataFromTarget) {
            return metadataFromTarget;
          }
        }
        for (var _i = 0, _a = this.getAncestors(target); _i < _a.length; _i++) {
          var ancestor = _a[_i];
          var ancestorMetadataMap = metadatas.get(ancestor);
          if (ancestorMetadataMap) {
            var ancestorResult = ancestorMetadataMap.get(propertyName);
            if (ancestorResult) {
              return ancestorResult;
            }
          }
        }
        return void 0;
      };
      MetadataStorage3.prototype.findMetadatas = function(metadatas, target, propertyName) {
        var metadataFromTargetMap = metadatas.get(target);
        var metadataFromTarget;
        if (metadataFromTargetMap) {
          metadataFromTarget = metadataFromTargetMap.get(propertyName);
        }
        var metadataFromAncestorsTarget = [];
        for (var _i = 0, _a = this.getAncestors(target); _i < _a.length; _i++) {
          var ancestor = _a[_i];
          var ancestorMetadataMap = metadatas.get(ancestor);
          if (ancestorMetadataMap) {
            if (ancestorMetadataMap.has(propertyName)) {
              metadataFromAncestorsTarget.push.apply(metadataFromAncestorsTarget, ancestorMetadataMap.get(propertyName));
            }
          }
        }
        return metadataFromAncestorsTarget.slice().reverse().concat((metadataFromTarget || []).slice().reverse());
      };
      MetadataStorage3.prototype.getAncestors = function(target) {
        if (!target)
          return [];
        if (!this._ancestorsMap.has(target)) {
          var ancestors = [];
          for (var baseClass = Object.getPrototypeOf(target.prototype.constructor); typeof baseClass.prototype !== "undefined"; baseClass = Object.getPrototypeOf(baseClass.prototype.constructor)) {
            ancestors.push(baseClass);
          }
          this._ancestorsMap.set(target, ancestors);
        }
        return this._ancestorsMap.get(target);
      };
      return MetadataStorage3;
    })()
  );

  // node_modules/.pnpm/class-transformer@0.5.1/node_modules/class-transformer/esm5/storage.js
  var defaultMetadataStorage = new MetadataStorage();

  // node_modules/.pnpm/class-transformer@0.5.1/node_modules/class-transformer/esm5/utils/get-global.util.js
  function getGlobal() {
    if (typeof globalThis !== "undefined") {
      return globalThis;
    }
    if (typeof global !== "undefined") {
      return global;
    }
    if (typeof window !== "undefined") {
      return window;
    }
    if (typeof self !== "undefined") {
      return self;
    }
  }

  // node_modules/.pnpm/class-transformer@0.5.1/node_modules/class-transformer/esm5/utils/is-promise.util.js
  function isPromise(p4) {
    return p4 !== null && typeof p4 === "object" && typeof p4.then === "function";
  }

  // node_modules/.pnpm/class-transformer@0.5.1/node_modules/class-transformer/esm5/TransformOperationExecutor.js
  var __spreadArray = function(to, from, pack) {
    if (pack || arguments.length === 2) for (var i8 = 0, l5 = from.length, ar; i8 < l5; i8++) {
      if (ar || !(i8 in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i8);
        ar[i8] = from[i8];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  function instantiateArrayType(arrayType) {
    var array = new arrayType();
    if (!(array instanceof Set) && !("push" in array)) {
      return [];
    }
    return array;
  }
  var TransformOperationExecutor = (
    /** @class */
    (function() {
      function TransformOperationExecutor2(transformationType, options) {
        this.transformationType = transformationType;
        this.options = options;
        this.recursionStack = /* @__PURE__ */ new Set();
      }
      TransformOperationExecutor2.prototype.transform = function(source, value, targetType, arrayType, isMap, level) {
        var _this = this;
        if (level === void 0) {
          level = 0;
        }
        if (Array.isArray(value) || value instanceof Set) {
          var newValue_1 = arrayType && this.transformationType === TransformationType.PLAIN_TO_CLASS ? instantiateArrayType(arrayType) : [];
          value.forEach(function(subValue, index) {
            var subSource = source ? source[index] : void 0;
            if (!_this.options.enableCircularCheck || !_this.isCircular(subValue)) {
              var realTargetType = void 0;
              if (typeof targetType !== "function" && targetType && targetType.options && targetType.options.discriminator && targetType.options.discriminator.property && targetType.options.discriminator.subTypes) {
                if (_this.transformationType === TransformationType.PLAIN_TO_CLASS) {
                  realTargetType = targetType.options.discriminator.subTypes.find(function(subType) {
                    return subType.name === subValue[targetType.options.discriminator.property];
                  });
                  var options = { newObject: newValue_1, object: subValue, property: void 0 };
                  var newType = targetType.typeFunction(options);
                  realTargetType === void 0 ? realTargetType = newType : realTargetType = realTargetType.value;
                  if (!targetType.options.keepDiscriminatorProperty)
                    delete subValue[targetType.options.discriminator.property];
                }
                if (_this.transformationType === TransformationType.CLASS_TO_CLASS) {
                  realTargetType = subValue.constructor;
                }
                if (_this.transformationType === TransformationType.CLASS_TO_PLAIN) {
                  subValue[targetType.options.discriminator.property] = targetType.options.discriminator.subTypes.find(function(subType) {
                    return subType.value === subValue.constructor;
                  }).name;
                }
              } else {
                realTargetType = targetType;
              }
              var value_1 = _this.transform(subSource, subValue, realTargetType, void 0, subValue instanceof Map, level + 1);
              if (newValue_1 instanceof Set) {
                newValue_1.add(value_1);
              } else {
                newValue_1.push(value_1);
              }
            } else if (_this.transformationType === TransformationType.CLASS_TO_CLASS) {
              if (newValue_1 instanceof Set) {
                newValue_1.add(subValue);
              } else {
                newValue_1.push(subValue);
              }
            }
          });
          return newValue_1;
        } else if (targetType === String && !isMap) {
          if (value === null || value === void 0)
            return value;
          return String(value);
        } else if (targetType === Number && !isMap) {
          if (value === null || value === void 0)
            return value;
          return Number(value);
        } else if (targetType === Boolean && !isMap) {
          if (value === null || value === void 0)
            return value;
          return Boolean(value);
        } else if ((targetType === Date || value instanceof Date) && !isMap) {
          if (value instanceof Date) {
            return new Date(value.valueOf());
          }
          if (value === null || value === void 0)
            return value;
          return new Date(value);
        } else if (!!getGlobal().Buffer && (targetType === Buffer || value instanceof Buffer) && !isMap) {
          if (value === null || value === void 0)
            return value;
          return Buffer.from(value);
        } else if (isPromise(value) && !isMap) {
          return new Promise(function(resolve, reject) {
            value.then(function(data) {
              return resolve(_this.transform(void 0, data, targetType, void 0, void 0, level + 1));
            }, reject);
          });
        } else if (!isMap && value !== null && typeof value === "object" && typeof value.then === "function") {
          return value;
        } else if (typeof value === "object" && value !== null) {
          if (!targetType && value.constructor !== Object)
            if (!Array.isArray(value) && value.constructor === Array) {
            } else {
              targetType = value.constructor;
            }
          if (!targetType && source)
            targetType = source.constructor;
          if (this.options.enableCircularCheck) {
            this.recursionStack.add(value);
          }
          var keys = this.getKeys(targetType, value, isMap);
          var newValue = source ? source : {};
          if (!source && (this.transformationType === TransformationType.PLAIN_TO_CLASS || this.transformationType === TransformationType.CLASS_TO_CLASS)) {
            if (isMap) {
              newValue = /* @__PURE__ */ new Map();
            } else if (targetType) {
              newValue = new targetType();
            } else {
              newValue = {};
            }
          }
          var _loop_1 = function(key2) {
            if (key2 === "__proto__" || key2 === "constructor") {
              return "continue";
            }
            var valueKey = key2;
            var newValueKey = key2, propertyName = key2;
            if (!this_1.options.ignoreDecorators && targetType) {
              if (this_1.transformationType === TransformationType.PLAIN_TO_CLASS) {
                var exposeMetadata = defaultMetadataStorage.findExposeMetadataByCustomName(targetType, key2);
                if (exposeMetadata) {
                  propertyName = exposeMetadata.propertyName;
                  newValueKey = exposeMetadata.propertyName;
                }
              } else if (this_1.transformationType === TransformationType.CLASS_TO_PLAIN || this_1.transformationType === TransformationType.CLASS_TO_CLASS) {
                var exposeMetadata = defaultMetadataStorage.findExposeMetadata(targetType, key2);
                if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {
                  newValueKey = exposeMetadata.options.name;
                }
              }
            }
            var subValue = void 0;
            if (this_1.transformationType === TransformationType.PLAIN_TO_CLASS) {
              subValue = value[valueKey];
            } else {
              if (value instanceof Map) {
                subValue = value.get(valueKey);
              } else if (value[valueKey] instanceof Function) {
                subValue = value[valueKey]();
              } else {
                subValue = value[valueKey];
              }
            }
            var type = void 0, isSubValueMap = subValue instanceof Map;
            if (targetType && isMap) {
              type = targetType;
            } else if (targetType) {
              var metadata_1 = defaultMetadataStorage.findTypeMetadata(targetType, propertyName);
              if (metadata_1) {
                var options = { newObject: newValue, object: value, property: propertyName };
                var newType = metadata_1.typeFunction ? metadata_1.typeFunction(options) : metadata_1.reflectedType;
                if (metadata_1.options && metadata_1.options.discriminator && metadata_1.options.discriminator.property && metadata_1.options.discriminator.subTypes) {
                  if (!(value[valueKey] instanceof Array)) {
                    if (this_1.transformationType === TransformationType.PLAIN_TO_CLASS) {
                      type = metadata_1.options.discriminator.subTypes.find(function(subType) {
                        if (subValue && subValue instanceof Object && metadata_1.options.discriminator.property in subValue) {
                          return subType.name === subValue[metadata_1.options.discriminator.property];
                        }
                      });
                      type === void 0 ? type = newType : type = type.value;
                      if (!metadata_1.options.keepDiscriminatorProperty) {
                        if (subValue && subValue instanceof Object && metadata_1.options.discriminator.property in subValue) {
                          delete subValue[metadata_1.options.discriminator.property];
                        }
                      }
                    }
                    if (this_1.transformationType === TransformationType.CLASS_TO_CLASS) {
                      type = subValue.constructor;
                    }
                    if (this_1.transformationType === TransformationType.CLASS_TO_PLAIN) {
                      if (subValue) {
                        subValue[metadata_1.options.discriminator.property] = metadata_1.options.discriminator.subTypes.find(function(subType) {
                          return subType.value === subValue.constructor;
                        }).name;
                      }
                    }
                  } else {
                    type = metadata_1;
                  }
                } else {
                  type = newType;
                }
                isSubValueMap = isSubValueMap || metadata_1.reflectedType === Map;
              } else if (this_1.options.targetMaps) {
                this_1.options.targetMaps.filter(function(map) {
                  return map.target === targetType && !!map.properties[propertyName];
                }).forEach(function(map) {
                  return type = map.properties[propertyName];
                });
              } else if (this_1.options.enableImplicitConversion && this_1.transformationType === TransformationType.PLAIN_TO_CLASS) {
                var reflectedType = Reflect.getMetadata("design:type", targetType.prototype, propertyName);
                if (reflectedType) {
                  type = reflectedType;
                }
              }
            }
            var arrayType_1 = Array.isArray(value[valueKey]) ? this_1.getReflectedType(targetType, propertyName) : void 0;
            var subSource = source ? source[valueKey] : void 0;
            if (newValue.constructor.prototype) {
              var descriptor = Object.getOwnPropertyDescriptor(newValue.constructor.prototype, newValueKey);
              if ((this_1.transformationType === TransformationType.PLAIN_TO_CLASS || this_1.transformationType === TransformationType.CLASS_TO_CLASS) && // eslint-disable-next-line @typescript-eslint/unbound-method
              (descriptor && !descriptor.set || newValue[newValueKey] instanceof Function))
                return "continue";
            }
            if (!this_1.options.enableCircularCheck || !this_1.isCircular(subValue)) {
              var transformKey = this_1.transformationType === TransformationType.PLAIN_TO_CLASS ? newValueKey : key2;
              var finalValue = void 0;
              if (this_1.transformationType === TransformationType.CLASS_TO_PLAIN) {
                finalValue = value[transformKey];
                finalValue = this_1.applyCustomTransformations(finalValue, targetType, transformKey, value, this_1.transformationType);
                finalValue = value[transformKey] === finalValue ? subValue : finalValue;
                finalValue = this_1.transform(subSource, finalValue, type, arrayType_1, isSubValueMap, level + 1);
              } else {
                if (subValue === void 0 && this_1.options.exposeDefaultValues) {
                  finalValue = newValue[newValueKey];
                } else {
                  finalValue = this_1.transform(subSource, subValue, type, arrayType_1, isSubValueMap, level + 1);
                  finalValue = this_1.applyCustomTransformations(finalValue, targetType, transformKey, value, this_1.transformationType);
                }
              }
              if (finalValue !== void 0 || this_1.options.exposeUnsetFields) {
                if (newValue instanceof Map) {
                  newValue.set(newValueKey, finalValue);
                } else {
                  newValue[newValueKey] = finalValue;
                }
              }
            } else if (this_1.transformationType === TransformationType.CLASS_TO_CLASS) {
              var finalValue = subValue;
              finalValue = this_1.applyCustomTransformations(finalValue, targetType, key2, value, this_1.transformationType);
              if (finalValue !== void 0 || this_1.options.exposeUnsetFields) {
                if (newValue instanceof Map) {
                  newValue.set(newValueKey, finalValue);
                } else {
                  newValue[newValueKey] = finalValue;
                }
              }
            }
          };
          var this_1 = this;
          for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
            var key = keys_1[_i];
            _loop_1(key);
          }
          if (this.options.enableCircularCheck) {
            this.recursionStack.delete(value);
          }
          return newValue;
        } else {
          return value;
        }
      };
      TransformOperationExecutor2.prototype.applyCustomTransformations = function(value, target, key, obj, transformationType) {
        var _this = this;
        var metadatas = defaultMetadataStorage.findTransformMetadatas(target, key, this.transformationType);
        if (this.options.version !== void 0) {
          metadatas = metadatas.filter(function(metadata) {
            if (!metadata.options)
              return true;
            return _this.checkVersion(metadata.options.since, metadata.options.until);
          });
        }
        if (this.options.groups && this.options.groups.length) {
          metadatas = metadatas.filter(function(metadata) {
            if (!metadata.options)
              return true;
            return _this.checkGroups(metadata.options.groups);
          });
        } else {
          metadatas = metadatas.filter(function(metadata) {
            return !metadata.options || !metadata.options.groups || !metadata.options.groups.length;
          });
        }
        metadatas.forEach(function(metadata) {
          value = metadata.transformFn({ value, key, obj, type: transformationType, options: _this.options });
        });
        return value;
      };
      TransformOperationExecutor2.prototype.isCircular = function(object) {
        return this.recursionStack.has(object);
      };
      TransformOperationExecutor2.prototype.getReflectedType = function(target, propertyName) {
        if (!target)
          return void 0;
        var meta = defaultMetadataStorage.findTypeMetadata(target, propertyName);
        return meta ? meta.reflectedType : void 0;
      };
      TransformOperationExecutor2.prototype.getKeys = function(target, object, isMap) {
        var _this = this;
        var strategy = defaultMetadataStorage.getStrategy(target);
        if (strategy === "none")
          strategy = this.options.strategy || "exposeAll";
        var keys = [];
        if (strategy === "exposeAll" || isMap) {
          if (object instanceof Map) {
            keys = Array.from(object.keys());
          } else {
            keys = Object.keys(object);
          }
        }
        if (isMap) {
          return keys;
        }
        if (this.options.ignoreDecorators && this.options.excludeExtraneousValues && target) {
          var exposedProperties = defaultMetadataStorage.getExposedProperties(target, this.transformationType);
          var excludedProperties = defaultMetadataStorage.getExcludedProperties(target, this.transformationType);
          keys = __spreadArray(__spreadArray([], exposedProperties, true), excludedProperties, true);
        }
        if (!this.options.ignoreDecorators && target) {
          var exposedProperties = defaultMetadataStorage.getExposedProperties(target, this.transformationType);
          if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {
            exposedProperties = exposedProperties.map(function(key) {
              var exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);
              if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {
                return exposeMetadata.options.name;
              }
              return key;
            });
          }
          if (this.options.excludeExtraneousValues) {
            keys = exposedProperties;
          } else {
            keys = keys.concat(exposedProperties);
          }
          var excludedProperties_1 = defaultMetadataStorage.getExcludedProperties(target, this.transformationType);
          if (excludedProperties_1.length > 0) {
            keys = keys.filter(function(key) {
              return !excludedProperties_1.includes(key);
            });
          }
          if (this.options.version !== void 0) {
            keys = keys.filter(function(key) {
              var exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);
              if (!exposeMetadata || !exposeMetadata.options)
                return true;
              return _this.checkVersion(exposeMetadata.options.since, exposeMetadata.options.until);
            });
          }
          if (this.options.groups && this.options.groups.length) {
            keys = keys.filter(function(key) {
              var exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);
              if (!exposeMetadata || !exposeMetadata.options)
                return true;
              return _this.checkGroups(exposeMetadata.options.groups);
            });
          } else {
            keys = keys.filter(function(key) {
              var exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);
              return !exposeMetadata || !exposeMetadata.options || !exposeMetadata.options.groups || !exposeMetadata.options.groups.length;
            });
          }
        }
        if (this.options.excludePrefixes && this.options.excludePrefixes.length) {
          keys = keys.filter(function(key) {
            return _this.options.excludePrefixes.every(function(prefix) {
              return key.substr(0, prefix.length) !== prefix;
            });
          });
        }
        keys = keys.filter(function(key, index, self2) {
          return self2.indexOf(key) === index;
        });
        return keys;
      };
      TransformOperationExecutor2.prototype.checkVersion = function(since, until) {
        var decision = true;
        if (decision && since)
          decision = this.options.version >= since;
        if (decision && until)
          decision = this.options.version < until;
        return decision;
      };
      TransformOperationExecutor2.prototype.checkGroups = function(groups) {
        if (!groups)
          return true;
        return this.options.groups.some(function(optionGroup) {
          return groups.includes(optionGroup);
        });
      };
      return TransformOperationExecutor2;
    })()
  );

  // node_modules/.pnpm/class-transformer@0.5.1/node_modules/class-transformer/esm5/constants/default-options.constant.js
  var defaultOptions = {
    enableCircularCheck: false,
    enableImplicitConversion: false,
    excludeExtraneousValues: false,
    excludePrefixes: void 0,
    exposeDefaultValues: false,
    exposeUnsetFields: true,
    groups: void 0,
    ignoreDecorators: false,
    strategy: void 0,
    targetMaps: void 0,
    version: void 0
  };

  // node_modules/.pnpm/class-transformer@0.5.1/node_modules/class-transformer/esm5/ClassTransformer.js
  var __assign = function() {
    __assign = Object.assign || function(t4) {
      for (var s4, i8 = 1, n5 = arguments.length; i8 < n5; i8++) {
        s4 = arguments[i8];
        for (var p4 in s4) if (Object.prototype.hasOwnProperty.call(s4, p4))
          t4[p4] = s4[p4];
      }
      return t4;
    };
    return __assign.apply(this, arguments);
  };
  var ClassTransformer = (
    /** @class */
    (function() {
      function ClassTransformer2() {
      }
      ClassTransformer2.prototype.instanceToPlain = function(object, options) {
        var executor = new TransformOperationExecutor(TransformationType.CLASS_TO_PLAIN, __assign(__assign({}, defaultOptions), options));
        return executor.transform(void 0, object, void 0, void 0, void 0, void 0);
      };
      ClassTransformer2.prototype.classToPlainFromExist = function(object, plainObject, options) {
        var executor = new TransformOperationExecutor(TransformationType.CLASS_TO_PLAIN, __assign(__assign({}, defaultOptions), options));
        return executor.transform(plainObject, object, void 0, void 0, void 0, void 0);
      };
      ClassTransformer2.prototype.plainToInstance = function(cls, plain, options) {
        var executor = new TransformOperationExecutor(TransformationType.PLAIN_TO_CLASS, __assign(__assign({}, defaultOptions), options));
        return executor.transform(void 0, plain, cls, void 0, void 0, void 0);
      };
      ClassTransformer2.prototype.plainToClassFromExist = function(clsObject, plain, options) {
        var executor = new TransformOperationExecutor(TransformationType.PLAIN_TO_CLASS, __assign(__assign({}, defaultOptions), options));
        return executor.transform(clsObject, plain, void 0, void 0, void 0, void 0);
      };
      ClassTransformer2.prototype.instanceToInstance = function(object, options) {
        var executor = new TransformOperationExecutor(TransformationType.CLASS_TO_CLASS, __assign(__assign({}, defaultOptions), options));
        return executor.transform(void 0, object, void 0, void 0, void 0, void 0);
      };
      ClassTransformer2.prototype.classToClassFromExist = function(object, fromObject, options) {
        var executor = new TransformOperationExecutor(TransformationType.CLASS_TO_CLASS, __assign(__assign({}, defaultOptions), options));
        return executor.transform(fromObject, object, void 0, void 0, void 0, void 0);
      };
      ClassTransformer2.prototype.serialize = function(object, options) {
        return JSON.stringify(this.instanceToPlain(object, options));
      };
      ClassTransformer2.prototype.deserialize = function(cls, json, options) {
        var jsonObject = JSON.parse(json);
        return this.plainToInstance(cls, jsonObject, options);
      };
      ClassTransformer2.prototype.deserializeArray = function(cls, json, options) {
        var jsonObject = JSON.parse(json);
        return this.plainToInstance(cls, jsonObject, options);
      };
      return ClassTransformer2;
    })()
  );

  // node_modules/.pnpm/class-transformer@0.5.1/node_modules/class-transformer/esm5/decorators/type.decorator.js
  function Type(typeFunction, options) {
    if (options === void 0) {
      options = {};
    }
    return function(target, propertyName) {
      var reflectedType = Reflect.getMetadata("design:type", target, propertyName);
      defaultMetadataStorage.addTypeMetadata({
        target: target.constructor,
        propertyName,
        reflectedType,
        typeFunction,
        options
      });
    };
  }

  // node_modules/.pnpm/class-transformer@0.5.1/node_modules/class-transformer/esm5/index.js
  var classTransformer = new ClassTransformer();
  function plainToInstance(cls, plain, options) {
    return classTransformer.plainToInstance(cls, plain, options);
  }

  // node_modules/.pnpm/class-validator@0.14.2/node_modules/class-validator/esm5/metadata/ValidationMetadata.js
  var ValidationMetadata = (
    /** @class */
    /* @__PURE__ */ (function() {
      function ValidationMetadata2(args) {
        this.groups = [];
        this.each = false;
        this.context = void 0;
        this.type = args.type;
        this.name = args.name;
        this.target = args.target;
        this.propertyName = args.propertyName;
        this.constraints = args === null || args === void 0 ? void 0 : args.constraints;
        this.constraintCls = args.constraintCls;
        this.validationTypeOptions = args.validationTypeOptions;
        if (args.validationOptions) {
          this.message = args.validationOptions.message;
          this.groups = args.validationOptions.groups;
          this.always = args.validationOptions.always;
          this.each = args.validationOptions.each;
          this.context = args.validationOptions.context;
        }
      }
      return ValidationMetadata2;
    })()
  );

  // node_modules/.pnpm/class-validator@0.14.2/node_modules/class-validator/esm5/validation-schema/ValidationSchemaToMetadataTransformer.js
  var ValidationSchemaToMetadataTransformer = (
    /** @class */
    (function() {
      function ValidationSchemaToMetadataTransformer2() {
      }
      ValidationSchemaToMetadataTransformer2.prototype.transform = function(schema) {
        var metadatas = [];
        Object.keys(schema.properties).forEach(function(property) {
          schema.properties[property].forEach(function(validation) {
            var validationOptions = {
              message: validation.message,
              groups: validation.groups,
              always: validation.always,
              each: validation.each
            };
            var args = {
              type: validation.type,
              name: validation.name,
              target: schema.name,
              propertyName: property,
              constraints: validation.constraints,
              validationTypeOptions: validation.options,
              validationOptions
            };
            metadatas.push(new ValidationMetadata(args));
          });
        });
        return metadatas;
      };
      return ValidationSchemaToMetadataTransformer2;
    })()
  );

  // node_modules/.pnpm/class-validator@0.14.2/node_modules/class-validator/esm5/utils/convert-to-array.util.js
  function convertToArray(val) {
    if (val instanceof Map) {
      return Array.from(val.values());
    }
    return Array.isArray(val) ? val : Array.from(val);
  }

  // node_modules/.pnpm/class-validator@0.14.2/node_modules/class-validator/esm5/utils/get-global.util.js
  function getGlobal2() {
    if (typeof globalThis !== "undefined") {
      return globalThis;
    }
    if (typeof global !== "undefined") {
      return global;
    }
    if (typeof window !== "undefined") {
      return window;
    }
    if (typeof self !== "undefined") {
      return self;
    }
  }

  // node_modules/.pnpm/class-validator@0.14.2/node_modules/class-validator/esm5/utils/is-promise.util.js
  function isPromise2(p4) {
    return p4 !== null && typeof p4 === "object" && typeof p4.then === "function";
  }

  // node_modules/.pnpm/class-validator@0.14.2/node_modules/class-validator/esm5/metadata/MetadataStorage.js
  var __values = function(o4) {
    var s4 = typeof Symbol === "function" && Symbol.iterator, m5 = s4 && o4[s4], i8 = 0;
    if (m5) return m5.call(o4);
    if (o4 && typeof o4.length === "number") return {
      next: function() {
        if (o4 && i8 >= o4.length) o4 = void 0;
        return { value: o4 && o4[i8++], done: !o4 };
      }
    };
    throw new TypeError(s4 ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var __read = function(o4, n5) {
    var m5 = typeof Symbol === "function" && o4[Symbol.iterator];
    if (!m5) return o4;
    var i8 = m5.call(o4), r5, ar = [], e2;
    try {
      while ((n5 === void 0 || n5-- > 0) && !(r5 = i8.next()).done) ar.push(r5.value);
    } catch (error) {
      e2 = { error };
    } finally {
      try {
        if (r5 && !r5.done && (m5 = i8["return"])) m5.call(i8);
      } finally {
        if (e2) throw e2.error;
      }
    }
    return ar;
  };
  var __spreadArray2 = function(to, from, pack) {
    if (pack || arguments.length === 2) for (var i8 = 0, l5 = from.length, ar; i8 < l5; i8++) {
      if (ar || !(i8 in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i8);
        ar[i8] = from[i8];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  var MetadataStorage2 = (
    /** @class */
    (function() {
      function MetadataStorage3() {
        this.validationMetadatas = /* @__PURE__ */ new Map();
        this.constraintMetadatas = /* @__PURE__ */ new Map();
      }
      Object.defineProperty(MetadataStorage3.prototype, "hasValidationMetaData", {
        get: function() {
          return !!this.validationMetadatas.size;
        },
        enumerable: false,
        configurable: true
      });
      MetadataStorage3.prototype.addValidationSchema = function(schema) {
        var _this = this;
        var validationMetadatas = new ValidationSchemaToMetadataTransformer().transform(schema);
        validationMetadatas.forEach(function(validationMetadata) {
          return _this.addValidationMetadata(validationMetadata);
        });
      };
      MetadataStorage3.prototype.addValidationMetadata = function(metadata) {
        var existingMetadata = this.validationMetadatas.get(metadata.target);
        if (existingMetadata) {
          existingMetadata.push(metadata);
        } else {
          this.validationMetadatas.set(metadata.target, [metadata]);
        }
      };
      MetadataStorage3.prototype.addConstraintMetadata = function(metadata) {
        var existingMetadata = this.constraintMetadatas.get(metadata.target);
        if (existingMetadata) {
          existingMetadata.push(metadata);
        } else {
          this.constraintMetadatas.set(metadata.target, [metadata]);
        }
      };
      MetadataStorage3.prototype.groupByPropertyName = function(metadata) {
        var grouped = {};
        metadata.forEach(function(metadata2) {
          if (!grouped[metadata2.propertyName])
            grouped[metadata2.propertyName] = [];
          grouped[metadata2.propertyName].push(metadata2);
        });
        return grouped;
      };
      MetadataStorage3.prototype.getTargetValidationMetadatas = function(targetConstructor, targetSchema, always, strictGroups, groups) {
        var e_1, _a;
        var includeMetadataBecauseOfAlwaysOption = function(metadata) {
          if (typeof metadata.always !== "undefined")
            return metadata.always;
          if (metadata.groups && metadata.groups.length)
            return false;
          return always;
        };
        var excludeMetadataBecauseOfStrictGroupsOption = function(metadata) {
          if (strictGroups) {
            if (!groups || !groups.length) {
              if (metadata.groups && metadata.groups.length)
                return true;
            }
          }
          return false;
        };
        var filteredForOriginalMetadatasSearch = this.validationMetadatas.get(targetConstructor) || [];
        var originalMetadatas = filteredForOriginalMetadatasSearch.filter(function(metadata) {
          if (metadata.target !== targetConstructor && metadata.target !== targetSchema)
            return false;
          if (includeMetadataBecauseOfAlwaysOption(metadata))
            return true;
          if (excludeMetadataBecauseOfStrictGroupsOption(metadata))
            return false;
          if (groups && groups.length > 0)
            return metadata.groups && !!metadata.groups.find(function(group) {
              return groups.indexOf(group) !== -1;
            });
          return true;
        });
        var filteredForInheritedMetadatasSearch = [];
        try {
          for (var _b = __values(this.validationMetadatas.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
            var _d = __read(_c.value, 2), key = _d[0], value = _d[1];
            if (targetConstructor.prototype instanceof key) {
              filteredForInheritedMetadatasSearch.push.apply(filteredForInheritedMetadatasSearch, __spreadArray2([], __read(value), false));
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        var inheritedMetadatas = filteredForInheritedMetadatasSearch.filter(function(metadata) {
          if (typeof metadata.target === "string")
            return false;
          if (metadata.target === targetConstructor)
            return false;
          if (metadata.target instanceof Function && !(targetConstructor.prototype instanceof metadata.target))
            return false;
          if (includeMetadataBecauseOfAlwaysOption(metadata))
            return true;
          if (excludeMetadataBecauseOfStrictGroupsOption(metadata))
            return false;
          if (groups && groups.length > 0)
            return metadata.groups && !!metadata.groups.find(function(group) {
              return groups.indexOf(group) !== -1;
            });
          return true;
        });
        var uniqueInheritedMetadatas = inheritedMetadatas.filter(function(inheritedMetadata) {
          return !originalMetadatas.find(function(originalMetadata) {
            return originalMetadata.propertyName === inheritedMetadata.propertyName && originalMetadata.type === inheritedMetadata.type;
          });
        });
        return originalMetadatas.concat(uniqueInheritedMetadatas);
      };
      MetadataStorage3.prototype.getTargetValidatorConstraints = function(target) {
        return this.constraintMetadatas.get(target) || [];
      };
      return MetadataStorage3;
    })()
  );
  function getMetadataStorage() {
    var global2 = getGlobal2();
    if (!global2.classValidatorMetadataStorage) {
      global2.classValidatorMetadataStorage = new MetadataStorage2();
    }
    return global2.classValidatorMetadataStorage;
  }

  // node_modules/.pnpm/class-validator@0.14.2/node_modules/class-validator/esm5/validation/ValidationError.js
  var ValidationError = (
    /** @class */
    (function() {
      function ValidationError2() {
      }
      ValidationError2.prototype.toString = function(shouldDecorate, hasParent, parentPath, showConstraintMessages) {
        var _this = this;
        if (shouldDecorate === void 0) {
          shouldDecorate = false;
        }
        if (hasParent === void 0) {
          hasParent = false;
        }
        if (parentPath === void 0) {
          parentPath = "";
        }
        if (showConstraintMessages === void 0) {
          showConstraintMessages = false;
        }
        var boldStart = shouldDecorate ? "\x1B[1m" : "";
        var boldEnd = shouldDecorate ? "\x1B[22m" : "";
        var constraintsToString = function() {
          var _a;
          return (showConstraintMessages ? Object.values : Object.keys)((_a = _this.constraints) !== null && _a !== void 0 ? _a : {}).join(", ");
        };
        var propConstraintFailed = function(propertyName) {
          return " - property ".concat(boldStart).concat(parentPath).concat(propertyName).concat(boldEnd, " has failed the following constraints: ").concat(boldStart).concat(constraintsToString()).concat(boldEnd, " \n");
        };
        if (!hasParent) {
          return "An instance of ".concat(boldStart).concat(this.target ? this.target.constructor.name : "an object").concat(boldEnd, " has failed the validation:\n") + (this.constraints ? propConstraintFailed(this.property) : "") + (this.children ? this.children.map(function(childError) {
            return childError.toString(shouldDecorate, true, _this.property, showConstraintMessages);
          }).join("") : "");
        } else {
          var formattedProperty_1 = Number.isInteger(+this.property) ? "[".concat(this.property, "]") : "".concat(parentPath ? "." : "").concat(this.property);
          if (this.constraints) {
            return propConstraintFailed(formattedProperty_1);
          } else {
            return this.children ? this.children.map(function(childError) {
              return childError.toString(shouldDecorate, true, "".concat(parentPath).concat(formattedProperty_1), showConstraintMessages);
            }).join("") : "";
          }
        }
      };
      return ValidationError2;
    })()
  );

  // node_modules/.pnpm/class-validator@0.14.2/node_modules/class-validator/esm5/validation/ValidationTypes.js
  var ValidationTypes = (
    /** @class */
    (function() {
      function ValidationTypes2() {
      }
      ValidationTypes2.isValid = function(type) {
        var _this = this;
        return type !== "isValid" && type !== "getMessage" && Object.keys(this).map(function(key) {
          return _this[key];
        }).indexOf(type) !== -1;
      };
      ValidationTypes2.CUSTOM_VALIDATION = "customValidation";
      ValidationTypes2.NESTED_VALIDATION = "nestedValidation";
      ValidationTypes2.PROMISE_VALIDATION = "promiseValidation";
      ValidationTypes2.CONDITIONAL_VALIDATION = "conditionalValidation";
      ValidationTypes2.WHITELIST = "whitelistValidation";
      ValidationTypes2.IS_DEFINED = "isDefined";
      return ValidationTypes2;
    })()
  );

  // node_modules/.pnpm/class-validator@0.14.2/node_modules/class-validator/esm5/validation/ValidationUtils.js
  function constraintToString(constraint) {
    if (Array.isArray(constraint)) {
      return constraint.join(", ");
    }
    if (typeof constraint === "symbol") {
      constraint = constraint.description;
    }
    return "".concat(constraint);
  }
  var ValidationUtils = (
    /** @class */
    (function() {
      function ValidationUtils2() {
      }
      ValidationUtils2.replaceMessageSpecialTokens = function(message, validationArguments) {
        var messageString;
        if (message instanceof Function) {
          messageString = message(validationArguments);
        } else if (typeof message === "string") {
          messageString = message;
        }
        if (messageString && Array.isArray(validationArguments.constraints)) {
          validationArguments.constraints.forEach(function(constraint, index) {
            messageString = messageString.replace(new RegExp("\\$constraint".concat(index + 1), "g"), constraintToString(constraint));
          });
        }
        if (messageString && validationArguments.value !== void 0 && validationArguments.value !== null && ["string", "boolean", "number"].includes(typeof validationArguments.value))
          messageString = messageString.replace(/\$value/g, validationArguments.value);
        if (messageString)
          messageString = messageString.replace(/\$property/g, validationArguments.property);
        if (messageString)
          messageString = messageString.replace(/\$target/g, validationArguments.targetName);
        return messageString;
      };
      return ValidationUtils2;
    })()
  );

  // node_modules/.pnpm/class-validator@0.14.2/node_modules/class-validator/esm5/validation/ValidationExecutor.js
  var __read2 = function(o4, n5) {
    var m5 = typeof Symbol === "function" && o4[Symbol.iterator];
    if (!m5) return o4;
    var i8 = m5.call(o4), r5, ar = [], e2;
    try {
      while ((n5 === void 0 || n5-- > 0) && !(r5 = i8.next()).done) ar.push(r5.value);
    } catch (error) {
      e2 = { error };
    } finally {
      try {
        if (r5 && !r5.done && (m5 = i8["return"])) m5.call(i8);
      } finally {
        if (e2) throw e2.error;
      }
    }
    return ar;
  };
  var ValidationExecutor = (
    /** @class */
    (function() {
      function ValidationExecutor2(validator, validatorOptions) {
        this.validator = validator;
        this.validatorOptions = validatorOptions;
        this.awaitingPromises = [];
        this.ignoreAsyncValidations = false;
        this.metadataStorage = getMetadataStorage();
      }
      ValidationExecutor2.prototype.execute = function(object, targetSchema, validationErrors) {
        var _this = this;
        var _a, _b;
        if (!this.metadataStorage.hasValidationMetaData && ((_a = this.validatorOptions) === null || _a === void 0 ? void 0 : _a.enableDebugMessages) === true) {
          console.warn("No validation metadata found. No validation will be  performed. There are multiple possible reasons:\n  - There may be multiple class-validator versions installed. You will need to flatten your dependencies to fix the issue.\n  - This validation runs before any file with validation decorator was parsed by NodeJS.");
        }
        var groups = this.validatorOptions ? this.validatorOptions.groups : void 0;
        var strictGroups = this.validatorOptions && this.validatorOptions.strictGroups || false;
        var always = this.validatorOptions && this.validatorOptions.always || false;
        var forbidUnknownValues = ((_b = this.validatorOptions) === null || _b === void 0 ? void 0 : _b.forbidUnknownValues) === void 0 || this.validatorOptions.forbidUnknownValues !== false;
        var targetMetadatas = this.metadataStorage.getTargetValidationMetadatas(object.constructor, targetSchema, always, strictGroups, groups);
        var groupedMetadatas = this.metadataStorage.groupByPropertyName(targetMetadatas);
        if (forbidUnknownValues && !targetMetadatas.length) {
          var validationError = new ValidationError();
          if (!this.validatorOptions || !this.validatorOptions.validationError || this.validatorOptions.validationError.target === void 0 || this.validatorOptions.validationError.target === true)
            validationError.target = object;
          validationError.value = void 0;
          validationError.property = void 0;
          validationError.children = [];
          validationError.constraints = { unknownValue: "an unknown value was passed to the validate function" };
          validationErrors.push(validationError);
          return;
        }
        if (this.validatorOptions && this.validatorOptions.whitelist)
          this.whitelist(object, groupedMetadatas, validationErrors);
        Object.keys(groupedMetadatas).forEach(function(propertyName) {
          var value = object[propertyName];
          var definedMetadatas = groupedMetadatas[propertyName].filter(function(metadata) {
            return metadata.type === ValidationTypes.IS_DEFINED;
          });
          var metadatas = groupedMetadatas[propertyName].filter(function(metadata) {
            return metadata.type !== ValidationTypes.IS_DEFINED && metadata.type !== ValidationTypes.WHITELIST;
          });
          if (value instanceof Promise && metadatas.find(function(metadata) {
            return metadata.type === ValidationTypes.PROMISE_VALIDATION;
          })) {
            _this.awaitingPromises.push(value.then(function(resolvedValue) {
              _this.performValidations(object, resolvedValue, propertyName, definedMetadatas, metadatas, validationErrors);
            }));
          } else {
            _this.performValidations(object, value, propertyName, definedMetadatas, metadatas, validationErrors);
          }
        });
      };
      ValidationExecutor2.prototype.whitelist = function(object, groupedMetadatas, validationErrors) {
        var _this = this;
        var notAllowedProperties = [];
        Object.keys(object).forEach(function(propertyName) {
          if (!groupedMetadatas[propertyName] || groupedMetadatas[propertyName].length === 0)
            notAllowedProperties.push(propertyName);
        });
        if (notAllowedProperties.length > 0) {
          if (this.validatorOptions && this.validatorOptions.forbidNonWhitelisted) {
            notAllowedProperties.forEach(function(property) {
              var _a;
              var validationError = _this.generateValidationError(object, object[property], property);
              validationError.constraints = (_a = {}, _a[ValidationTypes.WHITELIST] = "property ".concat(property, " should not exist"), _a);
              validationError.children = void 0;
              validationErrors.push(validationError);
            });
          } else {
            notAllowedProperties.forEach(function(property) {
              return delete object[property];
            });
          }
        }
      };
      ValidationExecutor2.prototype.stripEmptyErrors = function(errors) {
        var _this = this;
        return errors.filter(function(error) {
          if (error.children) {
            error.children = _this.stripEmptyErrors(error.children);
          }
          if (Object.keys(error.constraints).length === 0) {
            if (error.children.length === 0) {
              return false;
            } else {
              delete error.constraints;
            }
          }
          return true;
        });
      };
      ValidationExecutor2.prototype.performValidations = function(object, value, propertyName, definedMetadatas, metadatas, validationErrors) {
        var customValidationMetadatas = metadatas.filter(function(metadata) {
          return metadata.type === ValidationTypes.CUSTOM_VALIDATION;
        });
        var nestedValidationMetadatas = metadatas.filter(function(metadata) {
          return metadata.type === ValidationTypes.NESTED_VALIDATION;
        });
        var conditionalValidationMetadatas = metadatas.filter(function(metadata) {
          return metadata.type === ValidationTypes.CONDITIONAL_VALIDATION;
        });
        var validationError = this.generateValidationError(object, value, propertyName);
        validationErrors.push(validationError);
        var canValidate = this.conditionalValidations(object, value, conditionalValidationMetadatas);
        if (!canValidate) {
          return;
        }
        this.customValidations(object, value, definedMetadatas, validationError);
        this.mapContexts(object, value, definedMetadatas, validationError);
        if (value === void 0 && this.validatorOptions && this.validatorOptions.skipUndefinedProperties === true) {
          return;
        }
        if (value === null && this.validatorOptions && this.validatorOptions.skipNullProperties === true) {
          return;
        }
        if ((value === null || value === void 0) && this.validatorOptions && this.validatorOptions.skipMissingProperties === true) {
          return;
        }
        this.customValidations(object, value, customValidationMetadatas, validationError);
        this.nestedValidations(value, nestedValidationMetadatas, validationError);
        this.mapContexts(object, value, metadatas, validationError);
        this.mapContexts(object, value, customValidationMetadatas, validationError);
      };
      ValidationExecutor2.prototype.generateValidationError = function(object, value, propertyName) {
        var validationError = new ValidationError();
        if (!this.validatorOptions || !this.validatorOptions.validationError || this.validatorOptions.validationError.target === void 0 || this.validatorOptions.validationError.target === true)
          validationError.target = object;
        if (!this.validatorOptions || !this.validatorOptions.validationError || this.validatorOptions.validationError.value === void 0 || this.validatorOptions.validationError.value === true)
          validationError.value = value;
        validationError.property = propertyName;
        validationError.children = [];
        validationError.constraints = {};
        return validationError;
      };
      ValidationExecutor2.prototype.conditionalValidations = function(object, value, metadatas) {
        return metadatas.map(function(metadata) {
          return metadata.constraints[0](object, value);
        }).reduce(function(resultA, resultB) {
          return resultA && resultB;
        }, true);
      };
      ValidationExecutor2.prototype.customValidations = function(object, value, metadatas, error) {
        var _this = this;
        metadatas.forEach(function(metadata) {
          _this.metadataStorage.getTargetValidatorConstraints(metadata.constraintCls).forEach(function(customConstraintMetadata) {
            if (customConstraintMetadata.async && _this.ignoreAsyncValidations)
              return;
            if (_this.validatorOptions && _this.validatorOptions.stopAtFirstError && Object.keys(error.constraints || {}).length > 0)
              return;
            var validationArguments = {
              targetName: object.constructor ? object.constructor.name : void 0,
              property: metadata.propertyName,
              object,
              value,
              constraints: metadata.constraints
            };
            if (!metadata.each || !(Array.isArray(value) || value instanceof Set || value instanceof Map)) {
              var validatedValue = customConstraintMetadata.instance.validate(value, validationArguments);
              if (isPromise2(validatedValue)) {
                var promise = validatedValue.then(function(isValid) {
                  if (!isValid) {
                    var _a2 = __read2(_this.createValidationError(object, value, metadata, customConstraintMetadata), 2), type2 = _a2[0], message2 = _a2[1];
                    error.constraints[type2] = message2;
                    if (metadata.context) {
                      if (!error.contexts) {
                        error.contexts = {};
                      }
                      error.contexts[type2] = Object.assign(error.contexts[type2] || {}, metadata.context);
                    }
                  }
                });
                _this.awaitingPromises.push(promise);
              } else {
                if (!validatedValue) {
                  var _a = __read2(_this.createValidationError(object, value, metadata, customConstraintMetadata), 2), type = _a[0], message = _a[1];
                  error.constraints[type] = message;
                }
              }
              return;
            }
            var arrayValue = convertToArray(value);
            var validatedSubValues = arrayValue.map(function(subValue) {
              return customConstraintMetadata.instance.validate(subValue, validationArguments);
            });
            var validationIsAsync = validatedSubValues.some(function(validatedSubValue) {
              return isPromise2(validatedSubValue);
            });
            if (validationIsAsync) {
              var asyncValidatedSubValues = validatedSubValues.map(function(validatedSubValue) {
                return isPromise2(validatedSubValue) ? validatedSubValue : Promise.resolve(validatedSubValue);
              });
              var asyncValidationIsFinishedPromise = Promise.all(asyncValidatedSubValues).then(function(flatValidatedValues) {
                var validationResult2 = flatValidatedValues.every(function(isValid) {
                  return isValid;
                });
                if (!validationResult2) {
                  var _a2 = __read2(_this.createValidationError(object, value, metadata, customConstraintMetadata), 2), type2 = _a2[0], message2 = _a2[1];
                  error.constraints[type2] = message2;
                  if (metadata.context) {
                    if (!error.contexts) {
                      error.contexts = {};
                    }
                    error.contexts[type2] = Object.assign(error.contexts[type2] || {}, metadata.context);
                  }
                }
              });
              _this.awaitingPromises.push(asyncValidationIsFinishedPromise);
              return;
            }
            var validationResult = validatedSubValues.every(function(isValid) {
              return isValid;
            });
            if (!validationResult) {
              var _b = __read2(_this.createValidationError(object, value, metadata, customConstraintMetadata), 2), type = _b[0], message = _b[1];
              error.constraints[type] = message;
            }
          });
        });
      };
      ValidationExecutor2.prototype.nestedValidations = function(value, metadatas, error) {
        var _this = this;
        if (value === void 0) {
          return;
        }
        metadatas.forEach(function(metadata) {
          if (metadata.type !== ValidationTypes.NESTED_VALIDATION && metadata.type !== ValidationTypes.PROMISE_VALIDATION) {
            return;
          } else if (_this.validatorOptions && _this.validatorOptions.stopAtFirstError && Object.keys(error.constraints || {}).length > 0) {
            return;
          }
          if (Array.isArray(value) || value instanceof Set || value instanceof Map) {
            var arrayLikeValue = value instanceof Set ? Array.from(value) : value;
            arrayLikeValue.forEach(function(subValue, index) {
              _this.performValidations(value, subValue, index.toString(), [], metadatas, error.children);
            });
          } else if (value instanceof Object) {
            var targetSchema = typeof metadata.target === "string" ? metadata.target : metadata.target.name;
            _this.execute(value, targetSchema, error.children);
          } else {
            var _a = __read2(_this.createValidationError(metadata.target, value, metadata), 2), type = _a[0], message = _a[1];
            error.constraints[type] = message;
          }
        });
      };
      ValidationExecutor2.prototype.mapContexts = function(object, value, metadatas, error) {
        var _this = this;
        return metadatas.forEach(function(metadata) {
          if (metadata.context) {
            var customConstraint = void 0;
            if (metadata.type === ValidationTypes.CUSTOM_VALIDATION) {
              var customConstraints = _this.metadataStorage.getTargetValidatorConstraints(metadata.constraintCls);
              customConstraint = customConstraints[0];
            }
            var type = _this.getConstraintType(metadata, customConstraint);
            if (error.constraints[type]) {
              if (!error.contexts) {
                error.contexts = {};
              }
              error.contexts[type] = Object.assign(error.contexts[type] || {}, metadata.context);
            }
          }
        });
      };
      ValidationExecutor2.prototype.createValidationError = function(object, value, metadata, customValidatorMetadata) {
        var targetName = object.constructor ? object.constructor.name : void 0;
        var type = this.getConstraintType(metadata, customValidatorMetadata);
        var validationArguments = {
          targetName,
          property: metadata.propertyName,
          object,
          value,
          constraints: metadata.constraints
        };
        var message = metadata.message || "";
        if (!metadata.message && (!this.validatorOptions || this.validatorOptions && !this.validatorOptions.dismissDefaultMessages)) {
          if (customValidatorMetadata && customValidatorMetadata.instance.defaultMessage instanceof Function) {
            message = customValidatorMetadata.instance.defaultMessage(validationArguments);
          }
        }
        var messageString = ValidationUtils.replaceMessageSpecialTokens(message, validationArguments);
        return [type, messageString];
      };
      ValidationExecutor2.prototype.getConstraintType = function(metadata, customValidatorMetadata) {
        var type = customValidatorMetadata && customValidatorMetadata.name ? customValidatorMetadata.name : metadata.type;
        return type;
      };
      return ValidationExecutor2;
    })()
  );

  // node_modules/.pnpm/class-validator@0.14.2/node_modules/class-validator/esm5/validation/Validator.js
  var __awaiter = function(thisArg, _arguments, P5, generator) {
    function adopt(value) {
      return value instanceof P5 ? value : new P5(function(resolve) {
        resolve(value);
      });
    }
    return new (P5 || (P5 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = function(thisArg, body) {
    var _4 = { label: 0, sent: function() {
      if (t4[0] & 1) throw t4[1];
      return t4[1];
    }, trys: [], ops: [] }, f6, y5, t4, g5;
    return g5 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g5[Symbol.iterator] = function() {
      return this;
    }), g5;
    function verb(n5) {
      return function(v3) {
        return step([n5, v3]);
      };
    }
    function step(op) {
      if (f6) throw new TypeError("Generator is already executing.");
      while (g5 && (g5 = 0, op[0] && (_4 = 0)), _4) try {
        if (f6 = 1, y5 && (t4 = op[0] & 2 ? y5["return"] : op[0] ? y5["throw"] || ((t4 = y5["return"]) && t4.call(y5), 0) : y5.next) && !(t4 = t4.call(y5, op[1])).done) return t4;
        if (y5 = 0, t4) op = [op[0] & 2, t4.value];
        switch (op[0]) {
          case 0:
          case 1:
            t4 = op;
            break;
          case 4:
            _4.label++;
            return { value: op[1], done: false };
          case 5:
            _4.label++;
            y5 = op[1];
            op = [0];
            continue;
          case 7:
            op = _4.ops.pop();
            _4.trys.pop();
            continue;
          default:
            if (!(t4 = _4.trys, t4 = t4.length > 0 && t4[t4.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _4 = 0;
              continue;
            }
            if (op[0] === 3 && (!t4 || op[1] > t4[0] && op[1] < t4[3])) {
              _4.label = op[1];
              break;
            }
            if (op[0] === 6 && _4.label < t4[1]) {
              _4.label = t4[1];
              t4 = op;
              break;
            }
            if (t4 && _4.label < t4[2]) {
              _4.label = t4[2];
              _4.ops.push(op);
              break;
            }
            if (t4[2]) _4.ops.pop();
            _4.trys.pop();
            continue;
        }
        op = body.call(thisArg, _4);
      } catch (e2) {
        op = [6, e2];
        y5 = 0;
      } finally {
        f6 = t4 = 0;
      }
      if (op[0] & 5) throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  };
  var Validator = (
    /** @class */
    (function() {
      function Validator2() {
      }
      Validator2.prototype.validate = function(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions) {
        return this.coreValidate(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions);
      };
      Validator2.prototype.validateOrReject = function(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions) {
        return __awaiter(this, void 0, void 0, function() {
          var errors;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.coreValidate(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions)];
              case 1:
                errors = _a.sent();
                if (errors.length)
                  return [2, Promise.reject(errors)];
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      Validator2.prototype.validateSync = function(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions) {
        var object = typeof objectOrSchemaName === "string" ? objectOrValidationOptions : objectOrSchemaName;
        var options = typeof objectOrSchemaName === "string" ? maybeValidatorOptions : objectOrValidationOptions;
        var schema = typeof objectOrSchemaName === "string" ? objectOrSchemaName : void 0;
        var executor = new ValidationExecutor(this, options);
        executor.ignoreAsyncValidations = true;
        var validationErrors = [];
        executor.execute(object, schema, validationErrors);
        return executor.stripEmptyErrors(validationErrors);
      };
      Validator2.prototype.coreValidate = function(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions) {
        var object = typeof objectOrSchemaName === "string" ? objectOrValidationOptions : objectOrSchemaName;
        var options = typeof objectOrSchemaName === "string" ? maybeValidatorOptions : objectOrValidationOptions;
        var schema = typeof objectOrSchemaName === "string" ? objectOrSchemaName : void 0;
        var executor = new ValidationExecutor(this, options);
        var validationErrors = [];
        executor.execute(object, schema, validationErrors);
        return Promise.all(executor.awaitingPromises).then(function() {
          return executor.stripEmptyErrors(validationErrors);
        });
      };
      return Validator2;
    })()
  );

  // node_modules/.pnpm/class-validator@0.14.2/node_modules/class-validator/esm5/container.js
  var defaultContainer = new /** @class */
  ((function() {
    function class_1() {
      this.instances = [];
    }
    class_1.prototype.get = function(someClass) {
      var instance = this.instances.find(function(instance2) {
        return instance2.type === someClass;
      });
      if (!instance) {
        instance = { type: someClass, object: new someClass() };
        this.instances.push(instance);
      }
      return instance.object;
    };
    return class_1;
  })())();
  var userContainer;
  var userContainerOptions;
  function getFromContainer(someClass) {
    if (userContainer) {
      try {
        var instance = userContainer.get(someClass);
        if (instance)
          return instance;
        if (!userContainerOptions || !userContainerOptions.fallback)
          return instance;
      } catch (error) {
        if (!userContainerOptions || !userContainerOptions.fallbackOnErrors)
          throw error;
      }
    }
    return defaultContainer.get(someClass);
  }

  // node_modules/.pnpm/class-validator@0.14.2/node_modules/class-validator/esm5/metadata/ConstraintMetadata.js
  var ConstraintMetadata = (
    /** @class */
    (function() {
      function ConstraintMetadata2(target, name, async) {
        if (async === void 0) {
          async = false;
        }
        this.target = target;
        this.name = name;
        this.async = async;
      }
      Object.defineProperty(ConstraintMetadata2.prototype, "instance", {
        // -------------------------------------------------------------------------
        // Accessors
        // -------------------------------------------------------------------------
        /**
         * Instance of the target custom validation class which performs validation.
         */
        get: function() {
          return getFromContainer(this.target);
        },
        enumerable: false,
        configurable: true
      });
      return ConstraintMetadata2;
    })()
  );

  // node_modules/.pnpm/class-validator@0.14.2/node_modules/class-validator/esm5/register-decorator.js
  function registerDecorator(options) {
    var constraintCls;
    if (options.validator instanceof Function) {
      constraintCls = options.validator;
      var constraintClasses = getFromContainer(MetadataStorage2).getTargetValidatorConstraints(options.validator);
      if (constraintClasses.length > 1) {
        throw "More than one implementation of ValidatorConstraintInterface found for validator on: ".concat(options.target.name, ":").concat(options.propertyName);
      }
    } else {
      var validator_1 = options.validator;
      constraintCls = /** @class */
      (function() {
        function CustomConstraint() {
        }
        CustomConstraint.prototype.validate = function(value, validationArguments) {
          return validator_1.validate(value, validationArguments);
        };
        CustomConstraint.prototype.defaultMessage = function(validationArguments) {
          if (validator_1.defaultMessage) {
            return validator_1.defaultMessage(validationArguments);
          }
          return "";
        };
        return CustomConstraint;
      })();
      getMetadataStorage().addConstraintMetadata(new ConstraintMetadata(constraintCls, options.name, options.async));
    }
    var validationMetadataArgs = {
      type: options.name && ValidationTypes.isValid(options.name) ? options.name : ValidationTypes.CUSTOM_VALIDATION,
      name: options.name,
      target: options.target,
      propertyName: options.propertyName,
      validationOptions: options.options,
      constraintCls,
      constraints: options.constraints
    };
    getMetadataStorage().addValidationMetadata(new ValidationMetadata(validationMetadataArgs));
  }

  // node_modules/.pnpm/class-validator@0.14.2/node_modules/class-validator/esm5/decorator/common/ValidateBy.js
  function buildMessage(impl, validationOptions) {
    return function(validationArguments) {
      var eachPrefix = validationOptions && validationOptions.each ? "each value in " : "";
      return impl(eachPrefix, validationArguments);
    };
  }
  function ValidateBy(options, validationOptions) {
    return function(object, propertyName) {
      registerDecorator({
        name: options.name,
        target: object.constructor,
        propertyName,
        options: validationOptions,
        constraints: options.constraints,
        validator: options.validator
      });
    };
  }

  // node_modules/.pnpm/class-validator@0.14.2/node_modules/class-validator/esm5/decorator/common/ValidateIf.js
  function ValidateIf(condition, validationOptions) {
    return function(object, propertyName) {
      var args = {
        type: ValidationTypes.CONDITIONAL_VALIDATION,
        target: object.constructor,
        propertyName,
        constraints: [condition],
        validationOptions
      };
      getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));
    };
  }

  // node_modules/.pnpm/class-validator@0.14.2/node_modules/class-validator/esm5/decorator/common/ValidateNested.js
  var __assign2 = function() {
    __assign2 = Object.assign || function(t4) {
      for (var s4, i8 = 1, n5 = arguments.length; i8 < n5; i8++) {
        s4 = arguments[i8];
        for (var p4 in s4) if (Object.prototype.hasOwnProperty.call(s4, p4))
          t4[p4] = s4[p4];
      }
      return t4;
    };
    return __assign2.apply(this, arguments);
  };
  function ValidateNested(validationOptions) {
    var opts = __assign2({}, validationOptions);
    var eachPrefix = opts.each ? "each value in " : "";
    opts.message = opts.message || eachPrefix + "nested property $property must be either object or array";
    return function(object, propertyName) {
      var args = {
        type: ValidationTypes.NESTED_VALIDATION,
        target: object.constructor,
        propertyName,
        validationOptions: opts
      };
      getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));
    };
  }

  // node_modules/.pnpm/class-validator@0.14.2/node_modules/class-validator/esm5/decorator/common/IsIn.js
  var IS_IN = "isIn";
  function isIn(value, possibleValues) {
    return Array.isArray(possibleValues) && possibleValues.some(function(possibleValue) {
      return possibleValue === value;
    });
  }
  function IsIn(values, validationOptions) {
    return ValidateBy({
      name: IS_IN,
      constraints: [values],
      validator: {
        validate: function(value, args) {
          return isIn(value, args === null || args === void 0 ? void 0 : args.constraints[0]);
        },
        defaultMessage: buildMessage(function(eachPrefix) {
          return eachPrefix + "$property must be one of the following values: $constraint1";
        }, validationOptions)
      }
    }, validationOptions);
  }

  // node_modules/.pnpm/class-validator@0.14.2/node_modules/class-validator/esm5/decorator/typechecker/IsNumber.js
  var IS_NUMBER = "isNumber";
  function isNumber(value, options) {
    if (options === void 0) {
      options = {};
    }
    if (typeof value !== "number") {
      return false;
    }
    if (value === Infinity || value === -Infinity) {
      return !!options.allowInfinity;
    }
    if (Number.isNaN(value)) {
      return !!options.allowNaN;
    }
    if (options.maxDecimalPlaces !== void 0) {
      var decimalPlaces = 0;
      if (value % 1 !== 0) {
        decimalPlaces = value.toString().split(".")[1].length;
      }
      if (decimalPlaces > options.maxDecimalPlaces) {
        return false;
      }
    }
    return Number.isFinite(value);
  }
  function IsNumber(options, validationOptions) {
    if (options === void 0) {
      options = {};
    }
    return ValidateBy({
      name: IS_NUMBER,
      constraints: [options],
      validator: {
        validate: function(value, args) {
          return isNumber(value, args === null || args === void 0 ? void 0 : args.constraints[0]);
        },
        defaultMessage: buildMessage(function(eachPrefix) {
          return eachPrefix + "$property must be a number conforming to the specified constraints";
        }, validationOptions)
      }
    }, validationOptions);
  }

  // node_modules/.pnpm/class-validator@0.14.2/node_modules/class-validator/esm5/decorator/typechecker/IsEnum.js
  function isEnum(value, entity) {
    var enumValues = Object.keys(entity).map(function(k4) {
      return entity[k4];
    });
    return enumValues.includes(value);
  }

  // node_modules/.pnpm/class-validator@0.14.2/node_modules/class-validator/esm5/decorator/typechecker/IsString.js
  var IS_STRING = "isString";
  function isString(value) {
    return value instanceof String || typeof value === "string";
  }
  function IsString(validationOptions) {
    return ValidateBy({
      name: IS_STRING,
      validator: {
        validate: function(value, args) {
          return isString(value);
        },
        defaultMessage: buildMessage(function(eachPrefix) {
          return eachPrefix + "$property must be a string";
        }, validationOptions)
      }
    }, validationOptions);
  }

  // node_modules/.pnpm/class-validator@0.14.2/node_modules/class-validator/esm5/decorator/typechecker/IsObject.js
  var IS_OBJECT = "isObject";
  function isObject(value) {
    return value != null && (typeof value === "object" || typeof value === "function") && !Array.isArray(value);
  }
  function IsObject(validationOptions) {
    return ValidateBy({
      name: IS_OBJECT,
      validator: {
        validate: function(value, args) {
          return isObject(value);
        },
        defaultMessage: buildMessage(function(eachPrefix) {
          return eachPrefix + "$property must be an object";
        }, validationOptions)
      }
    }, validationOptions);
  }

  // node_modules/.pnpm/class-validator@0.14.2/node_modules/class-validator/esm5/index.js
  function validate(schemaNameOrObject, objectOrValidationOptions, maybeValidatorOptions) {
    if (typeof schemaNameOrObject === "string") {
      return getFromContainer(Validator).validate(schemaNameOrObject, objectOrValidationOptions, maybeValidatorOptions);
    } else {
      return getFromContainer(Validator).validate(schemaNameOrObject, objectOrValidationOptions);
    }
  }

  // node_modules/.pnpm/zois-core@1.1.6/node_modules/zois-core/dist/validation.js
  async function c4(e2, t4) {
    try {
      const r5 = plainToInstance(t4, e2), a5 = await validate(r5);
      return a5.length > 0 ? { isValid: false, errors: a5.flatMap((s4) => Object.values(s4.constraints || {})) } : { isValid: true, validatedData: r5 };
    } catch (r5) {
      return { isValid: false, errors: ["Validation error: " + r5.message] };
    }
  }

  // node_modules/.pnpm/zois-core@1.1.6/node_modules/zois-core/dist/messaging.js
  var q2 = class {
    sendBeep(n5, e2) {
      const u4 = { IsSecret: true, BeepType: "Leash", MemberNumber: e2, Message: JSON.stringify({ ...n5 }) };
      ServerSend("AccountBeep", u4);
    }
    sendPacket(n5, e2, u4) {
      const r5 = { Content: m.key, Dictionary: { msg: n5 }, Type: "Hidden" };
      e2 && (r5.Dictionary.data = e2), u4 && (r5.Target = u4), ServerSend("ChatRoomChat", r5);
    }
    sendAction(n5, e2 = void 0, u4 = []) {
      if (!n5 || !ServerPlayerIsInChatRoom()) return;
      const r5 = CharacterPronounDescription(Player) === "She/Her", i8 = r5 ? "Her" : "His", p4 = r5 ? "Her" : "Him", c7 = r5 ? "Herself" : "Himself", t4 = r5 ? "She" : "He";
      n5 = n5.replaceAll("<Possessive>", i8).replaceAll("<possessive>", i8.toLocaleLowerCase()).replaceAll("<Intensive>", p4).replaceAll("<intensive>", p4.toLocaleLowerCase()).replaceAll("<SelfIntensive>", c7).replaceAll("<selfIntensive>", c7.toLocaleLowerCase()).replaceAll("<Pronoun>", t4).replaceAll("<pronoun>", t4.toLocaleLowerCase()), ServerSend("ChatRoomChat", { Content: "ZC_CUSTOM_ACTION", Type: "Action", Target: e2 ?? void 0, Dictionary: [{ Tag: 'MISSING TEXT IN "Interface.csv": ZC_CUSTOM_ACTION', Text: n5 }, ...u4] });
    }
    sendRequest({ message: n5, data: e2 = {}, target: u4, type: r5 = "packet" }) {
      const i8 = crypto.randomUUID();
      return new Promise((p4) => {
        let c7;
        r5 === "packet" ? (g2.sendPacket("request", { requestId: i8, message: n5, data: e2 }, u4), c7 = c2("ChatRoomMessage", a.ADD_BEHAVIOR, (t4, o4) => {
          const a5 = t4[0], s4 = T2(a5.Sender);
          if (!s4) return o4(t4);
          if (a5.Content === m.key && !s4.IsPlayer()) {
            const m5 = a5.Dictionary.msg, l5 = a5.Dictionary.data;
            m5 === "requestResponse" && l5.requestId === i8 && (c7(), p4({ data: l5.data, isError: false }));
          }
          return o4(t4);
        })) : (g2.sendBeep({ type: `${m.key}_request`, requestId: i8, message: n5, data: e2 }, u4), c7 = c2("ServerAccountBeep", a.ADD_BEHAVIOR, (t4, o4) => {
          const a5 = t4[0];
          if (a5.BeepType !== "Leash") return o4(t4);
          let s4;
          try {
            s4 = JSON.parse(a5.Message);
          } catch {
            return o4(t4);
          }
          return s4.type === `${m.key}_requestResponse` && s4.requestId === i8 && (c7(), p4({ data: s4.data, isError: false })), o4(t4);
        })), setTimeout(() => {
          c7(), p4({ isError: true });
        }, 6e3);
      });
    }
    sendLocal(n5) {
      if (!ServerPlayerIsInChatRoom()) return;
      const e2 = document.createElement("div");
      e2.setAttribute("class", "ChatMessage ChatMessageLocalMessage"), e2.setAttribute("data-time", ChatRoomCurrentTime()), e2.setAttribute("data-sender", `${Player.MemberNumber}`), k(e2, m.fontFamily), e2.style.background = m.chatMessageBackground ?? "#55edc095", e2.style.color = m.chatMessageColor ?? "black", e2.style.margin = "0.15em 0", typeof n5 == "string" ? e2.innerHTML = n5 : e2.appendChild(n5), document.querySelector("#TextAreaChatLog").appendChild(e2), ElementScrollToEnd("TextAreaChatLog");
    }
    sendChat(n5) {
      ServerSend("ChatRoomChat", { Type: "Chat", Content: n5 });
    }
    onRequest(n5, e2, u4) {
      let r5, i8;
      typeof e2 == "function" && e2.prototype?.constructor == e2 ? (i8 = e2, r5 = u4) : r5 = e2;
      const p4 = c2("ChatRoomMessage", a.ADD_BEHAVIOR, async (t4, o4) => {
        const a5 = t4[0], s4 = T2(a5.Sender);
        if (!s4) return o4(t4);
        if (a5.Content === m.key && !s4.IsPlayer()) {
          const m5 = a5.Dictionary?.msg, l5 = a5.Dictionary?.data;
          if (m5 === "request" && l5.message === n5) {
            if (typeof l5.requestId != "string" || typeof l5.message != "string") return;
            const h6 = await c4(l5.data, i8);
            if (i8 && !h6.isValid) return console.warn(`${m.name} DTO Failure:`, h6), o4(t4);
            const k4 = r5(l5.data, s4);
            k4 !== void 0 && g2.sendPacket("requestResponse", { requestId: l5.requestId, message: l5.message, data: k4 }, s4.MemberNumber);
          }
        }
        return o4(t4);
      }), c7 = c2("ServerAccountBeep", a.ADD_BEHAVIOR, async (t4, o4) => {
        const a5 = t4[0];
        if (a5.BeepType !== "Leash") return o4(t4);
        let s4;
        try {
          s4 = JSON.parse(a5.Message);
        } catch {
          return o4(t4);
        }
        if (s4.type === `${m.key}_request` && s4.message === n5) {
          if (typeof s4.requestId != "string") return;
          const m5 = await c4(s4.data, i8);
          if (i8 && !m5.isValid) return console.warn(`${m.name} DTO Failure:`, m5), o4(t4);
          const l5 = r5(s4.data, a5.MemberNumber, a5.MemberName);
          l5 !== void 0 && g2.sendBeep({ type: `${m.key}_requestResponse`, requestId: s4.requestId, message: s4.message, data: l5 }, a5.MemberNumber);
        }
        return o4(t4);
      });
      return () => {
        p4(), c7();
      };
    }
    onPacket(n5, e2, u4) {
      return c2("ChatRoomMessage", a.ADD_BEHAVIOR, async (r5, i8) => {
        let p4, c7;
        typeof e2 == "function" && e2.prototype?.constructor == e2 ? (c7 = e2, p4 = u4) : p4 = e2;
        const t4 = r5[0], o4 = T2(t4.Sender);
        if (!o4) return i8(r5);
        if (t4.Content === m.key && t4.Dictionary.msg === n5 && !o4.IsPlayer()) {
          const a5 = await c4(t4.Dictionary.data, c7);
          if (c7 && !a5.isValid) return console.warn(`${m.name} DTO Failure:`, a5), i8(r5);
          p4(t4.Dictionary.data, o4);
        }
        return i8(r5);
      });
    }
  };
  var g2 = new q2();

  // src/modules/storage.ts
  var modStorage = { version: "" };
  function loadStorage() {
    if (typeof Player.ExtensionSettings.BCC === "string") {
      modStorage = JSON.parse(LZString.decompressFromBase64(Player.ExtensionSettings.BCC)) ?? { version };
    } else modStorage = { version };
    if (!modStorage.version) modStorage.version = version;
    if (modStorage.version === "1.8.7") modStorage = { version };
    syncStorage();
    g2.onPacket("syncStorage", (data, sender) => {
      if (!sender.BCC) {
        g2.sendPacket("syncStorage", {
          storage: JSON.parse(JSON.stringify(modStorage))
        });
      }
      sender.BCC = data.storage;
    });
  }
  function syncStorage() {
    if (typeof modStorage !== "object") return;
    Player.ExtensionSettings.BCC = LZString.compressToBase64(JSON.stringify(modStorage));
    ServerPlayerExtensionSettingsSync("BCC");
    g2.sendPacket("syncStorage", {
      storage: JSON.parse(JSON.stringify(modStorage))
    });
  }
  function resetStorage() {
    modStorage = {
      version
    };
    syncStorage();
  }

  // node_modules/.pnpm/zois-core@1.1.6/node_modules/zois-core/dist/wardrobe.js
  function n(e2) {
    const s4 = AssetGroup.includes(e2) ? e2 : Asset.includes(e2) ? e2.Group : e2.Asset.Group;
    if (!AssetGroup.includes(s4)) throw new Error("Failed to convert item to group");
    return s4;
  }
  function y2(e2, s4 = false) {
    const r5 = n(e2);
    return r5.Category === "Appearance" && r5.AllowNone && r5.Clothing && (s4 || !r5.BodyCosplay);
  }
  function m2(e2) {
    const s4 = n(e2);
    return s4.Category === "Appearance" && s4.AllowNone && s4.Clothing && s4.BodyCosplay;
  }
  function i4(e2) {
    const s4 = n(e2);
    return s4.Category === "Appearance" && !s4.Clothing;
  }
  function A2(e2, s4 = ["ItemNeck", "ItemNeckAccessories", "ItemNeckRestraints"]) {
    const r5 = n(e2);
    return r5.Category !== "Item" || r5.BodyCosplay ? false : !s4.includes(r5.Name);
  }
  function I3(e2, s4, r5 = ["Cosplay", "Binds", "Collar", "Locks"], a5 = e2, u4 = false) {
    s4 = s4.filter((t4) => !!t4 && !i4(t4)), r5.includes("Cosplay") || (s4 = s4.filter((t4) => !m2(t4))), r5.includes("Binds") || (s4 = s4.filter((t4) => !A2(t4))), r5.includes("Collar") || (s4 = s4.filter((t4) => t4.Asset.Group.Name !== "ItemNeck")), r5.includes("Locks") || (s4 = s4.map((t4) => (t4.Property?.LockedBy && delete t4.Property.LockedBy, t4)));
    const p4 = [];
    if (u4) e2.Appearance = e2.Appearance.filter((t4) => i4(t4));
    else {
      const t4 = ValidationCreateDiffParams(a5, Player.MemberNumber);
      e2.Appearance = e2.Appearance.filter((o4) => i4(o4) || !ValidationCanRemoveItem(o4, t4, !!s4.find((l5) => l5?.Asset?.Group?.Name === o4?.Asset?.Group?.Name)) || o4.Property?.LockedBy && !DialogCanUnlock(a5, o4) || o4.Asset.Name === "SlaveCollar" && a5.IsPlayer() ? (p4.push(o4.Asset.Group.Name), true) : false);
    }
    for (const t4 of s4) {
      if (!u4 && (!f3(a5, t4.Asset.Group.Name, t4.Asset) || p4.includes(t4.Asset.Group.Name))) continue;
      CharacterAppearanceSetItem(e2, t4.Asset.Group.Name, t4.Asset, t4.Color);
      const o4 = InventoryGet(e2, t4.Asset.Group.Name);
      t4.Craft && CraftingValidate(t4.Craft, t4.Asset) !== CraftingStatusType.CRITICAL_ERROR && (o4.Craft = t4.Craft), t4.Property && (ValidationSanitizeProperties(e2, t4), o4.Property = t4.Property);
    }
    CharacterRefresh(e2), e2.IsNpc() || ChatRoomCharacterUpdate(e2);
  }
  function f3(e2, s4, r5) {
    return !ValidationIsItemBlockedOrLimited(e2, Player.MemberNumber, s4, r5.Name) && ServerChatRoomGetAllowItem(Player, e2);
  }
  function N4(e2, s4) {
    return s4.map((r5) => ServerBundledItemToAppearanceItem(e2, r5));
  }

  // src/modules/chaosAura.ts
  var chaosAuraLastData = {
    appearance: null,
    pose: null
  };
  function updateChaosAuraLastData() {
    chaosAuraLastData.appearance = ServerAppearanceBundle(
      Player.Appearance
    );
    chaosAuraLastData.pose = [...Player.ActivePose];
  }
  async function skyShieldAction(target) {
    const appearance1 = chaosAuraLastData.appearance;
    const activePose1 = chaosAuraLastData.pose;
    const appearance2 = ServerAppearanceBundle(Player.Appearance);
    const activePose2 = Player.ActivePose;
    let newAppearance = [...appearance2];
    let newActivePose = [...activePose2];
    const targetStorage = target.IsPlayer() ? modStorage : target.BCC;
    const itemsFilter = (item) => item.Group.startsWith("Item");
    const noItemsFilter = (item) => !item.Group.startsWith("Item");
    const restraintsFilter = (item) => InventoryGet(Player, item.Group)?.Asset?.IsRestraint;
    const noRestraintsFilter = (item) => !InventoryGet(Player, item.Group)?.Asset?.IsRestraint;
    const clothesFilter = (item) => y2(ServerBundledItemToAppearanceItem(Player.AssetFamily, item));
    const noClothesFilter = (item) => i4(ServerBundledItemToAppearanceItem(Player.AssetFamily, item));
    let triggered = false;
    const triggers = modStorage.chaosAura?.triggers;
    if (!(modStorage.chaosAura?.whiteList?.enabled && modStorage.chaosAura?.whiteList?.value?.includes(target.MemberNumber))) {
      if (triggers?.clothesChange) {
        if (JSON.stringify(
          appearance2.filter(clothesFilter)
        ) !== JSON.stringify(
          appearance1.filter(clothesFilter)
        )) {
          newAppearance = newAppearance.filter(noClothesFilter).concat(appearance1.filter(clothesFilter));
          triggered = true;
        }
      }
      if (triggers?.itemsChange) {
        if (modStorage.chaosAura?.ignoreItemsChangeIfNotRestraint) {
          if (JSON.stringify(
            appearance2.filter(restraintsFilter)
          ) !== JSON.stringify(
            appearance1.filter(restraintsFilter)
          )) {
            newAppearance = newAppearance.filter(noRestraintsFilter).concat(appearance1.filter(restraintsFilter));
            triggered = true;
          }
        } else {
          if (JSON.stringify(
            appearance2.filter(itemsFilter)
          ) !== JSON.stringify(
            appearance1.filter(itemsFilter)
          )) {
            newAppearance = newAppearance.filter(noItemsFilter).concat(appearance1.filter(itemsFilter));
            triggered = true;
          }
        }
      }
      if (triggers?.poseChange) {
        if (JSON.stringify(
          activePose1
        ) !== JSON.stringify(
          activePose2
        )) {
          newActivePose = activePose1;
          triggered = true;
        }
      }
      if (triggered) {
        ServerSend("ChatRoomCharacterUpdate", {
          ID: Player.OnlineID,
          ActivePose: newActivePose,
          Appearance: newAppearance
        });
        setTimeout(() => ServerSend("ChatRoomCharacterPoseUpdate", { Pose: newActivePose }), 500);
        g2.sendAction(
          `${N3(target)} tried to touch ${N3(
            Player
          )}, but ${N3(Player)} was protected by some kind of dark aura`
        );
        if (modStorage.chaosAura?.retribution && (!targetStorage?.chaosAura?.enabled || !targetStorage?.chaosAura?.triggers?.itemsChange || targetStorage?.chaosAura?.whiteList?.enabled && targetStorage?.chaosAura?.whiteList?.value?.includes(Player.MemberNumber)) && ServerChatRoomGetAllowItem(Player, target)) {
          const items1 = appearance1.filter(itemsFilter).map((item) => JSON.stringify(item));
          const items2 = appearance2.filter(itemsFilter).map((item) => JSON.stringify(item));
          let retributionItems = [];
          items2.forEach((item) => {
            if (!items1.includes(item)) retributionItems.push(JSON.parse(item));
          });
          retributionItems = retributionItems.filter(
            (item) => item.Group !== "ItemHandheld"
          );
          if (retributionItems.length > 0) {
            g2.sendAction(
              `Retribution: Used restraints are returned to ${N3(target)}`
            );
            ServerSend("ChatRoomCharacterUpdate", {
              ID: target.AccountName.replace("Online-", ""),
              ActivePose: target.ActivePose,
              Appearance: ServerAppearanceBundle(target.Appearance).concat(
                retributionItems
              )
            });
          }
        }
      }
    }
    chaosAuraLastData.appearance = newAppearance;
    chaosAuraLastData.pose = newActivePose;
    await p(() => {
      return JSON.stringify(
        ServerAppearanceBundle(
          Player.Appearance
        )
      ) === JSON.stringify(
        newAppearance
      );
    });
    return true;
  }
  function onPlayerAppearanceChange(target) {
    if (!modStorage.chaosAura?.enabled) return;
    if (target.IsPlayer()) updateChaosAuraLastData();
    else skyShieldAction(target);
  }
  function loadChaosAura() {
    if (modStorage.chaosAura?.enabled) updateChaosAuraLastData();
    c2("ChatRoomCharacterItemUpdate", a.OBSERVE, (args, next) => {
      next(args);
      const [target] = args;
      if (target.IsPlayer()) onPlayerAppearanceChange(Player);
    });
    c2("ChatRoomSyncItem", a.OBSERVE, (args, next) => {
      next(args);
      const [data] = args;
      const item = data?.Item;
      const target1 = T2(data?.Source);
      const target2 = T2(item?.Target);
      if (!target1 || !target2) return;
      if (target2.IsPlayer()) onPlayerAppearanceChange(target1);
    });
    c2("ChatRoomSyncSingle", a.OBSERVE, (args, next) => {
      next(args);
      const [data] = args;
      const target1 = T2(data?.SourceMemberNumber);
      const target2 = T2(data?.Character?.MemberNumber);
      if (!target1 || !target2) return;
      if (target2.IsPlayer()) onPlayerAppearanceChange(target1);
    });
  }

  // src/subscreens/chaosAuraSubscreen.ts
  var ChaosAuraSubscreen = class extends te {
    get icon() {
      return createElement(Shell);
    }
    get name() {
      return "Aura Of Chaos";
    }
    turnTrigger(triggerName) {
      if (!modStorage.chaosAura) modStorage.chaosAura = {};
      if (!modStorage.chaosAura.triggers) modStorage.chaosAura.triggers = {};
      modStorage.chaosAura.triggers[triggerName] = !modStorage.chaosAura.triggers[triggerName];
    }
    load() {
      super.load();
      let y5 = 240;
      this.createCheckbox({
        isChecked: modStorage.chaosAura?.enabled,
        x: 120,
        y: y5,
        text: "Enabled",
        onChange: () => {
          if (!modStorage.chaosAura) modStorage.chaosAura = {};
          modStorage.chaosAura.enabled = !modStorage.chaosAura.enabled;
          updateChaosAuraLastData();
        }
      });
      y5 += 90;
      this.createCheckbox({
        isChecked: modStorage.chaosAura?.retribution,
        x: 120,
        y: y5,
        text: "Retribution",
        onChange: () => {
          if (!modStorage.chaosAura) modStorage.chaosAura = {};
          modStorage.chaosAura.retribution = !modStorage.chaosAura.retribution;
        }
      });
      y5 += 120;
      this.createText({
        text: "Triggers:",
        x: 120,
        y: y5
      });
      y5 += 90;
      this.createCheckbox({
        text: "Clothes change",
        x: 140,
        y: y5,
        isChecked: modStorage.chaosAura?.triggers?.clothesChange,
        onChange: () => this.turnTrigger("clothesChange")
      });
      y5 += 90;
      this.createCheckbox({
        text: "Items change",
        x: 140,
        y: y5,
        isChecked: modStorage.chaosAura?.triggers?.itemsChange,
        onChange: () => this.turnTrigger("itemsChange")
      });
      y5 += 90;
      this.createCheckbox({
        text: "Pose change",
        x: 140,
        y: y5,
        isChecked: modStorage.chaosAura?.triggers?.poseChange,
        onChange: () => this.turnTrigger("poseChange")
      });
      y5 += 90;
      this.createCheckbox({
        text: "Magic cast",
        x: 140,
        y: y5,
        isChecked: modStorage.chaosAura?.triggers?.magicCast,
        onChange: () => this.turnTrigger("magicCast")
      });
      y5 += 90;
      this.createCheckbox({
        text: "Ignore items change if not restraint",
        x: 750,
        y: 240,
        isChecked: modStorage.chaosAura?.ignoreItemsChangeIfNotRestraint,
        onChange: () => {
          if (!modStorage.chaosAura) modStorage.chaosAura = {};
          modStorage.chaosAura.ignoreItemsChangeIfNotRestraint = !modStorage.chaosAura.ignoreItemsChangeIfNotRestraint;
        }
      });
      this.createInputList({
        title: "Whitelist",
        x: 750,
        y: 360,
        value: [],
        width: 800,
        height: 550
      });
      this.createCard({
        name: "Triggers count",
        value: 0,
        anchor: "bottom-right",
        x: 80,
        y: 60,
        modules: {
          value: [
            new x({ duration: 1100, endValue: 100 })
          ]
        }
      });
    }
    exit() {
      super.exit();
      this.setSubscreen(new MainSubscreen());
    }
  };

  // src/subscreens/overlaySubscreen.ts
  var OverlaySubscreen = class extends te {
    get icon() {
      return createElement(SendToBack);
    }
    get name() {
      return "Overlay";
    }
    load() {
      super.load();
    }
    exit() {
      super.exit();
      this.setSubscreen(new MainSubscreen());
    }
  };

  // src/spell-effects/baseEffect.ts
  var BaseEffect = class {
    removeHookCallbacks = [];
    get isInstant() {
      return true;
    }
    get id() {
      let charCode;
      for (const [key, value] of Object.entries(getSpellEffects())) {
        if (value.name === this.name) {
          charCode = parseInt(key, 10);
          break;
        }
      }
      return charCode;
    }
    get name() {
      return null;
    }
    get atoms() {
      return [];
    }
    get description() {
      return null;
    }
    get parameters() {
      return null;
    }
    get isActive() {
      if (this.isInstant) return false;
      const charCode = this.id;
      if (!charCode) return false;
      return modStorage.darkMagic?.state?.spells?.some((s4) => s4.effects.includes(String.fromCharCode(charCode)));
    }
    isActiveOn(C4) {
      if (this.isInstant) return false;
      if (C4.IsPlayer()) return this.isActive;
      if (!C4.BCC) return false;
      const charCode = this.id;
      if (!charCode) return false;
      return C4.BCC?.darkMagic?.state?.spells?.some((s4) => s4.effects.includes(String.fromCharCode(charCode)));
    }
    getSpellsWithEffect(C4 = Player) {
      const spells = [];
      if (!this.isActiveOn(C4)) return spells;
      const storage = C4.IsPlayer() ? modStorage : C4.BCC;
      for (const spell of (storage?.darkMagic?.state?.spells ?? []).toReversed()) {
        if (spell.effects?.includes(String.fromCharCode(this.id))) {
          spells.push(spell);
        }
      }
      return spells;
    }
    getParameter(name, C4 = Player) {
      if (!this.isActiveOn(C4)) return null;
      const storage = C4.IsPlayer() ? modStorage : C4.BCC;
      for (const spell of (storage?.darkMagic?.state?.spells ?? []).toReversed()) {
        if (spell.effects?.includes(String.fromCharCode(this.id))) {
          return spell.data?.[String.fromCharCode(this.id)]?.[name];
        }
      }
    }
    setParameter(name, value, spellName) {
      if (!this.isActive) return;
      const spell = modStorage.darkMagic.state.spells.find((s4) => s4.name === spellName);
      if (!spell) return;
      spell.data ??= {};
      spell.data[String.fromCharCode(this.id)] ??= {};
      spell.data[String.fromCharCode(this.id)][name] = value;
    }
    hookFunction(fnName, hookPriority, fn) {
      const removeHook = c2(fnName, hookPriority, fn);
      this.removeHookCallbacks.push(removeHook);
    }
    trigger(_event) {
    }
    remove(_event, spellName, push = true) {
      if (!this.isActive) return;
      for (const cb of this.removeHookCallbacks) cb();
      const spells = modStorage.darkMagic.state.spells;
      const spell = spells.find((s4) => s4.name === spellName);
      spell.effects = spell.effects.replaceAll(String.fromCharCode(this.id), "");
      if (spell.effects.length === 0) {
        spells.splice(spells.findIndex((s4) => s4.name === spellName), 1);
      }
      if (push) syncStorage();
    }
    canCast(sourceCharacter, targetCharacter) {
      if (sourceCharacter.MemberNumber === targetCharacter.MemberNumber) return { result: true };
      const effectsLimits = (targetCharacter.IsPlayer() ? modStorage : targetCharacter.BCC)?.darkMagic?.limits?.effects;
      const minimumRole = effectsLimits?.[String.fromCharCode(this.id)];
      switch (minimumRole) {
        case 0 /* EVERYONE */:
          return { result: true };
        case 1 /* FRIEND */:
          if (
            //@ts-expect-error
            sourceCharacter.FriendList?.includes(targetCharacter.MemberNumber) || //@ts-expect-error
            targetCharacter.FriendList?.includes(sourceCharacter.MemberNumber)
          ) {
            return { result: true };
          } else {
            return { result: false, reason: "EFFECTS_LIMITED" /* EFFECTS_LIMITED */ };
          }
        case 2 /* WHITELIST */:
          if (sourceCharacter.WhiteList?.includes(targetCharacter.MemberNumber) || targetCharacter.WhiteList?.includes(sourceCharacter.MemberNumber)) {
            return { result: true };
          } else {
            return { result: false, reason: "EFFECTS_LIMITED" /* EFFECTS_LIMITED */ };
          }
        case 3 /* LOVER */:
          if (targetCharacter.IsLoverOfCharacter(sourceCharacter)) {
            return { result: true };
          } else {
            return { result: false, reason: "EFFECTS_LIMITED" /* EFFECTS_LIMITED */ };
          }
        case 4 /* OWNER */:
          if (targetCharacter.IsOwnedByCharacter(sourceCharacter)) {
            return { result: true };
          } else {
            return { result: false, reason: "EFFECTS_LIMITED" /* EFFECTS_LIMITED */ };
          }
        default:
          if (this.atoms.includes(1e3 /* NOX */)) return { result: false, reason: "EFFECTS_LIMITED" /* EFFECTS_LIMITED */ };
          if (
            //@ts-expect-error
            sourceCharacter.FriendList?.includes(targetCharacter.MemberNumber) || //@ts-expect-error
            targetCharacter.FriendList?.includes(sourceCharacter.MemberNumber)
          ) {
            return { result: true };
          } else {
            return { result: false, reason: "EFFECTS_LIMITED" /* EFFECTS_LIMITED */ };
          }
      }
    }
  };

  // src/spell-effects/purificatioEffect.ts
  var PurificatioEffect = class extends BaseEffect {
    get name() {
      return "Purificatio";
    }
    get atoms() {
      return [1003 /* LUX */];
    }
    get description() {
      return "Removes all magic effects from the target.";
    }
    trigger(event) {
      super.trigger(event);
      const activeSpells = JSON.parse(JSON.stringify(modStorage.darkMagic?.state?.spells ?? []));
      for (const spell of activeSpells) {
        console.log(spell);
        for (const effectChar of spell.effects) {
          const effect = getSpellEffect(effectChar.charCodeAt(0));
          effect.remove(event, spell.name, false);
        }
      }
      syncStorage();
    }
  };

  // src/spell-effects/slumberCurseEffect.ts
  var SlumberCurseEffect = class extends BaseEffect {
    get isInstant() {
      return false;
    }
    get name() {
      return "Slumber Curse";
    }
    get atoms() {
      return [1001 /* IGNIS */, 1002 /* RATIO */];
    }
    get description() {
      return `Puts target to sleep. (Analogue of LSCG's "Slumbering" effect)`;
    }
    trigger(event) {
      super.trigger(event);
      if (event.init) {
        if (CharacterCanKneel(Player)) PoseSetActive(Player, "Kneel");
      }
      this.hookFunction("ChatRoomSendChat", a.OVERRIDE_BEHAVIOR, () => {
        return g2.sendLocal("You lost control of yourself");
      });
      this.hookFunction("Player.CanWalk", a.OVERRIDE_BEHAVIOR, () => false);
      this.hookFunction("Player.CanChangeToPose", a.OVERRIDE_BEHAVIOR, () => false);
      this.hookFunction("Player.CanChangeOwnClothes", a.OVERRIDE_BEHAVIOR, () => false);
      this.hookFunction("PoseCanChangeUnaidedStatus", a.OVERRIDE_BEHAVIOR, () => PoseChangeStatus.NEVER);
      this.hookFunction("ChatRoomCanAttemptStand", a.OVERRIDE_BEHAVIOR, () => false);
      this.hookFunction("ChatRoomCanAttemptKneel", a.OVERRIDE_BEHAVIOR, () => false);
      this.hookFunction("Player.CanInteract", a.OVERRIDE_BEHAVIOR, () => false);
      this.hookFunction("InventoryGroupIsBlockedForCharacter", a.OVERRIDE_BEHAVIOR, () => true);
      this.hookFunction("DialogClickExpressionMenu", a.OVERRIDE_BEHAVIOR, () => false);
      this.hookFunction("ChatRoomMapViewMove", a.OVERRIDE_BEHAVIOR, () => false);
    }
  };

  // src/spell-effects/vocisAlteratioEffect.ts
  function garbleSpeech(text, garbleWords) {
    let newText = "";
    const punctuation = ",.!?";
    for (const word of text.split(" ")) {
      const rword = word.split("").toReversed().join("");
      let wordPunctuation = "";
      if (punctuation.includes(rword[0])) {
        for (const c7 of rword.split("")) {
          if (punctuation.includes(c7)) wordPunctuation += c7;
        }
        wordPunctuation = wordPunctuation.split("").toReversed().join("");
      }
      newText += garbleWords[h2(0, garbleWords.length - 1)] + wordPunctuation + " ";
    }
    return newText.trim();
  }
  var VocisAlteratioEffect = class extends BaseEffect {
    get isInstant() {
      return false;
    }
    get name() {
      return "Vocis Alteratio";
    }
    get atoms() {
      return [1002 /* RATIO */];
    }
    get icon() {
      return null;
    }
    get description() {
      return "Changes target's speech.";
    }
    get parameters() {
      return [
        {
          name: "speechType",
          type: "choice",
          label: "Speech Type",
          options: [
            {
              name: "puppy",
              text: "Puppy"
            },
            {
              name: "kitty",
              text: "Kitty"
            },
            {
              name: "bunny",
              text: "Bunny"
            },
            {
              name: "baby",
              text: "Baby"
            },
            {
              name: "cow",
              text: "Cow"
            }
          ]
        }
      ];
    }
    trigger(event) {
      super.trigger(event);
      this.hookFunction("ServerSend", a.OVERRIDE_BEHAVIOR, (args, next) => {
        const message = args[0];
        const params = args[1];
        const speechType = this.getParameter("speechType");
        if (message === "ChatRoomChat" && ["Chat", "Whisper"].includes(params.Type)) {
          if (params.Content[0] !== "(") {
            if (speechType === "puppy") {
              params.Content = garbleSpeech(params.Content, [
                "wof",
                "woof",
                "wuf",
                "wooof",
                "awo",
                "awoo",
                "woo"
              ]);
            }
            if (speechType === "kitty") {
              params.Content = garbleSpeech(params.Content, [
                "meow",
                "meoow",
                "meooow",
                "meeow",
                "meeeow",
                "mnyaa",
                "mew",
                "meew",
                "meeew"
              ]);
            }
            if (speechType === "bunny") {
              params.Content = garbleSpeech(params.Content, [
                "\u0441\u043A\u0432\u0438"
              ]);
            }
            if (speechType === "baby") {
              params.Content = SpeechTransformBabyTalk(params.Content);
            }
            if (speechType === "cow") {
              params.Content = garbleSpeech(params.Content, [
                "mo",
                "moo",
                "mooo",
                "mu",
                "muu",
                "moooo"
              ]);
            }
          }
        }
        return next(args);
      });
    }
  };

  // src/assets/game-icons/atoms/lux.svg
  var lux_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="height: 512px; width: 512px;"><g class="" transform="translate(0,0)" style=""><path d="M320.063 19.72c-72.258 14.575-19.248 71.693-74.344 108.81 4.846-.49 9.746-.702 14.655-.624 16.288.26 32.785 3.72 48.594 10.72a126.431 126.431 0 0 1 14.25 7.405c12.107-47.476-37.103-96.38-3.158-126.31zM136.75 44.47c-40.76 61.357 36.984 64.33 24.406 129.405 17.407-21.255 41.17-35.9 67.156-42.313-25.006-42.138-94.4-41.924-91.562-87.093zm297.313 75.405c-32.547.872-45.475 46.314-96.594 36.22 21.35 17.42 36.034 41.25 42.467 67.31 42.306-24.92 42.053-94.466 87.282-91.624-13.43-8.92-24.06-12.15-33.158-11.905zm-177.97 26.656c-23.656.46-46.53 8.82-64.906 23.626l18.657 36.156L170 193.156a107.628 107.628 0 0 0-9.406 16.938c-8.726 19.708-11.002 40.59-7.78 60.344l44.78 2.125-34 30.312c10.798 20.622 28.414 37.852 51.406 48.03a107.842 107.842 0 0 0 9.313 3.626l24.53-38.25 9.095 43.814c27.3.075 53.737-10.387 73.593-29.188l-19.186-37.125 38.406 12.658a108.49 108.49 0 0 0 5.03-9.938c9.746-22.01 11.457-45.498 6.44-67.22l-37.626-1.75 27.687-24.718c-10.83-20.194-28.236-37.07-50.874-47.093a107.405 107.405 0 0 0-4.125-1.72l-25.874 40.313-9.906-47.75c-.5-.016-1-.023-1.5-.032-1.3-.02-2.61-.024-3.906 0zM133.407 186.5c-41.652.725-82.483 34.847-108.72 5.094 14.573 72.234 71.664 19.3 108.783 74.312-2.154-20.972.934-42.758 10.06-63.375a126.36 126.36 0 0 1 7.345-14.093c-5.822-1.47-11.642-2.038-17.47-1.937zm249.5 53.97a124.649 124.649 0 0 1-10.03 63.624l-.188.375a126.38 126.38 0 0 1-7.22 13.78c47.524 12.244 96.507-37.137 126.47-3.156-14.603-72.388-71.92-19.04-109.032-74.625zM136.53 283.405c-42.123 25.014-41.928 94.37-87.093 91.53 61.422 40.803 64.322-37.123 129.594-24.342-21.344-17.385-36.03-41.167-42.5-67.188zm219.064 48.906c-17.406 21.46-41.236 36.24-67.344 42.72 24.944 42.263 94.497 42.004 91.656 87.218 40.867-61.52-37.402-64.358-24.312-129.938zM193.406 360.72c-12.047 47.456 37.087 96.33 3.156 126.25 72.305-14.587 19.195-71.79 74.47-108.908-21.04 2.204-42.898-.9-63.594-10.062a126.43 126.43 0 0 1-14.032-7.28z" fill="%23000000" fill-opacity="1"></path></g></svg>';

  // src/assets/game-icons/atoms/motus.svg
  var motus_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="height: 512px; width: 512px;"><g class="" transform="translate(0,0)" style=""><path d="M396.082 17.326c-.166-.025-1.922.108-4.977.108-21.975 0-42.158 18.904-49.437 46.595l75.713 12.61-78.526 13.085c.564 16.248 5.55 30.99 13.062 42.367l54.39 9.603-41.277 7.29.484.607-15.91 2.47c-15.262 2.366-25.866 9.63-34.46 21.165-2.534 3.4-4.848 7.198-6.962 11.328l90.798 13.2-100.976 14.684a197.818 197.818 0 0 0-1.627 6.874c-1.662 7.613-2.953 15.622-3.982 23.854l115.275 14.107-117.81 14.418c-.525 9.083-.84 18.236-1.022 27.31l114.07 16.407-113.304 16.3h40.826l2.144 32.532 82.026 11.38-80.54 11.173 2.512 38.14 75.582 10.897-74.158 10.69 2.938 44.59h96.306l11.875-159.403h43.983c-.228-36.033-1.914-77.32-10.137-111.194-4.462-18.384-10.84-34.42-19.314-46.063-8.472-11.642-18.583-18.958-32.248-21.53l-15.59-2.933 10.124-12.213c10.435-12.587 17.49-30.688 17.49-51.127 0-37.056-22.084-66.04-47.127-69.295l-.106-.013-.108-.016zm-53.535 5.055L16.785 45.968l304.93 22.082c3.073-17.672 10.43-33.57 20.832-45.67zm-22.402 62.114L16.783 106.46l312.28 22.612c-5.686-12.618-8.96-27.047-8.96-42.422 0-.722.027-1.437.042-2.156zm-2.612 60.688L16.783 166.96l269.96 19.546c3.583-8.906 7.975-17.144 13.415-24.445 4.868-6.532 10.676-12.254 17.375-16.878zm-37.79 63.228-262.96 19.04L273.19 246.02c1.18-10.497 2.77-20.808 4.927-30.69.51-2.33 1.05-4.635 1.625-6.918zm-8.327 57.803L16.783 284.65l253.225 18.336c.18-12.057.585-24.438 1.408-36.773zm-1.562 60.605-253.07 18.325 297.22 21.52-1.072-16.267H269.86v-9.343c0-4.62-.01-9.38-.006-14.235zm45.294 57.22L16.783 405.64l301.227 21.81-2.862-43.413zm3.97 60.202L16.782 466.13l305.233 22.102-2.9-43.992z" fill="%23000000" fill-opacity="1"></path></g></svg>';

  // src/assets/game-icons/atoms/nox.svg
  var nox_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="512" height="512" viewBox="0 0 512 512"><path fill="currentColor" d="m268.725 389.28l3.74 28.7h-30.89l3.74-28.7a11.705 11.705 0 1 1 23.41 0m33.84-71.83a29.5 29.5 0 1 0 29.5 29.5a29.5 29.5 0 0 0-29.51-29.5zm-94.4 0a29.5 29.5 0 1 0 29.5 29.5a29.5 29.5 0 0 0-29.51-29.5zm245.71-62c0 98.2-48.22 182.68-117.39 220.24c-46 28.26-112.77 28.26-156.19 2.5c-71.72-36.21-122.17-122.29-122.17-222.73c0-78.16 30.54-147.63 77.89-191.67c0 0-42.08 82.86 9.1 135c-11.67-173.77 169.28-63 118-184c151.79 83.33 9.14 105 84.1 148.21c0 0 66.21 47 36.4-91.73c42.95 43.99 70.25 110.3 70.25 184.19zm-68.54 29.87c-2.45-65.49-54.88-119.59-120.26-124.07c-3.06-.21-6.15-.31-9.16-.31a129.4 129.4 0 0 0-129.43 129.35a132.15 132.15 0 0 0 24.51 76v25a35 35 0 0 0 34.74 34.69h6.26v16.61a34.66 34.66 0 0 0 34.71 34.39h61.78a34.48 34.48 0 0 0 34.51-34.39v-16.61h5.38a34.89 34.89 0 0 0 34.62-34.75v-28a129.32 129.32 0 0 0 22.33-77.9z"/></svg>';

  // src/assets/game-icons/atoms/ratio.svg
  var ratio_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="height: 512px; width: 512px;"><g class="" transform="translate(0,0)" style=""><path d="M241.063 54.406a293.615 293.615 0 0 0-12.313.282c-8.814 1.567-12.884 5.426-15.094 9.843-2.435 4.87-2.34 11.423.375 17.25 2.717 5.83 7.7 10.596 14.657 12.376 6.958 1.78 16.536.86 29.125-7.187l10.063 15.75c-15.818 10.11-31.124 12.777-43.813 9.53-12.688-3.247-22.103-12.123-26.968-22.563-4.584-9.836-5.426-21.376-1.03-31.624-42.917 6.94-81.777 23.398-111.626 46.562-9.81 10.688-10.77 23.11-6.47 31.594 4.83 9.526 16.21 16.48 38.97 9.28l5.656 17.813c-28.58 9.04-52.137-.588-61.28-18.625-2.23-4.397-3.592-9.156-4.127-14.063-4.814 5.712-9.16 11.658-13 17.844l.126.06c-8.614 19.616-8.81 33.203-5.376 42.032 3.436 8.83 10.635 14.44 21.72 17.532 22.168 6.18 58.065-1.277 83.343-20.156 10.82-8.08 21.077-27.677 21.97-42.875.445-7.6-1.165-13.604-4.345-17.438-3.18-3.834-8.272-6.703-18.813-6.594l-.187-18.686c14.487-.15 26.25 4.754 33.375 13.344 7.124 8.59 9.26 19.652 8.625 30.468-1.27 21.633-12.595 44.172-29.438 56.75-29.876 22.314-69.336 31.606-99.53 23.188-13.988-3.9-26.37-12.386-32.75-25.53-9.546 45.446 4.323 87.66 30.718 116.874 3.45 3.82 7.122 7.43 10.97 10.78-2.754-7.887-4.016-16.1-3.72-24.093.53-14.325 6.082-28.346 17.22-38.03 9.134-7.946 21.752-12.53 36.843-12.5 1.006 0 2.034.018 3.062.06 2.35.1 4.763.304 7.22.626l-2.44 18.532c-15.588-2.048-25.705 1.522-32.436 7.375-6.73 5.854-10.443 14.614-10.813 24.625-.74 20.024 12.07 43.406 39.69 50.188l-.032.188c27.192 5.19 57.536.372 88-18.22.018-.012.043-.017.062-.03 6.34-4.45 9.755-8.808 11.438-12.563 1.985-4.432 1.943-8.292.53-12.438-2.824-8.29-12.94-16.812-22.218-19.187-15.002-3.84-24.532 1.436-29 7.72-4.468 6.28-4.74 12.45 2.156 17.81l-11.47 14.75c-14.187-11.033-15.092-30.487-5.905-43.405 6.892-9.688 18.985-16.326 33.564-16.75a46.963 46.963 0 0 1 1.844-.03c4.306.03 8.79.622 13.437 1.81 15.505 3.97 29.84 15.277 35.28 31.25a36.189 36.189 0 0 1 1.876 13.314c16.71-8.538 34.332-16.12 52.282-21.814 30.156-13.78 43.23-37.938 42.72-58.28-.515-20.493-13.187-37.74-42.376-40.626l1.844-18.594c36.666 3.626 58.462 29.848 59.188 58.75.422 16.84-5.754 34.363-18.188 49.28 16.072-1.8 32.044-1.495 47.53 1.627-3.152-6.472-4.68-13.478-4.467-20.438.677-22.036 19.42-42.593 48.875-42.906a66.155 66.155 0 0 1 6.03.218l-1.5 18.625c-24.927-1.998-34.3 11.086-34.718 24.656-.412 13.42 8.545 28.442 34.22 30.436 28.3.25 48.588-15.098 58.53-37.906 13.31-30.536 6.997-76.317-34.844-118.188-.792-.793-1.578-1.593-2.375-2.375a40.42 40.42 0 0 1-2.842 10.844c-7.25 17.39-24.233 29.128-41.875 32.407-24.335 4.522-44.29-5.347-53.5-20.406-9.21-15.057-6.792-36.35 9.78-47.56l10.47 15.5c-8.913 6.028-9.28 14.19-4.313 22.31 4.967 8.122 16.17 15.156 34.156 11.814 11.306-2.102 23.896-11.33 28.03-21.25 2.07-4.96 2.47-9.862.408-15.47-1.675-4.555-5.187-9.764-11.72-15.25l-.187-.155c-27.316-20.587-56.338-35.393-85.75-45.157.018.032.045.06.063.093 6.684 12.22 7.18 26.082 3.063 38.344-8.233 24.525-34.07 43.848-66.032 42.78-6.948-.23-13.56 3.12-19.186 9.657-5.627 6.537-9.735 16.113-10.688 26.313-1.905 20.4 6.923 42.886 41.344 54L277 258.28c-41.083-13.264-56.83-45.546-54.22-73.5 1.307-13.975 6.706-26.962 15.157-36.78 8.452-9.818 20.475-16.603 33.97-16.156 24.04.802 42.323-14.084 47.687-30.063 2.682-7.988 2.335-15.937-1.75-23.405-3.968-7.252-11.83-14.423-25.906-19.656a292.57 292.57 0 0 0-50.875-4.314zM342.28 306.344c-41.915 3.41-87.366 23.4-125.28 46.562-55.98 34.198-114.89 26.733-156.688-4.28 16.444 58.844 74.712 70.788 135.5 55.905 6.083-2.285 12.06-6.538 17.157-12.03 7.057-7.607 12.17-17.47 13.78-25.625l18.344 3.625c-2.445 12.383-9.078 24.666-18.406 34.72-8.95 9.645-20.61 17.35-34.094 19.374-6.766 15.07-12.334 29.68-14.594 39.906-3.55 16.06 14.206 22.225 22.156 6.03 19.022-38.743 45.87-73.23 79.406-102.967 26.064-17.153 48.406-38.303 62.72-61.22z" fill="%23000000" fill-opacity="1"></path></g></svg>';

  // src/assets/game-icons/atoms/gemitum.svg
  var gemitum_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="height: 512px; width: 512px;"><g class="" transform="translate(0,0)" style=""><path d="M382.3 36.97c14.1 16.78 24.9 31.7 32.4 44.8C428 105.1 431.9 124 428.6 139.7c-3.2 15.8-13.4 27.1-24.1 35.9-10.5 8.7-21.9 15.7-30.3 22.9-1.8 1.8-1.9 2.8-1.3 5.3.6 2.6 2.9 6.2 6.6 9.2 7.5 6 19.6 9.3 32.4 2.9 22.8-11.4 38.3-25.3 46.6-40.3 8.4-15 10.2-31 4.8-49-8.2-27.32-34.4-58.79-81-89.63zm-252.7 0C82.99 67.83 56.8 99.29 48.62 126.6c-5.39 18-3.63 34 4.74 49 8.37 15 23.84 28.9 46.64 40.3v.1c12.8 6.3 24.8 3 32.3-3 3.7-3 6-6.6 6.6-9.2.6-2.5.5-3.5-1.3-5.3-8.3-7.2-19.7-14.2-30.3-22.9-10.67-8.8-20.8-20.1-24.05-35.8-3.25-15.8.64-34.6 13.92-58.01 7.43-13.09 18.23-28.01 32.43-44.78zm43.3 113.73c-7.6.1-15.3 1-22.9 2.7-9.8 2.2-19.3 5.8-28.2 10.7 8.7 6.8 19 13.2 28 21.1l.2.2.3.2c6.1 6.2 7.9 15.1 6.1 22.6-1.9 7.4-6.6 13.8-12.9 18.8-12.5 10-32.4 14.7-51.53 5-5.4-2.7-10.49-5.5-15.27-8.6-2.38 9.4-3.69 19.8-3.69 31.2 0 43 37.69 90 81.19 131.5 21.8 20.8 44.7 40.2 64.3 57.6 15.1 13.3 28.1 25.2 37.5 36.3 9.4-11.1 22.4-23 37.5-36.3 19.6-17.4 42.5-36.8 64.3-57.6 43.5-41.5 81.2-88.5 81.2-131.5 0-11.4-1.3-21.8-3.7-31.2-4.8 3.1-9.9 6-15.4 8.7-19.2 9.6-39.1 4.9-51.6-5.1-6.3-5-11-11.4-12.9-18.8-1.8-7.5 0-16.4 6.1-22.6l.3-.2.2-.2c9.1-7.9 19.4-14.3 28.1-21.1-8.8-4.9-18.3-8.5-28.1-10.7-40.6-9.2-83.6 5.6-97.6 40.6l-8.4 20.9-8.4-20.9c-11.3-28.5-41.9-43.6-74.7-43.3zm-17.8 102.1c20.6 28.5 49.5 50.4 84.9 67.2-52.2 33.9-104.2 4.1-84.9-67.2zm201.8 0c19.3 71.3-32.7 101.1-84.9 67.2 35.4-16.8 64.3-38.7 84.9-67.2z" fill="%23000000" fill-opacity="1"></path></g></svg>';

  // src/assets/game-icons/atoms/ignis.svg
  var ignis_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="height: 512px; width: 512px;"><g class="" transform="translate(0,0)" style=""><path d="M256 16c-52.5 252.632-210 277.845 0 454.688C466 293.845 308.5 268.63 256 16zM124.75 167.407C98.5 243.197 46 294.117 46 369.907S151 496 229.75 496c-157.5-126.317-105-202.278-105-328.593zm262.5 0c0 126.317 52.5 202.278-105 328.593C361 496 466 445.696 466 369.907c0-75.79-52.5-126.71-78.75-202.5z" fill="%23000000" fill-opacity="1"></path></g></svg>';

  // src/assets/game-icons/atoms/materia.svg
  var materia_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="height: 512px; width: 512px;"><g class="" transform="translate(0,0)" style=""><path d="M256.977 22.395c-16.8 0-32.49 7.65-45.864 20.177-13.372 12.53-24.82 29.98-34.363 51.117-2 4.428-3.91 9.03-5.736 13.777a264.528 264.528 0 0 0-14.83-1.926c-5.77-.575-11.4-.932-16.87-1.06-16.42-.39-31.427 1.275-44.58 5.262-17.536 5.317-32.006 15.083-40.406 29.63-8.4 14.55-9.62 31.964-5.457 49.81 4.165 17.845 13.552 36.484 27.087 55.318 2.84 3.95 5.874 7.912 9.076 11.873a263.816 263.816 0 0 0-9.064 11.86c-13.536 18.833-22.923 37.472-27.087 55.318-4.164 17.846-2.943 35.26 5.457 49.807 8.4 14.55 22.87 24.315 40.406 29.63 17.537 5.318 38.373 6.507 61.45 4.202 4.838-.484 9.78-1.13 14.808-1.922a263.92 263.92 0 0 0 5.746 13.802c9.543 21.14 20.99 38.587 34.363 51.116 13.373 12.528 29.065 20.18 45.864 20.18 16.798 0 32.49-7.652 45.863-20.18 13.372-12.53 24.82-29.977 34.363-51.116a263.844 263.844 0 0 0 5.746-13.8c5.022.79 9.96 1.437 14.794 1.92 23.078 2.304 43.915 1.115 61.45-4.202 17.538-5.316 32.008-15.082 40.408-29.63 8.4-14.55 9.62-31.962 5.457-49.807-4.165-17.845-13.553-36.484-27.087-55.318a265.744 265.744 0 0 0-9.065-11.86 262.57 262.57 0 0 0 9.076-11.872c13.535-18.834 22.922-37.473 27.086-55.318 4.164-17.846 2.943-35.26-5.457-49.81-8.4-14.547-22.87-24.313-40.406-29.63-13.152-3.987-28.16-5.652-44.578-5.263-5.474.128-11.105.485-16.874 1.06-4.84.484-9.787 1.133-14.817 1.925a265.385 265.385 0 0 0-5.737-13.776c-9.543-21.14-20.99-38.59-34.363-51.118-13.373-12.528-29.065-20.177-45.863-20.177zm0 18.687c11.205 0 22.192 4.923 33.086 15.13 10.893 10.205 21.297 25.653 30.107 45.167a237.315 237.315 0 0 1 4.086 9.643c-21.417 4.762-44.1 12.068-67.285 21.83-23.18-9.76-45.86-17.064-67.273-21.826 1.322-3.31 2.68-6.536 4.086-9.648 8.81-19.515 19.214-34.963 30.108-45.17 10.894-10.205 21.88-15.128 33.087-15.128zm-123.59 82.057c1.804-.018 3.637-.006 5.498.036 4.96.11 10.117.43 15.443.963 3.406.34 6.887.775 10.424 1.288-6.586 20.927-11.6 44.222-14.742 69.18-20.048 15.2-37.718 31.194-52.55 47.363a236.58 236.58 0 0 1-6.327-8.378c-12.495-17.386-20.67-34.12-24.063-48.658-3.392-14.538-2.16-26.513 3.442-36.217 5.602-9.704 15.36-16.757 29.644-21.088 9.375-2.843 20.6-4.375 33.23-4.49zm247.168 0c12.63.115 23.855 1.647 33.23 4.49 14.286 4.33 24.04 11.383 29.643 21.087 5.602 9.704 6.835 21.68 3.443 36.217-3.39 14.537-11.57 31.272-24.063 48.658a238.384 238.384 0 0 1-6.325 8.38c-14.83-16.167-32.495-32.157-52.537-47.355-3.14-24.962-8.16-48.26-14.746-69.19 3.533-.513 7.01-.95 10.413-1.288a200.322 200.322 0 0 1 15.444-.964 171.87 171.87 0 0 1 5.498-.037zm-49.92 5.64c4.97 15.438 9.085 32.472 12.156 50.7a508.006 508.006 0 0 0-30.446-19.035 508.29 508.29 0 0 0-31.69-16.843c17.32-6.455 34.127-11.407 49.98-14.82zm-147.317.003c15.85 3.414 32.655 8.366 49.97 14.82a508.802 508.802 0 0 0-31.69 16.842 509.235 509.235 0 0 0-30.434 19.024c3.07-18.223 7.184-35.253 12.154-50.687zm73.653 24.46c15.207 6.708 30.643 14.504 46.03 23.388 15.393 8.888 29.87 18.36 43.285 28.18 1.796 16.527 2.762 33.798 2.762 51.57 0 17.762-.963 35.026-2.758 51.546-13.415 9.818-27.89 19.288-43.278 28.174-15.39 8.885-30.83 16.684-46.04 23.392-15.212-6.708-30.652-14.507-46.042-23.392-15.385-8.883-29.854-18.35-43.264-28.164-1.795-16.523-2.76-33.79-2.76-51.557 0-17.775.965-35.048 2.762-51.577 13.413-9.817 27.885-19.288 43.273-28.172 15.388-8.883 30.824-16.68 46.03-23.386zm1.264 28.116-53.502 33.017 53.502 33.02 53.502-33.02-53.502-33.018zm-110.76 39.134a509.17 509.17 0 0 0-1.257 35.885c0 12.198.43 24.172 1.258 35.864-14.25-11.77-26.943-23.85-37.827-35.873 10.884-12.022 23.577-24.104 37.827-35.876zm219.005.01c14.243 11.77 26.933 23.847 37.813 35.867-10.88 12.02-23.57 24.097-37.813 35.864a508.92 508.92 0 0 0 1.256-35.855c0-12.204-.43-24.18-1.257-35.876zm-173.8 8.394v65.198l56.19 34.677v-65.195l-56.19-34.68zm131.058.034-56.177 34.67v65.164l56.178-34.67V228.93zm-226.28 41.84c14.834 16.17 32.502 32.16 52.548 47.36 3.14 24.955 8.156 48.248 14.74 69.175-3.53.51-7.006.947-10.406 1.287-21.304 2.127-39.887.84-54.172-3.49-14.286-4.33-24.04-11.386-29.643-21.09-5.602-9.705-6.835-21.68-3.443-36.217 3.392-14.537 11.568-31.272 24.063-48.658a236.048 236.048 0 0 1 6.314-8.367zm319.024.003c2.207 2.8 4.32 5.59 6.313 8.364 12.494 17.385 20.67 34.12 24.062 48.657 3.392 14.537 2.162 26.512-3.44 36.217-5.604 9.704-15.36 16.76-29.646 21.09-14.284 4.33-32.864 5.617-54.168 3.49a239.38 239.38 0 0 1-10.395-1.285c6.585-20.932 11.6-44.23 14.74-69.19 20.04-15.196 37.706-31.182 52.535-47.345zm-73.687 62.483c-3.07 18.226-7.184 35.26-12.154 50.697-15.854-3.413-32.663-8.368-49.984-14.822a509.453 509.453 0 0 0 31.7-16.848 509.238 509.238 0 0 0 30.44-19.027zm-171.635.01a508.383 508.383 0 0 0 30.424 19.017 510.02 510.02 0 0 0 31.7 16.848c-17.316 6.453-34.12 11.407-49.973 14.82-4.97-15.434-9.08-32.464-12.15-50.685zm86.37.85.68.42.677-.42h-1.356zm-.56 45.767c23.19 9.76 45.874 17.065 67.294 21.826a236.641 236.641 0 0 1-4.094 9.67c-8.81 19.513-19.214 34.96-30.108 45.167-10.893 10.206-21.88 15.13-33.085 15.13-11.206 0-22.193-4.924-33.086-15.13-10.893-10.206-21.297-25.654-30.107-45.168a239.258 239.258 0 0 1-4.095-9.67c21.416-4.762 44.098-12.066 67.283-21.825z" fill="%23000000" fill-opacity="1"></path></g></svg>';

  // src/assets/game-icons/beamsAura.svg
  var beamsAura_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="512" height="512" viewBox="0 0 512 512"><path fill="currentColor" d="M263.594 20.625c-13.394 0-25.824 7.217-35.47 20.188c-9.644 12.97-15.968 31.547-15.968 52.25s6.324 39.248 15.97 52.218c9.644 12.972 22.074 20.19 35.468 20.19c13.393 0 25.855-7.218 35.5-20.19c9.645-12.97 15.97-31.516 15.97-52.218c-.002-20.702-6.325-39.28-15.97-52.25s-22.107-20.187-35.5-20.187zM153.188 25l-16.563 8.625l60.5 116.063a72 72 0 0 1 8.72-4.032c-7.715-13.314-12.578-29.542-13.845-46.187zM374 25l-39.313 75.438c-1.316 15.668-5.802 31.003-12.843 43.78a78 78 0 0 1 9.187 3.657l59.564-114.25zM102.687 64.844l-13.874 12.53l84.124 93.19c3.88-4.996 8.217-9.51 13.063-13.44zm321.844 0l-81.467 90.22a72.5 72.5 0 0 1 11.78 10.874c.59.677 1.185 1.366 1.75 2.062l81.813-90.625l-13.875-12.53zM63.064 117.688L53 133.438l103.875 66.406c2.283-5.967 4.938-11.697 7.97-17.063L63.062 117.688zm401.093 0l-98.875 63.25c3.01 5.416 5.56 11.208 7.72 17.25l101.22-64.75l-10.064-15.75zm-153.28 42.78c-12.165 14.36-28.78 23.688-47.282 23.688c-18.056 0-34.3-8.885-46.375-22.656c-25.124 6.894-38.6 27.533-46.94 57.344c-8.19 29.287-9.914 66.253-10.155 101.562h26l-3.5-67.72l18.688-.936l4.125 80l11.218 163.78h38V362.97h18.688v132.56h40.812l9.97-164.467l4.093-79.313l18.655.938l-3.5 67.718h23.813c-.02-35.714-.425-73.276-7.844-102.812c-4.032-16.05-10.072-29.544-18.625-39.375c-7.528-8.652-16.887-14.755-29.845-17.75zM36.968 180.032l-5.314 17.907l116.28 34.532a228 228 0 0 1 4.25-18.25L36.97 180.03zm453.28 0l-112.688 33.44c1.485 5.964 2.715 12.113 3.72 18.405l114.28-33.938l-5.312-17.906zM26.22 247.688v18.688h117.218a378 378 0 0 1 2.062-18.688zm357.124 0c.645 6.16 1.106 12.402 1.47 18.688h116.155v-18.688zm-241.03 35.594l-110.66 32.844l5.313 17.938l104.593-31.032c.148-6.562.41-13.16.75-19.75zm243.217.19c.185 6.568.27 13.104.314 19.624l104.406 30.97l5.313-17.94L385.53 283.47zm-244.186 40.686L53 380.656l10.063 15.72l89.562-57.282h-11.313v-9.344c0-1.844.026-3.733.032-5.594zm244.562.03v14.908h-11.312l89.562 57.28l10.063-15.718zm-208.97 14.908L88.814 436.72l13.876 12.53l85.562-94.78l-1.063-15.376h-10.25zm165.44 0l-1.095 17.937l83.25 92.22l13.876-12.53l-88.125-97.626h-7.905zm-152.5 39.156l-53.25 102.188l16.56 8.656l39.158-75.125l-2.47-35.72zm149.843 4.594l-2.19 36.25l36.47 70l16.594-8.656l-50.875-97.594z"/></svg>';

  // src/assets/game-icons/cauldron.svg
  var cauldron_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="height: 512px; width: 512px;"><g class="" transform="translate(0,0)" style=""><path d="M259.063 25.094c-56.045 0-106.836 9.775-144.438 26.125-18.8 8.174-34.34 17.96-45.594 29.53-11.254 11.57-18.28 25.338-18.28 40.188 0 9.936 3.17 19.388 8.625 28.03-10.218 21.883-15.844 45.794-15.844 70.782 0 103.158 95.757 187.844 215.532 187.844 119.776 0 215.563-84.686 215.563-187.844 0-24.99-5.653-48.897-15.875-70.78 5.454-8.644 8.625-18.096 8.625-28.032 0-14.85-7.026-28.617-18.28-40.188-11.256-11.57-26.825-21.356-45.626-29.53-37.603-16.35-88.363-26.126-144.408-26.126zm0 18.687c53.848 0 102.554 9.6 136.968 24.564 17.208 7.482 30.775 16.306 39.658 25.437 8.882 9.133 13 18.115 13 27.157 0 9.043-4.118 18.057-13 27.188-8.883 9.13-22.45 17.956-39.657 25.438-34.413 14.963-83.12 24.562-136.967 24.562-53.85 0-102.555-9.6-136.97-24.563-17.206-7.48-30.804-16.306-39.687-25.437-8.882-9.13-12.97-18.145-12.97-27.188 0-9.042 4.088-18.024 12.97-27.156 8.883-9.13 22.48-17.954 39.688-25.436 34.414-14.964 83.12-24.563 136.97-24.563zm-7.782 17.282c-80.57 0-146 26.008-146 57.844 0 31.836 65.43 57.81 146 57.813 40.04 0 76.404-6.613 102.782-16.94-21.316 3.34-45.064 5.845-70.656 5.845-86.066 0-155.937-21.656-155.937-47.906s69.868-47.282 155.936-47.282c20.43 0 39.926.725 57.813 2.906-24.816-7.704-55.957-12.28-89.94-12.28zM87.657 360.5c-9.916 19.897-14.758 36.638-15.78 49.03-1.23 14.906 2.752 22.238 6.655 24.626 3.905 2.388 11.497 2.48 23.376-5.75 9.25-6.41 20.16-17.73 31.375-34.406-16.778-9.432-32.1-20.71-45.624-33.5zm342.75.063c-13.532 12.782-28.872 24.043-45.656 33.468 11.21 16.666 22.13 27.97 31.375 34.376 11.88 8.23 19.472 8.138 23.375 5.75 3.903-2.388 7.886-9.72 6.656-24.625-1.022-12.38-5.855-29.098-15.75-48.967zm-199.25 64.25c1.36 21.275 5.296 37.554 10.344 48.468 6.272 13.56 13.26 17.82 17.72 17.908 4.457.088 11.14-3.683 17.374-16.907 5.133-10.89 9.165-27.52 10.437-49.467a267.366 267.366 0 0 1-27.967 1.468c-9.437 0-18.75-.506-27.907-1.467z" fill="%23000000" fill-opacity="1"></path></g></svg>';

  // src/assets/game-icons/deathJuice.svg
  var deathJuice_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="height: 512px; width: 512px;"><g class="" transform="translate(0,0)" style=""><path d="M257.617 20.717c-7.083-.011-14.242.448-21.469 1.347-31.2 3.87-59.077 16.346-82.566 39.51-18.59 18.323-30.93 40.783-33.8 68.274-3.409 32.99 6.985 61.16 28.118 84.191 6.792 7.386 9.795 14.582 9.608 25.03-.297 16.428.974 32.882 1.65 50.308 21.027-12.421 41.214-24.384 61.674-36.48 12.176 21.378 24.055 42.27 36.479 63.976 12.148-21.517 23.894-42.3 35.826-63.244 19.753 11.8 39.24 23.46 59.373 35.557.514-16.94 1.733-32.799 1.246-48.6-.353-11.07 1.813-19.676 10.256-26.223 2.677-2.083 4.707-5.356 6.845-8.308 20.568-28.606 27.712-60.348 17.16-95.498-9.77-32.502-30.771-54.695-57.699-70.362-23.066-13.405-47.403-19.44-72.7-19.478zm82.799 105.207c17.942-.134 26.164 11.07 22.404 30.474-4.353 22.379-22.92 38.723-42.674 37.668-21.38-1.139-38.695-18.755-41.025-41.892-.186-1.811.435-4.598 1.6-5.547 10.658-8.605 45.704-20.593 59.695-20.703zm-165.154.03c13.717.865 29.494 7.548 45.084 14.91 2.297 1.107 4.408 2.785 6.763 3.464 5.847 1.651 6.088 6.113 5.25 11.31-3.76 22.217-23.004 39.484-42.785 38.401-22.433-1.218-39.592-19.269-41.162-43.351-1.083-16.59 6.766-24.952 26.85-24.735zm80.615 56.556c7.44 18.214 14.42 35.235 21.646 52.93h-43.187c7.144-17.588 14.152-34.637 21.54-52.93zm-16.172 141.84c-.146.319-.293.633-.42.976-2.894 7.981-6.197 15.856-9.984 23.543-8.334 16.832-17.293 33.365-25.71 50.09-6.63 13.125-10.336 26.845-7.74 41.783 5.71 32.582 36.67 54.827 69.63 49.844 39.886-6.033 59.48-41.103 48.603-74.902-4.357-13.586-11.283-26.469-17.941-39.159-8.46-16.062-16.528-32.279-23.061-49.11-2.348 4.152-4.698 8.311-7.057 12.491l-8.658 15.328-8.742-15.279a11284.8 11284.8 0 0 1-8.92-15.605zm.053 40.97c3.709.032 3.735 27.583 1.642 40.026-2.166 12.555.13 24.084 10.495 32.69 15.02 12.475 35.426 9.66 46.654-6.386.514-.68.975-1.355 1.49-2.06.404.083.756.164 1.162.219-.89 4.763-1.217 9.633-2.652 14.261-6.33 20.702-25.515 33.068-47.977 31.174-19.404-1.624-35.833-17.753-39.24-37.996-1.841-10.579 1.218-20.05 5.654-29.17 6.602-13.61 14.018-26.817 20.647-40.375.81-1.655 1.518-2.388 2.125-2.383z" fill="%23000000" fill-opacity="1"></path></g></svg>';

  // src/assets/game-icons/diceFire.svg
  var diceFire_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="height: 512px; width: 512px;"><g class="" transform="translate(0,0)" style=""><path d="M218.4 24.72c-14.2 0-30.5 3.56-49.5 11.88 77.2 8.6 65.9 91.4 14.1 106.2-65.4 18.7-131.31-23.7-98.34-99.2-39.67 18.95-42.17 80.8-12.93 111.5C141.3 227.9 56.9 279 37.25 200.7-1.929 326.2 60.34 489.5 258.7 489.5c250.7 0 282-374.7 129.2-415.04 26.5 43.04-13.1 70.94-24.9 73.14-51.3 9.9-58.1-122.89-144.6-122.88zm37.5 118.08c4.5 0 9.4 1.1 12.8 2.9l115.9 67.1c7.4 4.1 7.4 10.9 0 15.2l-115.9 66.9c-7.2 4.3-18.5 4.3-25.7 0L126.8 228c-7.3-4.3-7.3-11.1 0-15.2L243 145.7c3.4-1.8 7.9-2.9 12.9-2.9zm-89 62.6c-21.6-.4-33.1 15-18.2 24.3 9.6 4.8 23.7 4.4 32.7-.8 8.8-5.3 9.5-13.7 1.5-19.4-4.3-2.5-10-4-16-4.1zm178.6.1c-20.8.4-31.3 15.5-16.3 24.5 9.6 4.9 23.9 4.6 33-.7 8.9-5.3 9.5-13.9 1.2-19.6-4.2-2.4-9.9-4-15.9-4.2h-2zm-89 0c-6.6-.1-13 1.5-17.7 4.2-10.2 5.6-10.4 15.1-.6 20.9 9.9 5.8 25.8 5.6 35.1-.6 15-9 4.6-24.3-16.8-24.5zm-141 41c1.5.1 3.4.5 5.6 1.6l111.5 64.5c7.2 4.1 12.9 14.2 12.9 22.5v119.7c0 8.3-5.7 11.7-12.9 7.6L121.2 398c-7.4-4.3-13.2-14.2-13.2-22.6V255.7c0-6.2 3-9.2 7.5-9.2zm281.3 0c4.2 0 7.2 3 7.2 9.2v119.7c0 8.4-6 18.3-13 22.6l-111.5 64.4c-7.2 4.1-12.9.7-12.9-7.6V335.1c0-8.3 5.7-18.4 12.9-22.5L391 248.1c2.1-1.1 4.2-1.5 5.8-1.6zm-185 65.5h-1.1c-5.3.4-8.5 4.8-8.5 11.6-.6 10.4 7.2 24.1 16.9 29.8 9.8 5.6 17.6 1.1 17.2-9.9.2-14.2-13.3-31.1-24.5-31.5zm130.9 21.8c-11.2.1-24.8 17.2-24.7 31.4.1 10.4 7.7 14.4 17.2 8.9 9.4-5.5 17-18.3 17.1-28.8 0-6.7-3.3-11.1-8.5-11.5h-1.1zm-216.9 22.5c-5.4.3-8.7 4.7-8.7 11.6-.5 10.5 7.3 24.1 17 29.8 9.8 5.5 17.6 1 17.2-10.1 0-14.5-14.1-31.8-25.5-31.3z" fill="%23000000" fill-opacity="1"></path></g></svg>';

  // src/assets/game-icons/door.svg
  var door_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="height: 512px; width: 512px;"><g class="" transform="translate(0,0)" style=""><path d="M105 41v398h302V41H105zm55 174c18.1 0 33 14.9 33 33s-14.9 33-33 33-33-14.9-33-33 14.9-33 33-33zm0 18c-8.4 0-15 6.6-15 15s6.6 15 15 15 15-6.6 15-15-6.6-15-15-15zM73 457v30h366v-30H73z" fill="%23000000" fill-opacity="1"></path></g></svg>';

  // src/assets/game-icons/evilBook.svg
  var evilBook_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="512" height="512" viewBox="0 0 512 512"><path fill="currentColor" d="M93.998 27.8c-24.004-.13-42.94 15.268-54.732 32.778C27.094 78.653 20.66 98.816 24.684 115.1l.01.04l81.476 318.186c.11-9.534 2.292-19.376 6.22-28.596c4.24-9.948 10.73-19.412 19.245-27.21c7.477-7.44 17.398-13.343 29.234-16.575l.007-.002a77.5 77.5 0 0 1 13.787-2.74l.658-.07l323.2 11.25l-126.975-328.56l-275.21-12.96a56 56 0 0 0-2.34-.062zm-.107 18.69q.78.005 1.567.04l263.046 12.39l112.408 290.867l-299.46-9.77l-.653.07c-26.13 2.814-47.677 15.802-60.554 33.823l-67.42-263.29v-.003c-1.57-6.362 2.12-25.013 11.942-39.6c9.516-14.132 23.03-24.603 39.123-24.525zm17.426 17.403L93.35 69.037l73.06 255.193l17.967-5.142zm52.48 19.2c3.22 62.57 46.11 84.672 81.54 87.507l9.07-16.85l-43.873-19.943l15.91-8.95c-24.727-2.388-42.9-24.437-62.648-41.765zm180.157 2.948c-10.863 18.29-18.594 40.613-39.375 46.132l10.31 13.844l-24.808 16.07l14.943 13.84c29.995-7.382 59.367-33.122 38.93-89.885zm44.406 88.26l-33.432 59.067l-18.184-40.082l-25.455 50.627l-50.07-37.266l-8.277 35.157l-76.937-59.768l46.058 99.145l13.426-21.8l45.862 59.07l19.857-46.41l41.196 47.108l17.785-52.03l20.13 28.827l8.04-121.644zM176.214 376.866c-23.563 2.688-39.208 17.766-46.63 35.19c-6.863 16.106-5.658 33.007 1.804 42.7l315.006 10.862c-2.514-13.553-1.82-27.43 2.32-41.203l-21.546-6.818l34.252-20.055a127 127 0 0 1 7.658-10.48z"/></svg>';

  // src/assets/game-icons/handcuffs.svg
  var handcuffs_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="height: 512px; width: 512px;"><g class="" transform="translate(0,0)" style=""><path d="M147.406 20.03a30.817 30.817 0 0 0-3.156.157c-4.238.433-8.576 1.774-12.656 4.125-.008.005-.023-.004-.03 0l-29.783 17.22c-7.858 4.534-12.662 12.15-13.874 19.78-1.212 7.63.62 15.126 4.22 21.47.11.197.227.397.343.593l-11.72 40.22a36.448 36.448 0 0 0-5 4.124c-5.196 5.117-9.01 11.83-9.844 19.56-.835 7.732 1.923 16.39 8.406 22.876L98.626 194.5c6.633 6.63 15.296 9.602 23.188 9.03 4.63-.333 8.935-1.755 12.78-3.905l7.095 6.688a29.393 29.393 0 0 0-5.157 10.437l-1.624 6.03 18.063 4.845 1.624-6.063c1.06-3.953 2.712-5.37 5.125-6.437 1.205-.533 2.67-.867 4.28-.938 1.61-.07 3.366.126 5.063.594 3.393.938 6.375 2.963 7.968 5.157 1.594 2.195 2.284 4.266 1.282 8l-1.625 6.032 18.063 4.843 1.625-6.032c2.35-8.762.32-17.56-4.22-23.81-4.537-6.253-11.093-10.28-18.124-12.22a35.11 35.11 0 0 0-10.905-1.25c-1.67.075-3.34.28-5 .625l-10.344-9.75c2.06-3.75 3.42-7.944 3.75-12.438.586-7.917-2.42-16.574-9.093-23.25l-24.343-24.312c-4.677-4.68-10.516-7.357-16.313-8.156l6.157-21.095c.177.072.353.15.532.22 7.25 2.806 16.336 2.394 24.28-2.19l29.813-17.186c6.104-3.528 10.526-8.694 12.968-14.345l21.095 5.938c-.88 3.745-1.122 7.688-.5 11.687 1.194 7.683 6.06 15.35 14 19.938l29.813 17.218a31.333 31.333 0 0 0 11.78 3.97L255 140.78c-2.735 1.553-5.224 3.477-7.438 5.657-5.195 5.12-8.977 11.833-9.812 19.563-.835 7.73 1.89 16.39 8.375 22.875l4.22 4.22 13.218-13.22-4.22-4.22c-2.893-2.893-3.314-5.032-3.03-7.655.283-2.623 1.867-5.78 4.375-8.25 2.507-2.47 5.77-4.06 8.468-4.344.337-.035.68-.052 1-.062 2.252-.07 4.17.544 6.563 2.937v.032l4.217 4.188 13.188-13.188-4.188-4.218a28.68 28.68 0 0 0-16.656-8.188l-3.25-18.28c4.92-2.895 8.87-7.066 11.658-11.845 3.74-6.412 5.516-14.137 4.03-21.936-1.484-7.8-6.637-15.374-14.812-20.094l-29.78-17.188c-3.93-2.27-8.145-3.506-12.282-3.812-4.137-.306-8.206.305-11.813 1.688-4.304 1.65-8.01 4.21-11.093 7.343l-29.093-8.186a34.05 34.05 0 0 0-3.47-8.594c-3.684-6.445-9.47-11.856-16.968-14.47-2.81-.98-5.862-1.488-9-1.5zm-.187 18.564c1.063.03 2.05.252 3.03.593 2.614.912 5.225 3.153 6.906 6.094 1.682 2.942 2.312 6.365 1.78 9.126-.528 2.756-1.805 5.11-5.717 7.375-.01.006-.024-.004-.032 0l-29.782 17.19c-3.545 2.044-5.726 1.89-8.187.936a10.648 10.648 0 0 1-1.97-1.03l.094-.345-.906-.25c-1.53-1.183-2.977-2.804-4.063-4.718-1.737-3.06-2.425-6.634-2-9.312.425-2.678 1.4-4.598 4.75-6.53v-.032l29.78-17.188h.032c2.02-1.166 3.688-1.72 5.188-1.875.375-.038.74-.04 1.094-.03zM226.5 62.22c.31-.02.618-.024.938 0 1.276.09 2.637.53 4.312 1.5v.03l29.813 17.188c4.04 2.332 5.294 4.686 5.812 7.406.518 2.72-.138 6.105-1.844 9.03-1.705 2.927-4.343 5.174-7 6.095-2.654.92-5.316 1.02-9.25-1.25L219.47 85c-3.544-2.048-4.47-3.985-4.876-6.594-.406-2.608.28-6.09 2.062-9.125 1.783-3.034 4.532-5.435 7.063-6.405.948-.364 1.85-.598 2.78-.656zM98.344 136.624c2.246-.065 4.14.575 6.53 2.97l24.345 24.31c3.296 3.3 3.89 5.896 3.686 8.657-.204 2.762-1.688 5.865-4.094 8.25-2.405 2.386-5.54 3.892-8.343 4.094-2.805.203-5.415-.415-8.626-3.625L87.53 156.97c-2.89-2.895-3.313-5.065-3.03-7.69.283-2.622 1.867-5.778 4.375-8.25 2.508-2.47 5.773-4.06 8.47-4.343.336-.035.678-.053 1-.062zM320 149.875l-62.094 62.094 48.844 48.843 26.938-26.938.343.344a71.152 71.152 0 0 1 3.033-3.25c27.69-27.693 72.59-27.693 100.28 0 27.205 27.203 27.684 71.022 1.438 98.81-.004.014-.025.02-.03.033-1.03 2.514-1.372 4.965-1.28 7.343.18 4.757 2.415 9.505 5.936 13.063 3.52 3.556 8.17 5.75 12.875 5.936 3.614.144 7.41-.73 11.47-3.625 37.58-42.338 36.114-107.29-4.438-147.842-29.2-29.2-71.177-37.894-108.062-26.563l-5.375 1.656-3.97-3.968L320 149.875zm-11.75 40.688 18.313 18.312-13.22 13.22-18.312-18.314 13.22-13.218zm-186.53 48-17.876 66.78 36.78 9.844-.124.47c1.445.292 2.9.612 4.344 1 37.828 10.135 60.26 49.015 50.125 86.843-9.962 37.175-47.675 59.485-84.876 50.625-2.695.375-4.986 1.326-7 2.594-4.03 2.533-7.024 6.796-8.344 11.624-1.32 4.828-.908 9.988 1.28 14.156 1.686 3.206 4.35 6.085 8.907 8.156 55.445 11.366 110.96-22.407 125.813-77.78.003-.01-.003-.022 0-.032 10.673-39.878-2.783-80.572-31.03-106.844l-4.126-3.844 1.437-5.437 9.5-35.44-84.81-22.717zm159.655 23.28c-6.083 33.48 3.736 69.08 29.72 95.063 36.204 36.205 91.507 41.554 133.06 15.625-5.342-2.01-10.13-5.214-14.06-9.186-5.135-5.186-8.89-11.79-10.47-19.156-26.67 13.713-60.22 9.406-82.563-12.938-14.735-14.735-21.633-34.33-20.687-53.625l-3 3-6.625 6.625-6.594-6.625-18.78-18.78zm-131.656 4.094 18.06 4.844-6.686 25.033-18.063-4.844 6.69-25.033zm-59.47 17.938c-32.02 11.48-57.93 37.8-67.438 73.28-13.252 49.46 9.77 100.012 53 123.033-.936-5.626-.568-11.36.907-16.75 1.923-7.036 5.783-13.63 11.374-18.688C62.872 428.512 49.82 397.34 58 366.812c5.395-20.134 18.935-35.924 36.125-44.75L90 320.97l-9.03-2.44 2.405-9.03 6.875-25.625z" fill="%23000000" fill-opacity="1"></path></g></svg>';

  // src/assets/game-icons/hangingSpider.svg
  var hangingSpider_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="height: 512px; width: 512px;"><g class="" transform="translate(0,0)" style=""><path d="M245.625 14.656v141.53c-27.713 6.03-48.875 38.405-48.875 77.47 0 15.552 3.366 30.034 9.156 42.22a100.09 100.09 0 0 1-9.406-10.97c-33.54-45.34-33.54-121.904 0-167.25l-15-11.125c-39.288 53.12-39.292 136.387 0 189.5a119.17 119.17 0 0 0 7.97 9.69c-55.29-22.365-93.407-72.152-93.407-129.408H77.374c0 61.73 38.437 115.01 94.438 141.938-21.208 7.248-40.477 17.198-57 29.344-36.29 26.675-59.594 64.432-59.594 106.5h18.686c0-35.19 19.332-67.448 51.97-91.438 16.31-11.99 35.903-21.796 57.75-28.594a112.592 112.592 0 0 0-6.345 6.407c-42.477 46.365-42.477 120.787 0 167.155L191.063 475c-32.263-35.218-35.342-90.954-9.25-130.094 4.213 13.518 16.883 23.438 31.72 23.438 3.25 0 6.396-.49 9.374-1.375a33.232 33.232 0 0 0 1.78 5.25 37.482 37.482 0 0 0-7.28 22.25c0 14.788 8.532 27.58 20.938 33.717-.826-4.1-1.28-8.56-1.28-13.25 0-19.7 8.013-35.687 17.905-35.687 9.89 0 17.905 15.987 17.905 35.688 0 4.69-.456 9.15-1.28 13.25 12.404-6.14 20.936-18.93 20.936-33.72 0-8.215-2.657-15.814-7.124-22a33.05 33.05 0 0 0 1.875-5.406 32.767 32.767 0 0 0 9.033 1.282c14.87 0 27.566-9.965 31.75-23.53 26.16 39.143 23.102 94.94-9.188 130.186l13.78 12.625c42.48-46.368 42.48-120.79 0-167.156a112.235 112.235 0 0 0-6.342-6.408c21.845 6.798 41.438 16.604 57.75 28.594 32.637 23.99 51.968 56.25 51.968 91.438h18.69c0-42.068-23.305-79.825-59.595-106.5-16.524-12.146-35.792-22.096-57-29.344 56-26.93 94.438-80.208 94.438-141.938h-18.688c0 57.256-38.118 107.043-93.406 129.407 2.765-3.02 5.424-6.25 7.967-9.69 39.292-53.11 39.292-136.38 0-189.5l-15 11.126c33.542 45.345 33.54 121.913 0 167.25a99.622 99.622 0 0 1-9.375 10.906c5.77-12.18 9.125-26.627 9.125-42.156 0-39.065-21.162-71.44-48.875-77.47V14.657h-18.687zm9.47 281.5c8.137 0 14.53 6.398 14.53 14.53 0 8.135-6.393 14.533-14.53 14.533-8.14 0-14.5-6.398-14.5-14.533 0-8.133 6.366-14.53 14.5-14.53zm-41.564 24.438c8.14 0 14.532 6.398 14.532 14.53 0 8.134-6.393 14.532-14.53 14.532-8.14 0-14.532-6.396-14.532-14.53s6.398-14.532 14.53-14.532zm82.782 0c8.138 0 14.532 6.398 14.532 14.53 0 8.134-6.394 14.532-14.53 14.532-8.14 0-14.533-6.396-14.533-14.53s6.4-14.532 14.533-14.532zm-41.218 23.875c8.138 0 14.53 6.397 14.53 14.53s-6.392 14.53-14.53 14.53c-8.138 0-14.5-6.395-14.5-14.53 0-8.133 6.367-14.53 14.5-14.53z" fill="%23000000" fill-opacity="1"></path></g></svg>';

  // src/assets/game-icons/haunting.svg
  var haunting_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="height: 512px; width: 512px;"><g class="" transform="translate(0,0)" style=""><path d="M272.375 17.75c-3.073.063-6.2.27-9.344.594l-.467.062c-50.047 5.388-85.223 42.445-81.25 80.875 2.455 23.772 18.7 43.2 43.312 54.095l1.97.875 1.374 1.625 16.81 19.813 71.75-5.72 8.376-22.905 1-2.72 2.344-1.655c21.862-15.694 33.8-38.044 31.344-61.813-3.736-36.142-41.12-64.063-87.22-63.125zm46.5 48.656c13.252 0 24 10.717 24 23.97 0 13.25-10.748 24-24 24s-24-10.75-24-24c0-13.253 10.748-23.97 24-23.97zm-86.47 9.5c13.253 0 24 10.717 24 23.97 0 13.25-10.747 24-24 24-13.25 0-24-10.75-24-24 0-13.253 10.75-23.97 24-23.97zm41.407 35.438 23.907 38.875-41.5 3.06 17.592-41.936zm-164.468 7.22c-53.418-.164-65.813 17.017-89.844 27.342 7.457 62.138 33.86 128.37 17.5 232.438 19.145-14.237 59.438-96.563 59.438-96.563l-7.626 82.064 51.313-92 4.906 45.78 28.845-45.187c-1.093 24.925-4.462 51.423-21.25 74.782C114.293 400.553 99.5 477.06 99.5 477.06l46.72-50.5-20.44 66.844c37.762-30.703 55.564-65.578 66.907-102.187l6.5 101.03 26.594-60.156L261 491.656c-.13-24.413-3.5-47.555 5.75-70.094 8.515 29.13 55.87 51.816 80.406 42.657-40.048-39.82-69.453-161.727 9.906-204.408 2.53 22.436-3.683 44.846-18.843 67.282 26.68-11.406 44.907-27.785 54.78-50.688l-9.97 114.813c23.782-37.54 43.916-82.23 45.22-114.19 10.45 28.937 8.05 75.348 5.375 110.283 50.06-53.433 50.658-106.84 53.813-220.375-33.91-26.452-73.682-40.823-117.844-43.907-6.46 12.55-16.095 23.77-28 32.845l-9.563 26.156-.874 2.376 2.72 32.28-18.626 1.564-2.47-29.22-21.03 1.69 2.53 30.218-18.592 1.562-2.563-30.313-18.906 1.5 2.593 30.782-18.594 1.56-2.75-32.468-1.845-2.156-18.72-22.03c-20.886-9.807-37.6-25.673-46.218-45.5-24.256-3.692-43.582-5.266-59.343-5.314z" fill="%23000000" fill-opacity="1"></path></g></svg>';

  // src/assets/game-icons/hearts.svg
  var hearts_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="height: 512px; width: 512px;"><g class="" transform="translate(0,0)" style=""><path d="M480.25 156.355c0 161.24-224.25 324.43-224.25 324.43S31.75 317.595 31.75 156.355c0-91.41 70.63-125.13 107.77-125.13 77.65 0 116.48 65.72 116.48 65.72s38.83-65.73 116.48-65.73c37.14.01 107.77 33.72 107.77 125.14z" fill="%23000000" fill-opacity="1"></path></g></svg>';

  // src/assets/game-icons/iceBolt.svg
  var iceBolt_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="height: 512px; width: 512px;"><g class="" transform="translate(0,0)" style=""><path d="M18.094 18.125v43.53l76.156 9.407-29.97-52.937H18.095zm117.437 0 57 34.125-13.186-34.125H135.53zm121.22.156-19.938 7.314 60.344 61.468-19.844-52.218L256.75 18.28zM114.812 35.188l18.97 59.157 58.155 25.625.22 63.56 36.75-8.28-33.5-92.938-80.595-47.124zm94.47 7.126 48.843 138.656 3.625-61.626 29.53-3.78-82-73.25zm118.655 6.562-8.406 23.344 60.345 61.468L350.5 51.906l-22.563-3.03zm-285.5 42.75 54.657 47.5 4.094-44.875-58.75-2.625zm353.97 2.938 9.937 67.187-27.97 54.625 31.626-30 18.563-46.28-32.157-45.532zM18.093 106.78v67.5l21.843 11.97 62.657.28-84.5-79.75zm314.656 18.19-6.594 6.624-40.78 40.75 13.218 13.22 24.812-24.814v28.22l-12.625 12.624 12.626 52.97v2.217l-31.094 17.94-2-1.158-39.5-37.343-17.218 4.593-24.438-14.094 33.875-9.064-4.843-18.062L182.53 214.5l-9.03 2.438 2.406 9.03 14.938 55.657 18.03-4.844-9.093-33.874 24.44 14.125 4.624 17.22 52.125 15.53 1.842 1.064v36.062l-1.843 1.063-52.126 15.53-4.625 17.22-24.44 14.124 9.095-33.875-18.063-4.845-14.906 55.688-2.406 9 9.03 2.437 55.657 14.906 4.844-18.062-33.874-9.063 24.438-14.124 17.22 4.625 39.56-37.405 1.845-1.063 31.186 18v2.125l-12.625 52.97 12.626 12.624V457l-24.812-24.813-13.22 13.22 40.782 40.75 6.594 6.624 6.594-6.624 40.78-40.75-13.218-13.22-24.812 24.814v-28.22l12.625-12.624-12.626-52.97v-2.28l31.03-17.937 2 1.155 39.563 37.406 17.22-4.624 24.437 14.125-33.875 9.064 4.842 18.062L483 403.25l9-2.438-2.406-9-14.906-55.687-18.063 4.844 9.094 33.874-24.44-14.125-4.624-17.22-52.125-15.53-2.155-1.25v-35.69l2.156-1.25 52.126-15.53 4.625-17.22 24.44-14.124-9.095 33.875 18.063 4.845 14.906-55.656 2.406-9.032-9-2.438-55.688-14.906-4.843 18.062 33.874 9.063-24.438 14.093-17.22-4.594-39.498 37.343-2.157 1.25-30.936-17.875v-2.375l12.625-52.97-12.626-12.624v-28.22l24.812 24.813 13.22-13.22-40.782-40.75-6.594-6.624zm-203.47 1.124-17.56 35.156 46.843 33.97 14.062-53.876-43.344-15.25zm-66.874 76.25 56.657 85.844 40.562 13.218-14.72-80.5-14.624-14.625-18.31 15.814-49.564-19.75zm-23.468 28.594-7.688 27.5 35.094 18.625 1.344-27.875-28.75-18.25zm293.656 42.093 31.094 17.94v35.874l-31.094 17.97-31.094-17.97V290.97l31.094-17.94zM93.5 304.47l31.906 56.905 32.78 7.28 11.44-39.405L93.5 304.47zm-25.75 53.624 16.094 46.72 66.72-8.127-82.814-38.593zm78.375 66.97L117 453.717l95.844-20.533-66.72-8.125z" fill="%23000000" fill-opacity="1"></path></g></svg>';

  // src/assets/game-icons/loveInjection.svg
  var loveInjection_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="height: 512px; width: 512px;"><g class="" transform="translate(0,0)" style=""><path d="M110.814 19.584C86.886 19.1 66.43 42.18 74.574 72.572 33.3 61.514 1.52 106.864 33.804 137.152c27.285 25.595 75.65 12.207 105.592 13.594l35.608 35.61-20.8 20.798a45.184 45.184 0 0 0-17.956-3.72c-1.102 0-2.2.038-3.297.117-14.61 1.05-28.493 9.07-36.325 22.636-12.533 21.7-5.02 49.73 16.682 62.26l9.343-16.186c-12.953-7.48-17.322-23.778-9.84-36.73 7.204-12.477 22.578-16.98 35.274-10.622l.79.79 165.18 165.185c22 22 51.77 20.233 71.514 6.043l89.446 89.447 13.215-13.213-89.543-89.545c5.476-7.808 8.98-17.067 9.432-27.056.633-13.987-5.028-29.007-17.884-41.863l-166.363-166.37.516-.298c-7.48-12.954-3.115-29.253 9.84-36.73 12.957-7.48 29.25-3.115 36.73 9.84l16.185-9.345c-7.83-13.564-21.715-21.583-36.325-22.63a44.153 44.153 0 0 0-3.297-.118 45.184 45.184 0 0 0-22.636 6.066c-20.796 12.005-28.546 38.234-18.14 59.498l-18.528 18.53-34.986-34.986c-1.04-30.028 11.983-81.578-14.238-106.203-8.923-8.378-18.818-12.176-28.182-12.366zm107.64 149.752L375.837 326.73l-49.754 49.754-157.39-157.39 49.76-49.758zm.837 26.373-13.214 13.214L336.584 339.43l13.215-13.215L219.29 195.71z" fill="%23000000" fill-opacity="1"></path></g></svg>';

  // src/assets/game-icons/magicPortal.svg
  var magicPortal_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="512" height="512" viewBox="0 0 512 512"><path fill="currentColor" d="m88.418 17.17l-66.12 475.242h18.866l66.12-475.242H88.42zm315.7 0l66.023 475.242h18.87L422.988 17.17zm-56.26.24l-132.422.37c-59.343 41.506-78.325 97.982-61.596 168.03c-22.324-31.34-32.747-63.248-33.59-98.234l-26.684 191.78c1.05-3.64 2.25-7.31 3.653-11.012l-3.843 12.385l-4.934 35.454c.41 37.954 18.614 69.416 40.91 87.406c-18.52-6.774-35.355-15.287-49.25-27.445l-9.207 66.152c43.032 20.635 88.614 24.346 120.56 17.78c-33.542 18.813-71.344 29.428-125.382 16.886l-2.13 15.3h217.568c73.664-14.515 117.318-55.617 129.045-89.216c3.54 30.568-2.754 60.093-37.473 89.215h73.242l-41.553-299.11c-15.226-35.307-51.106-59.122-74.695-59.718c10.876-3.615 21.615-5.918 32.305-5.78c11.61.15 23.16 3.2 34.76 10.56l-4.207-30.278c-21.365-18.958-46.472-31.023-68.92-35.954c6.54-.477 13.043-.73 19.513-.685c15.23.104 30.273 1.868 45.18 6.21l-4.224-30.398C331.8 45.105 287.813 60.384 263.44 79.407c13.68-23.55 44.533-47.68 84.417-61.998zm-81.323 33.065c-68.785 37.085-71.87 82.26-36.1 122.146c-7.626-69.52 80.94-110.016 118.96-59.032c-40.867-20.17-77.79 7.84-76.21 47.723c23.234-23.997 98.678-13.267 79.795 36.19c-11.3-33.297-56.74-30.094-63.648-13.77c-14.75 34.866 64.34 14.582 98.117 66.284c-18.85-10.875-47.74.482-39.22 14.59c32.28 53.45 84.53 113.185 13.3 147.025c23.57-38.677 10.786-65.734-21.85-81.43c25.644 66.744-5.1 163.717-103.81 133.19c62.83-11.442 78.355-62.576 57.263-83.425c-23.617 60.37-122.14 97.174-181.444 38.453c58.693 22.535 99.285 7.31 120.644-26.39c-35.89 21.435-95.375 6.933-113.994-42.977c28.694 29.187 67.102 37.963 91.195 20.356c13.217-9.658 8.303-25.06-8.55-29.402c-24.53-6.32-61.988-12.852-76.563-36.588c21.722 6.003 43.444 10.698 65.166-3.375c-33.985-22.07-81.546-50.75-50.348-100.278c1.008 35.15 17.23 56.557 53.197 48.254c9.285-2.142 16.8-15.472 8.55-23.373c-61.138-58.54-47.58-160.406 65.548-174.168z"/></svg>';

  // src/assets/game-icons/magicSwirl.svg
  var magicSwirl_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="512" height="512" viewBox="0 0 512 512"><path fill="currentColor" d="M247.79 18.734C137.967 17.596 19.874 96.94 19.73 244.53l21.403-51.395c-9.485 72.28-7.75 147.236 38.79 202.502L38.2 377.355c39.24 69.774 126.333 90.976 200.855 92.51C124.11 429.9 67.87 342.277 63.912 246.492c-6.722-211.78 260.658-217.694 340.78-75.77c-3.417-19.492-8.623-38.426-15.618-56.11c77.406 89.155 59.293 214.875-21.29 253.036c-24.25 3.95-48.93 12.06-60.954 19c-58.548 33.802-6.27 126.536 53.225 92.188c9.44-5.45 23.404-17.303 36.494-31.352c64.36-59.52 98.1-118.24 93.108-188.94c-6.52 29.1-19.175 57.904-35.623 84.683c63.158-146.822 7.956-263.89-144.838-301.354c12.097 5.835 23.503 13.63 33.873 23.36c-57.415-23.752-131.123-22.62-186.884 3.505c28.066-26.2 64.776-43.73 102.2-49.642q-5.281-.307-10.597-.362zm-19.74 160.202l-19.843 100.566c-2.958 3.81-5.64 6.852-9.033 9.94l-25.688-49.096l-22.705 11.93l31.37 60.945c4.48 11.474 10.02 20.68 15.162 28.524c28.063 42.803 64.547 35.252 95.303 9.555l87.28-48.452l-12.71-22.498l-66.136 36.94c-1.517-3.154-3.266-6.552-5.056-9.51l67.818-64.96l-17.54-18.695l-66.47 63.762c-2.356-2.318-4.238-4.527-6.765-6.54l45.084-78.085l-22.733-13.127l-45.864 78.297c-3.79-1.31-7.72-2.2-11.595-2.745l15.656-81.896l-25.533-4.854z"/></svg>';

  // src/assets/game-icons/mouthWatering.svg
  var mouthWatering_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="512" height="512" viewBox="0 0 512 512"><path fill="currentColor" d="M87.75 30.72c-5.104.03-10.333.31-15.72.874c5.062 68.606 43.873 95.378 127.75 66.25c-26.35-43.13-62.692-67.418-112.03-67.125zm343.906 0c-49.338-.294-85.65 23.993-112 67.124c83.878 29.128 122.69 2.356 127.75-66.25a161 161 0 0 0-15.75-.875zM13.844 146.437c-.826 4.546-1.156 9.206-1.156 13.875c0 46.09 41.19 86.706 104.124 111.062c23.478 13.02 30.98 83.94 19.688 117.156c-2.47 7.262-12.906 26.75-12.906 35.626c0 12.032 9.75 21.97 21.78 21.97c12.033 0 21.75-9.938 21.75-21.97c0-8.93-11.05-28.19-13.093-35.625c-8.77-31.912-10.39-102.854 18.157-101.186c25.43 5.13 52.85 7.945 81.438 8h.094c19.003 1.767 24.585 30.437 15.843 56.156c-1.87 5.496-9.405 20.092-9.407 26.813c0 9.108 7.36 16.468 16.47 16.468c9.108 0 16.468-7.36 16.468-16.467c0-6.762-8.328-21.184-9.875-26.813c-5.86-26.52-4.616-39.726 12.81-41.656c19.96-2.21 28.955 77.376 17.283 111.72c-3.103 9.124-16 34-16 45.155a27.21 27.21 0 0 0 27.28 27.28a27.216 27.216 0 0 0 27.282-27.28c0-11.226-13.9-35.817-16.47-45.158c-11.062-40.25-6.928-130.344 18.533-138.093c.02-.008.04-.026.062-.033c.387-.097.77-.182 1.156-.28c.013-.01.02-.023.03-.032c2.284-.584 4.54-1.19 6.783-1.813c52.234-11.767 35.948 18 56.06 18c16.277 0 5.717-34.745 31.314-59.03c29.47-22.375 46.906-50.01 46.906-79.97c0-4.668-.36-9.328-1.188-13.875c-13.076 54.687-115.864 96.438-240.593 96.438c-124.73 0-227.55-41.75-240.626-96.438zM418 341.938c-12.01 0-21.75 9.74-21.75 21.75s9.74 21.718 21.75 21.718s21.72-9.71 21.72-21.72c0-12.008-9.71-21.748-21.72-21.748"/></svg>';

  // src/assets/game-icons/pawPrint.svg
  var pawPrint_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="height: 512px; width: 512px;"><g class="" transform="translate(0,0)" style=""><path d="m258.53 16.727-7.553 10.367s-14.79 20.28-29.64 44.75c-7.424 12.236-14.9 25.517-20.622 38.108-5.722 12.588-9.965 24.188-9.965 35.076 0 37.323 30.458 67.783 67.78 67.783 37.327 0 67.784-30.46 67.784-67.782 0-10.888-4.242-22.488-9.964-35.076-5.723-12.59-13.162-25.872-20.586-38.108-14.85-24.47-29.676-44.75-29.676-44.75l-7.557-10.367zm0 32.778c4.848 6.853 10.65 14.592 21.245 32.05 7.185 11.838 14.33 24.617 19.565 36.133 5.235 11.518 8.285 22.092 8.285 27.34 0 14.03-5.816 26.627-15.172 35.553a36.439 36.439 0 0 0 2.662-13.698c0-20.197-36.57-70.364-36.57-70.364s-36.572 50.167-36.572 70.364c0 4.86.955 9.492 2.675 13.734-9.377-8.928-15.21-21.54-15.21-35.588 0-5.248 3.087-15.822 8.322-27.34 5.234-11.516 12.38-24.295 19.564-36.133 10.594-17.457 16.36-25.195 21.207-32.05zM60.66 79.365l-3.285 12.374s-6.49 24.27-11.496 52.45c-2.503 14.09-4.652 29.19-5.44 42.998-.786 13.807-.538 26.13 3.395 36.28 13.484 34.803 52.873 52.214 87.676 38.73 34.803-13.486 52.21-52.913 38.728-87.713-3.933-10.153-12.09-19.383-21.974-29.055-9.884-9.67-21.653-19.38-32.996-28.105C92.578 99.875 71.463 86.3 71.463 86.3l-10.805-6.936zm394.725 0L444.578 86.3s-21.114 13.574-43.8 31.025c-11.344 8.726-23.114 18.434-33 28.105-9.883 9.672-18.002 18.902-21.936 29.055-13.483 34.8 3.888 74.227 38.69 87.713 34.804 13.484 74.23-3.927 87.714-38.73 3.934-10.15 4.145-22.473 3.358-36.28-.787-13.807-2.935-28.907-5.438-42.998-5.006-28.18-11.498-52.45-11.498-52.45l-3.285-12.376zm-11.826 30.55c2.042 8.137 4.64 17.446 8.213 37.56 2.42 13.636 4.46 28.142 5.18 40.772.72 12.63-.255 23.576-2.15 28.47-5.067 13.076-15.038 22.716-26.98 27.66a36.445 36.445 0 0 0 7.412-11.788c7.298-18.834-8.68-78.824-8.68-78.824s-52.227 33.564-59.523 52.395a36.434 36.434 0 0 0-2.467 13.725c-5.504-11.706-6.38-25.56-1.31-38.648 1.897-4.893 8.553-13.598 17.595-22.445 9.042-8.85 20.34-18.203 31.316-26.647 16.206-12.465 24.41-17.6 31.393-22.23zm-371.035.037c6.997 4.64 15.17 9.745 31.355 22.193 10.977 8.444 22.276 17.798 31.318 26.647 9.042 8.847 15.696 17.552 17.592 22.445 5.068 13.082 4.197 26.932-1.3 38.635.063-4.557-.722-9.2-2.47-13.71-7.295-18.832-59.523-52.396-59.523-52.396s-15.975 59.99-8.678 78.823a36.468 36.468 0 0 0 7.415 11.79c-11.945-4.942-21.92-14.583-26.988-27.663-1.896-4.894-2.872-15.84-2.152-28.47.72-12.63 2.797-27.137 5.22-40.772 3.568-20.096 6.167-29.375 8.212-37.523zm184.294 122.39c-43.658 0-79.31 28.473-87.347 66.686-22.89 8.593-43.324 19.73-57.71 34.275-15.516 15.688-25.112 34.84-25.112 55.518 0 30.856 20.97 57.578 52.124 75.997 31.154 18.418 73.17 29.38 119.322 29.38s87.99-10.95 118.994-29.38c31.004-18.43 51.832-45.18 51.832-75.996 0-20.867-9.736-40.188-25.48-55.99-14.613-14.672-35.395-25.875-58.692-34.423-8.38-37.994-44.513-66.066-87.932-66.066zm0 18.686c37.094 0 66.64 24.44 71.178 54.936l.838 5.656 5.44 1.832c23.44 7.892 42.783 19.37 55.92 32.557 13.136 13.187 20.04 27.7 20.04 42.817 0 14.93-6.83 29.376-19.52 42.178 3.65-7.606 5.618-15.66 5.618-24.004 0-25.25-31.607-64.705-89.514-79.745.172-1.57.26-3.162.26-4.774 0-25.574-22.076-46.31-49.308-46.31-27.233 0-49.31 20.736-49.31 46.31 0 1.543.085 3.065.24 4.568-58.223 14.926-89.483 54.81-89.483 79.953h-.002c0 8.25 1.937 16.215 5.533 23.743-12.622-12.743-19.41-27.096-19.41-41.916 0-14.955 6.777-29.303 19.71-42.38C137.982 333.37 157.032 321.95 180.09 314l5.402-1.868.805-5.694c4.324-30.847 33.236-55.41 70.52-55.41z" fill="%23000000" fill-opacity="1"></path></g></svg>';

  // src/assets/game-icons/plasticDuck.svg
  var plasticDuck_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="height: 512px; width: 512px;"><g class="" transform="translate(0,0)" style=""><path d="M322.8 50.96c-28.1.66-52.4 13.13-65.8 38.48-13.4 25.36-16.1 64.96 3.6 120.46v.2c3.2 9.4 2.4 19.2-2.6 26.4-5 7.3-12.9 11.6-21.9 14.5-18 5.8-42.3 6.4-69.3 4.5-48.7-3.5-105.4-15.7-142.38-27.9-2.34 56.3 13.28 113.7 45.28 157.2 34.2 46.5 86.2 77.5 156 76.2 45.3-.8 98.8-7.4 140.2-25.5 41.4-18 70-45.8 71.3-92.4v-.1c.6-19.8-18.4-47.1-36.3-74.7-8.9-13.8-17.3-27.8-21.9-42.4-4.6-14.5-5-30.3 3.2-44.5l.2-.3.2-.3c22.2-32.6 18.7-64.5 3.9-89.24-14.7-24.79-41.5-41.12-63.7-40.6zm30.5 42.05a18 18 0 0 1 18 17.99 18 18 0 0 1-18 18 18 18 0 0 1-18-18 18 18 0 0 1 18-17.99zM416 130.2c.4 14.3-2.4 29.3-9.2 44.2 19.5-1.2 38.8-3.4 53.6-8.4 9.6-3.1 17.1-7.4 21.8-12.3 2.7-2.9 4.5-6 5.6-9.7-24.7.3-51-6.3-71.8-13.8zm-72.6 142.5c6.5 13.6 6.1 28.2.7 40.9-5.4 12.7-15.3 23.8-27.7 33.9-24.7 20-59.6 35.5-93.6 44.8-34 9.3-66.4 12.8-88.7 4.8-11.2-4-20.6-12.6-22.2-24.5-1.6-12 3.6-24.8 14.4-39.8l14.6 10.6c-9.4 13-11.8 22.2-11.2 26.8.7 4.7 3.1 7.3 10.4 10 14.7 5.2 45.9 3.5 78-5.3 32-8.7 65.3-23.8 87-41.4 10.8-8.8 18.7-18.2 22.4-27 3.8-8.8 4.1-16.8-.3-26z" fill="%23000000" fill-opacity="1"></path></g></svg>';

  // src/assets/game-icons/pumpkinMask.svg
  var pumpkinMask_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="height: 512px; width: 512px;"><g class="" transform="translate(0,0)" style=""><path d="M256.156 16.875c-48.954 107.457-128.398 80.9-139.312 36.97-57.82 42.426-95.53 110.673-95.53 187.56-.002 128.577 104.928 232.94 234.217 232.94 129.29 0 234.22-104.363 234.22-232.94 0-76.278-37.273-143.847-94.313-186.343-11.27 42.068-78.266 67.493-139.28-38.187zM134.686 134.53c9.528-.102 20.15 2.023 30.5 6.5 25.48 11.024 39.598 32.274 31.5 47.47-8.095 15.196-35.33 18.585-60.81 7.563-25.48-11.023-39.567-32.304-31.47-47.5 4.808-9.023 16.358-13.88 30.28-14.032zm248.97 1.19c14.907-.366 27.44 4.532 32.5 14.03 8.097 15.196-6.02 36.446-31.5 47.47-25.48 11.02-52.684 7.632-60.78-7.564-8.098-15.196 5.988-36.446 31.468-47.47 9.555-4.132 19.368-6.25 28.312-6.467zM151.75 228.562 205 316.719l54.5-77.5 40.438 80.56 65.406-89.936 34.812 69.25 73.375-62.844c-1.208 56.223-38.25 133.637-83.78 165.344l-23.344-68.03-56.125 93.186-56.467-89.656-70.094 83.594-53.25-91.72-17.407 64.344c-46.367-40.18-69.01-99.95-66.907-158.593l54.157 68.186 51.437-74.344z" fill="%23000000" fill-opacity="1"></path></g></svg>';

  // src/assets/game-icons/rearAura.svg
  var rearAura_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="height: 512px; width: 512px;"><g class="" transform="translate(0,0)" style=""><path d="M256 23.545c-33.5 0-63.525 15.197-83.55 39.053L92.7 38.313l60.85 56.867a108.125 108.125 0 0 0-4.905 18.105L18.498 132.592 148.635 151.9a108.074 108.074 0 0 0 4.902 18.118L92.7 226.873l78.898-24.025a91.447 91.447 0 0 1 5.203-7.702 74.948 74.948 0 0 1 7.02-8.027c-11.435-15.14-18.21-34.01-18.21-54.503 0-50.03 40.357-90.39 90.39-90.39 50.03 0 90.39 40.36 90.39 90.39 0 20.494-6.774 39.36-18.208 54.5a74.47 74.47 0 0 1 7.02 8.03 90.44 90.44 0 0 1 5.204 7.703l78.895 24.023-60.837-56.857a108.173 108.173 0 0 0 4.902-18.116l130.137-19.308-130.147-19.307a107.94 107.94 0 0 0-4.906-18.103l60.85-56.87-79.75 24.286C319.52 38.743 289.5 23.545 256 23.545zm.002 45.182c-23.1 0-42.257 23.548-45.89 54.412h36.544v18.686H209.85c1.698 19.243 9.403 35.878 20.408 46.133H219.94c-11.947 2.392-20.787 8.595-28.223 18.446-7.56 10.013-13.304 23.86-17.34 39.875-7.365 29.223-8.98 65.15-9.22 97.33h39.972l10.32 149.056h81.103l10.322-149.057h39.973c-.24-32.18-1.856-68.107-9.22-97.33-4.037-16.014-9.782-29.86-17.34-39.874-7.437-9.85-16.278-16.054-28.226-18.447h-10.316c11.005-10.256 18.71-26.89 20.408-46.134h-36.81V123.14h36.547c-3.633-30.865-22.79-54.413-45.888-54.413z" fill="%23000000" fill-opacity="1"></path></g></svg>';

  // src/assets/game-icons/rollingEnergy.svg
  var rollingEnergy_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="height: 512px; width: 512px;"><g class="" transform="translate(0,0)" style=""><path d="M247.938 22.512c-5.385.044-10.847.333-16.383.88 49.65 15.005 92.127 46.742 123.267 86.678-74.16-71.848-204.8-83.864-278.77 6.287 31.555-16.907 66.822-25.68 102.405-27.865C84.727 118.84 4.497 225.975 21.87 343.362c5.088-48.045 28.862-89.52 61.384-123.923-38.258 74.284-32.22 171.41 40.635 231.185-25.41-47.422-33.08-102.405-25.536-154.338-1.3 105.1 83.482 210.304 201.582 198.656-49.652-15.006-92.126-46.743-123.266-86.68 77.723 65.68 198.16 66.868 278.77-6.288-118.67 44.753-214.692 21.26-272.243-27.8-59.206-40.744-78.126-121.06-41.584-184.353a139.021 139.021 0 0 1 23.967-30.66c2.78-3.18 5.636-6.203 8.598-9.074 2.31-1.3 4.622-2.572 6.935-3.824 24.733-17.675 54.666-26.8 84.914-26.028 22.46.573 45.09 6.594 65.88 18.598 44.02 25.415 68.904 71.378 69.593 118.842a61.63 61.63 0 0 1 .957 10.734c0 33.88-27.466 61.344-61.346 61.344-33.877 0-61.342-27.465-61.342-61.344 0-1.698.083-3.376.218-5.04 5.484 18.857 22.88 32.644 43.504 32.644 25.027 0 45.315-20.29 45.315-45.315 0-24.785-19.903-44.912-44.596-45.298a93.138 93.138 0 0 0-15.167-1.246c-51.192 0-92.69 41.5-92.69 92.69s41.5 92.687 92.69 92.687a96.7 96.7 0 0 0 3.1-.056c-.168.064-.333.132-.5.195a165.74 165.74 0 0 0 12.336-1.03c52.59-.886 123.364-25.954 154.09-71.7-18.303 8.484-35.666 14.587-52.488 16.763a181.554 181.554 0 0 0 17.482-24.133c36.147-44.718 64.673-112.748 53.784-168.2-7.195 19.63-15.35 37.046-25.623 51.583-3.217-46.517-23.284-92.15-63.62-125.244 25.406 47.422 33.076 102.404 25.532 154.337 1.24-100.173-75.723-200.44-185.2-199.535z" fill="%23000000" fill-opacity="1"></path></g></svg>';

  // src/assets/game-icons/spellBook.svg
  var spellBook_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="height: 512px; width: 512px;"><g class="" transform="translate(-12,-44)" style=""><path d="M319.61 20.654c13.145 33.114 13.144 33.115-5.46 63.5 33.114-13.145 33.116-13.146 63.5 5.457-13.145-33.114-13.146-33.113 5.457-63.498-33.114 13.146-33.113 13.145-63.498-5.459zM113.024 38.021c-11.808 21.04-11.808 21.04-35.724 24.217 21.04 11.809 21.04 11.808 24.217 35.725 11.808-21.04 11.808-21.04 35.724-24.217-21.04-11.808-21.04-11.808-24.217-35.725zm76.55 56.184c-.952 50.588-.95 50.588-41.991 80.18 50.587.95 50.588.95 80.18 41.99.95-50.588.95-50.588 41.99-80.18-50.588-.95-50.588-.95-80.18-41.99zm191.177 55.885c-.046 24.127-.048 24.125-19.377 38.564 24.127.047 24.127.046 38.566 19.375.047-24.126.046-24.125 19.375-38.564-24.126-.047-24.125-.046-38.564-19.375zm-184.086 83.88a96.38 96.38 0 0 0-3.492.134c-18.591 1.064-41.868 8.416-77.445 22.556L76.012 433.582c78.487-20.734 132.97-21.909 170.99-4.615V247.71c-18.076-8.813-31.79-13.399-46.707-13.737a91.166 91.166 0 0 0-3.629-.002zm122.686 11.42a209.3 209.3 0 0 0-8.514.098c-12.81.417-27.638 2.215-45.84 4.522v177.135c43.565-7.825 106.85-4.2 171.244 7.566l-39.78-177.197c-35.904-8.37-56.589-11.91-77.11-12.123zm2.289 16.95c18.889.204 36.852 2.768 53.707 5.02l4.437 16.523c-23.78-3.75-65.966-4.906-92.467-.98l-.636-17.805c11.959-2.154 23.625-2.88 34.959-2.758zm-250.483 4.658L60.54 313.002h24.094l10.326-46.004H71.158zm345.881 0 39.742 177.031 2.239 9.973 22.591-.152-40.855-186.852h-23.717zm-78.857 57.82c16.993.026 33.67.791 49.146 2.223l3.524 17.174c-32.645-3.08-72.58-2.889-102.995 0l-.709-17.174c16.733-1.533 34.04-2.248 51.034-2.223zm-281.793 6.18-6.924 30.004h24.394l6.735-30.004H56.389zm274.418 27.244c4.656.021 9.487.085 14.716.203l2.555 17.498c-19.97-.471-47.115.56-59.728 1.05l-.7-17.985c16.803-.493 29.189-.828 43.157-.766zm41.476.447c8.268.042 16.697.334 24.121.069l2.58 17.74c-8.653-.312-24.87-.83-32.064-.502l-2.807-17.234a257.25 257.25 0 0 1 8.17-.073zm-326.97 20.309-17.985 77.928 25.035-.17 17.455-77.758H45.313zm303.164 11.848c19.608-.01 38.66.774 56.449 2.572l2.996 20.787c-34.305-4.244-85.755-7.697-119.1-3.244l-.14-17.922c20.02-1.379 40.186-2.183 59.795-2.193zm-166.606 44.05c-30.112.09-67.916 6.25-115.408 19.76l-7.22 2.053 187.759-1.27v-6.347c-16.236-9.206-37.42-14.278-65.13-14.196zm134.41 6.174c-19.63.067-37.112 1.439-51.283 4.182v10.064l177.594-1.203c-44.322-8.634-89.137-13.17-126.31-13.043zM26 475v18h460v-18H26z" fill="%23000000" fill-opacity="1"></path></g></svg>';

  // src/assets/game-icons/wolfTrap.svg
  var wolfTrap_default = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="height: 512px; width: 512px;"><g class="" transform="translate(0,0)" style=""><path d="m106 113.773-32.963 74.375a99.166 99.166 0 0 0-3.12.704c-5.293 1.296-9.95 2.918-14.044 4.79l-8.266-53.435-25.037 87.277a108.288 108.288 0 0 0-3.338 11.635l-.26.905.07-.04c-3.632 16.665-3.56 35.726 3.597 55.818 3.306 14.022 15.515 30.355 40.24 48.135 29.193 20.992 75.05 42.954 138.495 63.86a39.272 39.272 0 0 1-.393-5.486c0-12.21 5.637-23.185 14.432-30.447l-4.07-42.73-31.54 37.69a620.827 620.827 0 0 1-27.896-11.3l-2.95-78.177-33.57 60.615c-9.068-4.85-17.496-9.773-25.294-14.75l-4.627-90.04-28.932 65.057c-7.485-6.607-13.957-13.243-19.45-19.86-4.244-20.016-.412-38.063 6.145-52.42l4.483-2.602c15.852-5.496 35.514-7.645 58.504-6.182 32.732 2.084 72.51 11.748 118.152 30.803.098-13.092 7.704-24.51 18.692-30.142l-5.597-52.59-30.14 42.78c-9.68-3.6-19.025-6.73-28.012-9.41l-4.26-68.73-32.567 59.774c-11.784-2.163-22.712-3.436-32.716-3.91l-3.77-71.97zm323.08 29.936-15.973 70.28c-9.928-1.244-20.884-1.876-32.837-1.777l-19.58-66.443-18.075 68.964c-9.342 1.12-19.127 2.635-29.316 4.55l-19.015-44.84-16.422 45.742c8.9 6.183 14.768 16.47 14.768 28.04 0 2.407-.257 4.758-.74 7.03 47.224-10.57 87.28-13.166 119.37-9.7 22.9 2.47 41.908 7.938 56.592 16.05l3.978 3.332c4.016 15.265 4.72 33.704-2.873 52.707-6.54 5.582-14.047 11.016-22.547 16.25l-17.43-69.034-19.89 87.94c-8.51 3.565-17.626 6.972-27.356 10.198l-19.724-61.576-19.274 72.674a622.45 622.45 0 0 1-29.326 6.37l-22.605-45.43-14.87 49.995a39.091 39.091 0 0 1 4.02 17.283 39.03 39.03 0 0 1-3.476 16.107c70.416-9.85 122.176-24.18 155.893-40.565 27.394-13.31 42.205-27.326 47.852-40.582 10.472-18.58 13.79-37.348 13.048-54.388l.063.053-.102-.942a107.887 107.887 0 0 0-1.308-12.035l-9.81-90.26-17.243 51.245c-3.714-2.54-8.03-4.93-13.023-7.11-.96-.417-1.95-.822-2.954-1.222L429.08 143.71zm-170.584 89.07c-8.642 0-15.443 6.802-15.443 15.445 0 3.53 1.15 6.74 3.084 9.318a161.247 161.247 0 0 1 23.101 1.844c2.91-2.793 4.705-6.733 4.705-11.162 0-8.64-6.806-15.446-15.447-15.446zm-12.652 43.468c-1.02-.003-2.032.005-3.033.025-12.016.244-22.59 2.134-30.23 4.98-5.094 1.9-8.82 4.23-10.85 6.22-2.03 1.99-2.375 3.155-2.375 4.37 0 2.426 3.81 8.437 14.258 13.844 10.448 5.408 25.905 9.714 42.992 10.954 17.088 1.24 32.486-.854 42.674-4.65 5.093-1.898 8.82-4.23 10.85-6.22 2.03-1.987 2.374-3.154 2.374-4.368 0-2.43-3.81-8.44-14.258-13.847-10.447-5.408-25.904-9.712-42.992-10.95a134.712 134.712 0 0 0-9.41-.357zm-5.688 57.215-2.96 29.51c1.08-.09 2.17-.15 3.273-.15 5.382 0 10.524 1.1 15.214 3.077l3.05-30.406a159.916 159.916 0 0 1-18.578-2.032zm.313 48.05c-11.6 0-20.798 9.2-20.798 20.8 0 11.595 9.2 20.796 20.797 20.796 11.594 0 20.798-9.203 20.798-20.798 0-11.595-9.202-20.798-20.8-20.798z" fill="%23000000" fill-opacity="1"></path></g></svg>';

  // src/dto/animaFurtaMessageDto.ts
  var PosDto = class {
    x;
    y;
  };
  __decorateClass([
    IsNumber()
  ], PosDto.prototype, "x", 2);
  __decorateClass([
    IsNumber()
  ], PosDto.prototype, "y", 2);
  var AnimaFurtaMessageDto = class {
    name;
    target;
    appearance;
    params;
    message;
    pos;
  };
  __decorateClass([
    IsString(),
    IsIn(["toggleKneel", "changeAppearance", "publishAction", "sendMessage", "mapMove"])
  ], AnimaFurtaMessageDto.prototype, "name", 2);
  __decorateClass([
    IsNumber(),
    ValidateIf((o4) => o4.name === "changeAppearance")
  ], AnimaFurtaMessageDto.prototype, "target", 2);
  __decorateClass([
    ValidateIf((o4) => o4.name === "changeAppearance")
  ], AnimaFurtaMessageDto.prototype, "appearance", 2);
  __decorateClass([
    ValidateIf((o4) => o4.name === "publishAction")
  ], AnimaFurtaMessageDto.prototype, "params", 2);
  __decorateClass([
    ValidateIf((o4) => o4.name === "sendMessage"),
    IsString()
  ], AnimaFurtaMessageDto.prototype, "message", 2);
  __decorateClass([
    ValidateIf((o4) => o4.name === "mapMove"),
    ValidateNested(),
    Type(() => PosDto)
  ], AnimaFurtaMessageDto.prototype, "pos", 2);

  // src/spell-effects/animaFurtaEffect.ts
  var AnimaFurtaEffect = class extends BaseEffect {
    get isInstant() {
      return false;
    }
    get name() {
      return "Anima Furta";
    }
    get atoms() {
      return [1001 /* IGNIS */, 1e3 /* NOX */, 1005 /* MOTUS */, 1002 /* RATIO */];
    }
    get description() {
      return "Lets you control target. (Chat, activities, poses, wardrobe, map moving)";
    }
    getControllableCharacter() {
      return ChatRoomCharacter.find((c7) => {
        return c7.BCC && this.isActiveOn(c7) && this.getSpellsWithEffect(c7)[0].castedBy === Player.MemberNumber;
      });
    }
    trigger(event) {
      super.trigger(event);
      console.log("event", event);
      if (event.init) {
        this.hookFunction("ChatRoomLeave", a.OBSERVE, (args, next) => {
          this.remove(event);
          return next(args);
        });
        this.hookFunction("ChatRoomListUpdate", a.OBSERVE, (args, next) => {
          const [_4, adding, memberNumber] = args;
          if (!adding && memberNumber === event.sourceCharacter?.MemberNumber) this.remove(event);
          return next(args);
        });
        this.hookFunction("ChatRoomSendChat", a.OVERRIDE_BEHAVIOR, () => {
          return g2.sendLocal("You lost control of yourself");
        });
        this.hookFunction("Player.CanWalk", a.OVERRIDE_BEHAVIOR, () => false);
        this.hookFunction("Player.CanChangeToPose", a.OVERRIDE_BEHAVIOR, () => false);
        this.hookFunction("Player.CanChangeOwnClothes", a.OVERRIDE_BEHAVIOR, () => false);
        this.hookFunction("PoseCanChangeUnaidedStatus", a.OVERRIDE_BEHAVIOR, () => PoseChangeStatus.NEVER);
        this.hookFunction("ChatRoomCanAttemptStand", a.OVERRIDE_BEHAVIOR, () => false);
        this.hookFunction("ChatRoomCanAttemptKneel", a.OVERRIDE_BEHAVIOR, () => false);
        this.hookFunction("Player.CanInteract", a.OVERRIDE_BEHAVIOR, () => false);
        this.hookFunction("InventoryGroupIsBlockedForCharacter", a.OVERRIDE_BEHAVIOR, () => true);
        this.hookFunction("DialogClickExpressionMenu", a.OVERRIDE_BEHAVIOR, () => false);
        this.hookFunction("ChatRoomMapViewMove", a.OVERRIDE_BEHAVIOR, () => false);
        g2.onPacket("animaFurtaCommand", AnimaFurtaMessageDto, (data, sender) => {
          console.log(data);
          if (!sender.BCC) return;
          if (!getSpellEffect(1e3 /* ANIMA_FURTA */).isActive) return;
          console.log(data);
          if (data.name === "toggleKneel") {
            const Dictionary = new DictionaryBuilder().sourceCharacter(Player).build();
            ServerSend("ChatRoomChat", { Content: Player.IsKneeling() ? "StandUp" : "KneelDown", Type: "Action", Dictionary });
            PoseSetActive(Player, Player.IsKneeling() ? "BaseLower" : "Kneel");
            ChatRoomStimulationMessage("Kneel");
            ServerSend("ChatRoomCharacterPoseUpdate", { Pose: Player.ActivePose });
          }
          if (data.name === "changeAppearance") {
            ServerAppearanceLoadFromBundle(
              T2(data.target),
              T2(data.target).AssetFamily,
              data.appearance,
              data.target
            );
            ChatRoomCharacterUpdate(T2(data.target));
          }
          if (data.name === "publishAction") {
            ServerSend("ChatRoomChat", data.params);
          }
          if (data.name === "sendMessage") {
            g2.sendChat(data.message);
          }
          if (data.name === "mapMove") {
            if (!Player.MapData) Player.MapData = {};
            Player.MapData.Pos = {
              X: data.pos.x,
              Y: data.pos.y
            };
            ChatRoomMapViewMovement = {
              X: data.pos.x,
              Y: data.pos.y,
              Direction: "East",
              TimeStart: CommonTime(),
              TimeEnd: CommonTime()
            };
          }
        });
      } else {
        this.remove(event);
      }
    }
  };

  // src/spell-effects/masqueradaEffect.ts
  var MasqueradaEffect = class extends BaseEffect {
    get isInstant() {
      return false;
    }
    get name() {
      return "Masquerada";
    }
    get atoms() {
      return [1006 /* MATERIA */];
    }
    get description() {
      return "Changes target's appearance.";
    }
    get parameters() {
      return [
        {
          name: "outfit",
          type: "text",
          label: "Outfit Code"
        }
      ];
    }
    trigger(event) {
      console.log(event);
      super.trigger(event);
      if (!event.init) return;
      const lastOutfit = LZString.compressToBase64(JSON.stringify(ServerAppearanceBundle(Player.Appearance)));
      this.setParameter("lastOutfit", lastOutfit, event.spellName);
      ServerAppearanceLoadFromBundle(Player, Player.AssetFamily, JSON.parse(LZString.decompressFromBase64(event.data.outfit)), event.sourceCharacter.MemberNumber);
      ChatRoomCharacterUpdate(Player);
      this.setParameter("outfit", void 0, event.spellName);
    }
    remove(event, spellName, push = true) {
      super.remove(event, spellName, push);
      console.log(event);
      ServerAppearanceLoadFromBundle(Player, Player.AssetFamily, JSON.parse(LZString.decompressFromBase64(event.data.lastOutfit)));
      ChatRoomCharacterUpdate(Player);
    }
  };

  // src/spell-effects/nomenFraudisEffect.ts
  var NomenFraudisEffect = class extends BaseEffect {
    get isInstant() {
      return false;
    }
    get name() {
      return "Nomen Fraudis";
    }
    get atoms() {
      return [1002 /* RATIO */];
    }
    get icon() {
      return null;
    }
    get description() {
      return "Causes the target to hallucinate with charaters names. They will be swapped.";
    }
    trigger(event) {
      super.trigger(event);
      this.hookFunction("ChatRoomMessage", a.OVERRIDE_BEHAVIOR, (args, next) => {
        const message = args[0];
        const sender = T2(message.Sender);
        if (!sender) return next(args);
        if (!sender.IsPlayer() && message.Type === "Chat") {
          const randomPlayer = ChatRoomCharacter[h2(0, ChatRoomCharacter.length - 1)];
          message.Sender = randomPlayer.MemberNumber;
        }
        return next(args);
      });
    }
  };

  // src/spell-effects/spatiumTransitusEffect.ts
  var SpatiumTransitusEffect = class extends BaseEffect {
    get name() {
      return "Spatium Transitus";
    }
    get atoms() {
      return [1002 /* RATIO */];
    }
    get icon() {
      return null;
    }
    get description() {
      return "Teleports target in the specified chat room. If the chat room does not exist then target creates it.";
    }
    get parameters() {
      return [
        {
          name: "lobby",
          type: "choice",
          label: "Lobby",
          options: [
            {
              name: "classic",
              text: "Classic"
            },
            {
              name: "extended",
              text: "Extended (Recommened)"
            }
          ]
        },
        {
          name: "isPrivate",
          type: "boolean",
          label: "Is Private"
        },
        {
          name: "roomName",
          type: "text",
          label: "Room Name"
        }
      ];
    }
    trigger(event) {
      super.trigger(event);
      const roomName = event.data.roomName;
      const isPrivate = event.data.isPrivate;
      const space = event.data.lobby;
      if (!roomName?.trim()) return;
      ChatRoomLeave();
      CommonSetScreen("Online", "ChatSearch");
      ChatSearchLastQueryJoinTime = CommonTime();
      ChatSearchLastQueryJoin = roomName;
      ServerSend("ChatRoomJoin", { Name: roomName });
      ChatRoomPingLeashedPlayers();
      ServerSocket.once("ChatRoomSearchResponse", (data) => {
        if (["CannotFindRoom", "RoomFull"].includes(data)) {
          ServerAccountUpdate.QueueData({ RoomCreateLanguage: "EN" });
          const newRoom = {
            Name: roomName,
            Language: "EN",
            Description: "",
            Background: "Introduction",
            Private: isPrivate,
            Locked: false,
            Space: space === "extended" ? "X" : "",
            Game: "",
            Admin: "",
            Whitelist: "",
            Ban: "",
            Limit: 10,
            BlockCategory: ""
          };
          ServerSend("ChatRoomCreate", newRoom);
          ServerSocket.once("ChatRoomCreateResponse", (data2) => {
            if (data2 === "ChatRoomCreated") {
              ChatRoomPingLeashedPlayers();
            }
          });
        }
      });
    }
  };

  // src/spell-effects/visioInversioEffect.ts
  var VisioInversioEffect = class extends BaseEffect {
    get isInstant() {
      return false;
    }
    get name() {
      return "Visio Inversio";
    }
    get atoms() {
      return [1003 /* LUX */];
    }
    get description() {
      return "Flips target's screen.";
    }
    trigger(event) {
      super.trigger(event);
      document.body.setAttribute("style", document.body.getAttribute("style") + "rotate:180deg;");
    }
    remove(event) {
      super.remove(event);
      document.body.setAttribute("style", document.body.getAttribute("style").replace("rotate:180deg;", ""));
    }
  };

  // src/spell-effects/vocisPrivatioEffect.ts
  var VocisPrivatioEffect = class extends BaseEffect {
    get isInstant() {
      return false;
    }
    get name() {
      return "Vocis Privatio";
    }
    get atoms() {
      return [1001 /* IGNIS */, 1002 /* RATIO */];
    }
    get description() {
      return "Takes away the target's voice. The target will lose the ability to send messages except chat commands and OOC.";
    }
    trigger(event) {
      super.trigger(event);
      this.hookFunction("ServerSend", a.OVERRIDE_BEHAVIOR, (args, next) => {
        const message = args[0];
        const params = args[1];
        if (message === "ChatRoomChat" && ["Chat", "Whisper"].includes(params.Type)) {
          if (params.Content[0] !== "(") {
            return g2.sendAction(`${N3(Player)} tries to say something, but <pronoun> doesn't have a voice`);
          }
        }
        return next(args);
      });
    }
  };

  // src/dto/castSpellMessageDto.ts
  var SpellDto = class {
    name;
    icon;
    effects;
    data;
    createdBy;
  };
  __decorateClass([
    IsString({ message: "tytg" })
  ], SpellDto.prototype, "name", 2);
  __decorateClass([
    ValidateIf((dto) => isEnum(dto.icon, SpellIcon))
  ], SpellDto.prototype, "icon", 2);
  __decorateClass([
    IsString(),
    ValidateIf((dto) => dto.effects?.split("")?.every((e2) => getSpellEffect(e2.charCodeAt(0)) instanceof BaseEffect))
  ], SpellDto.prototype, "effects", 2);
  __decorateClass([
    IsObject()
  ], SpellDto.prototype, "data", 2);
  __decorateClass([
    Type(() => CreatedByDto),
    ValidateNested()
  ], SpellDto.prototype, "createdBy", 2);
  var CastSpellMessageDto = class {
    spell;
  };
  __decorateClass([
    Type(() => SpellDto),
    ValidateNested()
  ], CastSpellMessageDto.prototype, "spell", 2);
  var CreatedByDto = class {
    name;
    id;
  };
  __decorateClass([
    IsString()
  ], CreatedByDto.prototype, "name", 2);
  __decorateClass([
    IsNumber()
  ], CreatedByDto.prototype, "id", 2);

  // src/spell-effects/traditioArtiumEffect.ts
  var TraditioArtiumEffect = class extends BaseEffect {
    get name() {
      return "Traditio Artium";
    }
    get atoms() {
      return [1001 /* IGNIS */];
    }
    get description() {
      return "Establishes connection with target, letting you share your magical arts";
    }
    async trigger(event) {
      super.trigger(event);
      const spells = event.sourceCharacter?.BCC?.darkMagic?.spells;
      if (!spells) return;
      const result = await ee2.showDialog({
        type: "choice_multiple",
        title: "Choose spells",
        body: "",
        width: 600,
        buttons: {
          direction: "column",
          list: spells.map((s4) => ({ text: s4.name, value: s4 }))
        }
      });
      console.log("Result", result);
      modStorage.darkMagic ??= {};
      modStorage.darkMagic.spells ??= [];
      modStorage.darkMagic.spells.push(...result);
      Q2.success({
        message: `Learned spells: ${result.map((s4) => s4.name).join(", ")}`,
        duration: 5e3
      });
      syncStorage();
    }
  };

  // src/modules/darkMagic.ts
  var showAnimaFurtaWaitingButton = false;
  var MAGIC_ITEMS = ["RainbowWand", "Broom", "AnimeGirlWand", "Baguette"];
  var MinimumRole = /* @__PURE__ */ ((MinimumRole2) => {
    MinimumRole2[MinimumRole2["EVERYONE"] = 0] = "EVERYONE";
    MinimumRole2[MinimumRole2["FRIEND"] = 1] = "FRIEND";
    MinimumRole2[MinimumRole2["WHITELIST"] = 2] = "WHITELIST";
    MinimumRole2[MinimumRole2["LOVER"] = 3] = "LOVER";
    MinimumRole2[MinimumRole2["OWNER"] = 4] = "OWNER";
    return MinimumRole2;
  })(MinimumRole || {});
  var atoms = {
    [1e3 /* NOX */]: {
      name: "Nox",
      iconDataUrl: nox_default,
      iconColor: "black",
      description: "It is used in the most powerful and dangerous spells, which is why by default all these spells are limited in the permission settings for your safety"
    },
    [1001 /* IGNIS */]: {
      name: "Ignis",
      iconDataUrl: ignis_default,
      iconColor: "orange",
      description: "The aspect used in spells for attack, self-defense, and so on"
    },
    [1002 /* RATIO */]: {
      name: "Ratio",
      iconDataUrl: ratio_default,
      iconColor: "#ffd1d1",
      description: "It is used in spells which change the behavior of the target and encourage the performance of any actions"
    },
    [1003 /* LUX */]: {
      name: "Lux",
      iconDataUrl: lux_default,
      iconColor: "yellow",
      description: "It is used in neutral safe spells, such as power-ups"
    },
    [1004 /* GEMITUM */]: {
      name: "Gemitum",
      iconDataUrl: gemitum_default,
      iconColor: "red",
      description: "It is used in erotic spells..?"
    },
    [1005 /* MOTUS */]: {
      name: "Motus",
      iconDataUrl: motus_default,
      iconColor: "#d4d0ff",
      description: "It is used in spells that move a target or make it move"
    },
    [1006 /* MATERIA */]: {
      name: "Materia",
      iconDataUrl: materia_default,
      iconColor: "#8f59fbff",
      description: "It is used in spells that change materia, that is, the space around you"
    }
  };
  var spellEffects = {
    [1e3 /* ANIMA_FURTA */]: new AnimaFurtaEffect(),
    [1001 /* MASQUERADA */]: new MasqueradaEffect(),
    [1002 /* NOMEN_FRAUDIS */]: new NomenFraudisEffect(),
    [1003 /* PURIFICATIO */]: new PurificatioEffect(),
    [1004 /* SLUMBER_CURSE */]: new SlumberCurseEffect(),
    [1005 /* SPATIUM_TRANSITUS */]: new SpatiumTransitusEffect(),
    [1006 /* VISIO_INVERSION */]: new VisioInversioEffect(),
    [1007 /* VOCIS_ALTERATIO */]: new VocisAlteratioEffect(),
    [1008 /* VOCIS_PRIVATIO */]: new VocisPrivatioEffect(),
    [1009 /* TRADITIO_ARTIUM */]: new TraditioArtiumEffect()
  };
  var SpellIcon = /* @__PURE__ */ ((SpellIcon2) => {
    SpellIcon2["BEAMS_AURA"] = "BeamsAura";
    SpellIcon2["CAULDRON"] = "Cauldron";
    SpellIcon2["DEATH_JUICE"] = "DeathJuice";
    SpellIcon2["DICE_FIRE"] = "DiceFire";
    SpellIcon2["DOOR"] = "Door";
    SpellIcon2["EVIL_BOOK"] = "EvilBook";
    SpellIcon2["HANDCUFFS"] = "Handcuffs";
    SpellIcon2["HANGING_SPIDER"] = "HangingSpider";
    SpellIcon2["HAUNTING"] = "Haunting";
    SpellIcon2["HEARTS"] = "Hearts";
    SpellIcon2["ICE_BOLT"] = "IceBolt";
    SpellIcon2["LOVE_INJECTION"] = "LoveInjection";
    SpellIcon2["MAGIC_PORTAL"] = "MagicPortal";
    SpellIcon2["MAGIC_SWIRL"] = "MagicSwirl";
    SpellIcon2["MOUTH_WATERING"] = "MouthWatering";
    SpellIcon2["PAW_PRINT"] = "PawPrint";
    SpellIcon2["PLASTIC_DUCK"] = "PlasticDuck";
    SpellIcon2["PUMPKIN_MASK"] = "PumpkinMask";
    SpellIcon2["REAR_AURA"] = "RearAura";
    SpellIcon2["ROLLING_ENERGY"] = "RollingEnergy";
    SpellIcon2["SPELL_BOOK"] = "SpellBool";
    SpellIcon2["WOLF_TRAP"] = "WolfTrap";
    return SpellIcon2;
  })(SpellIcon || {});
  var spellIcons = [
    {
      name: "BeamsAura" /* BEAMS_AURA */,
      dataurl: beamsAura_default
    },
    {
      name: "Cauldron" /* CAULDRON */,
      dataurl: cauldron_default
    },
    {
      name: "DeathJuice" /* DEATH_JUICE */,
      dataurl: deathJuice_default
    },
    {
      name: "DiceFire" /* DICE_FIRE */,
      dataurl: diceFire_default
    },
    {
      name: "Door" /* DOOR */,
      dataurl: door_default
    },
    {
      name: "EvilBook" /* EVIL_BOOK */,
      dataurl: evilBook_default
    },
    {
      name: "Handcuffs" /* HANDCUFFS */,
      dataurl: handcuffs_default
    },
    {
      name: "HangingSpider" /* HANGING_SPIDER */,
      dataurl: hangingSpider_default
    },
    {
      name: "Haunting" /* HAUNTING */,
      dataurl: haunting_default
    },
    {
      name: "Hearts" /* HEARTS */,
      dataurl: hearts_default
    },
    {
      name: "IceBolt" /* ICE_BOLT */,
      dataurl: iceBolt_default
    },
    {
      name: "LoveInjection" /* LOVE_INJECTION */,
      dataurl: loveInjection_default
    },
    {
      name: "MagicPortal" /* MAGIC_PORTAL */,
      dataurl: magicPortal_default
    },
    {
      name: "MagicSwirl" /* MAGIC_SWIRL */,
      dataurl: magicSwirl_default
    },
    {
      name: "MouthWatering" /* MOUTH_WATERING */,
      dataurl: mouthWatering_default
    },
    {
      name: "PawPrint" /* PAW_PRINT */,
      dataurl: pawPrint_default
    },
    {
      name: "PlasticDuck" /* PLASTIC_DUCK */,
      dataurl: plasticDuck_default
    },
    {
      name: "PumpkinMask" /* PUMPKIN_MASK */,
      dataurl: pumpkinMask_default
    },
    {
      name: "RearAura" /* REAR_AURA */,
      dataurl: rearAura_default
    },
    {
      name: "RollingEnergy" /* ROLLING_ENERGY */,
      dataurl: rollingEnergy_default
    },
    {
      name: "SpellBool" /* SPELL_BOOK */,
      dataurl: spellBook_default
    },
    {
      name: "WolfTrap" /* WOLF_TRAP */,
      dataurl: wolfTrap_default
    }
  ];
  function getSpellIcon(name) {
    return spellIcons.find((s4) => s4.name === name);
  }
  function getSpellIcons() {
    return spellIcons;
  }
  function getSpellEffect(effectId) {
    return spellEffects[effectId];
  }
  function getSpellEffects() {
    return spellEffects;
  }
  function isMagicItem(item) {
    if (!item) return false;
    return MAGIC_ITEMS.includes(item?.Asset?.Name);
  }
  function allowSpellCast(sourceCharacter, targetCharacter, spell) {
    if (!ServerChatRoomGetAllowItem(sourceCharacter, targetCharacter)) {
      return {
        result: false,
        reason: "INTERACTIONS_NOT_ALLOWED" /* INTERACTIONS_NOT_ALLOWED */
      };
    }
    if (!sourceCharacter.IsPlayer() && !sourceCharacter.BCC || !targetCharacter.IsPlayer() && !targetCharacter.BCC) return { result: false, reason: "NOT_BCC_PLAYER" /* NOT_BCC_PLAYER */ };
    if (spell.effects.length === 0) return { result: false, reason: "NO_EFFECTS" /* NO_EFFECTS */ };
    const storage = targetCharacter.IsPlayer() ? modStorage : targetCharacter.BCC;
    if ((storage.darkMagic?.state?.spells ?? []).length >= 10 && !isSpellInstant(spell)) {
      return {
        result: false,
        reason: "SPELLS_COUNT_LIMIT" /* SPELLS_COUNT_LIMIT */
      };
    }
    for (const effectChar of spell.effects.split("")) {
      const effect = getSpellEffect(effectChar.charCodeAt(0));
      const canCast = effect.canCast(sourceCharacter, targetCharacter);
      if (canCast.result === false) {
        return canCast;
      }
    }
    return { result: true };
  }
  function isSpellInstant(spell) {
    return spell.effects.split("").every((c7) => spellEffects[c7.charCodeAt(0)].isInstant);
  }
  function generateSpellName(name, attempt = 1) {
    let search;
    if (attempt === 1) search = name;
    else search = `${name} (${attempt - 1})`;
    if (modStorage.darkMagic?.state?.spells.find((s4) => s4.name === search)) {
      return generateSpellName(name, attempt + 1);
    }
    return search;
  }
  function processSpell(castedBy, spell) {
    if (!isSpellInstant(spell)) {
      modStorage.darkMagic ??= {};
      modStorage.darkMagic.state ??= {};
      modStorage.darkMagic.state.spells ??= [];
      modStorage.darkMagic.state.spells.push({
        name: generateSpellName(spell.name.trim()),
        icon: spell.icon,
        effects: spell.effects.split("").filter((c7) => !spellEffects[c7.charCodeAt(0)].isInstant).join(""),
        data: JSON.parse(JSON.stringify(spell.data ?? {})),
        createdBy: spell.createdBy,
        castedBy: {
          name: N3(castedBy),
          id: castedBy.MemberNumber
        }
      });
    }
    for (const c7 of spell.effects) {
      const effect = spellEffects[c7.charCodeAt(0)];
      effect.trigger({
        sourceCharacter: castedBy,
        data: JSON.parse(JSON.stringify(spell.data?.[c7] ?? {})),
        spellName: spell.name,
        init: true
      });
    }
    syncStorage();
    g2.sendAction(`Effects of "${spell.name}" spell was applied to ${N3(Player)}`);
  }
  function castSpell(target, spell) {
    g2.sendAction(`${N3(Player)} casts "${spell.name}" spell on ${N3(target)}`);
    if (target.IsPlayer()) {
      processSpell(target, spell);
    } else {
      g2.sendPacket("castSpell", { spell }, target.MemberNumber);
    }
  }
  async function loadDarkMagic() {
    for (const spell of modStorage.darkMagic?.state?.spells ?? []) {
      for (const c7 of spell.effects) {
        const effect = spellEffects[c7.charCodeAt(0)];
        effect.trigger({
          sourceCharacter: void 0,
          data: spell.data?.[c7],
          spellName: spell.name,
          init: false
        });
      }
    }
    g2.onPacket("castSpell", CastSpellMessageDto, (data, sender) => {
      console.log("Cast spell", data);
      const allow = allowSpellCast(sender, Player, data.spell);
      if (allow.result === false) return;
      processSpell(sender, data.spell);
    });
    c2("ChatRoomToggleKneel", a.OVERRIDE_BEHAVIOR, (args, next) => {
      const controllableCharacter = getSpellEffect(1e3 /* ANIMA_FURTA */).getControllableCharacter();
      if (!controllableCharacter) return next(args);
      if (![PoseChangeStatus.NEVER, PoseChangeStatus.NEVER_WITHOUT_AID].includes(
        PoseCanChangeUnaidedStatus(
          controllableCharacter,
          controllableCharacter.IsKneeling() ? "BaseLower" : "Kneel"
        )
      )) {
        PoseSetActive(
          controllableCharacter,
          controllableCharacter.IsKneeling() ? "BaseLower" : "Kneel"
        );
        return g2.sendPacket("animaFurtaCommand", {
          name: "toggleKneel"
        }, controllableCharacter.MemberNumber);
      }
      return next(args);
    });
    c2("ChatRoomSendChat", a.OVERRIDE_BEHAVIOR, (args, next) => {
      const controllableCharacter = getSpellEffect(1e3 /* ANIMA_FURTA */).getControllableCharacter();
      if (!controllableCharacter) return next(args);
      g2.sendPacket("animaFurtaCommand", {
        name: "sendMessage",
        message: document.getElementById("InputChat").value
      }, controllableCharacter.MemberNumber);
      document.getElementById("InputChat").value = "";
    });
    c2("ChatRoomAllowItem", a.OVERRIDE_BEHAVIOR, (args, next) => {
      const controllableCharacter = getSpellEffect(1e3 /* ANIMA_FURTA */).getControllableCharacter();
      if (!controllableCharacter) return next(args);
      const data = args[0];
      if (typeof data === "object" && typeof data.MemberNumber === "number" && typeof data.AllowItem === "boolean") {
        if (CurrentCharacter != null && CurrentCharacter.MemberNumber === data.MemberNumber) {
          data.AllowItem = ServerChatRoomGetAllowItem(controllableCharacter, CurrentCharacter);
          CurrentCharacter.AllowItem = data.AllowItem;
          CharacterSetCurrent(CurrentCharacter);
        }
      }
    });
    c2("DialogCanUnlock", a.OBSERVE, (args, next) => {
      const controllableCharacter = getSpellEffect(1e3 /* ANIMA_FURTA */).getControllableCharacter();
      if (!controllableCharacter) return next(args);
      const [target, item] = args;
      const lock = InventoryGetLock(item);
      if (!controllableCharacter.CanInteract()) return false;
      if (lock.Asset.Name === "ExclusivePadlock") return controllableCharacter.MemberNumber !== target.MemberNumber;
      if (lock.Asset.ExclusiveUnlock) {
        const allowedMembers = CommonConvertStringToArray(item.Property.MemberNumberListKeys);
        if (item.Property.MemberNumberListKeys != null) return allowedMembers.includes(controllableCharacter.MemberNumber);
        if (item.Property.LockMemberNumber === controllableCharacter.MemberNumber) return true;
      }
      if (lock.Asset.OwnerOnly && target.IsOwnedByMemberNumber(controllableCharacter.MemberNumber)) return true;
      if (lock.Asset.LoverOnly && target.IsLoverOfMemberNumber(controllableCharacter.MemberNumber)) return true;
      if (lock.Asset.FamilyOnly && target.IsInFamilyOfMemberNumber(controllableCharacter.MemberNumber)) return true;
      return false;
    });
    c2("InventoryLock", a.OVERRIDE_BEHAVIOR, (args, next) => {
      const controllableCharacter = getSpellEffect(1e3 /* ANIMA_FURTA */).getControllableCharacter();
      if (!controllableCharacter) return next(args);
      args[3] = controllableCharacter.MemberNumber;
      return next(args);
    });
    c2("Player.CanChangeOwnClothes", a.OVERRIDE_BEHAVIOR, (args, next) => {
      if (getSpellEffect(1e3 /* ANIMA_FURTA */).getControllableCharacter()) return false;
      return next(args);
    });
    c2("Player.IsDeaf", a.OVERRIDE_BEHAVIOR, (args, next) => {
      const controllableCharacter = getSpellEffect(1e3 /* ANIMA_FURTA */).getControllableCharacter();
      if (controllableCharacter) {
        return controllableCharacter.IsDeaf();
      }
      return next(args);
    });
    c2("Player.IsBlind", a.OVERRIDE_BEHAVIOR, (args, next) => {
      const controllableCharacter = getSpellEffect(1e3 /* ANIMA_FURTA */).getControllableCharacter();
      if (controllableCharacter) return controllableCharacter.IsBlind();
      return next(args);
    });
    c2("Player.GetDeafLevel", a.OVERRIDE_BEHAVIOR, (args, next) => {
      const controllableCharacter = getSpellEffect(1e3 /* ANIMA_FURTA */).getControllableCharacter();
      if (controllableCharacter) return controllableCharacter.GetDeafLevel();
      return next(args);
    });
    c2("Player.GetBlindLevel", a.OVERRIDE_BEHAVIOR, (args, next) => {
      const controllableCharacter = getSpellEffect(1e3 /* ANIMA_FURTA */).getControllableCharacter();
      if (controllableCharacter) return controllableCharacter.GetBlindLevel();
      return next(args);
    });
    c2("Player.HasTints", a.OVERRIDE_BEHAVIOR, (args, next) => {
      const effect = getSpellEffect(1e3 /* ANIMA_FURTA */);
      const controllableCharacter = effect.getControllableCharacter();
      if (controllableCharacter || effect.isActive) return true;
      return next(args);
    });
    c2("Player.GetTints", a.OVERRIDE_BEHAVIOR, (args, next) => {
      const effect = getSpellEffect(1e3 /* ANIMA_FURTA */);
      const controllableCharacter = effect.getControllableCharacter();
      if (controllableCharacter || effect.isActive) return [{ r: 0, g: 0, b: 100, a: 0.5 }];
      return next(args);
    });
    window.getControllableC = () => getSpellEffect(1e3 /* ANIMA_FURTA */).getControllableCharacter();
    I(
      "DrawCharacter",
      {
        "if (!C.IsPlayer() && !OverrideDark && (Player.IsBlind() || Player.HasTints())) {": `if (((getControllableC() && C.MemberNumber !== getControllableC().MemberNumber) || (!getControllableC() && !C.IsPlayer())) && !OverrideDark && (Player.IsBlind() || Player.HasTints())) {`
      }
    );
    c2("PoseCanChangeUnaidedStatus", a.OVERRIDE_BEHAVIOR, (args, next) => {
      const controllableCharacter = getSpellEffect(1e3 /* ANIMA_FURTA */).getControllableCharacter();
      if (!controllableCharacter) return next(args);
      if (!args[0].IsPlayer()) return next(args);
      args[0] = controllableCharacter;
      return next(args);
    });
    c2("Player.CanInteract", a.OVERRIDE_BEHAVIOR, (args, next) => {
      const controllableCharacter = getSpellEffect(1e3 /* ANIMA_FURTA */).getControllableCharacter();
      if (!controllableCharacter) return next(args);
      return controllableCharacter.CanInteract();
    });
    c2("DialogInventoryAdd", a.OVERRIDE_BEHAVIOR, (args, next) => {
      const controllableCharacter = getSpellEffect(1e3 /* ANIMA_FURTA */).getControllableCharacter();
      if (!controllableCharacter) return next(args);
      const [C4, item, isWorn, sortOrder] = args;
      const asset = item.Asset;
      if (asset.FamilyOnly && !controllableCharacter.IsInFamilyOfMemberNumber(C4.MemberNumber)) return;
      if (asset.LoverOnly && !controllableCharacter.IsLoverOfCharacter(C4)) return;
      if (asset.OwnerOnly && !C4.IsOwnedByCharacter(controllableCharacter)) return;
      const inventoryItem = DialogInventoryCreateItem(C4, item, isWorn, sortOrder);
      if (item.Craft != null) {
        inventoryItem.Craft = item.Craft;
        if (inventoryItem.SortOrder.charAt(0) === DialogSortOrder.Usable.toString()) inventoryItem.SortOrder = DialogSortOrder.PlayerFavoriteUsable.toString() + item.Asset.Description;
        if (inventoryItem.SortOrder.charAt(0) === DialogSortOrder.Unusable.toString()) inventoryItem.SortOrder = DialogSortOrder.PlayerFavoriteUnusable.toString() + item.Asset.Description;
      }
      DialogInventory.push(inventoryItem);
    });
    c2("ChatRoomOpenWardrobeScreen", a.OVERRIDE_BEHAVIOR, (args, next) => {
      const controllableCharacter = getSpellEffect(1e3 /* ANIMA_FURTA */).getControllableCharacter();
      if (!controllableCharacter) return next(args);
      if (controllableCharacter?.CanInteract()) {
        const module = CurrentModule;
        const screen = CurrentScreen;
        const inChatRoom = ServerPlayerIsInChatRoom();
        if (inChatRoom) {
          ChatRoomHideElements();
          ChatRoomStatusUpdate("Wardrobe");
        }
        CharacterAppearanceLoadCharacter(controllableCharacter, (ready) => {
          CommonSetScreen(module, screen);
          if (inChatRoom) {
            ChatRoomShowElements();
            ChatRoomStatusUpdate(null);
            if (ready) {
              g2.sendPacket("animaFurtaCommand", {
                name: "changeAppearance",
                target: controllableCharacter.MemberNumber,
                appearance: ServerAppearanceBundle(controllableCharacter.Appearance)
              }, controllableCharacter.MemberNumber);
            }
          }
        });
        return;
      }
      return next(args);
    });
    c2("ChatRoomOpenInformationScreen", a.OVERRIDE_BEHAVIOR, (args, next) => {
      const controllableCharacter = getSpellEffect(1e3 /* ANIMA_FURTA */).getControllableCharacter();
      if (!controllableCharacter) return next(args);
      ChatRoomHideElements();
      ChatRoomStatusUpdate("Preference");
      InformationSheetLoadCharacter(controllableCharacter);
    });
    c2("ChatRoomPublishAction", a.OVERRIDE_BEHAVIOR, (args, next) => {
      const controllableCharacter = getSpellEffect(1e3 /* ANIMA_FURTA */).getControllableCharacter();
      if (!controllableCharacter) return next(args);
      const [C4, Action, PrevItem, NextItem] = args;
      if (CurrentScreen !== "ChatRoom") return false;
      const dictionary = new DictionaryBuilder().sourceCharacter(controllableCharacter).destinationCharacter(C4).targetCharacter(C4);
      if (PrevItem != null) {
        dictionary.asset(PrevItem.Asset, "PrevAsset", PrevItem.Craft && PrevItem.Craft.Name);
      }
      if (NextItem != null) {
        dictionary.asset(NextItem.Asset, "NextAsset", NextItem.Craft && NextItem.Craft.Name);
      }
      if (C4.FocusGroup != null) {
        dictionary.focusGroup(C4.FocusGroup.Name);
      }
      g2.sendPacket("animaFurtaCommand", {
        name: "changeAppearance",
        appearance: ServerAppearanceBundle(C4.Appearance),
        target: C4.MemberNumber
      }, controllableCharacter.MemberNumber);
      g2.sendPacket("animaFurtaCommand", {
        name: "publishAction",
        params: { Content: Action, Type: "Action", Dictionary: dictionary.build() }
      }, controllableCharacter.MemberNumber);
      return true;
    });
    c2("ChatRoomMapViewMove", a.OVERRIDE_BEHAVIOR, async (args, next) => {
      if (showAnimaFurtaWaitingButton) return;
      const controllableCharacter = getSpellEffect(1e3 /* ANIMA_FURTA */).getControllableCharacter();
      if (!controllableCharacter) return next(args);
      controllableCharacter.MapData.Pos.X += (args[0] === "West" ? -1 : 0) + (args[0] === "East" ? 1 : 0);
      controllableCharacter.MapData.Pos.Y += (args[0] === "North" ? -1 : 0) + (args[0] === "South" ? 1 : 0);
      showAnimaFurtaWaitingButton = true;
      setTimeout(() => {
        showAnimaFurtaWaitingButton = false;
      }, 1e3);
      g2.sendPacket("animaFurtaCommand", {
        name: "mapMove",
        pos: { x: controllableCharacter.MapData.Pos.X, y: controllableCharacter.MapData.Pos.Y }
      }, controllableCharacter.MemberNumber);
    });
    c2("ChatRoomViews.Map.DrawUi", a.OBSERVE, (args, next) => {
      const controllableCharacter = getSpellEffect(1e3 /* ANIMA_FURTA */).getControllableCharacter();
      if (controllableCharacter && showAnimaFurtaWaitingButton) {
        DrawButton(790, 790, 200, 60, "Waiting...", "White");
      }
      return next(args);
    });
    window.bccDrawGridCharacter = () => window.getControllableC() ?? Player;
    I("ChatRoomMapViewDrawGrid", {
      "let ScreenX = (X - Player.MapData.Pos.X) * TileWidth + ChatRoomMapViewPerceptionRange * TileWidth;": "let ScreenX = (X - bccDrawGridCharacter().MapData.Pos.X) * TileWidth + ChatRoomMapViewPerceptionRange * TileWidth;",
      "let ScreenY = (Y - Player.MapData.Pos.Y) * TileHeight + ChatRoomMapViewPerceptionRange * TileWidth;": "let ScreenY = (Y - bccDrawGridCharacter().MapData.Pos.Y) * TileHeight + ChatRoomMapViewPerceptionRange * TileWidth;",
      "let MaxRange = Math.max(Math.abs(X - Player.MapData.Pos.X), Math.abs(Y - Player.MapData.Pos.Y));": "let MaxRange = Math.max(Math.abs(X - bccDrawGridCharacter().MapData.Pos.X), Math.abs(Y - bccDrawGridCharacter().MapData.Pos.Y));"
    });
    I("ChatRoomMapViewCalculatePerceptionMasks", {
      "if (ChatRoomMapViewHasSuperPowers()) {": "if (ChatRoomMapViewHasSuperPowers() || !bccDrawGridCharacter().IsPlayer()) {"
    });
  }

  // src/subscreens/dark-magic-subscreen/effectSettingsSubscreen.ts
  var EffectSettingsSubscreen = class extends te {
    constructor(effectId, spellSettings) {
      super();
      this.effectId = effectId;
      this.spellSettings = spellSettings;
      this.spellSettings = JSON.parse(JSON.stringify(this.spellSettings));
    }
    get name() {
      return `Create Spell > ${spellEffects[this.effectId].name}'s Settings`;
    }
    setParameter(name, value) {
      this.spellSettings.data[String.fromCharCode(this.effectId)] ??= {};
      this.spellSettings.data[String.fromCharCode(this.effectId)][name] = value;
    }
    getParameterValue(name) {
      this.spellSettings.data[String.fromCharCode(this.effectId)] ??= {};
      return this.spellSettings.data[String.fromCharCode(this.effectId)][name];
    }
    load() {
      super.load();
      if (!spellEffects[this.effectId].parameters) return this.exit();
      let y5 = 200;
      for (const param of spellEffects[this.effectId].parameters) {
        switch (param.type) {
          case "text": {
            const textInput = this.createInput({
              x: 200,
              y: y5,
              value: this.getParameterValue(param.name),
              placeholder: param.label,
              width: 500,
              onChange: () => {
                this.setParameter(param.name, textInput.value);
              }
            });
            y5 += 100;
            break;
          }
          case "number": {
            const numberInput = this.createInput({
              x: 200,
              y: y5,
              value: this.getParameterValue(param.name),
              placeholder: param.label,
              width: 500,
              modules: {
                base: [
                  new c({
                    type: "number"
                  })
                ]
              },
              onChange: () => {
                this.setParameter(param.name, numberInput.value);
              }
            });
            y5 += 100;
            break;
          }
          case "boolean":
            this.createCheckbox({
              text: param.label,
              x: 200,
              y: y5,
              isChecked: this.getParameterValue(param.name) ?? false,
              onChange: () => {
                this.setParameter(param.name, !(this.getParameterValue(param.name) ?? false));
              }
            });
            y5 += 100;
            break;
          case "choice":
            this.createSelect({
              x: 200,
              y: y5,
              options: param.options,
              currentOption: this.getParameterValue(param.name) ?? param.options[0].name,
              width: 500,
              onChange: (name) => {
                this.setParameter(param.name, name);
              }
            });
            y5 += 100;
            break;
        }
      }
    }
    exit() {
      super.exit();
      this.setSubscreen(
        new SpellEditorSubscreen(this.spellSettings, "Effects")
      );
    }
  };

  // src/subscreens/dark-magic-subscreen/spellEditorSubscreen.ts
  var SpellEditorSubscreen = class extends te {
    constructor(spellSettings, currentTab) {
      super();
      this.spellSettings = spellSettings;
      this.currentTab = currentTab;
      if (this.spellSettings) this.spellSettings = JSON.parse(JSON.stringify(this.spellSettings));
      this.spellSettings ??= {
        name: "",
        icon: getSpellIcons()[0].name,
        effects: "",
        data: {},
        createdBy: {
          name: N3(Player),
          id: Player.MemberNumber
        }
      };
      this.currentTab ??= "Main";
      this._oldName = this.spellSettings.name;
    }
    effectNameElement;
    effectDescriptionElement;
    effectTraitsContainerElement;
    effectAddElement;
    effectSettingsElement;
    effectAtomsElement;
    effectAtomsContainerElement;
    selectedEffectId;
    selectedSpellIconElement;
    _oldName;
    get icon() {
      return createElement(Wand);
    }
    get name() {
      return "Spell Editor";
    }
    selectEffect(effectId) {
      this.selectedEffectId = effectId;
      const effect = spellEffects[effectId];
      if (this.effectNameElement) {
        this.effectNameElement.textContent = effect.name;
      } else {
        this.effectNameElement = this.createText({
          text: effect.name,
          x: 1e3,
          y: 315,
          width: 500,
          modules: {
            base: [
              new y({
                fontWeight: "bold"
              })
            ]
          }
        });
      }
      if (this.effectTraitsContainerElement) {
        this.effectTraitsContainerElement.innerHTML = "";
      } else {
        this.effectTraitsContainerElement = this.createContainer({
          x: 1600,
          y: 315,
          width: 300
        });
      }
      if (effect.isInstant) {
        this.effectTraitsContainerElement.append(
          this.createText({
            place: false,
            text: "Instant",
            color: "#3e2653",
            fontSize: 2.5,
            modules: {
              base: [
                new y({
                  background: "#d18cff",
                  borderRadius: "0.25em",
                  padding: "0.2em 0.65em"
                })
              ]
            }
          })
        );
      }
      if (this.effectDescriptionElement) {
        this.effectDescriptionElement.textContent = effect.description;
      } else {
        this.effectDescriptionElement = this.createText({
          text: effect.description,
          withBorder: true,
          padding: 3,
          x: 1e3,
          y: 400,
          width: 800,
          height: 280,
          fontSize: 3
        });
      }
      if (this.effectAtomsElement) {
      } else {
        this.effectAtomsElement = this.createText({
          text: "Atoms:",
          x: 1e3,
          y: 700
        });
      }
      if (this.effectAtomsContainerElement) {
        this.effectAtomsContainerElement.innerHTML = "";
      } else {
        this.effectAtomsContainerElement = this.createContainer({
          x: 1e3,
          y: 760,
          width: 800,
          modules: {
            base: [
              new y({
                display: "flex",
                columnGap: "0.25em"
              })
            ]
          }
        });
      }
      effect.atoms.forEach((atomId) => {
        const atom = atoms[atomId];
        if (!atom) return;
        this.effectAtomsContainerElement.append(
          this.createSvg({
            dataurl: atom.iconDataUrl,
            size: 50,
            place: false
          })
        );
      });
      if (this.effectAddElement) {
        this.effectAddElement.textContent = this.spellSettings.effects.includes(String.fromCharCode(effectId)) ? "Remove Effect" : "Add Effect";
      } else {
        this.effectAddElement = this.createButton({
          text: this.spellSettings.effects.includes(String.fromCharCode(effectId)) ? "Remove Effect" : "Add Effect",
          anchor: "bottom-left",
          x: 1e3,
          y: 75,
          padding: 2,
          width: 365,
          onClick: () => {
            const effectButtonElement = document.getElementById(`effect-${String.fromCharCode(this.selectedEffectId)}-button`);
            if (this.spellSettings.effects.includes(String.fromCharCode(this.selectedEffectId))) {
              this.spellSettings.effects = this.spellSettings.effects.replaceAll(String.fromCharCode(this.selectedEffectId), "");
              this.effectAddElement.textContent = "Add Effect";
              effectButtonElement.setAttribute("data-zc-style", "default");
            } else {
              this.spellSettings.effects += String.fromCharCode(this.selectedEffectId);
              this.effectAddElement.textContent = "Remove Effect";
              effectButtonElement.setAttribute("data-zc-style", "green");
            }
          }
        });
      }
      if (this.effectSettingsElement) {
        this.effectSettingsElement.classList.toggle("zcDisabled", !spellEffects[this.selectedEffectId].parameters);
      } else {
        this.effectSettingsElement = this.createButton({
          text: "Settings",
          anchor: "bottom-left",
          x: 1435,
          y: 75,
          padding: 2,
          width: 365,
          onClick: () => this.setSubscreen(new EffectSettingsSubscreen(this.selectedEffectId, this.spellSettings)),
          isDisabled: () => !spellEffects[this.selectedEffectId].parameters
        });
      }
    }
    load() {
      super.load();
      this.createTabs({
        x: 160,
        y: 200,
        width: 2e3 - 320,
        tabs: [
          {
            name: "Main",
            load: () => {
              const spellName = this.createInput({
                x: 200,
                y: 315,
                width: 800,
                placeholder: "Spell name",
                padding: 2,
                value: this.spellSettings.name,
                onChange: () => {
                  this.spellSettings.name = spellName.value;
                }
              });
              this.createText({
                text: "Spell Icon",
                x: 200,
                y: 450
              });
              const iconsContainer = this.createScrollView({
                x: 200,
                y: 515,
                width: 1600,
                scroll: "x",
                modules: {
                  base: [
                    new y({
                      display: "flex",
                      gap: "4px"
                    })
                  ]
                }
              });
              iconsContainer.addEventListener("wheel", (e2) => {
                if (e2.deltaY !== 0) {
                  e2.preventDefault();
                  iconsContainer.scrollLeft += e2.deltaY;
                }
              });
              getSpellIcons().forEach((icon) => {
                iconsContainer.append(
                  this.createSvg({
                    place: false,
                    dataurl: icon.dataurl,
                    size: 150,
                    modules: {
                      base: [
                        new y({
                          cursor: "pointer",
                          borderRadius: "4px",
                          flexShrink: "0",
                          background: this.spellSettings.icon === icon.name ? "var(--tmd-element, #e6e6e6)" : ""
                        }),
                        new i({
                          hover: {
                            background: "var(--tmd-element, #e6e6e6)"
                          },
                          active: {
                            padding: "4px"
                          }
                        }),
                        new i2((target) => {
                          this.spellSettings.icon = icon.name;
                          this.selectedSpellIconElement.style.background = "";
                          target.style.background = "var(--tmd-element, #e6e6e6)";
                          this.selectedSpellIconElement = target;
                        })
                      ]
                    }
                  })
                );
              });
              this.selectedSpellIconElement = iconsContainer.children[getSpellIcons().findIndex((i8) => i8.name === this.spellSettings.icon)];
              if (this.spellSettings.createdBy.id !== Player.MemberNumber) {
                this.createText({
                  anchor: "bottom-right",
                  x: 325,
                  y: 115,
                  width: 600,
                  color: "red",
                  text: "Can't edit spells which were not created by you"
                });
              }
              this.createButton({
                anchor: "bottom-right",
                x: 100,
                y: 90,
                text: "Save",
                padding: 3,
                isDisabled: () => this.spellSettings.createdBy.id !== Player.MemberNumber,
                onClick: () => {
                  modStorage.darkMagic ??= {};
                  modStorage.darkMagic.spells ??= [];
                  const spell = modStorage.darkMagic.spells.find((s4) => s4.name === this._oldName);
                  if (spell) {
                    spell.name = this.spellSettings.name;
                    spell.effects = this.spellSettings.effects;
                    spell.icon = this.spellSettings.icon;
                    spell.data = this.spellSettings.data;
                  } else {
                    modStorage.darkMagic.spells.push(this.spellSettings);
                  }
                  this.exit();
                }
              });
            }
          },
          {
            name: "Effects",
            load: () => {
              const container = this.createScrollView({
                scroll: "y",
                x: 160,
                y: 315,
                width: 800,
                height: 1e3 - 75 - 315,
                modules: {
                  base: [
                    new y({
                      display: "flex",
                      flexDirection: "column",
                      rowGap: "0.3em"
                    })
                  ]
                }
              });
              Object.keys(spellEffects).forEach((effectKey) => {
                const effectId = parseInt(effectKey, 10);
                const effectItem = spellEffects[effectId];
                const btn = this.createButton({
                  text: effectItem.name,
                  place: false,
                  padding: 2,
                  fontSize: 3,
                  style: this.spellSettings.effects.includes(String.fromCharCode(effectId)) ? "green" : "default",
                  onClick: () => this.selectEffect(effectId),
                  modules: {
                    base: [
                      new y({
                        width: "100%"
                      })
                    ]
                  }
                });
                btn.id = `effect-${String.fromCharCode(effectId)}-button`;
                container.append(btn);
              });
              this.selectEffect(1e3 /* ANIMA_FURTA */);
            },
            exit: () => {
              this.effectNameElement = null;
              this.effectTraitsContainerElement = null;
              this.effectDescriptionElement = null;
              this.effectAtomsElement = null;
              this.effectAtomsContainerElement = null;
              this.effectAddElement = null;
              this.effectSettingsElement = null;
            }
          }
        ],
        currentTabName: this.currentTab
      });
    }
    exit() {
      super.exit();
      this.setSubscreen(new DarkMagicSubscreen());
    }
  };

  // src/subscreens/dark-magic-subscreen/mySpellsSubscreen.ts
  var MySpellsSubscreen = class extends te {
    get icon() {
      return createElement(BookHeart);
    }
    get name() {
      return "My Spells";
    }
    load() {
      super.load();
      const container = this.createScrollView({
        scroll: "y",
        x: 160,
        y: 220,
        width: 900,
        height: 600,
        modules: {
          base: [
            new y({
              display: "flex",
              flexDirection: "column",
              rowGap: "0.25em"
            })
          ]
        }
      });
      modStorage.darkMagic?.spells?.forEach((spell) => {
        container.append(
          this.createButton({
            text: spell.name,
            icon: getSpellIcon(spell.icon)?.dataurl ?? void 0,
            padding: 2,
            place: false,
            modules: {
              base: [
                new y({
                  position: "relative",
                  width: "100%"
                })
              ]
            },
            onClick: () => {
              this.setSubscreen(new SpellEditorSubscreen(spell));
            }
          })
        );
      });
    }
    exit() {
      super.exit();
      this.setSubscreen(new DarkMagicSubscreen());
    }
  };

  // src/subscreens/dark-magic-subscreen/limitsSubscreen.ts
  var minimumRoleNames = {
    [0 /* EVERYONE */]: "Everyone",
    [1 /* FRIEND */]: "Friend",
    [2 /* WHITELIST */]: "Whitelist",
    [3 /* LOVER */]: "Lover",
    [4 /* OWNER */]: "Owner"
  };
  var LimitsSubscreen = class extends te {
    get icon() {
      return createElement(Ban);
    }
    get name() {
      return "Limits";
    }
    load() {
      super.load();
      const container = this.createScrollView({
        scroll: "y",
        x: 160,
        y: 240,
        width: 800,
        height: 1e3 - 75 - 240,
        modules: {
          base: [
            new y({
              display: "flex",
              flexDirection: "column",
              rowGap: "0.3em"
            })
          ]
        }
      });
      for (const [key, value] of Object.entries(spellEffects)) {
        const _container = this.createContainer({
          place: false,
          modules: {
            base: [
              new y({
                display: "flex",
                alignItems: "center",
                justifyContent: "space-between",
                columnGap: "0.3em"
              })
            ]
          }
        });
        _container.append(
          this.createText({
            place: false,
            text: value.name
          }),
          this.createSelect({
            place: false,
            options: Object.values(MinimumRole).slice(Object.values(MinimumRole).length / 2).map((r5) => ({ name: r5.toString(), text: minimumRoleNames[r5] })),
            currentOption: typeof modStorage.darkMagic?.limits?.effects?.[String.fromCharCode(parseInt(key, 10))] === "number" ? modStorage.darkMagic?.limits?.effects?.[String.fromCharCode(parseInt(key, 10))].toString() : value.atoms.includes(1e3 /* NOX */) ? 3 /* LOVER */.toString() : 1 /* FRIEND */.toString(),
            width: 400,
            onChange(name) {
              modStorage.darkMagic ??= {};
              modStorage.darkMagic.limits ??= {};
              modStorage.darkMagic.limits.effects ??= {};
              modStorage.darkMagic.limits.effects[String.fromCharCode(parseInt(key, 10))] = parseInt(name, 10);
            },
            modules: {
              base: [
                new y({
                  position: "relative"
                }),
                new i2((target) => {
                  if (target.style.zIndex === "100") target.style.zIndex = "10";
                  else target.style.zIndex = "100";
                })
              ]
            }
          })
        );
        container.append(_container);
      }
      this.createText({
        x: 1100,
        y: 240,
        width: 650,
        text: `Here you can limit the use of certain spell effects on yourself.<br><b>Only</b> users who fit the minimum role will be able to use the spell with the effect that you limited.<br>Dangerous effects (those containing "Nox" atom) are limited <b>by default</b>`,
        withBorder: true,
        padding: 2
      });
    }
    exit() {
      super.exit();
    }
  };

  // src/ui-modules/shuffleTextModule.ts
  function shuffleString(str) {
    return str.split("").sort(() => Math.random() - Math.random()).join("");
  }
  var ShuffleTextModule = class extends r {
    effect(context, target) {
      const id = setInterval(() => {
        try {
          target.textContent = shuffleString(target.textContent);
        } catch {
          clearInterval(id);
        }
      }, 1e3);
    }
  };

  // src/subscreens/dark-magic-subscreen/tomeOfKnowledgeSubscreen.ts
  var TomeOfKnowledgeSubscreen = class extends te {
    get icon() {
      return createElement(SendToBack);
    }
    get name() {
      return "Tome of Knowledge";
    }
    load() {
      super.load();
      this.createText({
        text: "Basics",
        x: 200,
        y: 200,
        width: 1600,
        modules: {
          base: [
            new y({
              borderBottom: "1px solid var(--tmd-accent, gray)",
              paddingBottom: "5px"
            })
          ]
        }
      });
      this.createText({
        text: "True magic is not witchcraft, it is science. The ultimate science that governs the fundamental forces of the universe.",
        x: 200,
        y: 265,
        width: 1600
      });
      this.createText({
        text: "The world around us, visible and invisible, is made up of countless Magical Atoms \u2014 primordial particles that are the source of all supernatural energy. A magician is not a shaman who invokes spirits, but an arcanist engineer who, by force of will and mind, gathers these atoms into complex structures \u2014 formulas that we call spells.",
        x: 200,
        y: 365,
        width: 1600
      });
    }
  };

  // src/subscreens/darkMagicSubscreen.ts
  var DarkMagicSubscreen = class extends te {
    get icon() {
      return createElement(Skull);
    }
    get name() {
      return "Dark Magic";
    }
    load() {
      super.load();
      [
        new MySpellsSubscreen(),
        new SpellEditorSubscreen(),
        new LimitsSubscreen()
      ].forEach((t4, i8) => {
        t4.icon.style.width = "auto";
        t4.icon.style.height = "70%";
        this.createButton({
          text: t4.name,
          icon: t4.icon,
          x: 165,
          y: 320 + 115 * i8,
          width: 600,
          padding: 2,
          onClick: () => this.setSubscreen(t4)
        }).style.fontWeight = "bold";
      });
      this.createButton({
        text: "Tome of Knowledge",
        icon: evilBook_default,
        x: 165,
        y: 320 + 115 * 3 + 150,
        style: "inverted",
        width: 600,
        padding: 2,
        onClick: () => this.setSubscreen(new TomeOfKnowledgeSubscreen())
      }).style.fontWeight = "bold";
      this.createText({
        text: "QWERTYUIOPASDFGHJKLZXCVBNM",
        x: 165,
        y: 230,
        width: 2e3 - 2 * 165,
        modules: {
          base: [
            new ShuffleTextModule(),
            new y({
              fontFamily: "Kitnyx2",
              fontWeight: "bold",
              letterSpacing: "1em",
              overflow: "hidden",
              textAlign: "center",
              textShadow: "0 0 0.2em var(--tmd-text)"
            })
          ]
        }
      });
      const radius = 210;
      const centerX = 1350;
      const centerY = 600;
      this.createText({
        text: "Atoms Of Magic",
        x: centerX - radius / 2,
        y: centerY - 40,
        width: 200,
        modules: {
          base: [
            new y({
              textAlign: "center"
            })
          ]
        }
      });
      Object.values(atoms).forEach((atom, i8) => {
        const angle = i8 / Object.values(atoms).length * 2 * Math.PI;
        const x6 = centerX + radius * Math.cos(angle) - 35;
        const y5 = centerY + radius * Math.sin(angle) - 35;
        const iconContainer = this.createContainer({
          x: x6,
          y: y5,
          modules: {
            base: [
              new i({
                base: {
                  borderRadius: "50%",
                  padding: "0.2em",
                  filter: `drop-shadow(0 0 0.12em ${atom.iconColor})`
                }
              })
            ]
          }
        });
        iconContainer.append(
          this.createSvg({
            place: false,
            dataurl: atom.iconDataUrl,
            fill: atom.iconColor,
            size: 70
          })
        );
        this.createText({
          text: atom.name,
          color: atom.iconColor,
          x: x6,
          y: y5 + 80,
          width: 80,
          fontSize: 2,
          modules: {
            base: [
              new y({
                textAlign: "center"
              })
            ]
          }
        });
      });
    }
    exit() {
      super.exit();
      this.setSubscreen(new MainSubscreen());
    }
  };

  // src/modules/quickAccessMenu.ts
  var serverPing;
  var currentSubscreen;
  var qamScrollTop;
  var LOCAL_STORAGE_POS_KEY = "BCC_QAMButton_Pos";
  var Draggable = class {
    element;
    isReadyForDragging;
    isDragging;
    wasDragged;
    offset;
    constructor(element) {
      this.element = element;
      this.isDragging = false;
      this.offset = { x: 0, y: 0 };
      this.init();
    }
    init() {
      this.element.addEventListener("mousedown", this.onMouseDown.bind(this));
      document.addEventListener("mousemove", this.onMouseMove.bind(this));
      document.addEventListener("mouseup", this.onMouseUp.bind(this));
      this.element.addEventListener("touchstart", this.onTouchStart.bind(this));
      document.addEventListener("touchmove", this.onTouchMove.bind(this));
      document.addEventListener("touchend", this.onTouchEnd.bind(this));
      this.element.addEventListener("click", this.onClick.bind(this));
    }
    onMouseDown(e2) {
      if (e2.target === this.element) {
        this.isReadyForDragging = true;
        this.offset = {
          x: e2.clientX - this.element.getBoundingClientRect().left,
          y: e2.clientY - this.element.getBoundingClientRect().top
        };
        e2.preventDefault();
      }
    }
    onMouseMove(e2) {
      if (!this.isReadyForDragging) return;
      const x6 = e2.clientX - this.offset.x;
      const y5 = e2.clientY - this.offset.y;
      if (x6 >= 0 && x6 + this.element.offsetWidth <= window.innerWidth) this.element.style.left = x6 + "px";
      if (y5 >= 0 && y5 + this.element.offsetHeight <= window.innerHeight) this.element.style.top = y5 + "px";
      this.isDragging = true;
    }
    onMouseUp() {
      if (this.isReadyForDragging) this.isReadyForDragging = false;
      if (this.isDragging) {
        this.isDragging = false;
        this.wasDragged = true;
        if (typeof localStorage.setItem === "function") {
          const { top, left } = this.element.getBoundingClientRect();
          localStorage.setItem(LOCAL_STORAGE_POS_KEY, `${top}:${left}`);
        }
        setTimeout(() => {
          this.wasDragged = false;
        }, 100);
      }
    }
    onTouchStart(e2) {
      if (e2.target === this.element) {
        this.isReadyForDragging = true;
        const touch = e2.touches[0];
        this.offset = {
          x: touch.clientX - this.element.getBoundingClientRect().left,
          y: touch.clientY - this.element.getBoundingClientRect().top
        };
        e2.preventDefault();
      }
    }
    onTouchMove(e2) {
      if (!this.isReadyForDragging) return;
      const touch = e2.touches[0];
      const x6 = touch.clientX - this.offset.x;
      const y5 = touch.clientY - this.offset.y;
      this.element.style.left = x6 + "px";
      this.element.style.top = y5 + "px";
      e2.preventDefault();
      this.isDragging = true;
    }
    onTouchEnd() {
      if (this.isDragging) {
        this.isReadyForDragging = false;
        this.isDragging = false;
        this.wasDragged = true;
        setTimeout(() => {
          this.wasDragged = false;
        }, 100);
      }
    }
    onClick() {
      if (this.isDragging || this.wasDragged) return;
      console.log(this.isDragging, this.wasDragged);
      if (document.querySelector(".bccQAM")) {
        document.querySelector(".bccQAM").remove();
        currentSubscreen = null;
        return;
      }
      const d4 = document.createElement("div");
      d4.classList.add("bccQAM");
      document.body.append(d4);
      setQAMSubscreen(quickMenuSubscreens[0]);
    }
  };
  function getServer() {
    if (window.location.host === "www.bondageprojects.elementfx.com") return "America";
    if (window.location.host === "www.bondage-europe.com") return "Europe";
    if (window.location.host === "www.bondage-asia.com") return "Asia";
    return "Not defined";
  }
  function isBannedBy(C4) {
    return C4.HasOnBlacklist(Player);
  }
  function isAllowScripts(target = Player) {
    let allowHide = ValidationHasScriptPermission(
      target,
      "Hide",
      ScriptPermissionLevel.PUBLIC
    );
    let allowBlock = ValidationHasScriptPermission(
      target,
      "Block",
      ScriptPermissionLevel.PUBLIC
    );
    if (target.IsPlayer()) {
      if (!allowHide) {
        allowHide = ValidationHasScriptPermission(
          target,
          "Hide",
          ScriptPermissionLevel.SELF
        );
      }
      if (!allowBlock) {
        allowBlock = ValidationHasScriptPermission(
          target,
          "Block",
          ScriptPermissionLevel.SELF
        );
      }
    }
    if (target.IsOwnedByPlayer()) {
      if (!allowHide) {
        allowHide = ValidationHasScriptPermission(
          target,
          "Hide",
          ScriptPermissionLevel.OWNER
        );
      }
      if (!allowBlock) {
        allowBlock = ValidationHasScriptPermission(
          target,
          "Block",
          ScriptPermissionLevel.OWNER
        );
      }
    }
    if (target.IsLoverOfPlayer()) {
      if (!allowHide) {
        allowHide = ValidationHasScriptPermission(
          target,
          "Hide",
          ScriptPermissionLevel.LOVERS
        );
      }
      if (!allowBlock) {
        allowBlock = ValidationHasScriptPermission(
          target,
          "Block",
          ScriptPermissionLevel.LOVERS
        );
      }
    }
    if (target.WhiteList.includes(Player.MemberNumber)) {
      if (!allowHide) {
        allowHide = ValidationHasScriptPermission(
          target,
          "Hide",
          ScriptPermissionLevel.WHITELIST
        );
      }
      if (!allowBlock) {
        allowBlock = ValidationHasScriptPermission(
          target,
          "Block",
          ScriptPermissionLevel.WHITELIST
        );
      }
    }
    if (Player.FriendList.includes(target.MemberNumber)) {
      if (!allowHide) {
        allowHide = ValidationHasScriptPermission(
          target,
          "Hide",
          ScriptPermissionLevel.FRIENDS
        );
      }
      if (!allowBlock) {
        allowBlock = ValidationHasScriptPermission(
          target,
          "Block",
          ScriptPermissionLevel.FRIENDS
        );
      }
    }
    return {
      hide: allowHide,
      block: allowBlock
    };
  }
  var quickMenuBuilder = {
    buildButton(text) {
      const btn = document.createElement("button");
      Q(btn, {
        base: {
          cursor: "pointer",
          border: "none",
          padding: "0.65em",
          margin: "0.25em 1em",
          background: "#7e00ff",
          borderRadius: "4px",
          color: "white"
        },
        hover: {
          background: "rgb(143, 82, 255)"
        }
      });
      btn.textContent = text;
      return btn;
    },
    buildDescription(content) {
      const text = document.createElement("p");
      text.style.cssText = "padding: 0.65em; border-radius: 5px; border: 2px solid #d5d5d5; background: #f8f8f8; margin: 0.25em 1em;";
      text.textContent = content;
      return text;
    },
    buildSelect({
      onChange,
      options,
      currentOption
    }) {
      let isOpened = false;
      let optionsContainer;
      const select = document.createElement("div");
      select.classList.add("bccQAMSelect");
      select.style.margin = "0.25em 1em";
      select.style.position = "relative";
      select.setAttribute("opened", false);
      select.addEventListener("click", () => {
        if (options.length === 0) return;
        if (isOpened) {
          isOpened = false;
          select.style.zIndex = "10";
          optionsContainer.remove();
        } else {
          isOpened = true;
          select.style.zIndex = "100";
          optionsContainer = document.createElement("div");
          optionsContainer.setAttribute(
            "data-position",
            select.offsetTop > window.innerHeight / 2 - select.offsetHeight / 2 ? "top" : "bottom"
          );
          options.forEach((option) => {
            const e2 = document.createElement("div");
            e2.style.cssText = "display: flex; align-items: center; column-gap: 0.5em;";
            if (option.icon) {
              option.icon.style.cssText = "color: #bcbcbc;";
              e2.append(option.icon);
            }
            e2.append(option.text);
            if (option.name === currentOption) {
              e2.append(checkmark);
            }
            e2.addEventListener("click", () => {
              currentOption = option.name;
              p4.textContent = option.text;
              optionsContainer.remove();
              if (onChange) onChange(option.name);
            });
            optionsContainer.append(e2);
          });
          select.append(optionsContainer);
        }
      });
      const p4 = document.createElement("p");
      p4.style.paddingRight = "2em";
      if (options.length === 0) {
        p4.textContent = "No options";
      } else {
        p4.textContent = options.find((option) => option.name === currentOption)?.text ?? "Unknown";
      }
      const arrow = createElement(ChevronDown);
      const checkmark = createElement(Check);
      checkmark.style.cssText = "position: absolute; right: 0.25em;";
      select.append(p4, arrow);
      return select;
    },
    buildCharacterSelect(onChange) {
      const select = quickMenuBuilder.buildSelect({
        onChange: (value) => {
          const target = T2(parseInt(value, 10));
          if (onChange && target) onChange(target);
        },
        options: (ChatRoomCharacter.length === 0 ? [Player] : ChatRoomCharacter).map((c7) => {
          return {
            name: c7.MemberNumber.toString(),
            text: c7.Name + `(${c7.MemberNumber})`,
            icon: createElement(Target, { stroke: "red" })
          };
        }),
        currentOption: Player.MemberNumber.toString()
      });
      return select;
    },
    buildInput(placeholder) {
      const input = document.createElement("input");
      input.style.cssText = "border: none; background: #ebebeb; padding: 0.65em; margin: 0.25em 1em; border-radius: 5px;";
      input.placeholder = placeholder;
      return input;
    }
  };
  function setQAMSubscreen(s4) {
    if (!document.querySelector(".bccQAM")) return;
    const container = document.querySelector(".bccQAM");
    container.innerHTML = "";
    const header = document.createElement("div");
    header.style.cssText = "display: flex; align-items: center; justify-content: space-between;";
    const title = document.createElement("p");
    title.textContent = s4.name;
    title.style.cssText = "font-weight: bold; padding: 0.5em 1em; text-align: center; font-size: clamp(10px, 5vw, 24px); width: 100%; letter-spacing: 0.08em;";
    if (s4.name === "BONDAGE CLUB CHAOS") {
      title.style.textShadow = "-0.1em -0.05em 0 rgb(102, 0, 218)";
    } else {
      const backBtn = document.createElement("button");
      backBtn.style.cssText = "cursor: pointer; background: none; border: none;";
      backBtn.append(createElement(ChevronLeft));
      backBtn.addEventListener("click", () => {
        setQAMSubscreen(quickMenuSubscreens[0]);
      });
      header.append(backBtn);
    }
    header.append(title);
    container.append(header);
    if (s4.description) container.append(quickMenuBuilder.buildDescription(s4.description));
    s4.load(container);
    currentSubscreen = s4;
  }
  function toggleFeature(id) {
    modStorage.qam ??= {};
    modStorage.qam.enabledFeatures ??= "";
    const char = String.fromCharCode(id);
    if (modStorage.qam.enabledFeatures.includes(char)) {
      modStorage.qam.enabledFeatures = modStorage.qam.enabledFeatures.replaceAll(char, "");
    } else modStorage.qam.enabledFeatures += String.fromCharCode(id);
    setQAMSubscreen(quickMenuSubscreens[0]);
  }
  function isFeatureEnabled(id) {
    const char = String.fromCharCode(id);
    return modStorage.qam?.enabledFeatures?.includes(char);
  }
  var quickMenuSubscreens = [
    {
      name: "BONDAGE CLUB CHAOS",
      load: (container) => {
        const searchInput = document.createElement("input");
        searchInput.style.cssText = "border: none !important; outline: none !important; background: none; width: 100%; padding: 0.65em; margin: 0.25em 0;";
        searchInput.placeholder = "Search...";
        searchInput.addEventListener("input", () => {
          setItems(
            quickMenuItems.filter((i8) => isFeatureEnabled(i8.id) && i8.name.toLowerCase().includes(searchInput.value.toLowerCase()))
          );
        });
        container.append(searchInput);
        const buttonsContainer = document.createElement("div");
        buttonsContainer.style.cssText = "max-height: 50vh; overflow-y: auto; scrollbar-width: none;";
        container.append(buttonsContainer);
        const setItems = (items2) => {
          buttonsContainer.innerHTML = "";
          items2.forEach((b3) => {
            const btn = document.createElement("button");
            Q(btn, {
              base: {
                display: "flex",
                alignItems: "center",
                columnGap: "0.45em",
                cursor: "pointer",
                fontSize: "clamp(10px, 10vw, 30px)",
                background: "none",
                border: "none",
                padding: "0.25em",
                borderTop: "1px solid #e5e5e5",
                width: "100%"
              },
              hover: {
                background: "#eeeeee"
              }
            });
            const detailsContainer = document.createElement("div");
            detailsContainer.style.cssText = "display: flex; flex-direction: column; align-items: flex-start; row-gap: 4px;";
            const name = document.createElement("span");
            name.style.fontSize = "clamp(10px, 5vw, 22px)";
            name.textContent = b3.name;
            const description = document.createElement("span");
            description.style.fontSize = "clamp(8px, 1vw, 16px)";
            description.style.color = "#878787";
            description.style.maxWidth = "calc(340px - clamp(10px, 8vw, 35px) - 0.45em)";
            description.style.whiteSpace = "nowrap";
            description.style.overflow = "clip";
            description.style.textOverflow = "ellipsis";
            description.style.padding = "2px";
            description.textContent = quickMenuSubscreens.find((s4) => s4.name === b3.name)?.description;
            const icon = createElement(b3.icon);
            icon.style.cssText = "background: rgb(228 215 255 / 65%); flex-shrink: 0; width: clamp(10px, 8vw, 35px); height: clamp(10px, 8vw, 35px); padding: 4px; stroke: #7e63b6; border-radius: 4px;";
            btn.addEventListener("click", () => {
              const subscreen = quickMenuSubscreens.find((s4) => s4.name === b3.name);
              if (!subscreen) return console.warn(`Subscreen "${b3.name}" is not exists`);
              qamScrollTop = buttonsContainer.scrollTop;
              setQAMSubscreen(subscreen);
            });
            detailsContainer.append(name, description);
            btn.append(icon, detailsContainer);
            buttonsContainer.append(btn);
          });
        };
        const items = quickMenuItems.filter((i8) => isFeatureEnabled(i8.id));
        if (items.length === 0) {
          const p4 = document.createElement("p");
          p4.innerHTML = "You don't have any features enabled.<br>Configure it in QAM settings.";
          p4.style.margin = "1.5em auto";
          p4.style.background = "#f6f1ff";
          p4.style.padding = "0.65em";
          p4.style.border = "2px solid #eee5ff";
          p4.style.borderRadius = "4px";
          container.append(p4);
        } else setItems(items);
        const footer = document.createElement("div");
        footer.style.cssText = "display: flex; align-items: center; justify-content: space-between; padding: 0.65em; background: rgb(247, 242, 255); border-top: 2px solid #e8e8e8;";
        const server = document.createElement("div");
        server.style.cssText = "display: flex; align-items: center; column-gap: 0.5em; background: rgb(227, 210, 255); border-radius: 0.65em; padding: 0.65em; font-weight: bold;";
        const ping = document.createElement("div");
        ping.style.cssText = "padding: 4px; background: #cabaefe8; border-radius: 6px; font-size: 0.8em;";
        ping.textContent = serverPing + "ms";
        const settingsBtn = createElement(Settings, { stroke: "rgb(126, 99, 182)", height: "2em", width: "2em" });
        Q(settingsBtn, {
          base: {
            cursor: "pointer",
            background: "rgb(229, 208, 255)",
            padding: "0.25em",
            borderRadius: "4px"
          },
          hover: {
            background: "rgb(223, 199, 252)"
          }
        });
        settingsBtn.addEventListener("click", async () => {
          await PreferenceOpenSubscreen("Extensions");
          await PreferenceSubscreenExtensionsOpen(m.key, ["Online", "ChatRoom"]);
          R(new MainSubscreen(true));
        });
        server.append(getServer(), ping);
        footer.append(server, settingsBtn);
        container.append(footer);
        if (qamScrollTop) buttonsContainer.scroll({ top: qamScrollTop });
      }
    },
    {
      name: "Toggle Invisibility",
      description: "Toggle target's invisibility state",
      load: (d4) => {
        let target = Player;
        const select = quickMenuBuilder.buildCharacterSelect((C4) => {
          target = C4;
        });
        const btn = quickMenuBuilder.buildButton("Toggle Invisibility");
        btn.addEventListener("click", () => {
          if (!ServerChatRoomGetAllowItem(Player, target)) {
            return Q2.error({ message: "Interactions are not allowed", duration: 3e3 });
          }
          if (!isAllowScripts(target).hide) {
            if (target.IsPlayer()) {
              return Q2.error({
                title: "You don't allow to use scripts on yourself",
                message: `Enable "hide" option in the scripts settings`,
                duration: 7e3
              });
            } else {
              return Q2.error({
                message: `${N3(
                  target
                )} doesn't allow you to modify appearance using scripts`,
                duration: 6e3
              });
            }
          }
          if (!InventoryGet(target, "ItemScript")) {
            const itemScript = InventoryWear(target, "Script", "ItemScript");
            itemScript.Property = {
              Hide: AssetGroup.filter((a5) => a5.Name !== "ItemScript").map((a5) => a5.Name)
            };
            ChatRoomCharacterUpdate(target);
            Q2.success({
              message: `You have successfully activated invisibility for ${N3(
                target
              )}!`,
              duration: 6e3
            });
          } else {
            InventoryRemove(target, "ItemScript");
            ChatRoomCharacterUpdate(target);
            Q2.success({
              message: `You have successfully deactivated invisibility for ${N3(
                target
              )}!`,
              duration: 6e3
            });
          }
        });
        d4.append(select, btn);
      }
    },
    {
      name: "Poses Manager",
      description: "Change target's pose, y position",
      load: (container) => {
        let target = Player;
        const select = quickMenuBuilder.buildCharacterSelect((C4) => {
          target = C4;
          I_DONT_KNOW_HOW_TO_NAME_THIS_VARIABLE.innerHTML = "";
          I_DONT_KNOW_HOW_TO_NAME_THIS_VARIABLE.append(
            createPosesContainer("BodyUpper"),
            createPosesContainer("BodyLower"),
            createPosesContainer("BodyFull")
          );
        });
        const createPosesContainer = (category) => {
          const container2 = document.createElement("div");
          container2.style.cssText = "display: flex; gap: calc(0.5 * min(2dvh, 1dvw)); margin: 0.25em 1em;";
          PoseFemale3DCG.filter((p4) => p4.Category === category && (p4.AllowMenu || p4.AllowMenuTransient)).forEach((p4) => {
            const btn = document.createElement("button");
            Q(btn, {
              base: {
                cursor: "pointer",
                width: "3em",
                aspectRatio: "1/1",
                background: "none",
                border: "2px solid #d2d2d2",
                borderRadius: "8px"
              },
              hover: {
                borderColor: "#ad68ff"
              }
            });
            if (target.Pose.includes(p4.Name)) {
              btn.style.borderColor = "#ad68ff";
            }
            btn.addEventListener("click", () => {
              if (!ServerChatRoomGetAllowItem(Player, target)) {
                return Q2.error({ message: "Interactions are not allowed", duration: 3e3 });
              }
              PoseSetActive(target, p4.Name);
              ChatRoomCharacterUpdate(target);
              I_DONT_KNOW_HOW_TO_NAME_THIS_VARIABLE.innerHTML = "";
              I_DONT_KNOW_HOW_TO_NAME_THIS_VARIABLE.append(
                createPosesContainer("BodyUpper"),
                createPosesContainer("BodyLower"),
                createPosesContainer("BodyFull")
              );
            });
            const image = document.createElement("img");
            image.src = `Icons/Poses/${p4.Name}.png`;
            image.style.cssText = "width: 80%; height: auto;";
            btn.append(image);
            container2.append(btn);
          });
          return container2;
        };
        const I_DONT_KNOW_HOW_TO_NAME_THIS_VARIABLE = document.createElement("div");
        I_DONT_KNOW_HOW_TO_NAME_THIS_VARIABLE.append(
          createPosesContainer("BodyUpper"),
          createPosesContainer("BodyLower"),
          createPosesContainer("BodyFull")
        );
        const suspenseBtn = quickMenuBuilder.buildButton("Suspense");
        ;
        suspenseBtn.addEventListener("click", () => {
          if (!ServerChatRoomGetAllowItem(Player, target)) {
            return Q2.error({ message: "Interactions are not allowed", duration: 3e3 });
          }
          PoseSetActive(target, "Suspension");
          ChatRoomCharacterUpdate(target);
          I_DONT_KNOW_HOW_TO_NAME_THIS_VARIABLE.innerHTML = "";
          I_DONT_KNOW_HOW_TO_NAME_THIS_VARIABLE.append(
            createPosesContainer("BodyUpper"),
            createPosesContainer("BodyLower"),
            createPosesContainer("BodyFull")
          );
        });
        const overrideHeight = (h6) => {
          const emoticon = InventoryGet(target, "Emoticon");
          if (h6 === null) {
            delete emoticon.Property?.OverrideHeight;
          } else {
            emoticon.Property ??= {};
            const height = emoticon.Property.OverrideHeight?.Height ?? 0;
            emoticon.Property.OverrideHeight = { Height: height + h6 };
          }
          ChatRoomCharacterUpdate(target);
        };
        const heightOverrideControls = document.createElement("div");
        heightOverrideControls.style.cssText = "display: flex; justify-content: center; column-gap: 0.65em; margin-top: 0.25em; margin-bottom: 0.65em;";
        const dynamicClass = {
          base: {
            cursor: "pointer",
            aspectRatio: "1/1",
            width: "10%",
            background: "white",
            border: "2px solid #d2d2d2",
            borderRadius: "50%"
          },
          hover: {
            borderColor: "#ad68ff"
          }
        };
        const downBtn = document.createElement("button");
        Q(downBtn, dynamicClass);
        downBtn.append(createElement(ArrowDown));
        downBtn.addEventListener("click", () => {
          if (!ServerChatRoomGetAllowItem(Player, target)) {
            return Q2.error({ message: "Interactions are not allowed", duration: 3e3 });
          }
          overrideHeight(-10);
        });
        const resetBtn = document.createElement("button");
        Q(resetBtn, {
          base: {
            cursor: "pointer",
            padding: "0.25em 0.75em",
            border: "none",
            background: "#d3d3d3ff",
            borderRadius: "4px"
          },
          hover: {
            background: "#c3c3c3ff"
          }
        });
        resetBtn.textContent = "Reset";
        resetBtn.addEventListener("click", () => {
          if (!ServerChatRoomGetAllowItem(Player, target)) {
            return Q2.error({ message: "Interactions are not allowed", duration: 3e3 });
          }
          overrideHeight(null);
        });
        const upBtn = document.createElement("button");
        Q(upBtn, dynamicClass);
        upBtn.append(createElement(ArrowUp));
        upBtn.addEventListener("click", () => {
          if (!ServerChatRoomGetAllowItem(Player, target)) {
            return Q2.error({ message: "Interactions are not allowed", duration: 3e3 });
          }
          overrideHeight(10);
        });
        heightOverrideControls.append(downBtn, resetBtn, upBtn);
        container.append(select, I_DONT_KNOW_HOW_TO_NAME_THIS_VARIABLE, suspenseBtn, heightOverrideControls);
      }
    },
    {
      name: "Import Appearance",
      description: "Import appearance on target using base64 outfit code",
      load: (container) => {
        let target = Player;
        const input = quickMenuBuilder.buildInput("Code");
        const select = quickMenuBuilder.buildCharacterSelect((C4) => {
          target = C4;
        });
        const btn = quickMenuBuilder.buildButton("Import Appearance");
        btn.addEventListener("click", () => {
          if (!ServerChatRoomGetAllowItem(Player, target)) {
            return Q2.error({ message: "Interactions are not allowed", duration: 3e3 });
          }
          try {
            I3(
              target,
              N4(target.AssetFamily, JSON.parse(LZString.decompressFromBase64(input.value)))
            );
            Q2.success({
              message: `Appearance was successfully imported on ${N3(target)}`,
              duration: 4e3
            });
          } catch {
            Q2.error({
              title: "Oops!",
              message: "Error occurred while trying to import appearance",
              duration: 5e3
            });
          }
        });
        container.append(input, select, btn);
      }
    },
    {
      name: "Export Appearance",
      description: "Copy target's appearance to clipboard in utf-16 or base64 format",
      load: (container) => {
        let format = "base64";
        let target = Player;
        const formatSelect = quickMenuBuilder.buildSelect({
          options: [
            {
              name: "utf-16",
              text: "UTF-16 (Not safe)"
            },
            {
              name: "btoa",
              text: "BTOA (UBC)"
            },
            {
              name: "base64",
              text: "Base64 (Most mods)"
            }
          ],
          currentOption: "base64",
          onChange: (value) => {
            format = value;
          }
        });
        const select = quickMenuBuilder.buildCharacterSelect((C4) => {
          target = C4;
        });
        const btn = quickMenuBuilder.buildButton("Copy to clipboard");
        btn.addEventListener("click", async () => {
          if (isBannedBy(target)) return Q2.error({
            title: "Denied",
            message: "You are blacklisted or ghosted by this player",
            duration: 4500
          });
          const stringifiedAppearance = JSON.stringify(ServerAppearanceBundle(target.Appearance));
          let clipboardResult;
          if (format === "base64") {
            clipboardResult = LZString.compressToBase64(stringifiedAppearance);
          } else if (format === "utf-16") {
            clipboardResult = LZString.compressToUTF16(stringifiedAppearance);
          } else {
            clipboardResult = btoa(encodeURI(stringifiedAppearance));
          }
          try {
            await navigator.clipboard.writeText(clipboardResult);
            Q2.success({
              message: "Code was copied to your clipboard",
              duration: 3e3
            });
          } catch (e2) {
            const error = e2;
            Q2.error({
              title: error.name,
              message: error.message,
              duration: 8e3
            });
          }
        });
        container.append(formatSelect, select, btn);
      }
    },
    {
      name: "Leave Room",
      description: "Forcibly leave chat room",
      load: (container) => {
        const btn = quickMenuBuilder.buildButton("Leave Room");
        btn.addEventListener("click", () => {
          if (!ServerPlayerIsInChatRoom()) return;
          ChatRoomLeave();
          CommonSetScreen("Online", "ChatSearch");
        });
        container.append(btn);
      }
    },
    {
      name: "Total Release",
      description: "Release target from all items except for clothing and slave collar",
      load: (container) => {
        let target = Player;
        const select = quickMenuBuilder.buildCharacterSelect((C4) => {
          target = C4;
        });
        const btn = quickMenuBuilder.buildButton("Total Release");
        btn.addEventListener("click", () => {
          if (!ServerChatRoomGetAllowItem(Player, target)) {
            return Q2.error({ message: "Interactions are not allowed", duration: 3e3 });
          }
          CharacterReleaseTotal(target, true);
          Q2.success({
            message: `${N3(target)} was completely released`,
            duration: 4e3
          });
        });
        container.append(select, btn);
      }
    },
    {
      name: "Release",
      description: "Release target from certain items",
      load: (container) => {
        let target = Player;
        let itemGroup = "ItemNeck";
        const select = quickMenuBuilder.buildCharacterSelect((C4) => {
          target = C4;
          itemSelectContainer.innerHTML = "";
          createItemSelect();
        });
        const itemSelectContainer = document.createElement("div");
        const createItemSelect = () => {
          const options = target.Appearance.filter((a5) => a5.Asset.Group.Name.startsWith("Item") && !!InventoryGet(target, a5.Asset.Group.Name)).map((a5) => ({ name: a5.Asset.Group.Name, text: a5.Asset.Description }));
          const select2 = quickMenuBuilder.buildSelect({
            options,
            currentOption: options[0]?.name,
            onChange: (value) => {
              itemGroup = value;
            }
          });
          itemSelectContainer.append(select2);
        };
        const btn = quickMenuBuilder.buildButton("Release");
        btn.addEventListener("click", () => {
          if (!ServerChatRoomGetAllowItem(Player, target)) {
            return Q2.error({ message: "Interactions are not allowed", duration: 3e3 });
          }
          InventoryRemove(target, itemGroup, true);
          ChatRoomCharacterUpdate(target);
          Q2.success({
            message: `Successfully released ${N3(target)}'s ${itemGroup}`,
            duration: 4e3
          });
        });
        createItemSelect();
        container.append(select, itemSelectContainer, btn);
      }
    },
    {
      name: "Map Teleport",
      description: "Teleport to certain character on map",
      load: (container) => {
        let target = Player;
        const select = quickMenuBuilder.buildCharacterSelect((C4) => {
          target = C4;
        });
        const btn = quickMenuBuilder.buildButton("Map Teleport");
        btn.addEventListener("click", () => {
          if (!Player.MapData) Player.MapData = {};
          const x6 = target.MapData?.Pos?.X;
          const y5 = target.MapData?.Pos?.Y;
          if (!x6 || !y5) return;
          ;
          Player.MapData.Pos = {
            X: x6,
            Y: y5
          };
          ChatRoomMapViewMovement = {
            X: x6,
            Y: y5,
            TimeStart: CommonTime(),
            TimeEnd: CommonTime(),
            Direction: "East"
          };
          g2.sendLocal(
            `You were successfully teleported to ${N3(target)}`
          );
        });
        container.append(select, btn);
      }
    },
    {
      name: "Clone",
      description: "Copy target's appearance, nickname, label's color and expressions. With the opportunity to return to your original appearance.",
      load: (container) => {
        let target = Player;
        const select = quickMenuBuilder.buildCharacterSelect((C4) => {
          target = C4;
        });
        const cloneBtn = quickMenuBuilder.buildButton("Clone");
        const backupBtn = quickMenuBuilder.buildButton("Backup");
        backupBtn.addEventListener("click", () => {
          if (!modStorage.qam?.cloneBackup) return Q2.error({
            message: "You don't have backup",
            duration: 3e3
          });
          Player.Nickname = modStorage.qam.cloneBackup.nickName;
          Player.LabelColor = modStorage.qam.cloneBackup.labelColor;
          PoseSetActive(Player, modStorage.qam.cloneBackup.activePose[0]);
          CharacterSetFacialExpression(Player, "Emoticon", modStorage.qam.cloneBackup.emoticon?.expression, null, modStorage.qam.cloneBackup.emoticon?.color);
          CharacterSetFacialExpression(Player, "Blush", modStorage.qam.cloneBackup.blush?.expression);
          ServerAppearanceLoadFromBundle(
            Player,
            Player.AssetFamily,
            JSON.parse(LZString.decompressFromBase64(modStorage.qam.cloneBackup.appearance)),
            Player.MemberNumber
          );
          ServerSend("AccountUpdate", {
            Nickname: Player.Nickname,
            LabelColor: Player.LabelColor
          });
          ChatRoomCharacterUpdate(Player);
          Q2.success({
            message: `You have successfully canceled the cloning effect!`,
            duration: 4500
          });
          delete modStorage.qam.cloneBackup;
          syncStorage();
        });
        cloneBtn.addEventListener("click", () => {
          if (isBannedBy(target)) return Q2.error({
            title: "Denied",
            message: "You are blacklisted or ghosted by this player",
            duration: 4500
          });
          modStorage.qam ??= {};
          if (!modStorage.qam.cloneBackup) {
            modStorage.qam.cloneBackup = {
              nickName: N3(Player),
              labelColor: Player.LabelColor,
              emoticon: {
                expression: InventoryGet(Player, "Emoticon")?.Property?.Expression,
                // color: InventoryGet(Player, "Emoticon")?.Property?.Color
                color: ""
              },
              blush: {
                expression: InventoryGet(Player, "Blush")?.Property?.Expression
              },
              appearance: LZString.compressToBase64(JSON.stringify(ServerAppearanceBundle(Player.Appearance))),
              activePose: [...Player.ActivePose]
            };
            syncStorage();
          }
          Player.Nickname = N3(target);
          Player.LabelColor = target.LabelColor;
          PoseSetActive(Player, target.ActivePose[0]);
          CharacterSetFacialExpression(Player, "Emoticon", InventoryGet(target, "Emoticon")?.Property?.Expression, null, InventoryGet(target, "Emoticon")?.Property?.Color);
          CharacterSetFacialExpression(Player, "Blush", InventoryGet(target, "Blush")?.Property?.Expression);
          ServerAppearanceLoadFromBundle(
            Player,
            Player.AssetFamily,
            ServerAppearanceBundle(target.Appearance),
            Player.MemberNumber
          );
          ServerSend("AccountUpdate", {
            Nickname: Player.Nickname,
            LabelColor: Player.LabelColor
          });
          ChatRoomCharacterUpdate(Player);
          Q2.success({
            message: `You were successfully cloned ${N3(target)}`,
            duration: 4500
          });
        });
        container.append(select, cloneBtn, backupBtn);
      }
    },
    {
      name: "View Card Decks",
      description: "View target's decks of cards",
      load: (container) => {
        let target = Player;
        let deckIndex = 0;
        const select = quickMenuBuilder.buildCharacterSelect((_target) => {
          target = _target;
          refreshContent();
        });
        const contentContainer = document.createElement("div");
        const createCard = (card) => {
          const cardName = card.Name;
          const requiredLevel = card.RequiredLevel ? card.RequiredLevel : 1;
          const colors = ["", "white", "#a6a4a4", "#9be09b", "#b4b4f0", "#ed8e8e"];
          const img = document.createElement("img");
          img.style.cssText = `width: 2.5em; height: 5em; background: ${colors[requiredLevel]}; padding: 4px; border: 2px solid black;`;
          img.src = card.Type === "Event" ? `https://www.bondage-europe.com/${GameVersion}/BondageClub/Screens/MiniGame/ClubCard/Event/${cardName}.png` : `https://www.bondage-europe.com/${GameVersion}/BondageClub/Screens/MiniGame/ClubCard/Member/${cardName}.png`;
          return img;
        };
        const undoBundle = (bundle) => {
          const result = [];
          for (const entrie of bundle.split("")) {
            const cardId = entrie.charCodeAt(0);
            const card = ClubCardList.find((c7) => c7.ID === cardId);
            if (!card) continue;
            result.push(card);
          }
          return result;
        };
        const refreshContent = () => {
          contentContainer.innerHTML = "";
          deckIndex = 0;
          const select2 = quickMenuBuilder.buildSelect({
            options: target.Game.ClubCard?.Deck?.map((_4, i8) => ({ name: i8.toString(), text: target?.Game?.ClubCard?.DeckName?.[i8] || `Deck #${i8}` }))?.filter((n5) => !!target?.Game?.ClubCard?.Deck?.[parseInt(n5.name, 10)]),
            currentOption: deckIndex.toString(),
            onChange: (value) => {
              deckIndex = parseInt(value, 10);
              const selectedDeck2 = undoBundle(target.Game?.ClubCard?.Deck?.[deckIndex] ?? "");
              cardsContainer.innerHTML = "";
              cardsContainer.append(...selectedDeck2.map(createCard));
            }
          });
          const cardsContainer = document.createElement("div");
          cardsContainer.style.cssText = "display: flex; flex-wrap: wrap; gap: 0.25em; overflow-y: scroll; max-height: 50vh; margin: 0.25em 1em;";
          const selectedDeck = undoBundle(target.Game?.ClubCard?.Deck?.[deckIndex] ?? "");
          cardsContainer.append(...selectedDeck.map(createCard));
          contentContainer.append(select2, cardsContainer);
        };
        refreshContent();
        container.append(select, contentContainer);
      }
    },
    {
      name: "Cast Spell",
      description: "Cast dark magic spell",
      load: (container) => {
        if ((modStorage.darkMagic?.spells ?? []).length === 0) {
          const message = document.createElement("p");
          message.style.cssText = "margin: 1.65em auto; font-weight: bold;";
          message.textContent = "You don't have any spells to cast";
          container.append(message);
          return;
        }
        function dataURLToSVGElement(dataURL) {
          const svgEncoded = dataURL.replace("data:image/svg+xml,", "");
          const svgString = decodeURIComponent(svgEncoded);
          const div = document.createElement("div");
          div.innerHTML = svgString;
          return div.firstElementChild;
        }
        let target = Player;
        let spell = modStorage.darkMagic?.spells?.[0];
        const select = quickMenuBuilder.buildCharacterSelect((_target) => {
          target = _target;
        });
        const _select = quickMenuBuilder.buildSelect({
          options: modStorage.darkMagic?.spells?.map((s4) => ({ name: s4.name, text: s4.name, icon: dataURLToSVGElement(getSpellIcon(s4.icon).dataurl) })),
          currentOption: modStorage.darkMagic?.spells?.[0]?.name,
          onChange: (value) => {
            spell = modStorage.darkMagic.spells.find((s4) => s4.name === value);
          }
        });
        const btn = quickMenuBuilder.buildButton("Cast Spell");
        btn.addEventListener("click", () => {
          if (!spell) return;
          if (!Player.CanInteract()) {
            return Q2.error({ message: "You can't interact", duration: 3e3 });
          }
          if (!isMagicItem(InventoryGet(Player, "ItemHandheld"))) {
            return Q2.error({
              message: "You should hold magic item in your hand to cast spells",
              duration: 5e3
            });
          }
          const allow = allowSpellCast(Player, target, spell);
          if (allow.result === false) {
            return Q2.error({
              title: "Can't cast this spell",
              message: allow.reason,
              duration: 5e3
            });
          }
          castSpell(target, spell);
        });
        container.append(select, _select, btn);
      }
    },
    {
      name: "Put Locks",
      description: "Put lock on target's all items",
      load: (container) => {
        let target = Player;
        const locks = AssetGroupGet(Player.AssetFamily, "ItemMisc").Asset.filter((item) => item.Name?.endsWith("Padlock"));
        let lock = locks[0].Name;
        const select = quickMenuBuilder.buildCharacterSelect((_target) => {
          target = _target;
        });
        const _select = quickMenuBuilder.buildSelect({
          options: locks.map((l5) => ({ name: l5.Name, text: l5.Description })),
          currentOption: locks[0].Name,
          onChange: (value) => {
            lock = value;
          }
        });
        const btn = quickMenuBuilder.buildButton("Put Locks");
        btn.addEventListener("click", () => {
          InventoryFullLock(target, lock);
          ChatRoomCharacterUpdate(target);
          Q2.success({
            message: `You have successfully locked every item on ${N3(target)}'s body`,
            duration: 4500
          });
        });
        container.append(select, _select, btn);
      }
    },
    {
      name: "Remove Locks",
      description: "Remove all locks from target's body",
      load: (container) => {
        let target = Player;
        const select = quickMenuBuilder.buildCharacterSelect((_target) => {
          target = _target;
        });
        const btn = quickMenuBuilder.buildButton("Remove Locks");
        btn.addEventListener("click", () => {
          for (const a5 of Player.Appearance) {
            if (InventoryGetLock(a5)) InventoryUnlock(target, a5);
          }
          ChatRoomCharacterUpdate(target);
          Q2.success({
            message: `You have successfully unlocked every item on ${N3(target)}'s body`,
            duration: 4500
          });
        });
        container.append(select, btn);
      }
    }
  ];
  var quickMenuItems = [
    {
      id: 1e3,
      name: "Toggle Invisibility",
      icon: HatGlasses
    },
    {
      id: 1001,
      name: "Poses Manager",
      icon: PersonStanding
    },
    {
      id: 1002,
      name: "Import Appearance",
      icon: ClipboardPaste
    },
    {
      id: 1003,
      name: "Export Appearance",
      icon: ClipboardCopy
    },
    {
      id: 1004,
      name: "Leave Room",
      icon: LogOut
    },
    {
      id: 1005,
      name: "Total Release",
      icon: ShieldAlert
    },
    {
      id: 1006,
      name: "Release",
      icon: ShieldMinus
    },
    {
      id: 1007,
      name: "Map Teleport",
      icon: MapPinned
    },
    {
      id: 1008,
      name: "Clone",
      icon: CopyPlus
    },
    {
      id: 1009,
      name: "View Card Decks",
      icon: Eye
    },
    {
      id: 1010,
      name: "Cast Spell",
      icon: Wand
    },
    {
      id: 1011,
      name: "Put Locks",
      icon: Lock
    },
    {
      id: 1012,
      name: "Remove Locks",
      icon: LockOpen
    }
  ];
  function createQuickMenu() {
    const menuButton = document.createElement("button");
    menuButton.classList.add("bccQAMButton");
    const icon = document.createElement("img");
    icon.src = mouthWatering_default;
    menuButton.append(icon);
    document.body.append(menuButton);
    new Draggable(menuButton);
    if (typeof localStorage.getItem === "function") {
      const pos = localStorage.getItem(LOCAL_STORAGE_POS_KEY)?.split(":");
      if (pos) {
        menuButton.style.top = pos[0] + "px";
        menuButton.style.left = pos[1] + "px";
      }
    }
  }
  function removeQuickMenu() {
    document.querySelector(".bccQAMButton")?.remove();
  }
  async function pingServer() {
    const d1 = Date.now();
    const res = await fetch(window.location.href);
    if (res.status < 400) serverPing = Date.now() - d1;
  }
  function loadQuickAccessMenu() {
    if (modStorage.qam?.enabled) createQuickMenu();
    pingServer();
    setInterval(() => {
      if (!currentSubscreen || currentSubscreen.name !== "BONDAGE CLUB CHAOS") return;
      pingServer();
    }, 1e4);
  }

  // src/assets/images/qam.png
  var qam_default = "data:image/png;base64,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";

  // src/subscreens/quickAccessMenuSubscreen.ts
  var QuickAccessMenuSubscreen = class extends te {
    get icon() {
      return createElement(PanelsTopLeft);
    }
    get name() {
      return "Quick Access Menu";
    }
    load() {
      super.load();
      this.createCheckbox({
        isChecked: modStorage.qam?.enabled,
        text: "Enabled",
        x: 200,
        y: 200,
        onChange() {
          modStorage.qam ??= {};
          modStorage.qam.enabled = !modStorage.qam.enabled;
          if (modStorage.qam.enabled) createQuickMenu();
          else removeQuickMenu();
        }
      });
      this.createImage({
        x: 200,
        y: 300,
        src: qam_default,
        width: 350,
        modules: {
          base: [
            new y({
              border: "2px solid var(--tmd-accent, #e4e4e4)"
            })
          ]
        }
      });
      this.createText({
        x: 580,
        y: 300,
        width: 600,
        withBorder: true,
        text: `You can forget about the text commands. Any actions are performed through the "Quick Access Menu" (QAM).<br>Most of the functions and mechanics are located there.<br>The button to open the menu remembers its last position (Linked to the device and not to the account)`,
        padding: 2
      });
      this.createText({
        text: "Features",
        x: 1300,
        y: 200
      });
      const container = this.createScrollView({
        x: 1300,
        y: 280,
        width: 600,
        height: 620,
        scroll: "y",
        modules: {
          base: [
            new y({
              display: "flex",
              flexDirection: "column",
              rowGap: "0.45em"
            })
          ]
        }
      });
      quickMenuItems.forEach((i8) => {
        container.append(
          this.createCheckbox({
            text: i8.name,
            isChecked: isFeatureEnabled(i8.id),
            place: false,
            onChange: () => toggleFeature(i8.id)
          })
        );
      });
    }
    exit() {
      super.exit();
      this.setSubscreen(new MainSubscreen());
    }
  };

  // src/modules/cheats.ts
  function refreshBonus() {
    const skills = Player.Skill;
    if (modStorage.cheats?.permanentSkillsBoost) {
      skills.forEach((skill) => {
        skill.ModifierLevel = 5;
        skill.ModifierTimeout = Date.now() + 36e5;
      });
      const id = setInterval(() => {
        if (!modStorage.cheats?.permanentSkillsBoost) {
          return clearInterval(id);
        }
        const skills2 = Player.Skill;
        skills2.forEach((skill) => {
          skill.ModifierLevel = 5;
          skill.ModifierTimeout = Date.now() + 36e5;
        });
        ServerSend("AccountUpdate", {
          Skill: skills2
        });
      }, 1e5);
    } else {
      skills.forEach((skill) => {
        delete skill.ModifierLevel;
        delete skill.ModifierTimeout;
      });
    }
    ServerSend("AccountUpdate", {
      Skill: skills
    });
  }
  function loadCheats() {
    refreshBonus();
    c2("ServerSend", a.MODIFY_BEHAVIOR, (args, next) => {
      const message = args[0];
      const params = args[1];
      if (message === "ChatRoomCharacterItemUpdate") {
        if (modStorage.cheats?.autoTight && params.Target !== Player.MemberNumber) {
          const target = T2(params.Target);
          const item = InventoryGet(target, params.Group);
          if (item) {
            item.Difficulty = 1e3;
            params.Difficulty = 1e3;
          }
        }
      }
      if (message === "ChatRoomChat" && modStorage.cheats?.anonymousMode && (params.Type === "Action" && params.Content !== "Beep" || params.Type === "Status")) return null;
      return next(args);
    });
    c2("ChatRoomPlayerIsAdmin", a.OVERRIDE_BEHAVIOR, (args, next) => {
      if (modStorage.cheats?.mapSuperPower && next(args) === false) {
        return ChatRoomMapViewIsActive() && CurrentScreen !== "ChatAdmin" && !CurrentCharacter;
      }
      return next(args);
    });
    c2("CommonDrawAppearanceBuild", a.ADD_BEHAVIOR, (args, next) => {
      if (!modStorage.cheats?.xray) return next(args);
      const C4 = args[0];
      C4.AppearanceLayers?.forEach((Layer) => {
        const A5 = Layer.Asset;
        if (A5.Group?.Clothing) {
          A5.DynamicBeforeDraw = true;
        }
      });
      return next(args);
    });
    c2("CommonCallFunctionByNameWarn", a.OVERRIDE_BEHAVIOR, (args, next) => {
      const funcName = args[0];
      const params = args[1];
      if (!params) {
        return next(args);
      }
      const C4 = params["C"];
      const CA = params["CA"];
      const regex = /Assets(.+)BeforeDraw/i;
      if (regex.test(funcName) && modStorage.cheats?.xray) {
        const ret = next(args) ?? {};
        if (CA) {
          const layerName = (params["L"] ?? "")?.trim().slice(1) ?? "";
          const layerIx = CA.Asset.Layer.findIndex((l5) => l5.Name === layerName);
          const originalLayerOpacity = CA.Asset.Layer[layerIx]?.Opacity ?? CA.Asset.Opacity;
          const curOpacity = ret.Opacity ?? originalLayerOpacity ?? 1;
          ret.Opacity = curOpacity * 0.4;
          ret.AlphaMasks = [];
        }
        return ret;
      } else
        return next(args);
    });
    c2("ExtendedItemLoad", a.OBSERVE, (args, next) => {
      console.log(1);
      if (!modStorage.cheats?.showPadlocksPasswords) return next(args);
      console.log(3);
      if (!DialogFocusSourceItem || !["PasswordPadlock", "TimerPasswordPadlock"].includes(DialogFocusItem.Asset?.Name)) return next(args);
      if (InventoryItemMiscPasswordPadlockIsSet()) {
        console.log(2);
        p(() => !!document.getElementById("Password")).then(() => document.getElementById("Password").setAttribute("placeholder", DialogFocusSourceItem.Property?.Password));
      }
      return next(args);
    });
    c2("ChatRoomFocusCharacter", a.OBSERVE, (args, next) => {
      next(args);
      console.log("Loaded 1");
      if (!modStorage.cheats?.allowActivities) return next(args);
      console.log("Loaded 2");
      const C4 = CharacterGetCurrent();
      if (!C4) return next(args);
      console.log("Loaded 3");
      if (ServerChatRoomGetAllowItem(Player, C4)) return next(args);
      if (C4.HasOnBlacklist(Player)) {
        Q2.error({
          title: "Activities cheat denied",
          message: "You are blacklisted or ghosted by this player",
          duration: 4500
        });
        return next(args);
      }
      if (DialogMenuMode !== "dialog") return next(args);
      console.log("Loaded");
      setTimeout(() => DialogSetStatus("(You don's have access to use or remove items, but you can perform activities.)"), 1e3);
      console.log(C4.CurrentDialog);
    });
    c2("DialogClick", a.OVERRIDE_BEHAVIOR, (args, next) => {
      next(args);
      if (!modStorage.cheats?.allowActivities) return;
      console.log("Click");
      const C4 = MouseX < 500 ? Player : CurrentCharacter;
      if (!C4) return;
      if (ServerChatRoomGetAllowItem(Player, CurrentCharacter)) return;
      const X4 = MouseX < 500 ? 0 : 500;
      for (const Group of AssetGroup) {
        if (!Group.IsItem()) continue;
        const Zone = Group.Zone.find((Z3) => DialogClickedInZone(C4, Z3, 1, X4, 0, C4.HeightRatio));
        if (Zone) {
          DialogChangeFocusToGroup(C4, Group);
          DialogChangeMode("activities");
          break;
        }
      }
      const isExitButtonExists = !!document.getElementById("bcc-exit-dialog-button");
      if (CharacterGetCurrent()?.IsPlayer() && isExitButtonExists) ElementRemove("bcc-exit-dialog-button");
      if (!isExitButtonExists) {
        const button = ElementButton.Create("bcc-exit-dialog-button", () => DialogChangeMode("dialog"), { tooltip: "(BCC) Back", image: "Icons/Exit.png" });
        document.body.append(button);
        O(button, 40, 20, "top-right");
        ElementSetSize(button, 90, 90);
        button.addEventListener("click", () => {
          button.remove();
          DialogChangeFocusToGroup(C4, null);
        });
      }
    });
    c2("DialogResize", a.OBSERVE, (args, next) => {
      if (!modStorage.cheats?.allowActivities) return next(args);
      const button = document.getElementById("bcc-exit-dialog-button");
      if (button) {
        O(button, 40, 20, "top-right");
        ElementSetSize(button, 90, 90);
      }
      return next(args);
    });
  }

  // src/subscreens/cheatsSubscreen.ts
  function appendReputationElements(container, subscreen) {
    Player.Reputation.forEach((r5) => {
      const _container = subscreen.createContainer({
        place: false,
        modules: {
          base: [
            new y({
              display: "flex",
              alignItems: "center",
              justifyContent: "space-between"
            })
          ]
        }
      });
      const input = subscreen.createInput({
        width: 100,
        place: false,
        value: r5.Value.toString(),
        modules: {
          base: [
            new y({
              padding: "0.2em"
            })
          ]
        },
        onChange() {
          DialogSetReputation(r5.Type, parseInt(input.value, 10));
          ServerPlayerReputationSync();
        }
      });
      _container.append(
        subscreen.createText({
          text: r5.Type + ":",
          place: false
        }),
        input
      );
      container.append(_container);
    });
  }
  function appendSkillsElements(container, subscreen) {
    Player.Skill.forEach((s4) => {
      const _container = subscreen.createContainer({
        place: false,
        modules: {
          base: [
            new y({
              display: "flex",
              alignItems: "center",
              justifyContent: "space-between"
            })
          ]
        }
      });
      const input = subscreen.createInput({
        width: 100,
        place: false,
        value: s4.Level.toString(),
        modules: {
          base: [
            new y({
              padding: "0.2em"
            })
          ]
        },
        onChange() {
          s4.Level = parseInt(input.value, 10);
          ServerPlayerSkillSync();
        }
      });
      _container.append(
        subscreen.createText({
          text: s4.Type + ":",
          place: false
        }),
        input
      );
      container.append(_container);
    });
  }
  var CheatsSubscreen = class extends te {
    get icon() {
      return createElement(HandCoins);
    }
    get name() {
      return "Cheats";
    }
    load() {
      super.load();
      let y5 = 220;
      this.createText({
        text: "Money:",
        x: 200,
        y: y5,
        height: 60
      });
      const input = this.createInput({
        value: Player.Money.toString(),
        x: 360,
        y: y5 - 10,
        width: 400,
        height: 60,
        onChange() {
          if (parseInt(input.value, 10) < 0 || Number.isNaN(parseInt(input.value, 10))) return;
          Player.Money = parseInt(input.value, 10);
          ServerPlayerSync();
        }
      });
      y5 += 90;
      this.createCheckbox({
        text: "Permanent skills boost",
        x: 200,
        y: y5,
        isChecked: modStorage.cheats?.permanentSkillsBoost,
        onChange() {
          if (!modStorage.cheats) modStorage.cheats = {};
          modStorage.cheats.permanentSkillsBoost = !modStorage.cheats.permanentSkillsBoost;
          refreshBonus();
        }
      });
      y5 += 90;
      this.createCheckbox({
        text: "Auto tight restraints",
        x: 200,
        y: y5,
        isChecked: modStorage.cheats?.autoTight,
        onChange() {
          if (!modStorage.cheats) modStorage.cheats = {};
          modStorage.cheats.autoTight = !modStorage.cheats.autoTight;
        }
      });
      y5 += 90;
      this.createCheckbox({
        text: "Anonymous mode",
        x: 200,
        y: y5,
        isChecked: modStorage.cheats?.anonymousMode,
        onChange() {
          if (!modStorage.cheats) modStorage.cheats = {};
          modStorage.cheats.anonymousMode = !modStorage.cheats.anonymousMode;
        }
      });
      y5 += 90;
      this.createCheckbox({
        text: "Always allow interactions with activities",
        x: 200,
        y: y5,
        isChecked: modStorage.cheats?.allowActivities,
        onChange() {
          if (!modStorage.cheats) modStorage.cheats = {};
          modStorage.cheats.allowActivities = !modStorage.cheats.allowActivities;
        }
      });
      y5 += 90;
      this.createCheckbox({
        text: "Map super power",
        x: 200,
        y: y5,
        isChecked: modStorage.cheats?.mapSuperPower,
        onChange() {
          if (!modStorage.cheats) modStorage.cheats = {};
          modStorage.cheats.mapSuperPower = !modStorage.cheats.mapSuperPower;
        }
      });
      y5 += 90;
      this.createCheckbox({
        text: "Xray vision",
        x: 200,
        y: y5,
        isChecked: modStorage.cheats?.xray,
        onChange() {
          if (!modStorage.cheats) modStorage.cheats = {};
          modStorage.cheats.xray = !modStorage.cheats.xray;
          ChatRoomCharacter.forEach((c7) => {
            CharacterLoadCanvas(c7);
          });
        }
      });
      y5 += 90;
      this.createCheckbox({
        text: "Always show padlocks passwords",
        x: 200,
        y: y5,
        isChecked: modStorage.cheats?.showPadlocksPasswords,
        onChange() {
          if (!modStorage.cheats) modStorage.cheats = {};
          modStorage.cheats.showPadlocksPasswords = !modStorage.cheats.showPadlocksPasswords;
        }
      });
      this.createButton({
        text: "Get All Items",
        x: 1200,
        y: 220,
        padding: 2,
        onClick: () => {
          const ids = [];
          AssetFemale3DCG.forEach((group) => {
            group.Asset.forEach((item) => {
              if (typeof item === "string") return;
              if (item.Name) {
                let exists = false;
                for (let I6 = 0; I6 < Player.Inventory.length; I6++) {
                  if (Player.Inventory[I6].Name === item.Name && Player.Inventory[I6].Group === group.Group) exists = true;
                }
                if (!exists && item.InventoryID) {
                  InventoryAdd(Player, item.Name, group.Group, false);
                  if (!ids.includes(item.InventoryID)) {
                    ids.push(item.InventoryID);
                  }
                }
              }
            });
          });
          if (ids.length === 0) {
            return Q2.warn({
              message: `You already have all items`,
              duration: 4e3
            });
          }
          Q2.success({
            title: "New items were added to your inventory",
            message: `Items added: ${ids.length}`,
            duration: 6e3
          });
          ServerPlayerInventorySync();
        }
      });
      this.createSelect({
        x: 1200,
        y: 220 + 120,
        width: 500,
        currentOption: "reputation",
        options: [
          {
            name: "reputation",
            text: "Reputation"
          },
          {
            name: "skills",
            text: "Skills"
          }
        ],
        onChange: (name) => {
          if (name === "skills") {
            container.innerHTML = "";
            appendSkillsElements(container, this);
          } else {
            container.innerHTML = "";
            appendReputationElements(container, this);
          }
        }
      });
      const container = this.createScrollView({
        x: 1200,
        y: 220 + 120 + 95,
        width: 500,
        height: 495,
        scroll: "y",
        modules: {
          base: [
            new y({
              display: "flex",
              flexDirection: "column",
              rowGap: "0.2em"
            })
          ]
        }
      });
      appendReputationElements(container, this);
    }
    exit() {
      super.exit();
      this.setSubscreen(new MainSubscreen());
    }
  };

  // src/subscreens/attributionsSubscreen.ts
  var AttributionsSubscreen = class extends te {
    get name() {
      return "Attributions";
    }
    load() {
      super.load();
      this.createText({
        text: "Kitnyx2 font by KitTheCat",
        x: 220,
        y: 240
      });
      this.createText({
        text: "Game icons by https://game-icons.net licensed under <b>CC BY 3.0</b>",
        x: 220,
        y: 320
      });
      this.createText({
        text: "Lucide icons by https://lucide.dev licensed under <b>ISC</b> and <b>MIT (for portions derived from Feather)</b>",
        x: 220,
        y: 400,
        width: 1600
      });
      this.createSvg({
        x: 1550,
        y: 750,
        dataurl: hearts_default,
        size: 180,
        fill: "var(--tmd-accent, red)",
        stroke: "var(--tmd-accent, red)"
      });
      this.createSvg({
        x: 1700,
        y: 550,
        dataurl: hearts_default,
        size: 200,
        fill: "var(--tmd-accent, red)",
        stroke: "var(--tmd-accent, red)"
      });
      this.createSvg({
        x: 1775,
        y: 800,
        dataurl: hearts_default,
        size: 140,
        fill: "var(--tmd-accent, red)",
        stroke: "var(--tmd-accent, red)"
      });
    }
    exit() {
      super.exit();
      this.setSubscreen(new MainSubscreen());
    }
  };

  // src/subscreens/resetSettingsSubscreen.ts
  var ResetSettingsSubscreen = class extends te {
    get name() {
      return "Reset Settings";
    }
    load() {
      super.load();
      this.createText({
        text: "Caution!",
        x: 400,
        y: 240,
        width: 1200,
        modules: {
          base: [
            new y({
              textAlign: "center",
              fontWeight: "bold"
            })
          ]
        }
      });
      this.createText({
        text: "Are you sure you want to reset all your BCC settings to default?",
        x: 400,
        y: 350,
        width: 1200,
        modules: {
          base: [
            new y({
              textAlign: "center"
            })
          ]
        }
      });
      this.createText({
        text: "This action cannot be undone!",
        x: 400,
        y: 460,
        width: 1200,
        modules: {
          base: [
            new y({
              textAlign: "center"
            })
          ]
        }
      });
      this.createButton({
        text: "Confirm",
        x: 750,
        y: 700,
        width: 500,
        padding: 2,
        onClick: () => {
          resetStorage();
          this.exit();
        }
      });
    }
    exit() {
      super.exit();
      this.setSubscreen(new MainSubscreen());
    }
  };

  // src/subscreens/mainSubscreen.ts
  var quotes = [
    "Chaos is not always the opposite of order",
    "Chaos is complex order, not mess",
    "I find peace in chaos, because it contains the possibility of everything",
    "War is the father of all things, and chaos is their mother",
    "Chaos is a feature, not a bug of the universe",
    "There is a love for chaos in every creator because only out of it is new things born",
    "Chaos often turns out to be not destruction, but a different form of organization \u2014 more complex, dynamic and full of possibilities",
    "\u1F1C\u03C1\u03B9\u03C2"
  ];
  var MainSubscreen = class extends te {
    constructor(animations = false) {
      super();
      this.animations = animations;
    }
    load() {
      super.load();
      this.createCard({
        anchor: "bottom-right",
        x: 90,
        y: 65,
        name: "Version",
        value: version,
        icon: createElement(GitPullRequest),
        modules: this.animations ? {
          value: [
            new x2({
              duration: 850
            })
          ]
        } : void 0
      });
      this.createText({
        text: "BONDAGE CLUB CHAOS",
        fontSize: 12,
        x: 150,
        y: 80,
        width: 1600,
        modules: {
          base: [
            new PaintTextModule(this.animations)
          ]
        }
      });
      this.createText({
        text: quotes[h2(0, quotes.length - 1)],
        fontSize: 3,
        x: 800,
        y: 230,
        width: 1e3,
        modules: {
          base: [
            new y({
              textAlign: "center",
              fontWeight: "bold"
            })
          ]
        }
      });
      [
        new ChaosAuraSubscreen(),
        new OverlaySubscreen(),
        new DarkMagicSubscreen(),
        new QuickAccessMenuSubscreen(),
        new CheatsSubscreen()
      ].forEach((t4, i8) => {
        this.createButton({
          text: t4.name,
          icon: t4.icon,
          x: 165,
          y: 280 + 115 * i8,
          width: 575,
          padding: 2,
          modules: {
            base: [
              new TentaclesModule()
            ],
            icon: [
              new y({
                width: "auto",
                height: "70%"
              })
            ]
          },
          onClick: () => this.setSubscreen(t4)
        }).style.fontWeight = "bold";
      });
      this.createButton({
        text: "Source Code",
        icon: createElement(CodeXml),
        x: 1050,
        y: 400,
        width: 485,
        padding: 2,
        onClick() {
          window.open("https://github.com/FurryZoi/Bondage-Club-Chaos", "_blank");
        }
      });
      this.createButton({
        text: "Issues",
        icon: createElement(Bug),
        x: 1050,
        y: 510,
        width: 485,
        padding: 2,
        onClick() {
          window.open("https://github.com/FurryZoi/Bondage-Club-Chaos/issues", "_blank");
        }
      });
      this.createButton({
        text: "Attributions",
        icon: createElement(Heart),
        x: 1050,
        y: 620,
        width: 485,
        padding: 2,
        onClick: () => this.setSubscreen(new AttributionsSubscreen())
      });
      this.createButton({
        text: "Reset Settings",
        icon: createElement(Trash2),
        x: 1050,
        y: 730,
        style: "inverted",
        width: 485,
        padding: 2,
        onClick: () => this.setSubscreen(new ResetSettingsSubscreen())
      });
    }
    exit() {
      super.exit();
      this.setSubscreen(null);
      syncStorage();
      PreferenceSubscreenExtensionsClear();
    }
  };

  // src/modules/settings.ts
  function loadSettingsSubscreen() {
    PreferenceRegisterExtensionSetting({
      Identifier: "BCC",
      ButtonText: "BCC Settings",
      Image: mouthWatering_default.replace('width="512"', 'width="85"').replace('height="512"', 'height="85"'),
      click: () => {
        ee()?.click();
      },
      run: () => {
        ee()?.run();
      },
      exit: () => false,
      load: () => {
        R(new MainSubscreen(true));
      }
    });
  }

  // src/assets/Kitnyx2.ttf
  var Kitnyx2_default = "data:font/ttf;base64,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";

  // src/modules/overlay.ts
  function loadOverlay() {
    c2(
      "ChatRoomCharacterViewDrawOverlay",
      a.ADD_BEHAVIOR,
      (args, next) => {
        next(args);
        if (ChatRoomHideIconState !== 0) return;
        const [C4, CharX, CharY, Zoom] = args;
        let bccData;
        if (C4.IsPlayer()) {
          bccData = modStorage;
        } else {
          if (!C4.BCC) return;
          bccData = C4.BCC;
        }
        const displayTitles = "show";
        if (MouseHovering(CharX, CharY, 500 * Zoom, 1e3 * Zoom) && displayTitles === "show on hover" || displayTitles === "show") {
          DrawTextFit(
            `BCC v${bccData?.version}`,
            CharX + 250 * Zoom,
            CharY + 50 * Zoom,
            140 * Zoom,
            "#8337ff"
          );
        }
        let spellIconY = 200;
        for (const spell of bccData?.darkMagic?.state?.spells ?? []) {
          DrawCircle(CharX + 400 * Zoom, CharY + spellIconY * Zoom, 20 * Zoom, 2, "#c4b2e2ff", "#e6d6ffff");
          DrawImageResize(getSpellIcon(spell.icon).dataurl, CharX + 400 * Zoom - 12 * Zoom, CharY + spellIconY * Zoom - 12 * Zoom, 25 * Zoom, 25 * Zoom);
          if (MouseIn(CharX + 400 * Zoom - 20 * Zoom, CharY + spellIconY * Zoom - 20 * Zoom, 40 * Zoom, 40 * Zoom)) {
            DrawRect(CharX + 400 * Zoom - 100 * Zoom - 75 * Zoom, CharY + spellIconY * Zoom - 15 * Zoom, 150 * Zoom, 100 * Zoom, "#e6d6ffff");
            DrawTextFit(spell.name, CharX + 400 * Zoom - 100 * Zoom, CharY + 10 * Zoom + spellIconY * Zoom, 150 * Zoom, "Black");
            DrawTextFit(`Casted by: ${spell.castedBy?.name} (${spell.castedBy?.id})`, CharX + 400 * Zoom - 100 * Zoom, CharY + 40 * Zoom + spellIconY * Zoom, 150 * Zoom, "Black");
            DrawTextFit(`Created by: ${spell.createdBy?.name} (${spell.createdBy?.id})`, CharX + 400 * Zoom - 100 * Zoom, CharY + 70 * Zoom + spellIconY * Zoom, 150 * Zoom, "Black");
          }
          spellIconY += 45;
          if (spellIconY >= 700) break;
        }
      }
    );
  }

  // node_modules/.pnpm/@sugarch+bc-mod-hook-manager@0.3.1_bondage-club-mod-sdk@1.2.0/node_modules/@sugarch/bc-mod-hook-manager/dist/index.mjs
  var t2 = class {
    constructor(t4) {
      this.hookMng = t4, this.workList = [];
    }
    run(t4, o4) {
      let i8, n5 = false;
      for (const s4 of this.workList) if ("inject" === s4.value) s4.work(t4, o4);
      else if ("next" === s4.value) i8 = o4(t4), n5 = true;
      else if ("override" === s4.value) i8 = s4.work(t4, o4), n5 = true;
      else if ("flag" === s4.value) {
        if (!s4.flag) break;
        s4.once && (s4.flag = false);
      } else if ("check" === s4.value && !s4.work(t4, o4)) break;
      return n5 ? i8 : o4(t4);
    }
    next() {
      return this.workList.push({ value: "next" }), this;
    }
    inject(t4) {
      return this.workList.push({ value: "inject", work: t4 }), this;
    }
    inside(t4, { once: o4 = false, priority: i8 = 1 } = {}) {
      const n5 = { value: "flag", flag: false, once: o4 };
      return this.hookMng.hookFunction(t4, i8, (t5, o5) => {
        n5.flag = true;
        const i9 = o5(t5);
        return n5.flag = false, i9;
      }), this.workList.push(n5), this;
    }
    when(t4) {
      return this.workList.push({ value: "check", work: t4 }), this;
    }
    override(t4) {
      return this.workList.push({ value: "override", work: t4 }), this;
    }
  };
  var o;
  var i5 = class {
    static info(t4) {
      o?.info(t4);
    }
    static warn(t4) {
      o?.warn(t4);
    }
    static error(t4) {
      o?.error(t4);
    }
  };
  var n2 = class {
    constructor(t4 = false) {
      this.done = t4, this.list = [];
    }
    run() {
      for (this.done = true; this.list.length > 0; ) this.list.shift()();
    }
    push(t4) {
      this.done ? t4() : this.list.push(t4);
    }
  };
  var s = new n2();
  var r2 = new n2();
  var e = new n2();
  var h3 = new n2();
  function l2() {
    return null != globalThis.Player && "number" == typeof globalThis.Player.MemberNumber;
  }
  var u = new class {
    constructor() {
      this.mMod = void 0;
    }
    get mod() {
      return this.mMod;
    }
    push(t4, o4) {
      t4.push(o4);
    }
    initWithMod(t4) {
      this.mMod = t4, h3.run(), r2.run();
      const o4 = () => e.run();
      l2() ? o4() : this.mod.hookFunction("LoginResponse", 0, (t5, i8) => {
        i8(t5), l2() && o4();
      }), s.run();
    }
    afterInit(t4) {
      this.push(s, t4);
    }
    afterPlayerLogin(t4) {
      this.push(e, t4);
    }
    patchFunction(t4, o4) {
      this.push(h3, () => this.mod.patchFunction(t4, o4));
    }
    invokeOriginal(t4, ...o4) {
      return this.mod ? this.mod.callOriginal(t4, o4) : globalThis[t4]?.(...o4);
    }
    hookFunction(t4, o4, i8) {
      this.push(r2, () => this.mod.hookFunction(t4, o4, i8));
    }
    progressiveHook(o4, i8 = 1) {
      const n5 = new t2(this);
      return this.hookFunction(o4, i8, (t4, o5) => n5.run(t4, o5)), n5;
    }
    insideFlag(t4, o4 = 1) {
      const i8 = { inside: false };
      return this.hookFunction(t4, o4, (t5, o5) => {
        i8.inside = true;
        const n5 = o5(t5);
        return i8.inside = false, n5;
      }), i8;
    }
    hookPlayerFunction(t4, o4, i8) {
      var n5;
      n5 = () => this.mod.hookFunction(t4, o4, i8), l2() ? e.push(n5) : n5();
    }
    globalFunction(t4, o4) {
      "function" != typeof o4 && i5.warn("globalFunction: param is not a function"), null == globalThis[t4] ? globalThis[t4] = o4 : globalThis[t4] != o4 && i5.warn(`globalFunction: ${t4} is already defined`);
    }
    randomGlobalFunction(t4, o4) {
      const i8 = (t5) => t5 + Math.random().toString(16).substring(2);
      let n5 = i8(t4);
      for (; null != globalThis[n5]; ) n5 = i8(t4);
      return globalThis[n5] = o4, n5;
    }
    setLogger(t4) {
      !(function(t5) {
        o = t5;
      })(t4);
    }
  }();

  // node_modules/.pnpm/@sugarch+bc-event-handler@1.0.1_@sugarch+bc-mod-hook-manager@0.3.1_bondage-club-mod-sdk_21bcdc4580febcdd49c098e386a8de88/node_modules/@sugarch/bc-event-handler/dist/index.mjs
  function t3(e2) {
    return e2 && e2.__esModule && Object.prototype.hasOwnProperty.call(e2, "default") ? e2.default : e2;
  }
  var r3;
  var n3;
  var s2;
  var i6;
  function o2() {
    if (n3) return r3;
    n3 = 1;
    const e2 = "object" == typeof process && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...e3) => console.error("SEMVER", ...e3) : () => {
    };
    return r3 = e2;
  }
  function a3() {
    if (i6) return s2;
    i6 = 1;
    const e2 = Number.MAX_SAFE_INTEGER || 9007199254740991;
    return s2 = { MAX_LENGTH: 256, MAX_SAFE_COMPONENT_LENGTH: 16, MAX_SAFE_BUILD_LENGTH: 250, MAX_SAFE_INTEGER: e2, RELEASE_TYPES: ["major", "premajor", "minor", "preminor", "patch", "prepatch", "prerelease"], SEMVER_SPEC_VERSION: "2.0.0", FLAG_INCLUDE_PRERELEASE: 1, FLAG_LOOSE: 2 };
  }
  var h4;
  var c5;
  var E;
  var l3;
  var f4;
  var p2;
  var u2;
  var I4;
  var v;
  var m3;
  var R3;
  var d2 = { exports: {} };
  function N5() {
    return h4 || (h4 = 1, (function(e2, t4) {
      const { MAX_SAFE_COMPONENT_LENGTH: r5, MAX_SAFE_BUILD_LENGTH: n5, MAX_LENGTH: s4 } = a3(), i8 = o2(), h6 = (t4 = e2.exports = {}).re = [], c7 = t4.safeRe = [], E3 = t4.src = [], l5 = t4.safeSrc = [], f6 = t4.t = {};
      let p4 = 0;
      const u4 = "[a-zA-Z0-9-]", I6 = [["\\s", 1], ["\\d", s4], [u4, n5]], v3 = (e3, t5, r6) => {
        const n6 = ((e4) => {
          for (const [t6, r7] of I6) e4 = e4.split(`${t6}*`).join(`${t6}{0,${r7}}`).split(`${t6}+`).join(`${t6}{1,${r7}}`);
          return e4;
        })(t5), s5 = p4++;
        i8(e3, s5, t5), f6[e3] = s5, E3[s5] = t5, l5[s5] = n6, h6[s5] = new RegExp(t5, r6 ? "g" : void 0), c7[s5] = new RegExp(n6, r6 ? "g" : void 0);
      };
      v3("NUMERICIDENTIFIER", "0|[1-9]\\d*"), v3("NUMERICIDENTIFIERLOOSE", "\\d+"), v3("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${u4}*`), v3("MAINVERSION", `(${E3[f6.NUMERICIDENTIFIER]})\\.(${E3[f6.NUMERICIDENTIFIER]})\\.(${E3[f6.NUMERICIDENTIFIER]})`), v3("MAINVERSIONLOOSE", `(${E3[f6.NUMERICIDENTIFIERLOOSE]})\\.(${E3[f6.NUMERICIDENTIFIERLOOSE]})\\.(${E3[f6.NUMERICIDENTIFIERLOOSE]})`), v3("PRERELEASEIDENTIFIER", `(?:${E3[f6.NONNUMERICIDENTIFIER]}|${E3[f6.NUMERICIDENTIFIER]})`), v3("PRERELEASEIDENTIFIERLOOSE", `(?:${E3[f6.NONNUMERICIDENTIFIER]}|${E3[f6.NUMERICIDENTIFIERLOOSE]})`), v3("PRERELEASE", `(?:-(${E3[f6.PRERELEASEIDENTIFIER]}(?:\\.${E3[f6.PRERELEASEIDENTIFIER]})*))`), v3("PRERELEASELOOSE", `(?:-?(${E3[f6.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${E3[f6.PRERELEASEIDENTIFIERLOOSE]})*))`), v3("BUILDIDENTIFIER", `${u4}+`), v3("BUILD", `(?:\\+(${E3[f6.BUILDIDENTIFIER]}(?:\\.${E3[f6.BUILDIDENTIFIER]})*))`), v3("FULLPLAIN", `v?${E3[f6.MAINVERSION]}${E3[f6.PRERELEASE]}?${E3[f6.BUILD]}?`), v3("FULL", `^${E3[f6.FULLPLAIN]}$`), v3("LOOSEPLAIN", `[v=\\s]*${E3[f6.MAINVERSIONLOOSE]}${E3[f6.PRERELEASELOOSE]}?${E3[f6.BUILD]}?`), v3("LOOSE", `^${E3[f6.LOOSEPLAIN]}$`), v3("GTLT", "((?:<|>)?=?)"), v3("XRANGEIDENTIFIERLOOSE", `${E3[f6.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), v3("XRANGEIDENTIFIER", `${E3[f6.NUMERICIDENTIFIER]}|x|X|\\*`), v3("XRANGEPLAIN", `[v=\\s]*(${E3[f6.XRANGEIDENTIFIER]})(?:\\.(${E3[f6.XRANGEIDENTIFIER]})(?:\\.(${E3[f6.XRANGEIDENTIFIER]})(?:${E3[f6.PRERELEASE]})?${E3[f6.BUILD]}?)?)?`), v3("XRANGEPLAINLOOSE", `[v=\\s]*(${E3[f6.XRANGEIDENTIFIERLOOSE]})(?:\\.(${E3[f6.XRANGEIDENTIFIERLOOSE]})(?:\\.(${E3[f6.XRANGEIDENTIFIERLOOSE]})(?:${E3[f6.PRERELEASELOOSE]})?${E3[f6.BUILD]}?)?)?`), v3("XRANGE", `^${E3[f6.GTLT]}\\s*${E3[f6.XRANGEPLAIN]}$`), v3("XRANGELOOSE", `^${E3[f6.GTLT]}\\s*${E3[f6.XRANGEPLAINLOOSE]}$`), v3("COERCEPLAIN", `(^|[^\\d])(\\d{1,${r5}})(?:\\.(\\d{1,${r5}}))?(?:\\.(\\d{1,${r5}}))?`), v3("COERCE", `${E3[f6.COERCEPLAIN]}(?:$|[^\\d])`), v3("COERCEFULL", E3[f6.COERCEPLAIN] + `(?:${E3[f6.PRERELEASE]})?(?:${E3[f6.BUILD]})?(?:$|[^\\d])`), v3("COERCERTL", E3[f6.COERCE], true), v3("COERCERTLFULL", E3[f6.COERCEFULL], true), v3("LONETILDE", "(?:~>?)"), v3("TILDETRIM", `(\\s*)${E3[f6.LONETILDE]}\\s+`, true), t4.tildeTrimReplace = "$1~", v3("TILDE", `^${E3[f6.LONETILDE]}${E3[f6.XRANGEPLAIN]}$`), v3("TILDELOOSE", `^${E3[f6.LONETILDE]}${E3[f6.XRANGEPLAINLOOSE]}$`), v3("LONECARET", "(?:\\^)"), v3("CARETTRIM", `(\\s*)${E3[f6.LONECARET]}\\s+`, true), t4.caretTrimReplace = "$1^", v3("CARET", `^${E3[f6.LONECARET]}${E3[f6.XRANGEPLAIN]}$`), v3("CARETLOOSE", `^${E3[f6.LONECARET]}${E3[f6.XRANGEPLAINLOOSE]}$`), v3("COMPARATORLOOSE", `^${E3[f6.GTLT]}\\s*(${E3[f6.LOOSEPLAIN]})$|^$`), v3("COMPARATOR", `^${E3[f6.GTLT]}\\s*(${E3[f6.FULLPLAIN]})$|^$`), v3("COMPARATORTRIM", `(\\s*)${E3[f6.GTLT]}\\s*(${E3[f6.LOOSEPLAIN]}|${E3[f6.XRANGEPLAIN]})`, true), t4.comparatorTrimReplace = "$1$2$3", v3("HYPHENRANGE", `^\\s*(${E3[f6.XRANGEPLAIN]})\\s+-\\s+(${E3[f6.XRANGEPLAIN]})\\s*$`), v3("HYPHENRANGELOOSE", `^\\s*(${E3[f6.XRANGEPLAINLOOSE]})\\s+-\\s+(${E3[f6.XRANGEPLAINLOOSE]})\\s*$`), v3("STAR", "(<|>)?=?\\s*\\*"), v3("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), v3("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
    })(d2, d2.exports)), d2.exports;
  }
  function O3() {
    if (u2) return p2;
    u2 = 1;
    const e2 = o2(), { MAX_LENGTH: t4, MAX_SAFE_INTEGER: r5 } = a3(), { safeRe: n5, t: s4 } = N5(), i8 = (function() {
      if (E) return c5;
      E = 1;
      const e3 = Object.freeze({ loose: true }), t5 = Object.freeze({});
      return c5 = (r6) => r6 ? "object" != typeof r6 ? e3 : r6 : t5;
    })(), { compareIdentifiers: h6 } = (function() {
      if (f4) return l3;
      f4 = 1;
      const e3 = /^[0-9]+$/, t5 = (t6, r6) => {
        const n6 = e3.test(t6), s5 = e3.test(r6);
        return n6 && s5 && (t6 = +t6, r6 = +r6), t6 === r6 ? 0 : n6 && !s5 ? -1 : s5 && !n6 ? 1 : t6 < r6 ? -1 : 1;
      };
      return l3 = { compareIdentifiers: t5, rcompareIdentifiers: (e4, r6) => t5(r6, e4) }, l3;
    })();
    class I6 {
      constructor(o4, a5) {
        if (a5 = i8(a5), o4 instanceof I6) {
          if (o4.loose === !!a5.loose && o4.includePrerelease === !!a5.includePrerelease) return o4;
          o4 = o4.version;
        } else if ("string" != typeof o4) throw new TypeError(`Invalid version. Must be a string. Got type "${typeof o4}".`);
        if (o4.length > t4) throw new TypeError(`version is longer than ${t4} characters`);
        e2("SemVer", o4, a5), this.options = a5, this.loose = !!a5.loose, this.includePrerelease = !!a5.includePrerelease;
        const h7 = o4.trim().match(a5.loose ? n5[s4.LOOSE] : n5[s4.FULL]);
        if (!h7) throw new TypeError(`Invalid Version: ${o4}`);
        if (this.raw = o4, this.major = +h7[1], this.minor = +h7[2], this.patch = +h7[3], this.major > r5 || this.major < 0) throw new TypeError("Invalid major version");
        if (this.minor > r5 || this.minor < 0) throw new TypeError("Invalid minor version");
        if (this.patch > r5 || this.patch < 0) throw new TypeError("Invalid patch version");
        h7[4] ? this.prerelease = h7[4].split(".").map((e3) => {
          if (/^[0-9]+$/.test(e3)) {
            const t5 = +e3;
            if (t5 >= 0 && t5 < r5) return t5;
          }
          return e3;
        }) : this.prerelease = [], this.build = h7[5] ? h7[5].split(".") : [], this.format();
      }
      format() {
        return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
      }
      toString() {
        return this.version;
      }
      compare(t5) {
        if (e2("SemVer.compare", this.version, this.options, t5), !(t5 instanceof I6)) {
          if ("string" == typeof t5 && t5 === this.version) return 0;
          t5 = new I6(t5, this.options);
        }
        return t5.version === this.version ? 0 : this.compareMain(t5) || this.comparePre(t5);
      }
      compareMain(e3) {
        return e3 instanceof I6 || (e3 = new I6(e3, this.options)), h6(this.major, e3.major) || h6(this.minor, e3.minor) || h6(this.patch, e3.patch);
      }
      comparePre(t5) {
        if (t5 instanceof I6 || (t5 = new I6(t5, this.options)), this.prerelease.length && !t5.prerelease.length) return -1;
        if (!this.prerelease.length && t5.prerelease.length) return 1;
        if (!this.prerelease.length && !t5.prerelease.length) return 0;
        let r6 = 0;
        do {
          const n6 = this.prerelease[r6], s5 = t5.prerelease[r6];
          if (e2("prerelease compare", r6, n6, s5), void 0 === n6 && void 0 === s5) return 0;
          if (void 0 === s5) return 1;
          if (void 0 === n6) return -1;
          if (n6 !== s5) return h6(n6, s5);
        } while (++r6);
      }
      compareBuild(t5) {
        t5 instanceof I6 || (t5 = new I6(t5, this.options));
        let r6 = 0;
        do {
          const n6 = this.build[r6], s5 = t5.build[r6];
          if (e2("build compare", r6, n6, s5), void 0 === n6 && void 0 === s5) return 0;
          if (void 0 === s5) return 1;
          if (void 0 === n6) return -1;
          if (n6 !== s5) return h6(n6, s5);
        } while (++r6);
      }
      inc(e3, t5, r6) {
        if (e3.startsWith("pre")) {
          if (!t5 && false === r6) throw new Error("invalid increment argument: identifier is empty");
          if (t5) {
            const e4 = `-${t5}`.match(this.options.loose ? n5[s4.PRERELEASELOOSE] : n5[s4.PRERELEASE]);
            if (!e4 || e4[1] !== t5) throw new Error(`invalid identifier: ${t5}`);
          }
        }
        switch (e3) {
          case "premajor":
            this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t5, r6);
            break;
          case "preminor":
            this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t5, r6);
            break;
          case "prepatch":
            this.prerelease.length = 0, this.inc("patch", t5, r6), this.inc("pre", t5, r6);
            break;
          case "prerelease":
            0 === this.prerelease.length && this.inc("patch", t5, r6), this.inc("pre", t5, r6);
            break;
          case "release":
            if (0 === this.prerelease.length) throw new Error(`version ${this.raw} is not a prerelease`);
            this.prerelease.length = 0;
            break;
          case "major":
            0 === this.minor && 0 === this.patch && 0 !== this.prerelease.length || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
            break;
          case "minor":
            0 === this.patch && 0 !== this.prerelease.length || this.minor++, this.patch = 0, this.prerelease = [];
            break;
          case "patch":
            0 === this.prerelease.length && this.patch++, this.prerelease = [];
            break;
          case "pre": {
            const e4 = Number(r6) ? 1 : 0;
            if (0 === this.prerelease.length) this.prerelease = [e4];
            else {
              let n6 = this.prerelease.length;
              for (; --n6 >= 0; ) "number" == typeof this.prerelease[n6] && (this.prerelease[n6]++, n6 = -2);
              if (-1 === n6) {
                if (t5 === this.prerelease.join(".") && false === r6) throw new Error("invalid increment argument: identifier already exists");
                this.prerelease.push(e4);
              }
            }
            if (t5) {
              let n6 = [t5, e4];
              false === r6 && (n6 = [t5]), 0 === h6(this.prerelease[0], t5) ? isNaN(this.prerelease[1]) && (this.prerelease = n6) : this.prerelease = n6;
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${e3}`);
        }
        return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
      }
    }
    return p2 = I6;
  }
  var A3;
  var L2;
  var $;
  var S3;
  var y3 = (function() {
    if (R3) return m3;
    R3 = 1;
    const e2 = (function() {
      if (v) return I4;
      v = 1;
      const e3 = O3();
      return I4 = (t4, r5, n5 = false) => {
        if (t4 instanceof e3) return t4;
        try {
          return new e3(t4, r5);
        } catch (e4) {
          if (!n5) return null;
          throw e4;
        }
      }, I4;
    })();
    return m3 = (t4, r5) => {
      const n5 = e2(t4, r5);
      return n5 ? n5.version : null;
    }, m3;
  })();
  var _2 = t3(y3);
  var C2 = (function() {
    if (S3) return $;
    S3 = 1;
    const e2 = (function() {
      if (L2) return A3;
      L2 = 1;
      const e3 = O3();
      return A3 = (t4, r5, n5) => new e3(t4, n5).compare(new e3(r5, n5)), A3;
    })();
    return $ = (t4, r5, n5) => e2(t4, r5, n5) < 0, $;
  })();
  var T3 = t3(C2);
  function g3(e2) {
    return globalThis[e2];
  }
  var P3 = class _P {
    static _initStorage() {
      var e2, t4;
      g3(this._namespace) || (e2 = this._namespace, t4 = {}, globalThis[e2] = t4);
    }
    static get(e2, t4) {
      this._initStorage();
      const r5 = g3(this._namespace);
      return e2 in r5 || (r5[e2] = t4()), r5[e2];
    }
    static getMayOverride(e2, t4) {
      this._initStorage();
      const r5 = g3(this._namespace);
      return r5[e2] = t4(r5[e2]), r5[e2];
    }
    static getByVersion(e2, t4, r5, n5) {
      if (this._initStorage(), !_2(t4)) throw new Error(`Invalid version for ${e2}: ${t4}`);
      const s4 = g3(this._namespace), i8 = `${e2}.__Version`, o4 = s4[e2], a5 = s4[i8];
      return o4 ? a5 && !T3(a5, t4) || (s4[e2] = n5(a5, o4), s4[i8] = t4) : (s4[e2] = r5(o4), s4[i8] = t4), s4[e2];
    }
    static set(e2, t4) {
      this._initStorage(), g3(this._namespace)[e2] = t4;
    }
    static has(e2) {
      return this._initStorage(), e2 in g3(this._namespace);
    }
    static delete(e2) {
      this._initStorage();
      const t4 = g3(this._namespace);
      return e2 in t4 && delete t4[e2];
    }
    static setImplementation(e2) {
      const t4 = ["get", "set", "has", "delete"];
      for (const r5 of t4) {
        if ("function" != typeof e2[r5]) throw new Error(`Implementation must provide a '${r5}' function`);
        _P[r5] = e2[r5];
      }
    }
    static createNamespace(e2) {
      return { get: (t4, r5) => _P.get(`${e2}.${t4}`, r5), getMayOverride: (t4, r5) => _P.getMayOverride(`${e2}.${t4}`, r5), set: (t4, r5) => _P.set(`${e2}.${t4}`, r5), has: (t4) => _P.has(`${e2}.${t4}`), delete: (t4) => _P.delete(`${e2}.${t4}`) };
    }
  };
  function w2(e2) {
    return new Promise((t4) => setTimeout(t4, e2));
  }
  function M3(e2, t4 = 100) {
    return (async () => {
      for (; !e2(); ) await w2(t4);
    })();
  }
  P3._namespace = "__BC_LUZI_GLOBALS__", P3.createNamespace("OnceFlag");
  var D3;
  var b = { exports: {} };
  var F2 = (D3 || (D3 = 1, (function(e2) {
    var t4 = Object.prototype.hasOwnProperty, r5 = "~";
    function n5() {
    }
    function s4(e3, t5, r6) {
      this.fn = e3, this.context = t5, this.once = r6 || false;
    }
    function i8(e3, t5, n6, i9, o5) {
      if ("function" != typeof n6) throw new TypeError("The listener must be a function");
      var a6 = new s4(n6, i9 || e3, o5), h6 = r5 ? r5 + t5 : t5;
      return e3._events[h6] ? e3._events[h6].fn ? e3._events[h6] = [e3._events[h6], a6] : e3._events[h6].push(a6) : (e3._events[h6] = a6, e3._eventsCount++), e3;
    }
    function o4(e3, t5) {
      0 === --e3._eventsCount ? e3._events = new n5() : delete e3._events[t5];
    }
    function a5() {
      this._events = new n5(), this._eventsCount = 0;
    }
    Object.create && (n5.prototype = /* @__PURE__ */ Object.create(null), new n5().__proto__ || (r5 = false)), a5.prototype.eventNames = function() {
      var e3, n6, s5 = [];
      if (0 === this._eventsCount) return s5;
      for (n6 in e3 = this._events) t4.call(e3, n6) && s5.push(r5 ? n6.slice(1) : n6);
      return Object.getOwnPropertySymbols ? s5.concat(Object.getOwnPropertySymbols(e3)) : s5;
    }, a5.prototype.listeners = function(e3) {
      var t5 = r5 ? r5 + e3 : e3, n6 = this._events[t5];
      if (!n6) return [];
      if (n6.fn) return [n6.fn];
      for (var s5 = 0, i9 = n6.length, o5 = new Array(i9); s5 < i9; s5++) o5[s5] = n6[s5].fn;
      return o5;
    }, a5.prototype.listenerCount = function(e3) {
      var t5 = r5 ? r5 + e3 : e3, n6 = this._events[t5];
      return n6 ? n6.fn ? 1 : n6.length : 0;
    }, a5.prototype.emit = function(e3, t5, n6, s5, i9, o5) {
      var a6 = r5 ? r5 + e3 : e3;
      if (!this._events[a6]) return false;
      var h6, c7, E3 = this._events[a6], l5 = arguments.length;
      if (E3.fn) {
        switch (E3.once && this.removeListener(e3, E3.fn, void 0, true), l5) {
          case 1:
            return E3.fn.call(E3.context), true;
          case 2:
            return E3.fn.call(E3.context, t5), true;
          case 3:
            return E3.fn.call(E3.context, t5, n6), true;
          case 4:
            return E3.fn.call(E3.context, t5, n6, s5), true;
          case 5:
            return E3.fn.call(E3.context, t5, n6, s5, i9), true;
          case 6:
            return E3.fn.call(E3.context, t5, n6, s5, i9, o5), true;
        }
        for (c7 = 1, h6 = new Array(l5 - 1); c7 < l5; c7++) h6[c7 - 1] = arguments[c7];
        E3.fn.apply(E3.context, h6);
      } else {
        var f6, p4 = E3.length;
        for (c7 = 0; c7 < p4; c7++) switch (E3[c7].once && this.removeListener(e3, E3[c7].fn, void 0, true), l5) {
          case 1:
            E3[c7].fn.call(E3[c7].context);
            break;
          case 2:
            E3[c7].fn.call(E3[c7].context, t5);
            break;
          case 3:
            E3[c7].fn.call(E3[c7].context, t5, n6);
            break;
          case 4:
            E3[c7].fn.call(E3[c7].context, t5, n6, s5);
            break;
          default:
            if (!h6) for (f6 = 1, h6 = new Array(l5 - 1); f6 < l5; f6++) h6[f6 - 1] = arguments[f6];
            E3[c7].fn.apply(E3[c7].context, h6);
        }
      }
      return true;
    }, a5.prototype.on = function(e3, t5, r6) {
      return i8(this, e3, t5, r6, false);
    }, a5.prototype.once = function(e3, t5, r6) {
      return i8(this, e3, t5, r6, true);
    }, a5.prototype.removeListener = function(e3, t5, n6, s5) {
      var i9 = r5 ? r5 + e3 : e3;
      if (!this._events[i9]) return this;
      if (!t5) return o4(this, i9), this;
      var a6 = this._events[i9];
      if (a6.fn) a6.fn !== t5 || s5 && !a6.once || n6 && a6.context !== n6 || o4(this, i9);
      else {
        for (var h6 = 0, c7 = [], E3 = a6.length; h6 < E3; h6++) (a6[h6].fn !== t5 || s5 && !a6[h6].once || n6 && a6[h6].context !== n6) && c7.push(a6[h6]);
        c7.length ? this._events[i9] = 1 === c7.length ? c7[0] : c7 : o4(this, i9);
      }
      return this;
    }, a5.prototype.removeAllListeners = function(e3) {
      var t5;
      return e3 ? (t5 = r5 ? r5 + e3 : e3, this._events[t5] && o4(this, t5)) : (this._events = new n5(), this._eventsCount = 0), this;
    }, a5.prototype.off = a5.prototype.removeListener, a5.prototype.addListener = a5.prototype.on, a5.prefixed = r5, a5.EventEmitter = a5, e2.exports = a5;
  })(b)), b.exports);
  var G2 = t3(F2);
  var U2 = "1.0.1";
  var x4 = class {
    constructor() {
      this.handler = new G2(), u.hookFunction("ChatRoomMessage", 10, (e2, t4) => {
        const { Type: r5 } = e2[0];
        return "ServerMessage" !== r5 && "Status" !== r5 && this.handler.emit(r5, e2[0]), t4(e2);
      }), u.hookFunction("ChatRoomSync", 1, (e2, t4) => {
        const r5 = Player && !ServerPlayerIsInChatRoom() && RelogData?.ChatRoomName !== e2[0].Name, n5 = t4(e2);
        return r5 && this.handler.emit("PlayerJoin", Player), n5;
      }), u.hookFunction("ServerSend", 1, (e2, t4) => ("ChatRoomLeave" === e2[0] && Player && this.handler.emit("PlayerLeave", Player), t4(e2)));
    }
    on(...e2) {
      this.handler.on(...e2);
    }
    off(...e2) {
      this.handler.off(...e2);
    }
    once(...e2) {
      this.handler.once(...e2);
    }
  };
  var X2 = P3.get(`ChatRoomEvents@${U2}`, () => new x4());
  var j2 = class {
    constructor() {
      this.handler = new G2(), u.hookFunction("ActivityOrgasmStop", 9, (e2, t4) => {
        const [r5, n5] = e2;
        r5.IsPlayer() && (ActivityOrgasmRuined ? this.handler.emit("ruined", { Player: r5 }) : n5 >= 60 && this.handler.emit("resisted", { Player: r5 })), t4(e2);
      }), u.hookFunction("ActivityOrgasmStart", 9, (e2, t4) => {
        const [r5] = e2;
        r5.IsPlayer() && !ActivityOrgasmRuined && this.handler.emit("orgasmed", { Player: r5 }), t4(e2);
      });
    }
    on(...e2) {
      this.handler.on(...e2);
    }
    once(...e2) {
      this.handler.once(...e2);
    }
    off(...e2) {
      this.handler.off(...e2);
    }
  };
  var k2 = P3.get(`OrgasmEvents@${U2}`, () => new j2());
  var H = class {
    constructor() {
      this.handler = new G2(), (async () => {
        var e2;
        await M3(() => Array.isArray(ChatRoomMessageHandlers)), ChatRoomRegisterMessageHandler((e2 = this.handler, { Description: `SugarChain ChatMessage Handler v${U2}`, Priority: 1024, Callback: (t4, r5, n5, s4) => (e2.emit(t4.Type, t4, r5, n5, s4), false) }));
      })();
    }
    on(...e2) {
      this.handler.on(...e2);
    }
    once(...e2) {
      this.handler.once(...e2);
    }
    off(...e2) {
      this.handler.off(...e2);
    }
  };
  var B = P3.get(`ChatRoomMessageHandlerEvents@${U2}`, () => new H());
  var V2 = { pullActivityInfo: function(...e2) {
    const [t4, r5, n5, s4] = e2;
    if ("Activity" !== t4.Type || !t4.Dictionary || !s4) return;
    const { ActivityName: i8, ActivityAsset: o4, CraftingNames: a5, FocusGroup: h6, TargetMemberNumber: c7 } = s4;
    if (!(i8 && h6 && c7 && r5.MemberNumber)) return;
    return { SourceCharacter: r5.MemberNumber, SourceCharacterC: r5, TargetCharacter: c7, ActivityGroup: h6, ActivityName: i8, Asset: void 0 !== o4 ? { Asset: o4, CraftName: a5?.ActivityAsset } : void 0, Dictionary: t4.Dictionary };
  } };
  var z = { OthersOnSelf: /* @__PURE__ */ new Set(["OthersOnSelf", "AnyOnSelf", "SelfInvolved", "AnyInvolved"]), SelfOnSelf: /* @__PURE__ */ new Set(["SelfOnSelf", "AnyOnSelf", "SelfInvolved", "AnyInvolved"]), SelfOnOthers: /* @__PURE__ */ new Set(["SelfOnOthers", "SelfInvolved", "AnyInvolved"]), OthersOnOthers: /* @__PURE__ */ new Set(["AnyInvolved"]) };
  var J = class {
    constructor() {
      this._handlers = [], (async () => {
        var e2;
        await M3(() => Array.isArray(ChatRoomMessageHandlers)), ChatRoomRegisterMessageHandler((e2 = (...e3) => this.emit(...e3), { Description: `SugarChain Activity Handler v${U2}`, Priority: 290, Callback: (t4, r5, n5, s4) => {
          const i8 = V2.pullActivityInfo(t4, r5, n5, s4);
          if (!i8) return false;
          const o4 = i8.TargetCharacter === Player.MemberNumber ? r5.MemberNumber === i8.TargetCharacter ? z.SelfOnSelf : z.OthersOnSelf : i8.SourceCharacter === Player.MemberNumber ? z.SelfOnOthers : z.OthersOnOthers;
          return e2(o4, i8.ActivityName, r5, Player, i8), false;
        } }));
      })();
    }
    emit(e2, t4, ...r5) {
      const n5 = [...this._handlers], s4 = [];
      for (const i8 of n5) if (null !== i8.activity && t4 !== i8.activity || !e2.has(i8.mode)) s4.push(i8);
      else {
        try {
          i8.listener(...r5);
        } catch (e3) {
          console.error(`Error in activity event listener for ${i8.activity} (${i8.mode}):`, e3);
        }
        i8.once || s4.push(i8);
      }
      this._handlers = s4;
    }
    on(e2, t4, r5) {
      this._handlers.push({ mode: e2, activity: t4, listener: r5, once: false });
    }
    once(e2, t4, r5) {
      this._handlers.push({ mode: e2, activity: t4, listener: r5, once: true });
    }
    onAny(e2, t4) {
      this._handlers.push({ mode: e2, activity: null, listener: t4, once: false });
    }
    onceAny(e2, t4) {
      this._handlers.push({ mode: e2, activity: null, listener: t4, once: true });
    }
    off(e2, t4, r5) {
      this._handlers = r5 ? this._handlers.filter((n5) => n5.mode !== e2 || n5.activity !== t4 || n5.listener !== r5) : this._handlers.filter((r6) => r6.mode !== e2 || r6.activity !== t4);
    }
  };
  var Y2 = P3.get(`ActivityEvents@${U2}`, () => new J());
  var Z = class {
    isAllowed(e2) {
      return e2 in this.modifiers;
    }
    constructor() {
      this.modifiers = { ChatRoomChat: [], ChatRoomCharacterUpdate: [], ChatRoomCharacterExpressionUpdate: [], ChatRoomCharacterPoseUpdate: [], ChatRoomCharacterArousalUpdate: [], ChatRoomCharacterItemUpdate: [], ChatRoomCharacterMapDataUpdate: [], ChatRoomGame: [] }, u.hookFunction("ServerSend", 10, (e2, t4) => {
        const [r5, n5] = e2;
        if (this.isAllowed(r5)) {
          const t5 = this.modifiers[r5];
          for (const r6 of t5) e2[1] = r6(n5);
        }
        return t4(e2);
      });
    }
    addModifier(e2, t4) {
      this.modifiers[e2].push(t4);
    }
    removeModifier(e2, t4) {
      const r5 = this.modifiers[e2].indexOf(t4);
      r5 > -1 && this.modifiers[e2].splice(r5, 1);
    }
  };
  var W3 = P3.get("ServerSendModifiers", () => new Z());

  // node_modules/.pnpm/@sugarch+bc-activity-manager@1.0.2_@sugarch+bc-event-handler@1.0.1_@sugarch+bc-mod-hook_6cfdd4ed286b1fc197c98264f1c63cce/node_modules/@sugarch/bc-activity-manager/dist/index.mjs
  var i7;
  var r4 = class {
    static info(t4) {
      i7?.info(t4);
    }
    static warn(t4) {
      i7?.warn(t4);
    }
    static error(t4) {
      i7?.error(t4);
    }
  };
  var s3 = /* @__PURE__ */ new Set();
  function n4(e2, i8) {
    s3.has(e2) ? r4.warn(`Handler for ${e2} already exists, skipping`) : Y2.on(i8.mode ?? "SelfInvolved", e2, (t4, e3, r5) => {
      i8.run?.(e3, t4, r5);
    });
  }
  var a4 = [];
  var o3 = false;
  function c6(t4) {
    o3 ? t4() : a4.push(t4);
  }
  function E2(t4, e2, i8) {
    return (function(t5, e3) {
      const i9 = "TW" !== TranslationLanguage ? TranslationLanguage : "CN";
      let r5 = t5(i9);
      return void 0 !== r5 ? r5 : (r5 = "CN" === i9 ? t5("CN") : t5("EN") || t5("CN"), void 0 !== r5 ? r5 : e3);
    })((i9) => t4[i9]?.[e2], i8);
  }
  var h5 = {};
  function u3(t4, e2) {
    for (const [i8, r5] of Object.entries(t4)) r5 && e2(i8, r5);
  }
  function m4(t4, e2, i8, r5) {
    u3(e2, (e3, s4) => {
      h5[e3] = (function(t5, e4, i9 = {}) {
        const r6 = { ...i9 };
        return u3(t5, (t6, i10) => {
          const { key: s5, value: n5 } = e4(t6, i10);
          r6[s5] = n5;
        }), r6;
      })(s4, (e4, s5) => ({ key: `${t4}Chat${i8}-${e4}-${r5}`, value: s5 }), h5[e3] || {});
    });
  }
  var I5 = { ItemVulva: "ItemPenis", ItemVulvaPiercings: "ItemGlans" };
  function p3(t4, e2, i8, r5, s4) {
    l4(e2) ? (function(t5, e3, i9, r6, s5) {
      u3(e3, (e4, n5) => {
        h5[e4] || (h5[e4] = {});
        for (const a5 of s5) {
          h5[e4][`${t5}Chat${i9}-${a5}-${r6}`] = n5;
          const s6 = I5[a5];
          s6 && (h5[e4][`${t5}Chat${i9}-${s6}-${r6}`] = n5);
        }
      });
    })(t4, e2, i8, r5, s4) : m4(t4, e2, i8, r5);
  }
  function l4(t4) {
    return Object.values(t4).some((t5) => "string" == typeof t5);
  }
  function A4(t4) {
    const { activity: e2, label: i8, labelSelf: r5, dialog: s4, dialogSelf: n5 } = t4, { Name: a5, Target: o4, TargetSelf: c7 } = e2, E3 = i8 ?? r5 ?? { CN: a5 };
    l4(E3) ? u3(E3, (t5, e3) => {
      h5[t5] || (h5[t5] = {}), h5[t5][`Activity${a5}`] = e3;
    }) : u3(E3, (t5, e3) => {
      h5[t5] || (h5[t5] = {}), h5[t5][`Activity${a5}`] = Object.values(e3)[0] || a5;
    }), p3("Label-", E3, "Other", a5, o4), s4 && p3("", s4, "Other", a5, o4);
    const m5 = "boolean" == typeof c7 && c7 ? o4 : Array.isArray(c7) ? c7 : [], I6 = r5 || i8;
    I6 && p3("Label-", I6, "Self", a5, m5);
    const A5 = n5 || s4;
    A5 && p3("", A5, "Self", a5, m5);
  }
  var f5 = {};
  function g4(t4) {
    f5[t4.name] = t4;
  }
  function N6(t4, e2) {
    return e2.map((e3) => {
      if ("function" == typeof e3) {
        const i8 = (function(t5) {
          for (; ; ) {
            const e4 = `${t5}_prereq_${Math.random().toString(36).substring(2)}`;
            if (!f5[e4]) return e4;
          }
        })(t4);
        return g4({ name: i8, test: e3 }), i8;
      }
      return e3;
    });
  }
  var R4 = {};
  function $2(t4) {
    R4[t4.activity.Name] = t4;
  }
  function L3(t4) {
    return t4 && t4.__esModule && Object.prototype.hasOwnProperty.call(t4, "default") ? t4.default : t4;
  }
  var d3;
  var v2;
  var O4;
  var y4;
  function S4() {
    if (v2) return d3;
    v2 = 1;
    const t4 = "object" == typeof process && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...t5) => console.error("SEMVER", ...t5) : () => {
    };
    return d3 = t4;
  }
  function T4() {
    if (y4) return O4;
    y4 = 1;
    const t4 = Number.MAX_SAFE_INTEGER || 9007199254740991;
    return O4 = { MAX_LENGTH: 256, MAX_SAFE_COMPONENT_LENGTH: 16, MAX_SAFE_BUILD_LENGTH: 250, MAX_SAFE_INTEGER: t4, RELEASE_TYPES: ["major", "premajor", "minor", "preminor", "patch", "prepatch", "prerelease"], SEMVER_SPEC_VERSION: "2.0.0", FLAG_INCLUDE_PRERELEASE: 1, FLAG_LOOSE: 2 };
  }
  var C3;
  var D4;
  var w3;
  var F3;
  var P4;
  var G3;
  var M4;
  var b2;
  var _3;
  var U3;
  var X3;
  var k3 = { exports: {} };
  function j3() {
    return C3 || (C3 = 1, (function(t4, e2) {
      const { MAX_SAFE_COMPONENT_LENGTH: i8, MAX_SAFE_BUILD_LENGTH: r5, MAX_LENGTH: s4 } = T4(), n5 = S4(), a5 = (e2 = t4.exports = {}).re = [], o4 = e2.safeRe = [], c7 = e2.src = [], E3 = e2.safeSrc = [], h6 = e2.t = {};
      let u4 = 0;
      const m5 = "[a-zA-Z0-9-]", I6 = [["\\s", 1], ["\\d", s4], [m5, r5]], p4 = (t5, e3, i9) => {
        const r6 = ((t6) => {
          for (const [e4, i10] of I6) t6 = t6.split(`${e4}*`).join(`${e4}{0,${i10}}`).split(`${e4}+`).join(`${e4}{1,${i10}}`);
          return t6;
        })(e3), s5 = u4++;
        n5(t5, s5, e3), h6[t5] = s5, c7[s5] = e3, E3[s5] = r6, a5[s5] = new RegExp(e3, i9 ? "g" : void 0), o4[s5] = new RegExp(r6, i9 ? "g" : void 0);
      };
      p4("NUMERICIDENTIFIER", "0|[1-9]\\d*"), p4("NUMERICIDENTIFIERLOOSE", "\\d+"), p4("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${m5}*`), p4("MAINVERSION", `(${c7[h6.NUMERICIDENTIFIER]})\\.(${c7[h6.NUMERICIDENTIFIER]})\\.(${c7[h6.NUMERICIDENTIFIER]})`), p4("MAINVERSIONLOOSE", `(${c7[h6.NUMERICIDENTIFIERLOOSE]})\\.(${c7[h6.NUMERICIDENTIFIERLOOSE]})\\.(${c7[h6.NUMERICIDENTIFIERLOOSE]})`), p4("PRERELEASEIDENTIFIER", `(?:${c7[h6.NONNUMERICIDENTIFIER]}|${c7[h6.NUMERICIDENTIFIER]})`), p4("PRERELEASEIDENTIFIERLOOSE", `(?:${c7[h6.NONNUMERICIDENTIFIER]}|${c7[h6.NUMERICIDENTIFIERLOOSE]})`), p4("PRERELEASE", `(?:-(${c7[h6.PRERELEASEIDENTIFIER]}(?:\\.${c7[h6.PRERELEASEIDENTIFIER]})*))`), p4("PRERELEASELOOSE", `(?:-?(${c7[h6.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${c7[h6.PRERELEASEIDENTIFIERLOOSE]})*))`), p4("BUILDIDENTIFIER", `${m5}+`), p4("BUILD", `(?:\\+(${c7[h6.BUILDIDENTIFIER]}(?:\\.${c7[h6.BUILDIDENTIFIER]})*))`), p4("FULLPLAIN", `v?${c7[h6.MAINVERSION]}${c7[h6.PRERELEASE]}?${c7[h6.BUILD]}?`), p4("FULL", `^${c7[h6.FULLPLAIN]}$`), p4("LOOSEPLAIN", `[v=\\s]*${c7[h6.MAINVERSIONLOOSE]}${c7[h6.PRERELEASELOOSE]}?${c7[h6.BUILD]}?`), p4("LOOSE", `^${c7[h6.LOOSEPLAIN]}$`), p4("GTLT", "((?:<|>)?=?)"), p4("XRANGEIDENTIFIERLOOSE", `${c7[h6.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), p4("XRANGEIDENTIFIER", `${c7[h6.NUMERICIDENTIFIER]}|x|X|\\*`), p4("XRANGEPLAIN", `[v=\\s]*(${c7[h6.XRANGEIDENTIFIER]})(?:\\.(${c7[h6.XRANGEIDENTIFIER]})(?:\\.(${c7[h6.XRANGEIDENTIFIER]})(?:${c7[h6.PRERELEASE]})?${c7[h6.BUILD]}?)?)?`), p4("XRANGEPLAINLOOSE", `[v=\\s]*(${c7[h6.XRANGEIDENTIFIERLOOSE]})(?:\\.(${c7[h6.XRANGEIDENTIFIERLOOSE]})(?:\\.(${c7[h6.XRANGEIDENTIFIERLOOSE]})(?:${c7[h6.PRERELEASELOOSE]})?${c7[h6.BUILD]}?)?)?`), p4("XRANGE", `^${c7[h6.GTLT]}\\s*${c7[h6.XRANGEPLAIN]}$`), p4("XRANGELOOSE", `^${c7[h6.GTLT]}\\s*${c7[h6.XRANGEPLAINLOOSE]}$`), p4("COERCEPLAIN", `(^|[^\\d])(\\d{1,${i8}})(?:\\.(\\d{1,${i8}}))?(?:\\.(\\d{1,${i8}}))?`), p4("COERCE", `${c7[h6.COERCEPLAIN]}(?:$|[^\\d])`), p4("COERCEFULL", c7[h6.COERCEPLAIN] + `(?:${c7[h6.PRERELEASE]})?(?:${c7[h6.BUILD]})?(?:$|[^\\d])`), p4("COERCERTL", c7[h6.COERCE], true), p4("COERCERTLFULL", c7[h6.COERCEFULL], true), p4("LONETILDE", "(?:~>?)"), p4("TILDETRIM", `(\\s*)${c7[h6.LONETILDE]}\\s+`, true), e2.tildeTrimReplace = "$1~", p4("TILDE", `^${c7[h6.LONETILDE]}${c7[h6.XRANGEPLAIN]}$`), p4("TILDELOOSE", `^${c7[h6.LONETILDE]}${c7[h6.XRANGEPLAINLOOSE]}$`), p4("LONECARET", "(?:\\^)"), p4("CARETTRIM", `(\\s*)${c7[h6.LONECARET]}\\s+`, true), e2.caretTrimReplace = "$1^", p4("CARET", `^${c7[h6.LONECARET]}${c7[h6.XRANGEPLAIN]}$`), p4("CARETLOOSE", `^${c7[h6.LONECARET]}${c7[h6.XRANGEPLAINLOOSE]}$`), p4("COMPARATORLOOSE", `^${c7[h6.GTLT]}\\s*(${c7[h6.LOOSEPLAIN]})$|^$`), p4("COMPARATOR", `^${c7[h6.GTLT]}\\s*(${c7[h6.FULLPLAIN]})$|^$`), p4("COMPARATORTRIM", `(\\s*)${c7[h6.GTLT]}\\s*(${c7[h6.LOOSEPLAIN]}|${c7[h6.XRANGEPLAIN]})`, true), e2.comparatorTrimReplace = "$1$2$3", p4("HYPHENRANGE", `^\\s*(${c7[h6.XRANGEPLAIN]})\\s+-\\s+(${c7[h6.XRANGEPLAIN]})\\s*$`), p4("HYPHENRANGELOOSE", `^\\s*(${c7[h6.XRANGEPLAINLOOSE]})\\s+-\\s+(${c7[h6.XRANGEPLAINLOOSE]})\\s*$`), p4("STAR", "(<|>)?=?\\s*\\*"), p4("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), p4("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
    })(k3, k3.exports)), k3.exports;
  }
  function B2() {
    if (M4) return G3;
    M4 = 1;
    const t4 = S4(), { MAX_LENGTH: e2, MAX_SAFE_INTEGER: i8 } = T4(), { safeRe: r5, t: s4 } = j3(), n5 = (function() {
      if (w3) return D4;
      w3 = 1;
      const t5 = Object.freeze({ loose: true }), e3 = Object.freeze({});
      return D4 = (i9) => i9 ? "object" != typeof i9 ? t5 : i9 : e3;
    })(), { compareIdentifiers: a5 } = (function() {
      if (P4) return F3;
      P4 = 1;
      const t5 = /^[0-9]+$/, e3 = (e4, i9) => {
        const r6 = t5.test(e4), s5 = t5.test(i9);
        return r6 && s5 && (e4 = +e4, i9 = +i9), e4 === i9 ? 0 : r6 && !s5 ? -1 : s5 && !r6 ? 1 : e4 < i9 ? -1 : 1;
      };
      return F3 = { compareIdentifiers: e3, rcompareIdentifiers: (t6, i9) => e3(i9, t6) }, F3;
    })();
    class o4 {
      constructor(a6, c7) {
        if (c7 = n5(c7), a6 instanceof o4) {
          if (a6.loose === !!c7.loose && a6.includePrerelease === !!c7.includePrerelease) return a6;
          a6 = a6.version;
        } else if ("string" != typeof a6) throw new TypeError(`Invalid version. Must be a string. Got type "${typeof a6}".`);
        if (a6.length > e2) throw new TypeError(`version is longer than ${e2} characters`);
        t4("SemVer", a6, c7), this.options = c7, this.loose = !!c7.loose, this.includePrerelease = !!c7.includePrerelease;
        const E3 = a6.trim().match(c7.loose ? r5[s4.LOOSE] : r5[s4.FULL]);
        if (!E3) throw new TypeError(`Invalid Version: ${a6}`);
        if (this.raw = a6, this.major = +E3[1], this.minor = +E3[2], this.patch = +E3[3], this.major > i8 || this.major < 0) throw new TypeError("Invalid major version");
        if (this.minor > i8 || this.minor < 0) throw new TypeError("Invalid minor version");
        if (this.patch > i8 || this.patch < 0) throw new TypeError("Invalid patch version");
        E3[4] ? this.prerelease = E3[4].split(".").map((t5) => {
          if (/^[0-9]+$/.test(t5)) {
            const e3 = +t5;
            if (e3 >= 0 && e3 < i8) return e3;
          }
          return t5;
        }) : this.prerelease = [], this.build = E3[5] ? E3[5].split(".") : [], this.format();
      }
      format() {
        return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
      }
      toString() {
        return this.version;
      }
      compare(e3) {
        if (t4("SemVer.compare", this.version, this.options, e3), !(e3 instanceof o4)) {
          if ("string" == typeof e3 && e3 === this.version) return 0;
          e3 = new o4(e3, this.options);
        }
        return e3.version === this.version ? 0 : this.compareMain(e3) || this.comparePre(e3);
      }
      compareMain(t5) {
        return t5 instanceof o4 || (t5 = new o4(t5, this.options)), a5(this.major, t5.major) || a5(this.minor, t5.minor) || a5(this.patch, t5.patch);
      }
      comparePre(e3) {
        if (e3 instanceof o4 || (e3 = new o4(e3, this.options)), this.prerelease.length && !e3.prerelease.length) return -1;
        if (!this.prerelease.length && e3.prerelease.length) return 1;
        if (!this.prerelease.length && !e3.prerelease.length) return 0;
        let i9 = 0;
        do {
          const r6 = this.prerelease[i9], s5 = e3.prerelease[i9];
          if (t4("prerelease compare", i9, r6, s5), void 0 === r6 && void 0 === s5) return 0;
          if (void 0 === s5) return 1;
          if (void 0 === r6) return -1;
          if (r6 !== s5) return a5(r6, s5);
        } while (++i9);
      }
      compareBuild(e3) {
        e3 instanceof o4 || (e3 = new o4(e3, this.options));
        let i9 = 0;
        do {
          const r6 = this.build[i9], s5 = e3.build[i9];
          if (t4("build compare", i9, r6, s5), void 0 === r6 && void 0 === s5) return 0;
          if (void 0 === s5) return 1;
          if (void 0 === r6) return -1;
          if (r6 !== s5) return a5(r6, s5);
        } while (++i9);
      }
      inc(t5, e3, i9) {
        if (t5.startsWith("pre")) {
          if (!e3 && false === i9) throw new Error("invalid increment argument: identifier is empty");
          if (e3) {
            const t6 = `-${e3}`.match(this.options.loose ? r5[s4.PRERELEASELOOSE] : r5[s4.PRERELEASE]);
            if (!t6 || t6[1] !== e3) throw new Error(`invalid identifier: ${e3}`);
          }
        }
        switch (t5) {
          case "premajor":
            this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", e3, i9);
            break;
          case "preminor":
            this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", e3, i9);
            break;
          case "prepatch":
            this.prerelease.length = 0, this.inc("patch", e3, i9), this.inc("pre", e3, i9);
            break;
          case "prerelease":
            0 === this.prerelease.length && this.inc("patch", e3, i9), this.inc("pre", e3, i9);
            break;
          case "release":
            if (0 === this.prerelease.length) throw new Error(`version ${this.raw} is not a prerelease`);
            this.prerelease.length = 0;
            break;
          case "major":
            0 === this.minor && 0 === this.patch && 0 !== this.prerelease.length || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
            break;
          case "minor":
            0 === this.patch && 0 !== this.prerelease.length || this.minor++, this.patch = 0, this.prerelease = [];
            break;
          case "patch":
            0 === this.prerelease.length && this.patch++, this.prerelease = [];
            break;
          case "pre": {
            const t6 = Number(i9) ? 1 : 0;
            if (0 === this.prerelease.length) this.prerelease = [t6];
            else {
              let r6 = this.prerelease.length;
              for (; --r6 >= 0; ) "number" == typeof this.prerelease[r6] && (this.prerelease[r6]++, r6 = -2);
              if (-1 === r6) {
                if (e3 === this.prerelease.join(".") && false === i9) throw new Error("invalid increment argument: identifier already exists");
                this.prerelease.push(t6);
              }
            }
            if (e3) {
              let r6 = [e3, t6];
              false === i9 && (r6 = [e3]), 0 === a5(this.prerelease[0], e3) ? isNaN(this.prerelease[1]) && (this.prerelease = r6) : this.prerelease = r6;
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${t5}`);
        }
        return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
      }
    }
    return G3 = o4;
  }
  var x5;
  var W4;
  var V3;
  var H2;
  var z2 = L3((function() {
    if (X3) return U3;
    X3 = 1;
    const t4 = (function() {
      if (_3) return b2;
      _3 = 1;
      const t5 = B2();
      return b2 = (e2, i8, r5 = false) => {
        if (e2 instanceof t5) return e2;
        try {
          return new t5(e2, i8);
        } catch (t6) {
          if (!r5) return null;
          throw t6;
        }
      };
    })();
    return U3 = (e2, i8) => {
      const r5 = t4(e2, i8);
      return r5 ? r5.version : null;
    };
  })());
  var Z2 = (function() {
    if (H2) return V3;
    H2 = 1;
    const t4 = (function() {
      if (W4) return x5;
      W4 = 1;
      const t5 = B2();
      return x5 = (e2, i8, r5) => new t5(e2, r5).compare(new t5(i8, r5)), x5;
    })();
    return V3 = (e2, i8, r5) => t4(e2, i8, r5) < 0, V3;
  })();
  var q3 = L3(Z2);
  function Y3(t4) {
    return globalThis[t4];
  }
  var J2 = class _J {
    static _initStorage() {
      var t4, e2;
      Y3(this._namespace) || (t4 = this._namespace, e2 = {}, globalThis[t4] = e2);
    }
    static get(t4, e2) {
      this._initStorage();
      const i8 = Y3(this._namespace);
      return t4 in i8 || (i8[t4] = e2()), i8[t4];
    }
    static getMayOverride(t4, e2) {
      this._initStorage();
      const i8 = Y3(this._namespace);
      return i8[t4] = e2(i8[t4]), i8[t4];
    }
    static getByVersion(t4, e2, i8, r5) {
      if (this._initStorage(), !z2(e2)) throw new Error(`Invalid version for ${t4}: ${e2}`);
      const s4 = Y3(this._namespace), n5 = `${t4}.__Version`, a5 = s4[t4], o4 = s4[n5];
      return a5 ? o4 && !q3(o4, e2) || (s4[t4] = r5(o4, a5), s4[n5] = e2) : (s4[t4] = i8(a5), s4[n5] = e2), s4[t4];
    }
    static set(t4, e2) {
      this._initStorage(), Y3(this._namespace)[t4] = e2;
    }
    static has(t4) {
      return this._initStorage(), t4 in Y3(this._namespace);
    }
    static delete(t4) {
      this._initStorage();
      const e2 = Y3(this._namespace);
      return t4 in e2 && delete e2[t4];
    }
    static setImplementation(t4) {
      const e2 = ["get", "set", "has", "delete"];
      for (const i8 of e2) {
        if ("function" != typeof t4[i8]) throw new Error(`Implementation must provide a '${i8}' function`);
        _J[i8] = t4[i8];
      }
    }
    static createNamespace(t4) {
      return { get: (e2, i8) => _J.get(`${t4}.${e2}`, i8), getMayOverride: (e2, i8) => _J.getMayOverride(`${t4}.${e2}`, i8), set: (e2, i8) => _J.set(`${t4}.${e2}`, i8), has: (e2) => _J.has(`${t4}.${e2}`), delete: (e2) => _J.delete(`${t4}.${e2}`) };
    }
  };
  J2._namespace = "__BC_LUZI_GLOBALS__";
  var Q3 = J2.createNamespace("OnceFlag");
  function K2(t4, e2) {
    Q3.get(t4, () => false) || (Q3.set(t4, true), e2());
  }
  function tt(t4) {
    return new Promise((e2) => setTimeout(e2, t4));
  }
  function et(t4, e2 = 100) {
    return (async () => {
      for (; !t4(); ) await tt(e2);
    })();
  }
  var it = class {
    static get emptyImage() {
      return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAACXBIWXMAAC4jAAAuIwF4pT92AAAAG3RFWHRTb2Z0d2FyZQBDZWxzeXMgU3R1ZGlvIFRvb2zBp+F8AAAADUlEQVQI12P4//8/AwAI/AL+XJ/P2gAAAABJRU5ErkJggg==";
    }
    static assetPreviewIconPath(t4) {
      const e2 = "Asset" in t4 ? t4.Asset : t4;
      return `${AssetGetPreviewPath(e2)}/${e2.Name}.png`;
    }
    static activityPreviewIconPath(t4) {
      return `Assets/Female3DCG/Activity/${("Activity" in t4 ? t4.Activity : t4).Name}.png`;
    }
  };
  function rt(t4, e2) {
    const i8 = /* @__PURE__ */ new Set();
    let r5 = t4;
    for (; e2[r5]; ) {
      if (i8.has(r5)) return console.warn(`Circular dependency detected during resolution: ${r5}`), "";
      i8.add(r5), r5 = e2[r5];
    }
    return r5;
  }
  function st(t4) {
    const e2 = {};
    for (const i8 of Object.keys(t4)) {
      const r5 = rt(i8, t4);
      if (!r5) return console.warn(`Circular dependency detected during optimization: ${i8}`), null;
      e2[i8] = r5;
    }
    return e2;
  }
  var nt = new class {
    constructor() {
      this.basic = {}, this.custom = {}, this.customSrc = {};
    }
    addImgMapping(t4) {
      const e2 = { ...this.customSrc, ...t4 }, i8 = st(e2);
      i8 ? (this.customSrc = e2, this.custom = i8) : console.warn("Failed to add mappings due to circular dependencies.");
    }
    rebuildCustomMapping() {
      const t4 = st(this.customSrc);
      t4 ? this.custom = t4 : console.warn("Failed to rebuild mappings due to circular dependencies.");
    }
    migrateTo(t4) {
      t4.customSrc = { ...t4.customSrc, ...this.customSrc }, t4.basic = { ...t4.basic, ...this.basic }, t4.rebuildCustomMapping(), this.customSrc = t4.customSrc, this.basic = t4.basic, this.custom = t4.custom;
    }
    setBasicImgMapping(t4) {
      this.basic = { ...t4, ...this.basic };
    }
    mapImgSrc(t4) {
      if ("string" != typeof t4) return t4;
      if (!t4.endsWith(".png")) return t4;
      if (t4.startsWith("data:image")) return t4;
      if (t4.startsWith("http")) return t4;
      if (t4.startsWith("@nomap/")) return t4;
      const e2 = t4.startsWith("./") ? t4.slice(2) : t4;
      let i8 = e2;
      return this.custom[i8] && (i8 = this.custom[i8]), this.basic[i8] && (i8 = this.basic[i8]), i8 !== e2 ? i8 : t4;
    }
    mapImg(t4, e2) {
      let i8 = t4;
      i8.startsWith("data:image") || i8.startsWith("http") || (this.custom[i8] && (i8 = this.custom[i8]), this.basic[i8] && (i8 = this.basic[i8]), i8 !== t4 && e2(i8));
    }
  }();
  var ot = class {
    constructor() {
      K2("ImgMappingOnce.GLDrawLoadImage.crossOrigin", () => {
        u.patchFunction("GLDrawLoadImage", { "Img.src = url;": 'Img.crossOrigin = "Anonymous";\n		Img.src = url;' });
      }), ["DrawImageEx", "DrawImageResize", "GLDrawImage", "DrawGetImage"].forEach((t4) => {
        u.hookFunction(t4, 10, (t5, e2) => (t5[0] = nt.mapImgSrc(t5[0]), e2(t5)));
      }), K2("ImgMappingOnce.nomap", () => {
        ["DrawImageEx", "DrawImageResize", "GLDrawImage", "DrawGetImage"].forEach((t4) => {
          u.hookFunction(t4, 0, (t5, e2) => ("string" == typeof t5[0] && t5[0].startsWith("@nomap/") && (t5[0] = t5[0].substring(7)), e2(t5)));
        });
      }), u.hookFunction("GLDrawLoadTextureAlphaMask", 0, (t4, e2) => (Array.isArray(t4[5]) && (t4[5] = t4[5].map((t5) => ({ ...t5, Url: nt.mapImgSrc(t5.Url) }))), e2(t4))), (async () => {
        await et(() => void 0 !== globalThis.ElementButton), u.hookFunction("ElementButton.CreateForAsset", 0, (t4, e2) => (nt.mapImg(it.assetPreviewIconPath(t4[1]), (e3) => {
          t4[4] = { ...t4[4], image: e3 };
        }), e2(t4))), u.hookFunction("ElementButton.CreateForActivity", 0, (t4, e2) => {
          const i8 = t4[1], r5 = t4[4]?.image ?? (i8.Item ? it.assetPreviewIconPath(i8.Item.Asset) : `Assets/Female3DCG/Activity/${i8.Activity.Name}.png`);
          return nt.mapImg(r5, (e3) => {
            t4[4] = { ...t4[4], image: e3 };
          }), e2(t4);
        }), u.hookFunction("ElementButton.Create", 0, (t4, e2) => {
          if (t4[0]?.startsWith("dialog-inventory")) {
            const e3 = t4[2];
            e3?.icons && (e3.icons = e3.icons.map((t5) => {
              if ("string" == typeof t5 && t5.endsWith("Padlock")) {
                const e4 = `Assets/Female3DCG/ItemMisc/Preview/${t5}.png`, i8 = nt.mapImgSrc(e4);
                if (i8 !== e4) return { name: t5, iconSrc: i8, tooltipText: InterfaceTextGet("PreviewIconPadlock").replace("AssetName", AssetGet("Female3DCG", "ItemMisc", t5)?.Description ?? t5) };
              }
              return t5;
            }));
          }
          if (t4[0]?.startsWith("dialog-expression-button-grid-Emoticon")) {
            const e3 = t4[2];
            e3?.image && (e3.image = nt.mapImgSrc(e3.image));
          }
          return e2(t4);
        });
      })();
    }
    get storage() {
      return nt;
    }
    addImgMapping(t4) {
      nt.addImgMapping(t4);
    }
    setBasicImgMapping(t4) {
      nt.setBasicImgMapping(t4);
    }
  };
  var ct = J2.get("ImageMapping@2.0.1", () => new ot());
  function Et(t4, e2) {
    if ("function" == typeof e2) return void (ht[t4.Name] = e2);
    const i8 = {}, r5 = it.activityPreviewIconPath(t4);
    Array.isArray(e2) ? i8[r5] = `Assets/Female3DCG/${e2[0]}/Preview/${e2[1]}.png` : "None" === e2 || void 0 === e2 ? i8[r5] = it.emptyImage : e2.startsWith("http") || e2.startsWith("data:image") ? i8[r5] = e2 : i8[r5] = it.activityPreviewIconPath({ Name: e2 }), ct.addImgMapping(i8);
  }
  var ht = {};
  var ut = {};
  var mt = {};
  function It(t4) {
    t4.override && (ut[t4.activity.Name] && r4.warn(`Override for ${t4.activity.Name} already exists, skipping`), ut[t4.activity.Name] || (ut[t4.activity.Name] = t4.override)), t4.item && (mt[t4.activity.Name] && r4.warn(`Item provider for ${t4.activity.Name} already exists, skipping`), mt[t4.activity.Name] || (mt[t4.activity.Name] = t4.item));
  }
  var pt = class {
    addPrerequisites(t4) {
      c6(() => t4.forEach((t5) => g4(t5)));
    }
    checkActivityAvailability(t4) {
      return !ActivityFemale3DCGOrdering.includes(t4);
    }
    addCustomActivity(t4) {
      Array.isArray(t4) || (t4 = [t4]);
      for (const e2 of t4) {
        const t5 = { ...e2 };
        c6(() => {
          t5.activity.Prerequisite = N6(t5.activity.Name, t5.activity.Prerequisite), t5.activity.ActivityID = -1, ActivityFemale3DCG.push(t5.activity), ActivityFemale3DCGOrdering.push(t5.activity.Name), A4(t5), n4(t5.activity.Name, t5), $2(t5), It(t5), Et(t5.activity, t5.useImage);
        });
      }
    }
    removeCustomActivity(t4) {
      ActivityFemale3DCG = ActivityFemale3DCG.filter((e2) => e2.Name !== t4), ActivityFemale3DCGOrdering = ActivityFemale3DCGOrdering.filter((e2) => e2 !== t4);
    }
    activityIsCustom(t4) {
      return (function(t5) {
        return !!R4[t5];
      })(t4);
    }
    addCustomActivities(t4) {
      this.addCustomActivity(t4);
    }
    activityTrigger(t4) {
      c6(() => n4(t4.name, t4));
    }
    init() {
      (async () => {
        await et(() => Array.isArray(ActivityFemale3DCG) && ActivityFemale3DCG.length > 0 && Array.isArray(ActivityFemale3DCGOrdering)), (function(t4 = {}) {
          const { startMsg: e2 = "Start loading", endMsg: i8 = "Loading completed, time usage: " } = t4, s4 = Date.now();
          for (r4.info(e2), o3 = true; a4.length > 0; ) {
            const t5 = a4.shift();
            t5 && t5();
          }
          const n5 = Date.now();
          r4.info(`${i8} ${n5 - s4}ms`);
        })();
      })(), u.hookFunction("ActivityRun", 0, (t4, e2) => {
        const i8 = ut[t4[3].Activity.Name];
        if (i8) return i8(t4[0], t4[1], t4[2], t4[3]);
        const r5 = mt[t4[3].Activity.Name];
        if (r5) {
          const e3 = r5(t4[0], t4[1], t4[2], t4[3]);
          e3 && (t4[3].Item = e3);
        }
        return e2(t4);
      }), u.hookFunction("ElementButton.CreateForActivity", 1, (t4, e2) => {
        const [i8, r5, s4] = t4, n5 = ht[r5.Activity.Name];
        if (n5) {
          const e3 = n5(r5.Activity, s4, r5.Group) ?? it.emptyImage;
          e3 && (t4[4] = { ...t4[4], image: e3 });
        }
        return e2(t4);
      }), (function() {
        const t4 = (t5) => E2(h5, t5);
        u.hookFunction("ActivityDictionaryText", 1, (e2, i8) => t4(e2[0]) || i8(e2)), u.progressiveHook("ServerSend", 1).inside("ActivityRun").inject((e2) => {
          const { Content: i8, Dictionary: r5, Type: s4 } = e2[1];
          if ("Activity" !== s4 || !r5) return;
          const n5 = t4(i8);
          n5 && r5.push({ Tag: `MISSING ACTIVITY DESCRIPTION FOR KEYWORD ${i8}`, Text: n5 });
        });
      })(), u.hookFunction("ActivityCheckPrerequisite", 1, (t4, e2) => {
        const i8 = f5[t4[0]];
        return i8 ? i8.test(...t4) : e2(t4);
      });
    }
    setLogger(t4) {
      !(function(t5) {
        i7 = t5;
      })(t4);
    }
    typePrerequisiteNames() {
      return this;
    }
    typeActivityNames() {
      return this;
    }
  };
  var lt = new pt();

  // src/modules/activities.ts
  function addActivities() {
    lt.addCustomActivity({
      activity: {
        Name: "BCC_StealPanties" /* STEAL_PANTIES */,
        Prerequisite: ["UseHands", (_4, _acter, acted) => !!InventoryGet(acted, "Panties")],
        MaxProgress: 0,
        Target: ["ItemPelvis", "ItemButt", "ItemVulva", "ItemVulvaPiercings"]
      },
      useImage: (_activity, target, _group) => {
        console.log(target);
        const asset = InventoryGet(target, "Panties")?.Asset;
        return AssetGetPreviewPath(asset) + "/" + asset?.Name + ".png";
      },
      label: { EN: "Steal Panties" },
      dialog: { EN: "SourceCharacter steals TargetCharacter's panties." },
      run: (_player, sender, info) => {
        if (!sender.IsPlayer()) return;
        const target = T2(info.TargetCharacter);
        InventoryRemove(target, "Panties");
        InventoryWear(Player, "Panties", "ItemHandheld", "red", 10, Player.MemberNumber, {
          Item: "Panties",
          Name: `${N3(target)}'s panties`,
          Description: "",
          Color: "red",
          Property: "Normal",
          Lock: "",
          Private: false,
          ItemProperty: {},
          Type: null,
          TypeRecord: null,
          MemberNumber: target.MemberNumber,
          MemberName: N3(target)
        });
        ChatRoomCharacterUpdate(target);
        ChatRoomCharacterUpdate(Player);
      }
    });
    lt.addCustomActivity({
      activity: {
        Name: "BCC_SuckOnTipOfHair" /* SUCK_ON_TIP_HAIR */,
        Prerequisite: ["UseMouth"],
        MaxProgress: 0,
        Target: ["ItemHead", "ItemHood", "ItemEars"]
      },
      useImage: "Kiss",
      label: { EN: "Suck on tip of hair" },
      dialog: { EN: "SourceCharacter sucks on TargetCharacter's tip of hair." },
      run: (_player, sender, info) => {
        if (!sender.IsPlayer()) return;
        const target = T2(info.TargetCharacter);
        const hairColor = InventoryGet(target, "HairFront")?.Color?.[0] ?? "#6a3628";
        InventoryWear(Player, "Tentacles", "ItemMouth2", hairColor, 10, target.MemberNumber, {
          Item: "Tentacles",
          Name: `${N3(target)}'s tip of hair`,
          Description: "",
          Color: hairColor,
          Property: "Decoy",
          Lock: "",
          Private: false,
          ItemProperty: {},
          Type: null,
          TypeRecord: null,
          MemberNumber: target.MemberNumber,
          MemberName: N3(target)
        });
        ChatRoomCharacterUpdate(Player);
      }
    });
    u.initWithMod(t);
    lt.init();
  }

  // src/index.ts
  function start() {
    C({
      name: "BCC",
      fullName: "Bondage Club Chaos",
      key: "BCC",
      version,
      fontFamily: "Yusei Magic",
      singleToastsTheme: {
        backgroundColor: "#191919",
        titleColor: "#e600d2",
        messageColor: "#a9a9a9",
        iconFillColor: "#e600d2",
        iconStrokeColor: "#731f71",
        progressBarColor: "#242424"
      }
    });
    O2(`${styles_default2}@font-face { font-family: Kitnyx2; src: url(${Kitnyx2_default}); }`);
    loadStorage();
    loadSettingsSubscreen();
    loadCheats();
    loadQuickAccessMenu();
    loadChaosAura();
    loadOverlay();
    loadDarkMagic();
    addActivities();
    Q2.success({
      title: `${m.fullName} loaded`,
      message: `v${version}`,
      duration: 4500
    });
  }
  P2(start);
})();
/*! Bundled license information:

reflect-metadata/Reflect.js:
  (*! *****************************************************************************
  Copyright (C) Microsoft. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)

react/cjs/react.development.js:
  (**
   * @license React
   * react.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.development.js:
  (**
   * @license React
   * scheduler.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.development.js:
  (**
   * @license React
   * react-dom.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom-client.development.js:
  (**
   * @license React
   * react-dom-client.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-runtime.development.js:
  (**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

lucide/dist/esm/defaultAttributes.js:
lucide/dist/esm/createElement.js:
lucide/dist/esm/icons/arrow-down.js:
lucide/dist/esm/icons/arrow-up.js:
lucide/dist/esm/icons/ban.js:
lucide/dist/esm/icons/book-heart.js:
lucide/dist/esm/icons/bug.js:
lucide/dist/esm/icons/check.js:
lucide/dist/esm/icons/chevron-down.js:
lucide/dist/esm/icons/chevron-left.js:
lucide/dist/esm/icons/circle-x.js:
lucide/dist/esm/icons/clipboard-copy.js:
lucide/dist/esm/icons/clipboard-paste.js:
lucide/dist/esm/icons/code-xml.js:
lucide/dist/esm/icons/copy-plus.js:
lucide/dist/esm/icons/eye.js:
lucide/dist/esm/icons/git-pull-request.js:
lucide/dist/esm/icons/hand-coins.js:
lucide/dist/esm/icons/hat-glasses.js:
lucide/dist/esm/icons/heart.js:
lucide/dist/esm/icons/lock.js:
lucide/dist/esm/icons/lock-open.js:
lucide/dist/esm/icons/log-out.js:
lucide/dist/esm/icons/map-pinned.js:
lucide/dist/esm/icons/panels-top-left.js:
lucide/dist/esm/icons/person-standing.js:
lucide/dist/esm/icons/send-to-back.js:
lucide/dist/esm/icons/settings.js:
lucide/dist/esm/icons/shell.js:
lucide/dist/esm/icons/shield-alert.js:
lucide/dist/esm/icons/shield-minus.js:
lucide/dist/esm/icons/skull.js:
lucide/dist/esm/icons/target.js:
lucide/dist/esm/icons/trash-2.js:
lucide/dist/esm/icons/wand.js:
lucide/dist/esm/lucide.js:
  (**
   * @license lucide v0.541.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/shared/src/utils.js:
lucide-react/dist/esm/defaultAttributes.js:
lucide-react/dist/esm/Icon.js:
lucide-react/dist/esm/createLucideIcon.js:
lucide-react/dist/esm/icons/circle-alert.js:
lucide-react/dist/esm/icons/circle-check.js:
lucide-react/dist/esm/icons/circle-x.js:
lucide-react/dist/esm/icons/info.js:
lucide-react/dist/esm/lucide-react.js:
  (**
   * @license lucide-react v0.542.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

@sugarch/bc-mod-hook-manager/dist/index.mjs:
  (**
   * @sugarch/bc-mod-hook-manager v0.3.1
   * 
   * Copyright (c) 2025 SugarChain Studio
   * License: MIT
   * https://github.com/SugarChain-Studio/sugarch-utilities
   * @preserve
   *)

@sugarch/bc-event-handler/dist/index.mjs:
  (**
   * @sugarch/bc-event-handler v1.0.1
   * 
   * Copyright (c) 2025 SugarChain Studio
   * License: MIT
   * https://github.com/SugarChain-Studio/sugarch-utilities
   * @preserve
   *)
  (**
   * @sugarch/bc-mod-utility v0.2.11
   * 
   * Copyright (c) 2025 SugarChain Studio
   * License: MIT
   * https://github.com/SugarChain-Studio/sugarch-utilities
   * @preserve
   *)

@sugarch/bc-activity-manager/dist/index.mjs:
  (**
   * @sugarch/bc-activity-manager v1.0.2
   * 
   * Copyright (c) 2025 SugarChain Studio
   * License: MIT
   * https://github.com/SugarChain-Studio/sugarch-utilities
   * @preserve
   *)
  (**
   * @sugarch/bc-mod-utility v0.2.11
   * 
   * Copyright (c) 2025 SugarChain Studio
   * License: MIT
   * https://github.com/SugarChain-Studio/sugarch-utilities
   * @preserve
   *)
  (**
   * @sugarch/bc-image-mapping v2.0.1
   * 
   * Copyright (c) 2025 SugarChain Studio
   * License: MIT
   * https://github.com/SugarChain-Studio/sugarch-utilities
   * @preserve
   *)
*/
//# sourceMappingURL=bundle.js.map
